<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DocForge</title>

    <link rel="icon" href="data:;base64,=" />
    <link rel="stylesheet" href="/styles.css" />

    <style>

body { margin: 0; }
html, body { background: #000 !important; }
      main.wrap { max-width: 100%; margin: 0; }

      /* ---- Header alignment: match pricing.html (vault-style) ---- */
      .brand-left {
        display: flex;
        align-items: center;
        gap: 14px;
      }

      .brand-text {
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      .brand-divider {
        width: 1px;
        align-self: stretch;
        background: var(--line);
        margin: 0 10px;
        opacity: 0.9;
      }

      .left-secure-nav {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .nav-chip {
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 0.9rem;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        cursor: default;
        opacity: 0.9;
        text-decoration: none;
        white-space: nowrap;
      }

      .nav-chip:hover { background: rgba(255, 255, 255, 0.06); }

      .nav-chip-pill {
        font-size: 0.78rem;
        color: var(--muted);
        border-radius: 999px;
        padding: 3px 8px;
        border: 1px solid var(--line);
        background: rgba(0, 0, 0, 0.3);
      }

      .nav-chip-active {
        border-color: rgba(96, 165, 250, 0.8);
        box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.4);
        opacity: 1;
      }

      .right-nav-cluster {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .top-nav {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .nav-link {
        border-radius: 999px;
        padding: 8px 14px;
        border: 1px solid transparent;
        background: transparent;
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--muted);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        text-decoration: none;
      }

      .nav-link:hover { background: rgba(255, 255, 255, 0.04); color: var(--text); }

      .nav-link-active {
        border-color: var(--line);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
      }

      .workspace-menu { position: relative; }
      .workspace-toggle { cursor: pointer; }
      .workspace-caret { font-size: 0.8rem; opacity: 0.8; }

      .workspace-dropdown {
        position: absolute;
        right: 0;
        top: 100%;
        margin-top: 8px;
        background: rgba(15, 22, 36, 0.96);
        border: 1px solid var(--line);
        border-radius: 14px;
        box-shadow: var(--shadow);
        padding: 8px;
        display: none;
        flex-direction: column;
        min-width: 280px;
        z-index: 80;
      }

      .workspace-item {
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 0.92rem;
        color: var(--muted);
        text-align: left;
        border: none;
        background: transparent;
        width: 100%;
        cursor: pointer;
        text-decoration: none;
        display: block;
        white-space: nowrap;
      }

      .workspace-item:hover { background: rgba(255, 255, 255, 0.04); color: var(--text); }
      .workspace-menu.workspace-open .workspace-dropdown { display: flex; }

      @media (max-width: 980px) {
        .brand-left { flex-wrap: wrap; }
        .right-nav-cluster { gap: 10px; }
        .workspace-dropdown { right: auto; left: 0; }
      }
    
      /* ---- Sidebar tool grid (3 per row) ---- */
      .tool-tabs{
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
        overflow: auto;
      }
      .tool-tab{
  /* Uniform “tab box” sizing + centered labels */
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  white-space: normal;
  line-height: 1.15;
  min-height: 52px;
  height: 52px;
  padding: 10px 10px;
  width: 100%;
  box-sizing: border-box;

  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.10);
  background: rgba(255, 255, 255, 0.03);
  color: var(--muted);
  font-weight: 700;
  letter-spacing: 0.2px;

  overflow: hidden; /* keep long labels from changing size */
}
.tool-tab:hover{
  background: rgba(255, 255, 255, 0.05);
  color: var(--text);
}
.tool-tab-active{
  border-color: var(--line);
  background: rgba(255, 255, 255, 0.06);
  color: var(--text);
}
      @media (max-width: 1100px){
        .tool-tabs{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
      }
      @media (max-width: 640px){
        .tool-tabs{ grid-template-columns: repeat(1, minmax(0, 1fr)); }
      }

body { margin: 0; }
      main.wrap { max-width: 100%; margin: 0; }

      /* ---- Office layout ---- */
      .office-shell { padding: 14px 14px 24px; }
      .office-grid {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 12px;
        min-height: calc(100vh - 92px);
      }
      .panel {
        background: rgba(255,255,255,0.02);
        border: 1px solid rgba(255,255,255,0.10);
        border-radius: 14px;
        overflow: hidden;
      }
      .panel-head {
        padding: 12px 12px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
        display:flex;
        align-items:center;
        justify-content: space-between;
        gap: 10px;
      }
      .panel-title { font-weight: 900; }
      .panel-body { padding: 12px 12px; }
      .iframe-wrap .panel-body { flex: 1; min-height: 0; padding: 0; }

      .stack { display:flex; flex-direction:column; gap: 10px; }
      .row { display:flex; align-items:center; gap: 8px; flex-wrap: wrap; }
      .muted { color: var(--muted); font-size: 0.92rem; }
      .input, select {
        background: rgba(0,0,0,0.35);
        border: 1px solid rgba(255,255,255,0.12);
        color: var(--text);
        border-radius: 10px;
        padding: 10px 10px;
        outline: none;
      }
      .file-list { display:flex; flex-direction:column; gap: 6px; margin-top: 6px; max-height: calc(100vh - 260px); overflow:auto; padding-right: 4px; }
      .file-item {
        display:flex; align-items:center; justify-content:space-between; gap: 8px;
        padding: 10px 10px;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        background: rgba(255,255,255,0.01);
      }
      .file-name { font-weight: 700; font-size: 0.95rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .file-meta { color: var(--muted); font-size: 0.82rem; }
      .file-actions { display:flex; align-items:center; gap: 8px; flex-shrink: 0; }
      .iframe-wrap { height: 100%; display:flex; flex-direction:column; }
      iframe#officeFrame { width: 100%; height: 100%; border: 0; background: rgba(0,0,0,0.35); }
      .status { margin-top: 8px; font-size: 0.92rem; }
      .status.ok { color: #9ae6b4; }
      .status.err { color: #feb2b2; }
      .small { font-size: 0.86rem; }
      .pill {
        display:inline-flex; align-items:center; gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.10);
        color: var(--muted);
        font-size: 0.85rem;
      }
    

      /* ---- DocForge tabs + clean list ---- */
      .tool-tabs { display:flex; gap: 8px; flex-wrap: wrap; margin: 6px 0 10px; }
      .tab-btn {
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(255,255,255,0.06);
        color: #eaeaea;
        padding: 8px 10px;
        border-radius: 12px;
        font-weight: 700;
        cursor: pointer;
      }
      .tab-btn.active { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.18); }
      .tab-btn:focus { outline: 2px solid rgba(255,255,255,0.22); outline-offset: 2px; }

      .file-list { display:flex; flex-direction: column; gap: 6px; }
      .file-item {
        display:flex;
        align-items:center;
        gap: 10px;
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.08);
        background: rgba(255,255,255,0.04);
        cursor: pointer;
        user-select: none;
      }
      .file-item:hover { background: rgba(255,255,255,0.06); }
      .file-item.selected { background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.18); }
      .file-name { overflow:hidden; text-overflow: ellipsis; white-space: nowrap; width: 100%; font-weight: 700; }
      .file-toolbar { flex-wrap: wrap; gap: 8px; }

    
/* Uniform tool button sizing */
.ps-tabs button, .tabs button, .tool-tabs button, .toolbar button, button.tab, button.tabbtn, .tabbtn, .toolbtn, .tool button{
  min-width: 110px;
  height: 36px;
  padding: 0 12px !important;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-sizing: border-box;
}


/* ===========================
   DocForge File Explorer v2
   =========================== */

/* Details pane (inline rename/move) */
.explorer-wrap{ position: relative; }
.explorer-wrap.with-details .file-list{ padding-right: 360px; }
.explorer-wrap.with-details .file-toolbar{ padding-right: 360px; }

.details-pane{
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 340px;
  border-left: 1px solid rgba(255,255,255,0.08);
  background: linear-gradient(180deg, rgba(15,20,40,0.95), rgba(8,12,24,0.92));
  backdrop-filter: blur(10px);
  border-top-left-radius: 14px;
  border-bottom-left-radius: 14px;
  overflow: hidden;
  z-index: 30;
  box-shadow: -18px 0 40px rgba(0,0,0,0.35);
}
.details-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 12px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
.details-title{ font-weight: 800; letter-spacing: .2px; }
.icon-btn{
  width: 32px; height: 32px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.03);
  color: var(--text);
  cursor: pointer;
}
.details-body{ padding: 12px 12px; overflow:auto; height: calc(100% - 58px); }
.details-row{ padding: 10px 0; border-bottom: 1px dashed rgba(255,255,255,0.08); }
.details-row:last-child{ border-bottom: none; }
.details-actions{ margin-top: 8px; display:flex; gap: 8px; }
.chips{ display:flex; gap: 8px; flex-wrap:wrap; }
.chip{
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.03);
  color: var(--text);
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
  cursor:pointer;
}
.chip.active{ background: rgba(110,168,255,0.14); border-color: rgba(110,168,255,0.32); }
.pin-row, .recentfolders-row{ align-items:center; justify-content:space-between; gap: 10px; }

/* Details pane: preview + activity + share */
.details-preview{
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.25);
  border-radius: 14px;
  overflow: hidden;
  height: 190px;
  display:flex;
  align-items:center;
  justify-content:center;
  position: relative;
}
.details-preview .preview-placeholder{
  padding: 12px;
  text-align:center;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}
.details-preview iframe,
.details-preview img{
  width: 100%;
  height: 100%;
  border: 0;
  display:block;
}
.details-kv{
  display:flex;
  justify-content:space-between;
  gap:10px;
  font-size: 12px;
  color: var(--muted);
}
.details-kv b{ color: var(--text); font-weight: 700; }
.activity-list{ display:flex; flex-direction:column; gap:8px; }
.activity-item{
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  padding: 8px 10px;
}
.activity-item .top{
  display:flex;
  justify-content:space-between;
  gap:10px;
  font-size: 12px;
  color: var(--muted);
}
.activity-item .what{ color: var(--text); font-weight: 700; }
.activity-item .meta{ margin-top: 4px; font-size: 12px; color: var(--muted); line-height:1.3; }
.details-subhead{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  margin-bottom: 8px;
}
.small-btn{
  height: 30px;
  padding: 0 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.03);
  color: var(--text);
  cursor: pointer;
  font-weight: 700;
  font-size: 12px;
}
.small-btn:hover{ background: rgba(255,255,255,0.06); }
.small-btn:disabled{ opacity: .5; cursor: not-allowed; }

.explorer-head{ display:flex; flex-direction:column; gap: 10px; margin-bottom: 10px; }
.explorer-row{ align-items:center; }

.breadcrumbs{
  display:flex;
  align-items:center;
  gap: 6px;
  flex-wrap: wrap;
  padding: 8px 10px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
}
.crumb{
  display:inline-flex;
  align-items:center;
  gap: 6px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.20);
  padding: 6px 10px;
  border-radius: 999px;
  color: var(--text);
  font-weight: 800;
  font-size: 0.86rem;
  cursor: pointer;
}
.crumb:hover{ background: rgba(255,255,255,0.05); }
.crumb.sep{ border: none; background: transparent; padding: 0; cursor: default; opacity: 0.6; font-weight: 900; }

.segmented{
  display:inline-flex;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.25);
  border-radius: 12px;
  overflow: hidden;
}
.seg-btn{
  border: 0;
  background: transparent;
  color: var(--muted);
  padding: 8px 10px;
  font-weight: 800;
  cursor: pointer;
}
.seg-btn:hover{ background: rgba(255,255,255,0.06); color: var(--text); }
.seg-btn.active{ background: rgba(255,255,255,0.12); color: var(--text); }

.toggle-pill{
  cursor: pointer;
  user-select: none;
  padding: 8px 10px;
}
.toggle-pill input{ accent-color: #60a5fa; }

.file-list{ max-height: calc(100vh - 330px); overflow:auto; padding-right: 4px; }
.file-item{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(255,255,255,0.04);
}
.file-item:hover{ background: rgba(255,255,255,0.06); }
.file-item.selected{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.18); }

.file-ico{
  width: 34px;
  height: 34px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.35);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight: 900;
  color: rgba(255,255,255,0.92);
  flex: 0 0 auto;
}

.file-main{ min-width: 0; flex: 1; display:flex; flex-direction:column; gap: 2px; }
.file-name{ overflow:hidden; text-overflow: ellipsis; white-space: nowrap; width: 100%; font-weight: 900; }
.file-sub{ color: var(--muted); font-size: 0.82rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

.file-quick{
  display:flex;
  align-items:center;
  gap: 6px;
  flex: 0 0 auto;
  opacity: 0;
  pointer-events: none;
  transition: opacity 120ms ease;
}
.file-item:hover .file-quick,
.file-item.selected .file-quick{
  opacity: 1;
  pointer-events: auto;
}
.mini-btn{
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.25);
  color: var(--text);
  border-radius: 10px;
  height: 32px;
  padding: 0 10px;
  font-weight: 800;
  cursor: pointer;
}
.mini-btn:hover{ background: rgba(255,255,255,0.06); }
.mini-btn.starred{ border-color: rgba(250,204,21,0.55); box-shadow: 0 0 0 1px rgba(250,204,21,0.25); }

.file-list.grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
}
.file-list.grid .file-item{ flex-direction:column; align-items:stretch; }
.file-list.grid .file-ico{ width: 44px; height: 44px; border-radius: 12px; }
.file-list.grid .file-quick{ opacity: 1; pointer-events:auto; justify-content:flex-end; }
@media (max-width: 980px){
  .file-list.grid{ grid-template-columns: repeat(1, minmax(0, 1fr)); }
}

.row.file-toolbar{
  position: sticky;
  bottom: 0;
  padding: 10px 0 0;
  background: linear-gradient(to top, rgba(10,14,22,0.92), rgba(10,14,22,0));
  border-top: 1px solid rgba(255,255,255,0.06);
  margin-top: 8px;
}


/* ---- DocForge Explorer v4: multi-select, inline actions, hover preview ---- */
.file-item{ position: relative; }
.file-check{
  width: 18px;
  height: 18px;
  accent-color: #60a5fa;
  flex: 0 0 auto;
  margin-right: 2px;
}
.file-quick{ gap: 6px; }
.mini-icon{
  width: 32px;
  height: 32px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.22);
  color: var(--text);
  font-weight: 900;
  cursor: pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  line-height: 1;
}
.mini-icon:hover{ background: rgba(255,255,255,0.06); }
.mini-icon.danger{ border-color: rgba(239,68,68,0.35); }
.mini-icon.starred{ border-color: rgba(250,204,21,0.55); box-shadow: 0 0 0 1px rgba(250,204,21,0.25); }

.bulk-bar{
  position: sticky;
  bottom: 54px;
  z-index: 15;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 10px 10px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.35);
  backdrop-filter: blur(10px);
  border-radius: 14px;
  margin-top: 10px;
}
.bulk-left{ display:flex; align-items:center; gap: 10px; }
.bulk-count{ font-weight: 900; }
.link-btn{
  border: 0;
  background: transparent;
  color: rgba(255,255,255,0.80);
  font-weight: 800;
  cursor: pointer;
  padding: 6px 8px;
  border-radius: 10px;
}
.link-btn:hover{ background: rgba(255,255,255,0.06); color: var(--text); }

.bulk-actions{ display:flex; gap: 8px; flex-wrap: wrap; justify-content:flex-end; }
.bulk-pop{
  position: absolute;
  right: 10px;
  top: calc(100% + 8px);
  width: min(420px, 96vw);
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(12px);
  border-radius: 14px;
  padding: 10px;
  box-shadow: 0 16px 50px rgba(0,0,0,0.55);
}
.bulk-pop .row{ margin-top: 8px; }
.bulk-pop .pop-title{ font-weight: 900; }
.bulk-pop .pop-actions{ display:flex; gap: 8px; justify-content:flex-end; margin-top: 10px; }

.hover-preview{
  position: fixed;
  z-index: 50;
  width: 308px;
  height: 360px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(14px);
  box-shadow: 0 18px 70px rgba(0,0,0,0.65);
  overflow:hidden;
  pointer-events: none;
}
.hover-preview .hp-head{
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
  display:flex;
  gap: 10px;
  align-items:center;
}
.hover-preview .hp-ico{
  width: 34px; height: 34px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.35);
  display:flex; align-items:center; justify-content:center;
  font-weight: 900;
}
.hover-preview .hp-title{
  font-weight: 900;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space: nowrap;
  width: 100%;
}
.hover-preview .hp-body{
  height: calc(100% - 58px);
  display:flex;
  align-items:center;
  justify-content:center;
}
.hover-preview iframe, .hover-preview img{
  width: 100%;
  height: 100%;
  border: 0;
  object-fit: cover;
}
.hover-preview .hp-ph{
  padding: 14px;
  color: rgba(255,255,255,0.70);
  font-weight: 800;
  text-align:center;
}


.file-list.grid .file-check{
  position:absolute;
  top: 12px;
  left: 12px;
}
.file-list.grid .file-ico{ margin-left: 18px; }


/* --- DocForge v5: Drag/Drop + Keyboard nav + Type-to-search --- */
.file-item.kbd-focus{ outline:2px solid rgba(120,180,255,0.8); outline-offset:-2px; }
.file-item.dragging{ opacity:0.65; }
.folder-drop-target.drag-over, .trash-drop-target.drag-over{
  box-shadow: 0 0 0 2px rgba(120,180,255,0.7) inset;
}
.hover-preview{ pointer-events:none; }


      /* --- DocForge Folder Tree --- */
      .foldertree-wrap{
        margin: 8px 0 10px 0;
        border: 1px solid rgba(255,255,255,.08);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(0,0,0,.18);
      }
      .foldertree-head{
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding: 8px 10px;
        border-bottom: 1px solid rgba(255,255,255,.08);
      }
      .foldertree-title{ font-size: 12px; color: rgba(255,255,255,.78); letter-spacing:.2px; }
      .foldertree{ max-height: 220px; overflow:auto; padding: 6px 6px 10px 6px; }
      /* Vault folder area +15% height */
      #folderTreeWrap .foldertree{ max-height: 253px; }

      .foldertree.collapsed{ display:none; }
      .folder-node{
        display:flex;
        align-items:center;
        gap: 6px;
        padding: 6px 8px;
        border-radius: 10px;
        cursor:pointer;
        user-select:none;
        color: rgba(255,255,255,.86);
      }
      .folder-node:hover{ background: rgba(255,255,255,.06); }
      .folder-node.active{ background: rgba(99,102,241,.18); outline: 1px solid rgba(99,102,241,.35); }
      .folder-node .twisty{ width: 14px; display:inline-flex; justify-content:center; opacity:.75; }
      .folder-node .icon{ width: 14px; display:inline-flex; justify-content:center; opacity:.9; }
      .folder-node .name{ flex:1; font-size: 12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
      .file-node{ display:flex; align-items:center; gap:6px; padding: 6px 8px; border-radius: 10px; cursor:pointer; user-select:none; color: rgba(255,255,255,.80); }
      .file-node:hover{ background: rgba(255,255,255,.05); color: rgba(255,255,255,.92); }
      .file-node.active{ background: rgba(99,102,241,.14); outline: 1px solid rgba(99,102,241,.28); }
      .file-node .twisty{ width:14px; display:inline-flex; justify-content:center; opacity:0; }
      .file-node .icon{ width:14px; display:inline-flex; justify-content:center; opacity:.9; }
      .file-node .name{ flex:1; font-size: 12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
      .folder-children{ margin-left: 16px; padding-left: 6px; border-left: 1px dashed rgba(255,255,255,.10); }
      .folder-drop-target.drop-hover{ background: rgba(16,185,129,.18)!important; outline: 1px dashed rgba(16,185,129,.6); }
      .drag-ghost{
        position:fixed; top:-9999px; left:-9999px;
        padding: 10px 12px;
        background: rgba(15,23,42,.92);
        border: 1px solid rgba(255,255,255,.18);
        border-radius: 12px;
        color: rgba(255,255,255,.9);
        font-size: 12px;
        display:flex;
        align-items:center;
        gap: 10px;
        box-shadow: 0 12px 30px rgba(0,0,0,.35);
        pointer-events:none;
      }
      .drag-ghost .badge{
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(99,102,241,.25);
        border: 1px solid rgba(99,102,241,.35);
        font-weight: 600;
      }


/* DocForge view tabs */
.main-tabs{display:flex;gap:10px;margin:2px 0 12px;}
.main-tabs .main-tab{flex:0 0 auto;padding:8px 14px;border-radius:999px;}
.pane{width:100%;}
.suite-hint{opacity:.9;line-height:1.25;margin:2px 2px 10px;}
.pane-files .row.between{margin:0 0 10px;}



      /* --- DocForge Clean Files UI (dedupe + compact) --- */
      #breadcrumbs, #pinRow, #recentFoldersRow { display:none !important; }
      #openIdRow { display:none !important; }
      .explorer-head .explorer-row label[for="folderSelect"],
      .explorer-head .explorer-row #folderSelect { display:none !important; }
      .explorer-head { padding-bottom: 6px; }
      .explorer-head .explorer-row { gap: 10px; }
      .explorer-head .segmented { transform: translateZ(0); }
      .foldertree-wrap { margin-top: 10px; }
      .foldertree-head { padding: 10px 12px; }
      .foldertree { padding: 8px 10px; }
      .toggle-pill { padding: 6px 10px; font-size: 0.86rem; }
      /* keep file list fully visible */
      .explorer-wrap { overflow: visible; }


      /* UX cleanup */
      #filesToSuiteBtn{display:none!important;}
      

      .grid-popout{position:fixed; inset:0; background:rgba(0,0,0,.55); display:flex; align-items:center; justify-content:center; z-index:9999;}
      .grid-popout[hidden]{display:none;}
      .grid-popout-card{width:min(1100px, calc(100vw - 32px)); height:min(820px, calc(100vh - 32px)); background:rgba(16,22,34,.96); border:1px solid rgba(255,255,255,.10); border-radius:16px; box-shadow:0 18px 60px rgba(0,0,0,.45); overflow:hidden; display:flex; flex-direction:column;}
      .grid-popout-head{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08);}
      .grid-popout-title{font-weight:700; letter-spacing:.2px;}
      .grid-popout-body{flex:1; overflow:auto; padding:12px;}
      body.grid-popout-open{overflow:hidden;}



/* --- UI cleanup: hide redundant selection/action controls (requested) --- */
#bulkBar, #bulkPop, #fileToolbar { display: none !important; }
.file-check { display: none !important; }
.file-actions, .mini-icon { display: none !important; }
/* Keep row alignment nice when actions are hidden */
.file-item { justify-content: flex-start !important; }



/* --- Requested: remove redundant bottom file tiles/list; tree-only is the source of truth --- */
#fileList { display: none !important; }

/* --- Requested: remove Details pane sections: Star, Tags, Preview --- */
#detailsPane .details-row:has(#detailsStarBtn),
#detailsPane .details-row:has(#detailsTagsInput){
  display: none !important;
}

/* Hide the Preview pane itself (keep useful buttons like "Copy download link") */
label[for="detailsPreview"],
#detailsPreview,
#detailsPreviewOpenBtn{
  display: none !important;
}

/* --- Tree file hover popout (locked) --- */
.tree-file-popout{
  position: fixed;
  z-index: 9998;
  min-width: 180px;
  max-width: 260px;
  pointer-events: auto;
}
.tree-file-popout[hidden]{ display:none !important; }
.tree-file-popout-card{
  background: rgba(18, 22, 32, .96);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  box-shadow: 0 18px 50px rgba(0,0,0,.55);
  overflow: hidden;
  backdrop-filter: blur(10px);
}
.tree-file-popout-head{
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.tree-file-popout-title{
  font-weight: 700;
  font-size: 13px;
  line-height: 1.2;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tree-file-popout-sub{
  margin-top: 4px;
  font-size: 11px;
  opacity: .75;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tree-file-popout-actions{
  padding: 10px 10px 12px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}
.tree-file-popout-actions .btn{
  width: 100%;
  justify-content: center;
  padding: 9px 10px;
  border-radius: 12px;
}
.tree-file-popout-actions .btn.danger{
  border-color: rgba(255, 90, 90, .35);
}





/* --- Tree Quick Tools (secondary popout) --- */
.tree-quicktools-popout{
  position: fixed;
  z-index: 9999;
  min-width: 360px;
  max-width: 520px;
  pointer-events: auto;
}
.tree-quicktools-popout[hidden]{ display:none !important; }
.tree-quicktools-card{
  background: rgba(18, 22, 32, .96);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  box-shadow: 0 18px 50px rgba(0,0,0,.55);
  overflow: hidden;
  backdrop-filter: blur(10px);
}
.tree-quicktools-head{
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.tree-quicktools-title{
  font-weight: 650;
  font-size: 13px;
  color: rgba(255,255,255,.92);
  letter-spacing: .2px;
}
.tree-quicktools-grid{
  padding: 10px 10px 12px;
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 10px;
}
.qt-tile{
  appearance: none;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.03);
  color: rgba(255,255,255,.88);
  border-radius: 14px;
  padding: 14px 10px;
  font-size: 12px;
  line-height: 1.15;
  text-align: center;
  cursor: pointer;
  min-height: 54px;
  display:flex;
  align-items:center;
  justify-content:center;
  white-space: normal;
}
.qt-tile:hover{
  background: rgba(255,255,255,.06);
  border-color: rgba(255,255,255,.16);
}
.qt-tile:active{
  transform: translateY(1px);
}

/* --- Requested: remove top filter/view tabs (All/Recent/Starred/Trash + List/Grid) --- */
.segmented[aria-label="Filters"],
.segmented[aria-label="View"]{
  display: none !important;
}



/* --- Dual explorer spacing --- */
#guestFolderTreeWrap{ margin-top: 14px; }



/* --- Account status dot (green glow when logged in) --- */
#accountLoginBtn{ display:inline-flex; align-items:center; gap:8px; }
.account-dot{
  width: 8px;
  height: 8px;
  border-radius: 999px;
  display: inline-block;
  background: rgba(255,255,255,.22);
  box-shadow: none;
}
.account-dot.dot-logged-in{
  background: #22c55e;
  box-shadow: 0 0 0 3px rgba(34,197,94,.18), 0 0 18px rgba(34,197,94,.65);
}



/* --- Popout preview + stability tweaks --- */
.tree-file-popout{
  min-width: 616px !important;
  max-width: 968px !important;
}
.tree-file-popout-preview{
  padding: 10px 12px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.tree-file-popout-preview iframe,
.tree-file-popout-preview img{
  width: 100%;
  height: 440px;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  background: rgba(0,0,0,.25);
}
.tree-file-popout-preview .generic{
  width: 100%;
  height: 440px;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: .8;
  font-size: 12px;
}



/* --- Use a single unified popout (hide guest popout) --- */




/* --- Office Suite: hide New button (no uploads/creation here) --- */
#officeSuitePane #newBtn{ display:none !important; }
#officeSuitePane .row:has(#newBtn){ display:none !important; }



/* --- Office Suite tab bar (hide Files tab) --- */
#filesTabBtn{ display:none !important; }
#suiteToFilesBtn{ min-width: 160px; }


/* --- Popout preview: hide built-in PDF viewer toolbar/icons + prevent edits (overlay) --- */
.tree-file-popout-preview{ position: relative; }
.tree-file-popout-preview[data-mode="iframe"]::before{
  content:"";
  position:absolute;
  top:0; left:0; right:0;
  height:56px; /* cover toolbar/edit icons area */
  background: rgba(18, 22, 32, .96);
  z-index: 6;
  pointer-events: auto; /* block toolbar clicks */
}
.tree-file-popout-preview[data-mode="iframe"] iframe{
  pointer-events: auto; /* interactive so password prompts work */ /* make preview non-interactive */
}

/* --- Popout actions: smaller, centered vertical column --- */
.tree-file-popout-actions{
  display:flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 10px 12px 12px;
}
.tree-file-popout-actions .btn{
  width: 60%;
  max-width: 360px;
  min-width: 220px;
  font-size: 12px;
  padding: 7px 10px;
  justify-content: center;
}



/* --- Save modal polish (DocForge) --- */
#saveModal.modal{
  position: fixed;
  inset: 0;
  display: none; /* openModal() switches to flex */
  align-items: center;
  justify-content: center;
  padding: 16px;
  background: rgba(0,0,0,0.55);
  z-index: 9999;
}
#saveModal .modal-card{
  width: min(520px, 92vw);
  background: rgba(18,22,32,0.96);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 18px;
  box-shadow: 0 18px 60px rgba(0,0,0,0.55);
  overflow: hidden;
  backdrop-filter: blur(10px);
}
#saveModal .modal-header{
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  padding: 16px 16px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
#saveModal .modal-title{ font-weight: 900; font-size: 1.1rem; }
#saveModal .modal-body{ padding: 14px 16px; }
#saveModal .modal-footer{
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 10px;
  padding: 12px 16px 16px;
  border-top: 1px solid rgba(255,255,255,0.08);
}
#saveModal label.row{
  flex-wrap: nowrap;
  align-items: center;
  justify-content: flex-start;
  gap: 10px;
}
#saveModal input[type="checkbox"],
#saveModal input[type="radio"]{
  width: 18px !important;
  height: 18px !important;
  padding: 0 !important;
  margin: 0 !important;
  flex: 0 0 auto;
  appearance: auto;
}
#saveModal .modal-body .stack{ gap: 12px; }
#saveModal .status{ margin-top: 4px; }

#saveModal .select,
#saveModal button.select{
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.12);
  color: var(--text);
  border-radius: 10px;
  padding: 10px 10px;
  outline: none;
}
#saveModal button.select{
  display:block;
}

/* Save modal: Vault folder dropdown (anchored, left-pane tree styling) */
#saveModal .save-folder-dropdown.foldertree-wrap{
  position: absolute; /* anchored inside the Folder field container */
  left: 50%;
  top: calc(100% + 8px);
  transform: translateX(-50%);
  margin: 0;
  z-index: 99999;
  min-width: 320px;
  width: max(100%, 320px);
  background: rgba(10,14,22,.98);
  border: 1px solid rgba(255,255,255,.16);
  box-shadow: 0 18px 46px rgba(0,0,0,.62);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
#saveModal.folderdrop-open .modal-card{ overflow: visible; }
#saveModal .save-folder-dropdown .foldertree{
  height: 260px;
  max-height: 260px;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}


/* Hide Trash everywhere (UI still may soft-delete behind the scenes) */
#filterTrashBtn, #detailsTrashBtn, #bulkTrashBtn, #trashSelBtn, #restoreSelBtn, #emptyTrashBtn, #treePopTrashBtn, #guestTreePopTrashBtn { display:none !important; }


      /* ---- Dark UX Prompt Modal ---- */
      .uxp.hidden{ display:none; }
      .uxp{ position:fixed; inset:0; z-index: 99999; display:flex; align-items:center; justify-content:center; }
      .uxp-backdrop{ position:absolute; inset:0; background: rgba(0,0,0,0.72); backdrop-filter: blur(6px); }
      .uxp-card{
        position:relative;
        width:min(520px, calc(100vw - 28px));
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(14,14,18,0.98);
        box-shadow: 0 20px 80px rgba(0,0,0,0.65);
        overflow:hidden;
      }
      .uxp-head{
        display:flex; align-items:center; justify-content:space-between;
        padding: 14px 14px 10px 16px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
      }
      .uxp-title{ font-weight: 800; letter-spacing: 0.2px; color: rgba(255,255,255,0.95); }
      .uxp-x{
        width:36px; height:36px; border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(255,255,255,0.04);
        color: rgba(255,255,255,0.92);
        cursor:pointer;
      }
      .uxp-x:hover{ background: rgba(255,255,255,0.07); }
      .uxp-body{ padding: 14px 16px 6px 16px; }
      .uxp-label{ display:block; font-size: 12px; color: rgba(255,255,255,0.70); margin: 0 0 8px 2px; }
      .uxp-input{
        width:100%;
        padding: 12px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(0,0,0,0.45);
        color: rgba(255,255,255,0.95);
        outline:none;
      }
      .uxp-input:focus{
        border-color: rgba(96,165,250,0.70);
        box-shadow: 0 0 0 3px rgba(96,165,250,0.18);
      }
      .uxp-hint{ min-height: 18px; margin-top: 8px; font-size: 12px; color: rgba(255,255,255,0.55); }
      .uxp-actions{
        display:flex; justify-content:flex-end; gap:10px;
        padding: 10px 16px 16px 16px;
      }
      .uxp-actions .btn{ border-radius: 14px; padding: 10px 14px; }
      .uxp-actions .btn.secondary{
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(255,255,255,0.04);
        color: rgba(255,255,255,0.90);
      }
      .uxp-actions .btn.secondary:hover{ background: rgba(255,255,255,0.07); }
      .uxp-actions .btn.primary{
        border: 1px solid rgba(96,165,250,0.70);
        background: rgba(96,165,250,0.20);
        color: rgba(255,255,255,0.96);
      }
      .uxp-actions .btn.primary:hover{ background: rgba(96,165,250,0.28); }
      .uxp-error{ color: rgba(248,113,113,0.95) !important; }

    
      /* ---- Remove Non-account file explorer ---- */
      #guestFolderTreeWrap{ display:none !important; }
</style>
    <script src="https://unpkg.com/docx-preview@0.3.4/dist/docx-preview.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>

  <body>

    <!-- UX Prompt Modal (dark) -->
    <div id="uxPrompt" class="uxp hidden" aria-hidden="true">
      <div class="uxp-backdrop" data-uxp-close="1"></div>
      <div class="uxp-card" role="dialog" aria-modal="true" aria-labelledby="uxpTitle">
        <div class="uxp-head">
          <div id="uxpTitle" class="uxp-title">Prompt</div>
          <button class="uxp-x" type="button" aria-label="Close" data-uxp-close="1">✕</button>
        </div>
        <div class="uxp-body">
          <label id="uxpLabel" class="uxp-label" for="uxpInput">Label</label>
          <input id="uxpInput" class="uxp-input" type="text" autocomplete="off" />
          <div id="uxpHint" class="uxp-hint"></div>
        </div>
        <div class="uxp-actions">
          <button id="uxpCancel" class="btn secondary" type="button" data-uxp-cancel="1">Cancel</button>
          <button id="uxpOk" class="btn primary" type="button">OK</button>
        </div>
      </div>
    </div>

    <header class="topbar">
      <div class="topbar-inner">
        <!-- LEFT: Brand + Secure tabs -->
        <div class="brand-left">
          <div class="brand">
            <div class="logo"></div>
            <div class="brand-text">PDFRealm</div>
          </div>

          <div class="brand-divider"></div>

          <nav class="left-secure-nav" aria-label="Secure">
                                    <a href="/?ai=1" class="nav-chip" id="aiOperatorNav">AI Operator</a>
<a href="/?ai=1" class="nav-chip" data-ai-nav="1">
              AI Operator
              <span class="nav-chip-pill">BETA</span>
            </a>
<a href="/vault.html" class="nav-chip">
              Secure Vault
              <span class="nav-chip-pill">AES-256</span>
            </a>
            <a href="/office.html" class="nav-chip nav-chip-active">
              DocForge
              <span class="nav-chip-pill">PDFStudio + Office Suite</span>
            </a>
            <a href="/" class="nav-chip">Quick Tools</a>
          </nav>
        </div>

        <!-- RIGHT: Tools + Industry Packs + Pricing + Account -->
        <div class="right-nav-cluster">
          <nav class="top-nav" aria-label="Primary">
<div class="workspace-menu" id="industryMenuWrap">
              <button class="nav-link workspace-toggle" type="button" id="industryToggle">
                Industry Packs
                <span class="workspace-caret">▾</span>
              </button>
              <div class="workspace-dropdown" id="industryDropdown" role="menu" aria-label="Industry Packs">
                <a class="workspace-item" role="menuitem" href="/broker.html">Broker TMS Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/carrier.html">Carrier Dashboard</a>
                <div style="height:1px; background: rgba(255,255,255,0.10); margin: 8px 10px;"></div>
                <a class="workspace-item" role="menuitem" href="/legal.html">Legal Workspace</a>
                <a class="workspace-item" role="menuitem" href="/real-estate.html">Real Estate Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/accounting.html">Accounting Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/hr.html">HR Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/marketing.html">Marketing Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/csuite.html">C-Suite Dashboard</a>
              </div>
            </div>

            <a href="/pricing.html" class="nav-link">Pricing</a>
          </nav>

          <div class="top-actions">
            <button
              id="accountLoginBtn"
              class="btn"
              type="button"
              aria-haspopup="dialog"
              aria-controls="accountModal"
            >Account <span id="accountDot" class="account-dot" aria-hidden="true"></span></button>
          </div>
        </div>
      </div>
    </header>

    <main class="wrap office-shell">
      <div class="office-grid">
        <!-- LEFT: Vault Office files -->
        <section class="panel">
          <div class="panel-head">
            <div>
              <div class="panel-title">Office Workspace</div>
              <div class="muted small"></div>
            </div>
            <span class="pill" id="authPill">Auth: unknown</span>
          </div>

          <div class="panel-body">
            <div class="stack">

<div class="main-tabs" id="mainTabs" role="tablist" aria-label="DocForge Views">
  <button type="button" class="tab-btn main-tab" id="suiteTabBtn" role="tab" aria-selected="true">Office Suite</button>
</div>

              <div id="officeSuitePane" class="pane pane-suite">
  <div class="muted small suite-hint">Pick a tool tab, then press Enter.</div>
  <div class="tool-tabs" id="toolTabs" role="tablist" aria-label="DocForge Tools">
  <button type="button" class="tab-btn active" data-tool="pdf" role="tab" aria-selected="true">PDFStudio</button>
  <button type="button" class="tab-btn" data-tool="docx" role="tab" aria-selected="false">Docx</button>
  <button type="button" class="tab-btn" data-tool="pptx" role="tab" aria-selected="false">PPTX</button>
  <button type="button" class="tab-btn" data-tool="xlsx" role="tab" aria-selected="false">ExcelX</button>
</div>
<div class="row gap" style="justify-content:center; align-items:center;">
    <button class="btn" id="suiteToFilesBtn" type="button">Enter</button>
  
  </div>
</div>

<div id="filesPane" class="pane pane-files" style="display:none;">
  <div class="row between">
    <span class="pill" id="modePill">Mode: PDFStudio</span>
    <button class="btn" id="filesToSuiteBtn" type="button">Office Suite</button>
  </div>
  <div class="explorer-wrap" id="explorerWrap">

<div class="explorer-head">
  <div class="breadcrumbs" id="breadcrumbs" aria-label="Folder breadcrumbs"></div>

  <div class="row pin-row" id="pinRow">
    <div class="chips" id="pinnedFolders" aria-label="Pinned folders"></div>
    <button class="btn btn-secondary" id="pinFolderBtn" type="button" title="Pin/unpin current folder">Pin</button>
  </div>

  <div class="row recentfolders-row" id="recentFoldersRow" style="display:none">
    <span class="muted small" style="min-width:64px">Recent</span>
    <div class="chips" id="recentFolders" aria-label="Recent folders"></div>
  </div>


  <div class="row explorer-row">
    <label class="muted small" for="folderSelect">Folder</label>
    <select id="folderSelect" class="input" style="min-width: 210px;">
      <option value="">/ (root)</option>
    </select>

    <button class="btn btn-secondary" id="refreshBtn" type="button" title="Refresh (R)">Refresh</button>
    <button class="btn btn-secondary" id="uploadBtn" type="button" title="Upload files to this folder">Upload</button>
    <button class="btn btn-secondary" id="newFolderBtn" type="button" title="Create a new folder">New folder</button>
    <button class="btn btn-secondary" id="newBtn" type="button" style="display:none">Tool</button>
    <input id="uploadInput" type="file" style="display:none" multiple accept=".pdf,application/pdf" />
  </div>
  <div class="row explorer-row" style="justify-content: space-between; gap: 10px;">
    <div class="row" style="gap: 10px; flex-wrap: wrap;">
      <div class="segmented" role="tablist" aria-label="Filters">
        <button class="seg-btn active" id="filterAllBtn" type="button">All</button>
        <button class="seg-btn" id="filterRecentBtn" type="button">Recent</button>
        <button class="seg-btn" id="filterStarBtn" type="button">Starred</button>
        <button class="seg-btn trash-drop-target" id="filterTrashBtn" type="button">Trash</button>
      </div>
    </div>

    <div class="segmented" role="tablist" aria-label="View">
      <button class="seg-btn active" id="viewListBtn" type="button" title="List view">List</button>
      <button class="seg-btn" id="viewGridBtn" type="button" title="Grid view">Grid</button>
    </div>
  </div>
</div>

  <div class="foldertree-wrap" id="folderTreeWrap">
    <div class="foldertree-head">
      <div class="foldertree-title">Vault Folder</div>
      <div class="foldertree-actions">
        <button class="icon-btn" id="folderTreeCollapseBtn" type="button" title="Collapse/expand folder tree">▾</button>
      </div>
    </div>
    <div class="foldertree" id="folderTree" aria-label="Folder tree"></div>
  </div>
  
  <!-- Local (no-account) explorer (upsell alternative to Vault) -->
  <div class="foldertree-wrap" id="guestFolderTreeWrap">
    <div class="foldertree-head">
      <div class="foldertree-title" style="display:flex; align-items:center; gap:10px;">
        <span>Non-account Folder</span>
        <span class="pill" id="guestExportPricePill" title="Export price">$2.99 export</span>
      </div>
      <div class="foldertree-actions" style="display:flex; align-items:center; gap:8px;">
        <button class="btn btn-secondary" id="guestImportPdfBtn" type="button" title="Import a PDF into Non-account Folder">Import PDF</button>
        <button class="icon-btn" id="guestFolderTreeCollapseBtn" type="button" title="Collapse/expand local folder tree">▾</button>
      </div>
    </div>
    <input id="guestImportPdfInput" type="file" accept=".pdf,application/pdf" style="display:none" />
    <div class="foldertree" id="guestFolderTree" aria-label="Local folder tree"></div>
  </div>


<div class="file-list" id="fileList"></div>


<div class="bulk-bar" id="bulkBar" hidden>
  <div class="bulk-left">
    <span class="bulk-count" id="bulkCount">0 selected</span>
    <button class="link-btn" id="bulkSelectAllBtn" type="button" title="Select all in view">Select all</button>
    <button class="link-btn" id="bulkClearBtn" type="button" title="Clear selection (Esc)">Clear</button>
  </div>

  <div class="bulk-actions">
    <button class="btn btn-secondary" id="bulkOpenBtn" type="button">Open</button>
    <button class="btn btn-secondary" id="bulkMoveBtn" type="button">Move</button>
    <button class="btn btn-secondary" id="bulkTrashBtn" type="button">Trash</button>
    <button class="btn btn-danger" id="bulkDeleteBtn" type="button">Delete</button>
    <button class="btn btn-secondary" id="bulkStarBtn" type="button" title="Star / Unstar">★</button>
    <button class="btn btn-secondary" id="bulkTagBtn" type="button">Tag</button>
  </div>

  <div class="bulk-pop" id="bulkPop" hidden aria-label="Bulk action panel">
    <div class="pop-title" id="bulkPopTitle">Bulk action</div>
    <div id="bulkPopBody"></div>
  </div>
</div>


<div class="row file-toolbar" id="fileToolbar">
  <button class="btn btn-secondary" id="openSelBtn" type="button" disabled>Open</button>
  <button class="btn btn-secondary" id="renameSelBtn" type="button" disabled>Rename</button>
  <button class="btn btn-secondary" id="moveSelBtn" type="button" disabled>Move</button>
  <button class="btn btn-secondary" id="trashSelBtn" type="button" disabled>Trash</button>
  <button class="btn btn-secondary" id="restoreSelBtn" type="button" disabled style="display:none;">Restore</button>
  <button class="btn btn-secondary" id="emptyTrashBtn" type="button" disabled style="display:none;">Empty Trash</button>
  <button class="btn btn-danger" id="deleteSelBtn" type="button" disabled>Delete</button>
</div>

              <div class="row" id="openIdRow">
                <input id="openIdInput" class="input" placeholder="Open by File ID (UUID)..." style="flex:1; min-width: 200px;" />
                <button class="btn btn-secondary" id="openIdBtn" type="button">Open</button>
              </div>
  <aside class="details-pane" id="detailsPane" hidden aria-label="Selected file details">
    <div class="details-head">
      <div class="details-title">Details</div>
      <button class="icon-btn" id="detailsCloseBtn" type="button" title="Close">✕</button>
    </div>

    <div class="details-body">
      <div class="details-row">
        <label class="muted small">Name</label>
        <input class="input" id="detailsNameInput" type="text" placeholder="File name" />
        <div class="details-actions">
          <button class="btn btn-secondary" id="detailsRenameBtn" type="button">Save name</button>
        </div>
      </div>

      <div class="details-row">
        <label class="muted small">Folder</label>
        <select class="input" id="detailsFolderSelect">
          <option value="">/ (root)</option>
        </select>
        <input class="input" id="detailsFolderInput" type="text" placeholder="Or type folder path (e.g. forms/2026)" />
        <div class="details-actions">
          <button class="btn btn-secondary" id="detailsMoveBtn" type="button">Move</button>
        </div>
      </div>

      <div class="details-row">
        <label class="muted small">Star</label>
        <div class="row" style="justify-content:space-between; align-items:center; gap:10px;">
          <span class="muted small">Keep at top</span>
          <button class="btn btn-secondary" id="detailsStarBtn" type="button" title="Toggle star">☆</button>
        </div>
      </div>

      <div class="details-row">
        <label class="muted small">Tags</label>
        <input class="input" id="detailsTagsInput" type="text" placeholder="comma,separated,tags" />
        <div class="muted small" style="margin-top:6px">Tags are saved locally for now.</div>
      </div>

      <div class="details-row">
        <label class="muted small">Info</label>
        <div class="muted small" id="detailsInfo" style="line-height:1.4">—</div>
      </div>
      <div class="details-row">
        <div class="details-subhead">
          <label class="muted small" style="margin:0">Preview</label>
          <button class="small-btn" id="detailsPreviewOpenBtn" type="button" title="Open in main preview">Open</button>
        </div>
        <div class="details-preview" id="detailsPreview">
          <div class="preview-placeholder">Select a file to preview.</div>
        </div>
        <div class="details-kv" style="margin-top:8px">
          <span>Access</span>
          <b id="detailsPermLabel">Private (Vault)</b>
        </div>
        <div class="details-actions" style="margin-top:8px">
          <button class="btn btn-secondary" id="detailsCopyLinkBtn" type="button" title="Creates a temporary signed download link">Copy download link</button>
        </div>
      </div>

      <div class="details-row">
        <div class="details-subhead">
          <label class="muted small" style="margin:0">Duplicates</label>
          <button class="small-btn" id="detailsFindDupesBtn" type="button">Find</button>
        </div>
        <div class="muted small" id="detailsDupes">—</div>
      </div>

      <div class="details-row">
        <div class="details-subhead">
          <label class="muted small" style="margin:0">Activity</label>
          <button class="small-btn" id="detailsClearActivityBtn" type="button">Clear</button>
        </div>
        <div class="activity-list" id="detailsActivity"></div>
      </div>


      <div class="details-row">
        <label class="muted small">Actions</label>
        <div class="row" style="gap:8px; flex-wrap:wrap;">
          <button class="btn btn-primary" id="detailsOpenBtn" type="button">Open</button>
          <button class="btn btn-secondary" id="detailsTrashBtn" type="button">Trash</button>
          <button class="btn btn-danger" id="detailsDeleteBtn" type="button">Delete</button>
        </div>
      </div>
    </div>
  </aside>

</div>


              <div class="status" id="status"></div>
            </div>
          </div>
        
</div>
</section>

        <!-- RIGHT: Collabora iframe -->
        <section class="panel iframe-wrap">
          <div class="panel-head">
            <div>
              <div class="panel-title">Editor</div>
              <div class="muted small"></div>
            </div>
            <div class="row">
              <button class="btn btn-primary" id="saveBtn" type="button">Save</button>
              <button class="btn btn-secondary" id="popoutBtn" type="button">Popout</button>
              <button class="btn btn-secondary" id="clearBtn" type="button">Clear</button>
            </div>
          </div>
          <div class="panel-body" style="padding: 0;">
            <iframe id="officeFrame" title="PDFRealm Office Editor" referrerpolicy="no-referrer"></iframe>
          </div>
        </section>
      </div>
    </main>

    

    <!-- Account Modal -->
<div id="accountModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="mh">Account</div>
          <button id="accountModalClose" class="btn btn-secondary" type="button">Close</button>
        </div>
        <div class="modal-body">
          <div class="card">
            <label for="loginEmail">Email</label>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
            <label for="loginPassword">Password</label>
            <input id="loginPassword" type="password" placeholder="••••••••" />
            <div class="modal-row">
              <button id="loginSubmitBtn" class="btn btn-primary" type="button">Login</button>
              <button id="logoutBtn" class="btn btn-secondary" type="button" style="display:none;">Sign out</button>
              <button id="subscribeMonthlyBtn" class="btn btn-secondary" type="button">Subscribe (stub)</button>
              <button id="subscribeYearlyBtn" class="btn btn-secondary" type="button">Subscribe (stub)</button>
            </div>
            <div id="loginStatus" style="margin-top:10px; color: var(--muted); font-size: 0.95rem;"></div>
          </div>
        </div>
      </div>
    </div>
<!-- Save modal -->
    <div class="modal" id="saveModal" role="dialog" aria-modal="true" aria-labelledby="saveModalTitle" style="display:none;">
      <div class="modal-card">
        <div class="modal-header">
          <div>
            <div class="modal-title" id="saveModalTitle">Save</div>
            <div class="muted small" id="saveModalSub">Choose where to save this file.</div>
          </div>
          <button class="icon-btn" type="button" id="saveModalClose" aria-label="Close">✕</button>
        </div>

        <div class="modal-body">
          <div class="stack">
            <label class="row" style="justify-content:flex-start; gap:10px;">
              <input type="checkbox" id="saveLocalChk" checked />
              <span>Download to this device</span>
            </label>

            <label class="row" style="justify-content:flex-start; gap:10px;">
              <input type="checkbox" id="saveVaultChk" />
              <span>Save to Vault</span>
            </label>

            
            <label id="saveEncryptRow" class="row" style="justify-content:flex-start; gap:10px; margin-top:6px;">
               <input type="checkbox" id="saveEncryptChk" />
              <span>Password/Encrypt file (PDF)</span>
            </label>

            <div id="saveEncryptPwRow" class="stack" style="display:none; padding-left:26px;">              <div class="muted small">Current password (only if this PDF is already protected)</div>
              <input class="input" id="saveEncryptCurrPw" type="password" placeholder="Enter current password" autocomplete="current-password" />
              <div class="muted small" style="margin-top:10px;">New password</div>
<input class="input" id="saveEncryptPw" type="password" placeholder="Enter password" autocomplete="new-password" />
              <div class="muted small" style="margin-top:6px;">Confirm password (optional)</div>
              <input class="input" id="saveEncryptPw2" type="password" placeholder="Re-enter password" autocomplete="new-password" />
            </div>

<div id="vaultSaveOptions" class="stack" style="display:none; padding:10px; border:1px solid rgba(255,255,255,0.12); border-radius:12px;">
              <label class="row" style="justify-content:flex-start; gap:10px;">
                <input type="radio" name="vaultSaveMode" value="overwrite" checked />
                <span>Overwrite this file</span>
              </label>
              <label class="row" style="justify-content:flex-start; gap:10px;">
                <input type="radio" name="vaultSaveMode" value="copy" />
                <span>Save as a new copy</span>
              </label>

              <div class="row" style="gap:10px;">
                <div style="flex:1; position:relative;">
                  <div class="muted small">Folder</div>
                  <button id="saveVaultFolderBtn" class="select" type="button" style="width:100%; text-align:left; cursor:pointer;">(root)</button>

                  <!-- True dropdown folder picker (matches left pane explorer styles) -->
                  <div id="saveVaultFolderDropdown" class="foldertree-wrap save-folder-dropdown" aria-hidden="true" style="display:none;">
                    <div class="foldertree-head">
                      <div class="foldertree-title">Select folder</div>
                      <button id="saveVaultFolderDropClose" class="toggle-pill" type="button">Close</button>
                    </div>
                    <div class="foldertree" id="saveVaultFolderTree" aria-label="Folder tree"></div>
                  </div>

                  <select id="saveVaultFolder" class="select" style="display:none;"></select>
                </div>
                <div style="flex:1;">
                  <div class="muted small">Filename</div>
                  <input id="saveVaultName" class="input" placeholder="document.pdf" />
                </div>
              </div>
              <div class="muted small">If you choose “Save as a new copy”, the original stays unchanged.</div>
            </div>

            <div class="status" id="saveStatus"></div>
          </div>
        </div>

        <div class="modal-footer">
          <button class="btn btn-secondary" type="button" id="saveCancelBtn">Cancel</button>
          <button class="btn btn-primary" type="button" id="saveConfirmBtn">Save</button>
        </div>
      </div>
    </div>

  


    <script>
      (function(){
        const LS = { TOKEN: "pdfrealm_token" };
        const els = {
          authPill: document.getElementById("authPill"),

          toolTabs: document.getElementById("toolTabs"),
          newBtn: document.getElementById("newBtn"),

          refreshBtn: document.getElementById("refreshBtn"),
          folderSelect: document.getElementById("folderSelect"),
          folderTree: document.getElementById("folderTree"),
          folderTreeWrap: document.getElementById("folderTreeWrap"),
          folderTreeCollapseBtn: document.getElementById("folderTreeCollapseBtn"),

          pinnedFolders: document.getElementById("pinnedFolders"),
          pinFolderBtn: document.getElementById("pinFolderBtn"),
          recentFoldersRow: document.getElementById("recentFoldersRow"),
          recentFolders: document.getElementById("recentFolders"),

          explorerWrap: document.getElementById("explorerWrap"),
          detailsPane: document.getElementById("detailsPane"),
          detailsCloseBtn: document.getElementById("detailsCloseBtn"),
          detailsNameInput: document.getElementById("detailsNameInput"),
          detailsRenameBtn: document.getElementById("detailsRenameBtn"),
          detailsFolderSelect: document.getElementById("detailsFolderSelect"),
          detailsFolderInput: document.getElementById("detailsFolderInput"),
          detailsMoveBtn: document.getElementById("detailsMoveBtn"),
          detailsStarBtn: document.getElementById("detailsStarBtn"),
          detailsTagsInput: document.getElementById("detailsTagsInput"),
          detailsInfo: document.getElementById("detailsInfo"),
          detailsOpenBtn: document.getElementById("detailsOpenBtn"),
          detailsTrashBtn: document.getElementById("detailsTrashBtn"),
          detailsDeleteBtn: document.getElementById("detailsDeleteBtn"),

          detailsPreview: document.getElementById("detailsPreview"),
          detailsPreviewOpenBtn: document.getElementById("detailsPreviewOpenBtn"),
          detailsCopyLinkBtn: document.getElementById("detailsCopyLinkBtn"),
          detailsPermLabel: document.getElementById("detailsPermLabel"),
          detailsDupes: document.getElementById("detailsDupes"),
          detailsFindDupesBtn: document.getElementById("detailsFindDupesBtn"),
          detailsActivity: document.getElementById("detailsActivity"),
          detailsClearActivityBtn: document.getElementById("detailsClearActivityBtn"),

          searchInput: document.getElementById("searchInput"),
          fileList: document.getElementById("fileList"),

          bulkBar: document.getElementById("bulkBar"),
          bulkCount: document.getElementById("bulkCount"),
          bulkSelectAllBtn: document.getElementById("bulkSelectAllBtn"),
          bulkClearBtn: document.getElementById("bulkClearBtn"),
          bulkOpenBtn: document.getElementById("bulkOpenBtn"),
          bulkMoveBtn: document.getElementById("bulkMoveBtn"),
          bulkTrashBtn: document.getElementById("bulkTrashBtn"),
          bulkDeleteBtn: document.getElementById("bulkDeleteBtn"),
          bulkStarBtn: document.getElementById("bulkStarBtn"),
          bulkTagBtn: document.getElementById("bulkTagBtn"),
          bulkPop: document.getElementById("bulkPop"),
          bulkPopTitle: document.getElementById("bulkPopTitle"),
          bulkPopBody: document.getElementById("bulkPopBody"),

          hoverPreview: document.getElementById("hoverPreview"),
          hpIco: document.getElementById("hpIco"),
          hpTitle: document.getElementById("hpTitle"),
          hpBody: document.getElementById("hpBody"),

          openSelBtn: document.getElementById("openSelBtn"),
          renameSelBtn: document.getElementById("renameSelBtn"),
          moveSelBtn: document.getElementById("moveSelBtn"),
          trashSelBtn: document.getElementById("trashSelBtn"),
          restoreSelBtn: document.getElementById("restoreSelBtn"),
          emptyTrashBtn: document.getElementById("emptyTrashBtn"),
          deleteSelBtn: document.getElementById("deleteSelBtn"),

          status: document.getElementById("status"),
          openIdInput: document.getElementById("openIdInput"),
          openIdBtn: document.getElementById("openIdBtn"),
          frame: document.getElementById("officeFrame"),
          popoutBtn: document.getElementById("popoutBtn"),
          clearBtn: document.getElementById("clearBtn"),
          saveBtn: document.getElementById("saveBtn"),
          saveModal: document.getElementById("saveModal"),
          saveModalClose: document.getElementById("saveModalClose"),
          saveCancelBtn: document.getElementById("saveCancelBtn"),
          saveConfirmBtn: document.getElementById("saveConfirmBtn"),
          saveLocalChk: document.getElementById("saveLocalChk"),
          saveVaultChk: document.getElementById("saveVaultChk"),
          vaultSaveOptions: document.getElementById("vaultSaveOptions"),
          saveVaultFolder: document.getElementById("saveVaultFolder"),
          saveVaultFolderBtn: document.getElementById("saveVaultFolderBtn"),
          saveVaultFolderDropdown: document.getElementById("saveVaultFolderDropdown"),
          saveVaultFolderTree: document.getElementById("saveVaultFolderTree"),
          saveVaultFolderDropClose: document.getElementById("saveVaultFolderDropClose"),
          saveVaultName: document.getElementById("saveVaultName"),
          saveEncryptChk: document.getElementById("saveEncryptChk"),
          saveEncryptPwRow: document.getElementById("saveEncryptPwRow"),
                    saveEncryptCurrPw: document.getElementById("saveEncryptCurrPw"),
saveEncryptPw: document.getElementById("saveEncryptPw"),
          saveEncryptPw2: document.getElementById("saveEncryptPw2"),
          saveStatus: document.getElementById("saveStatus"),
          breadcrumbs: document.getElementById("breadcrumbs"),
          sortSelect: document.getElementById("sortSelect"),
          quickOpenChk: document.getElementById("quickOpenChk"),
          viewListBtn: document.getElementById("viewListBtn"),
          viewGridBtn: document.getElementById("viewGridBtn"),
          filterAllBtn: document.getElementById("filterAllBtn"),
          filterRecentBtn: document.getElementById("filterRecentBtn"),
          filterStarBtn: document.getElementById("filterStarBtn"),
          filterTrashBtn: document.getElementById("filterTrashBtn"),
          uploadBtn: document.getElementById("uploadBtn"),
          uploadInput: document.getElementById("uploadInput"),
          newFolderBtn: document.getElementById("newFolderBtn"),
        };

/* --- Tree file hover popout controller (locked) --- */
const treePop = (() => {
  let wrap = null;
  let card = null;
  let titleEl = null;
  let subEl = null;
  let frameEl = null;
  let imgEl = null;
  let genEl = null;
  const vaultPreviewCache = new Map(); // id -> objectURL
  const vaultPreviewBlobCache = new Map(); // id -> Blob

  async function getVaultPreviewBlob(id){
    const sid = String(id||"");
    if (!sid) return null;
    if (vaultPreviewBlobCache.has(sid)) return vaultPreviewBlobCache.get(sid);
    if (!state.token) return null;
    const proxy = "/api/vault/file-proxy/" + encodeURIComponent(sid);
    const resp = await fetch(proxy, { headers: (state.token ? { "Authorization": "Bearer " + state.token } : {}),
            credentials: "same-origin" });
    if (!resp.ok) throw new Error("Preview fetch failed ("+resp.status+")");
    const blob = await resp.blob();
    vaultPreviewBlobCache.set(sid, blob);

    // Cache a local copy so previews can still work when signed out
    try{
      if (typeof guestPutBlob === "function"){
        const nm = (current && current.item && (current.item.name || current.item.filename)) || ("vault_" + sid);
        const f = new File([blob], nm, { type: blob.type || "application/octet-stream" });
        await guestPutBlob("v_" + sid, f);
      }
    } catch(e){}
    return blob;
  }

  async function getVaultPreviewUrl(id){
    const sid = String(id||"");
    if (!sid) return "";
    if (vaultPreviewCache.has(sid)) return vaultPreviewCache.get(sid);
    const blob = await getVaultPreviewBlob(sid);
    if (!blob) return "";
    const url = URL.createObjectURL(blob);
    vaultPreviewCache.set(sid, url);
    return url;
  }

  async function renderRichPreviewFromBlob(blob, filename){
    const name = String(filename||"").toLowerCase();
    if (!blob) return false;
    if (!frameEl) return false;

    const isDocx = !!name.match(/\.(docx|doc|odt|rtf)$/);
    const isXlsx = !!name.match(/\.(xlsx|xls|ods|csv|tsv)$/);
    const isText = !!name.match(/\.(txt|md|json|log|csv|tsv|js|ts|css|html|xml|yml|yaml)$/);

    // helper to write html into iframe
    const writeIframe = (bodyHtml, headHtml="")=>{
      const d = frameEl.contentDocument;
      if (!d) return;
      d.open();
      d.write(`<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">${headHtml}</head><body>${bodyHtml}
</body></html>`);
      d.close();
    };

    try{
      setPreviewMode("iframe");
      if (frameEl.src !== "about:blank") frameEl.src = "about:blank";
    }catch(e){}

    await new Promise(r=>setTimeout(r,0));

    if (isDocx){
      const ab = await blob.arrayBuffer();
      if (window.docx && typeof window.docx.renderAsync === "function"){
        writeIframe('<div id="docx-root" style="padding:10px;"></div>',
          '<style>body{margin:0;padding:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}</style>');
        await new Promise(r=>setTimeout(r,0));
        const d = frameEl.contentDocument;
        const root = d && d.getElementById("docx-root");
        if (!root) return false;
        try{
          await window.docx.renderAsync(ab, root, root, { breakPages: true });
        }catch(e){
          root.innerHTML = `<div style="padding:12px;font:12px/1.4 system-ui;">DOCX preview failed: ${String(e && e.message || e)}</div>`;
        }
        return true;
      } else {
        writeIframe('<div style="padding:12px;font:12px/1.4 system-ui;">DOCX preview library not loaded (docx-preview). If you are offline, bundle it locally.</div>');
        return true;
      }
    }

    if (isXlsx){
      const ab = await blob.arrayBuffer();
      if (window.XLSX){
        try{
          const wb = window.XLSX.read(ab, { type: "array" });
          const sheetName = (wb.SheetNames && wb.SheetNames[0]) ? wb.SheetNames[0] : null;
          const ws = sheetName ? wb.Sheets[sheetName] : null;
          const htmlTable = ws ? window.XLSX.utils.sheet_to_html(ws, { editable:false }) : "<div style='padding:12px;'>No sheets</div>";
          const head = "<style>body{margin:0;padding:10px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;} table{border-collapse:collapse;} td,th{border:1px solid #ddd;padding:4px 6px;font-size:12px;vertical-align:top;} </style>";
          writeIframe(htmlTable, head);
        }catch(e){
          writeIframe(`<div style="padding:12px;font:12px/1.4 system-ui;">Spreadsheet preview failed: ${String(e && e.message || e)}</div>`);
        }
        return true;
      } else {
        writeIframe('<div style="padding:12px;font:12px/1.4 system-ui;">Spreadsheet preview library not loaded (xlsx / SheetJS). If you are offline, bundle it locally.</div>');
        return true;
      }
    }

    if (isText){
      let t = "";
      try{ t = await blob.text(); }catch(e){}
      const safe = String(t||"").slice(0, 200000);
      const esc = safe.replace(/[&<>]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;" }[c]));
      const head = "<style>body{margin:0;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono',monospace;font-size:12px;white-space:pre-wrap;word-break:break-word;}</style>";
      writeIframe("<pre>"+esc+"</pre>", head);
      return true;
    }

    return false;
  }

  function setPreviewMode(mode){
    // mode: 'iframe' | 'img' | 'generic'
    if (!frameEl || !imgEl || !genEl) return;
    
    try{
      const wrap = (frameEl && frameEl.closest) ? frameEl.closest(".tree-file-popout-preview") : (frameEl ? frameEl.parentElement : null);
      if (wrap) wrap.dataset.mode = mode;
    } catch(e){}
// hide all
    frameEl.hidden = true; frameEl.style.display = "none";
    imgEl.hidden = true; imgEl.style.display = "none";
    genEl.hidden = true; genEl.style.display = "none";
    if (mode === 'iframe') { frameEl.hidden = false; frameEl.style.display = "block"; }
    if (mode === 'img') { imgEl.hidden = false; imgEl.style.display = "block"; }
    if (mode === 'generic') { genEl.hidden = false; genEl.style.display = "flex"; }
  }


  let btnOpen = null;
  let btnRename = null;
  let btnMove = null;
  let btnTrash = null;
  let btnDelete = null;
  let btnQuickTools = null;
  let qtWrap = null;
  let qtHideTimer = null;
  let btnSaveVault = null;

  let current = null; // { item, folderPath, anchorEl }
  let hideTimer = null;

  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

  function bind(){
    wrap = document.getElementById("treeFilePopout");
    if (!wrap) return false;

    card = wrap.querySelector(".tree-file-popout-card");
    titleEl = document.getElementById("treeFilePopoutTitle");
    subEl = document.getElementById("treeFilePopoutSub");
    frameEl = document.getElementById("treeFilePopoutFrame");
    imgEl = document.getElementById("treeFilePopoutImg");
    genEl = document.getElementById("treeFilePopoutGeneric");

    btnOpen = document.getElementById("treePopOpenBtn");
    btnRename = document.getElementById("treePopRenameBtn");
    btnMove = document.getElementById("treePopMoveBtn");
    btnTrash = document.getElementById("treePopTrashBtn");
    try{ if (btnTrash){ btnTrash.hidden = true; btnTrash.disabled = true; } }catch(e){}
    btnDelete = document.getElementById("treePopDeleteBtn");
    btnQuickTools = document.getElementById("treePopQuickToolsBtn");
    qtWrap = document.getElementById("treeQuickToolsPopout");
    // Ensure the secondary popout is attached to <body> so it can render above everything
    try {
      if (qtWrap && qtWrap.parentElement !== document.body) document.body.appendChild(qtWrap);
    } catch(e){}
    btnSaveVault = document.getElementById("treePopSaveVaultBtn");

    // Only wire events once
    if (!wrap.dataset.bound){
      const cancelHide = ()=>{ clearTimeout(hideTimer); };
      const scheduleHide = ()=>{
        clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
          if (!wrap) return;
          if (qtWrap) qtWrap.hidden = true;
          wrap.hidden = true;
          current = null;
        }, 140);
      };

      // Lock behavior: popout remains open while hovered
      wrap.addEventListener("mouseenter", cancelHide);
      wrap.addEventListener("mouseleave", scheduleHide);

      // Button handlers (use existing app functions)
      const ensureFolderSelected = async (folderPath)=>{
        const fp = String(folderPath || "");
        if (String(state.currentFolder || "") !== fp){
          state.currentFolder = fp;
          try { els.folderSelect.value = state.currentFolder; } catch(e){}
          try { trackRecentFolder(state.currentFolder); } catch(e){}
          try { savePrefs(); } catch(e){}
          try { await loadList();
  // FALLBACK: file may have landed in a different folder than requested (server may ignore folder fields or omit id).
  try {
    // If server didn't return an id, try to infer it from the current folder listing by filename.
    if (!savedVaultId) {
      const hitLocal = Array.isArray(state.items) && state.items
        .filter(it => String(it.name||it.filename||"") === String(filename||""))
        .sort((a,b)=> (new Date(b.updatedAt||b.modifiedAt||0)).getTime() - (new Date(a.updatedAt||a.modifiedAt||0)).getTime())[0];
      if (hitLocal && (hitLocal.id || hitLocal.key)) savedVaultId = hitLocal.id || hitLocal.key;
    }

    // If we have an id but it's not in the current folder list, check root quickly.
    const sid = savedVaultId ? String(savedVaultId) : "";
    const inCurrent = sid && Array.isArray(state.items) && state.items.some(it => String(it.id||it.key||"") === sid);

    if (!inCurrent) {
      const rootUrl = "/api/vault/list?folder=" + encodeURIComponent("") + "&_=" + Date.now();
      const rRoot = await apiFetch(rootUrl);
      const rootItems = (rRoot && rRoot.items) ? rRoot.items : [];

      const hit = (sid ? rootItems.find(it => String(it.id||it.key||"") === sid) : null) ||
                  rootItems
                    .filter(it => String(it.name||it.filename||"") === String(filename||""))
                    .sort((a,b)=> (new Date(b.updatedAt||b.modifiedAt||0)).getTime() - (new Date(a.updatedAt||a.modifiedAt||0)).getTime())[0];

      if (hit) {
        if (!savedVaultId && (hit.id || hit.key)) savedVaultId = hit.id || hit.key;
        const fph = String(hit.folderPath || hit.folder || "");
        if (String(fph) !== String(state.currentFolder||"")) {
          state.currentFolder = fph;
          try { els.folderSelect.value = state.currentFolder; } catch(e){}
          try { renderBreadcrumbs(); } catch(e){}
        }
        // Refresh list for the folder we actually landed in
        await loadList();
      }
    }
  } catch(e) {}

 } catch(e){}
        }
      };

      const act = async (fn)=>{
        if (!current || !current.item) return;
        cancelHide();
        const folderPath = current.folderPath || "";
        await ensureFolderSelected(folderPath);
        try { selectOnly(current.item.id); } catch(e){}
        try { fn(); } catch(e){}
        try { renderFolderTree();
// When user interacts with Vault folder tree or folder dropdown, exit guest mode
try{
  const _vaultTree = document.getElementById("folderTree");
  if (_vaultTree){
    _vaultTree.addEventListener("pointerdown", ()=>{ state.guestMode = false; }, true);
    _vaultTree.addEventListener("click", ()=>{ state.guestMode = false; }, true);
  }
  if (els && els.folderSelect){
    els.folderSelect.addEventListener("change", ()=>{ state.guestMode = false; }, true);
  }
}catch(e){}
 } catch(e){}
      };

      if (btnOpen)   btnOpen.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); act(()=>openSelected()); });
      if (btnRename) btnRename.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); act(()=>renameSelected()); });
      if (btnMove)   btnMove.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); act(()=>moveSelected()); });
      if (btnTrash)  btnTrash.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); act(()=>trashSelected()); });
      if (btnDelete) btnDelete.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); act(()=>deleteSelected()); });

      // Quick Tools: secondary popout to the right (stubs only)
      const positionQuickTools = ()=>{
        if (!qtWrap || !wrap || wrap.hidden) return;
        const r = wrap.getBoundingClientRect();
        const gap = 12;

        // default: to the right of main popout
        let left = Math.round(r.right + gap);
        let top = Math.round(r.top);

        qtWrap.style.left = left + "px";
        qtWrap.style.top = top + "px";

        // clamp into viewport; if it won't fit on the right, flip to the left
        const vw = window.innerWidth || document.documentElement.clientWidth || 1200;
        const vh = window.innerHeight || document.documentElement.clientHeight || 800;
        const w = qtWrap.offsetWidth || 420;
        const h = qtWrap.offsetHeight || 520;

        if (left + w > vw - 8){
          left = Math.max(8, Math.round(r.left - gap - w));
          qtWrap.style.left = left + "px";
        }
        if (top + h > vh - 8){
          top = Math.max(8, vh - 8 - h);
          qtWrap.style.top = top + "px";
        }
      };

      const showQuickTools = ()=>{
        if (!qtWrap) return;
        qtWrap.hidden = false;
        qtWrap.style.display = "block";
        positionQuickTools();
      };

      const hideQuickTools = ()=>{
        if (!qtWrap) return;
        qtWrap.hidden = true;
      };

      const cancelHideQuickTools = ()=>{ clearTimeout(qtHideTimer); };
      const scheduleHideQuickTools = ()=>{
        clearTimeout(qtHideTimer);
        qtHideTimer = setTimeout(() => {
          if (!qtWrap) return;
          const hovering = (qtWrap.matches && qtWrap.matches(":hover")) ||
                           (btnQuickTools && btnQuickTools.matches && btnQuickTools.matches(":hover"));
          if (hovering) return;
          hideQuickTools();
        }, 140);
      };

      if (btnQuickTools){
        // Also allow click to toggle (useful on trackpads / touch)
        btnQuickTools.addEventListener("click", (e)=>{
          e.preventDefault(); e.stopPropagation();
          cancelHide();
          cancelHideQuickTools();
          if (qtWrap && !qtWrap.hidden){
            hideQuickTools();
          } else {
            showQuickTools();
          }
        });
        btnQuickTools.addEventListener("mouseenter", (e)=>{
          e.preventDefault(); e.stopPropagation();
          cancelHide();
          cancelHideQuickTools();
          showQuickTools();
        });
        btnQuickTools.addEventListener("mouseleave", (e)=>{
          e.preventDefault(); e.stopPropagation();
          scheduleHideQuickTools();
        });
      }

      if (qtWrap){
        qtWrap.addEventListener("mouseenter", ()=>{
          cancelHide();
          cancelHideQuickTools();
        });
        qtWrap.addEventListener("mouseleave", ()=>{
          scheduleHideQuickTools();
        });
      }


      // Save to Vault from unified popout (local files only)
      if (btnSaveVault) btnSaveVault.addEventListener("click", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        if (!current || !current.item) return;
        cancelHide();
        try{
          if (!state.token){
            openModal("accountModal");
            setStatus("Sign in to save to Vault.", "");
            return;
          }
          if (String(current.item.storage||"") !== "local"){
            setStatus("Already in Vault.", "ok");
            return;
          }
          if (typeof window.__guestSaveToVault === "function"){
            setStatus("Saving to Vault...", "");
            await window.__guestSaveToVault(current.item);
            setStatus("Saved to Vault.", "ok");
          } else {
            throw new Error("Guest saver not available");
          }
        } catch(err){
          setStatus("Save to Vault failed: " + (err?.message || "unknown"), "err");
        }
      });



      window.addEventListener("resize", ()=>{
        if (wrap && !wrap.hidden) { position(); try{ if (qtWrap && !qtWrap.hidden && typeof positionQuickTools === 'function') positionQuickTools(); }catch(e){} }
      }, { passive:true });

      // expose for internal use inside bind scope
      wrap._cancelHide = cancelHide;
      wrap._scheduleHide = scheduleHide;

      wrap.dataset.bound = "1";
    }

    return true;
  }

  function ensureBound(){
    if (!wrap) bind();
    return !!wrap;
  }

  function position() {
    if (!ensureBound()) return;
    if (!current || !current.anchorEl) return;

    const r = current.anchorEl.getBoundingClientRect();
    const pad = 10;

    // ensure measurable
    wrap.hidden = false;
    const w = wrap.offsetWidth || 220;
    const h = wrap.offsetHeight || 260;

    let left = r.right + 10;
    let top  = r.top;

    // If overflowing right, place to the left of the row
    if (left + w + pad > window.innerWidth) left = r.left - w - 10;
    left = clamp(left, pad, window.innerWidth - w - pad);

    // Keep within viewport vertically
    top = clamp(top, pad, window.innerHeight - h - pad);

    wrap.style.left = left + "px";
    wrap.style.top  = top + "px";
  }

  function show(payload) {
    if (!ensureBound()) return;

    current = payload;

    const nm = (payload.item && (payload.item.name || payload.item.filename)) || ("File " + (payload.item?.id ?? ""));
    if (titleEl) titleEl.textContent = nm;

    const fp = payload.folderPath || "";
    if (subEl) subEl.textContent = fp ? ("in " + fp) : "";

    // show Save-to-Vault only for local files
    try{
      const isLocalItem = !!(payload && payload.item && (
            String(payload.item.storage||"") === "local" ||
            String(payload.previewUrl||"").startsWith("blob:") ||
            String(payload.item.id||"").startsWith("g_")
          ));
      if (btnSaveVault) btnSaveVault.style.display = isLocalItem ? "inline-flex" : "none";
    } catch(e){}

    // preview
    try{
      const nm = (payload.item && (payload.item.name || payload.item.filename)) || "";
      const id = String(payload.item?.id ?? "");
      const ext = nm.toLowerCase().split(".").pop() || "";
      const isImg = ["png","jpg","jpeg","webp","gif","bmp","svg"].includes(ext);
      const isPdfFile = (typeof isPdf === "function") ? isPdf(nm) : (ext === "pdf");

      const previewPassed = (payload && payload.previewUrl) ? String(payload.previewUrl) : "";
      const isLocal = !!(payload && payload.item && (
        String(payload.item.storage||"") === "local" ||
        previewPassed.startsWith("blob:") ||
        String(payload.item.id||"").startsWith("g_")
      ));

      // reset view
      try{
        setPreviewMode("generic");
        if (genEl) genEl.textContent = "Loading preview…";
      } catch(e){}

      // Local preview path (works when logged out)
      if (isLocal){
        if (previewPassed){
          const u = previewPassed;
          if (isImg){ setPreviewMode("img"); if (imgEl && imgEl.src !== u) imgEl.src = u; }
          else if (isPdfFile){ setPreviewMode("iframe"); if (frameEl && frameEl.src !== u) frameEl.src = u; }
          else { setPreviewMode("generic"); if (genEl) genEl.textContent = "No preview"; }
        } else if (typeof window.__guestObjectUrlFor === "function" && id){
          const thisId = id;
          Promise.resolve(window.__guestObjectUrlFor(thisId)).then((u)=>{
            if (!current || String(current.item?.id ?? "") !== String(thisId)) return;
            const url = String(u||"");
            if (!url){
              setPreviewMode("generic");
              if (genEl) genEl.textContent = "Preview unavailable";
              position();
              return;
            }
            if (isImg){ setPreviewMode("img"); if (imgEl && imgEl.src !== url) imgEl.src = url; }
            else if (isPdfFile){ setPreviewMode("iframe"); if (frameEl && frameEl.src !== url) frameEl.src = url; }
            else { setPreviewMode("generic"); if (genEl) genEl.textContent = "No preview"; }
            position();
          }).catch(()=>{
            if (!current || String(current.item?.id ?? "") !== String(thisId)) return;
            setPreviewMode("generic");
            if (genEl) genEl.textContent = "Preview unavailable";
            position();
          });
        } else {
          setPreviewMode("generic");
          if (genEl) genEl.textContent = "Preview unavailable";
        }
      } else {
        // Vault preview requires auth
        if (!state.token){
          // Try cached vault preview from local IndexedDB (if this file was previewed before while logged in)
          setPreviewMode("generic");
          if (genEl) genEl.textContent = "Loading preview…";
          const thisId = id;
          if (typeof guestObjectUrlFor === "function" && thisId){
            Promise.resolve(guestObjectUrlFor("v_" + thisId)).then((u)=>{
              if (!current || String(current.item?.id ?? "") !== String(thisId)) return;
              const url = String(u||"");
              if (!url){
                setPreviewMode("generic");
                if (genEl) genEl.textContent = "Sign in to preview Vault files";
                position();
                return;
              }
              if (isImg){ setPreviewMode("img"); if (imgEl && imgEl.src !== url) imgEl.src = url; }
              else if (isPdfFile){ setPreviewMode("iframe"); if (frameEl && frameEl.src !== url) frameEl.src = url; }
              else { setPreviewMode("generic"); if (genEl) genEl.textContent = "No preview"; }
              position();
            }).catch(()=>{
              if (!current || String(current.item?.id ?? "") !== String(thisId)) return;
              setPreviewMode("generic");
              if (genEl) genEl.textContent = "Sign in to preview Vault files";
              position();
            });
          } else {
            setPreviewMode("generic");
            if (genEl) genEl.textContent = "Sign in to preview Vault files";
          }
        } else if (id){
          const thisId = id;
          setPreviewMode("generic");
          if (genEl) genEl.textContent = "Loading preview…";
          getVaultPreviewUrl(id).then((url)=>{
            if (!current || String(current.item?.id ?? "") !== String(thisId)) return;
            const u = String(url||"");
            if (!u){
              setPreviewMode("generic");
              if (genEl) genEl.textContent = "Preview unavailable";
              position();
              return;
            }
            if (isImg){ setPreviewMode("img"); if (imgEl && imgEl.src !== u) imgEl.src = u; }
            else if (isPdfFile){ setPreviewMode("iframe"); if (frameEl && frameEl.src !== u) frameEl.src = u; }
            else { setPreviewMode("generic"); if (genEl) genEl.textContent = "No preview"; }
            position();
          }).catch(()=>{
            if (!current || String(current.item?.id ?? "") !== String(thisId)) return;
            setPreviewMode("generic");
            if (genEl) genEl.textContent = "Preview unavailable";
            position();
          });
        } else {
          setPreviewMode("generic");
          if (genEl) genEl.textContent = "Preview unavailable";
        }
      }
    } catch(e){
      setPreviewMode("generic");
      if (genEl) genEl.textContent = "Preview unavailable";
    }
    wrap.hidden = false;
    position();
  }

  function scheduleHide(){
    if (!ensureBound()) return;
    if (wrap._scheduleHide) wrap._scheduleHide();
  }

  function cancelHide(){
    if (!ensureBound()) return;
    if (wrap._cancelHide) wrap._cancelHide();
  }

  // Initial bind attempt; also bind once DOM is ready (fixes cases where script loads before popout HTML)
  bind();
  document.addEventListener("DOMContentLoaded", () => { bind(); }, { once: true });

  return { show, scheduleHide, cancelHide, position };
})();;



        
        // --- Account modal + auth wiring (keeps style consistent with index) ---
        
        // Dark UX prompt modal (replaces window.prompt for a clean in-app UX)
        async function uxPrompt(opts){
          opts = opts || {};
          const root = document.getElementById("uxPrompt");
          const titleEl = document.getElementById("uxpTitle");
          const labelEl = document.getElementById("uxpLabel");
          const inputEl = document.getElementById("uxpInput");
          const hintEl  = document.getElementById("uxpHint");
          const okBtn   = document.getElementById("uxpOk");
          const cancelBtn = document.getElementById("uxpCancel");

          // Fallback (shouldn't happen)
          if (!root || !titleEl || !labelEl || !inputEl || !okBtn || !cancelBtn) {
            const v = String(prompt((opts && opts.title) ? opts.title : "Enter value:", (opts && opts.value) ? opts.value : "") || "").trim();
            return v || null;
          }

          const prevActive = document.activeElement;

          titleEl.textContent = opts.title || "Enter value";
          labelEl.textContent = opts.label || "Value";
          inputEl.value = (opts.value != null) ? String(opts.value) : "";
          inputEl.placeholder = opts.placeholder || "";
          okBtn.textContent = opts.okText || "OK";
          hintEl.textContent = opts.hint || "";
          hintEl.classList.remove("uxp-error");

          root.classList.remove("hidden");
          root.setAttribute("aria-hidden", "false");

          // focus next tick
          setTimeout(() => { try{ inputEl.focus(); inputEl.select(); }catch(e){} }, 0);

          return await new Promise((resolve) => {
            const cleanup = (result) => {
              root.classList.add("hidden");
              root.setAttribute("aria-hidden", "true");
              window.removeEventListener("keydown", onKey, true);
              root.removeEventListener("click", onClick, true);
              okBtn.removeEventListener("click", onOk, true);
              cancelBtn.removeEventListener("click", onCancel, true);
              try{ if (prevActive && prevActive.focus) prevActive.focus(); }catch(e){}
              resolve(result);
            };

            const onOk = (ev) => {
              if (ev) { ev.preventDefault(); ev.stopPropagation(); }
              const v = String(inputEl.value || "").trim();
              if (opts.required !== false && !v){
                hintEl.textContent = opts.requiredMsg || "Please enter a value.";
                hintEl.classList.add("uxp-error");
                try{ inputEl.focus(); }catch(e){}
                return;
              }
              cleanup(v || null);
            };

            const onCancel = (ev) => {
              if (ev) { ev.preventDefault(); ev.stopPropagation(); }
              cleanup(null);
            };

            const onClick = (ev) => {
              const t = ev.target;
              if (t && t.getAttribute && (t.getAttribute("data-uxp-close")==="1" || t.getAttribute("data-uxp-cancel")==="1")){
                onCancel(ev);
              }
            };

            const onKey = (ev) => {
              // capture to prevent Office shortcuts from stealing Enter/Escape
              if (ev.key === "Escape") { ev.preventDefault(); ev.stopPropagation(); onCancel(ev); }
              if (ev.key === "Enter") { ev.preventDefault(); ev.stopPropagation(); onOk(ev); }
            };

            window.addEventListener("keydown", onKey, true);
            root.addEventListener("click", onClick, true);
            okBtn.addEventListener("click", onOk, true);
            cancelBtn.addEventListener("click", onCancel, true);
          });
        }
        window.uxPrompt = uxPrompt;

        function openModal(id) {
          const el = document.getElementById(id);
          if (!el) return;
          el.classList.add("open");
          el.style.display = "flex";
          el.setAttribute("aria-hidden", "false");
        }
        function closeModal(id) {
          const el = document.getElementById(id);
          if (!el) return;
          el.classList.remove("open");
          el.style.display = "none";
          el.setAttribute("aria-hidden", "true");
        }

        
        // Save Vault folder picker (true dropdown; uses the same folder tree UI as the left explorer)
        function openSaveVaultFolderPicker(){
          const dd = els.saveVaultFolderDropdown;
          if (!dd) return;

          try { renderSaveVaultFolderTree(); } catch(e){}
          dd.style.display = "block";
          dd.setAttribute("aria-hidden","false");
          state.saveFolderDropdownOpen = true;

          // Let the dropdown escape the card clipping while open (keeps default design otherwise)
          const sm = document.getElementById("saveModal");
          if (sm) sm.classList.add("folderdrop-open");

          // Keep centered on the Folder field and match width
          positionSaveVaultFolderDropdown();
        }
        function closeSaveVaultFolderPicker(){
          const dd = els.saveVaultFolderDropdown;
          if (!dd) return;
          dd.style.display = "none";
          dd.setAttribute("aria-hidden","true");
          state.saveFolderDropdownOpen = false;

          const sm = document.getElementById("saveModal");
          if (sm) sm.classList.remove("folderdrop-open");
        }
        function positionSaveVaultFolderDropdown(){
          const dd = els.saveVaultFolderDropdown;
          const btn = els.saveVaultFolderBtn;
          if (!dd || !btn) return;

          // Dropdown is positioned absolutely inside the Folder container;
          // we only need to match the trigger width (min 320px).
          const w = Math.max(btn.offsetWidth || 0, 320);
          dd.style.width = w + "px";
        }

        // Keep anchored on resize while open
        window.addEventListener("resize", ()=>{
          if (state.saveFolderDropdownOpen) positionSaveVaultFolderDropdown();
        }, { passive:true });

        function toggleSaveVaultFolderPicker(){
          const dd = els.saveVaultFolderDropdown;
          if (!dd) return;
          if (dd.style.display === "block") closeSaveVaultFolderPicker();
          else openSaveVaultFolderPicker();
        }

        // Close the dropdown on outside click / Escape (scoped)
        document.addEventListener("mousedown", (e)=>{
          if (!state.saveFolderDropdownOpen) return;
          const dd = els.saveVaultFolderDropdown;
          const btn = els.saveVaultFolderBtn;
          if (!dd || !btn) return;
          const t = e.target;
          if (dd.contains(t) || btn.contains(t)) return;
          closeSaveVaultFolderPicker();
        }, true);
        document.addEventListener("keydown", (e)=>{
          if (!state.saveFolderDropdownOpen) return;
          if (e.key === "Escape") closeSaveVaultFolderPicker();
        });

function renderSaveVaultFolderTree(){
          const treeEl = els.saveVaultFolderTree;
          if (!treeEl) return;

          // Logged out: Vault requires sign in
          if (!state.token){
            treeEl.innerHTML = `
              <div style="padding:12px 12px; font-size:12px; opacity:.85; line-height:1.35;">
                <b>Vault</b> is cloud storage. Sign in to use it.
              </div>
            `;
            return;
          }

          const cur = String(els.saveVaultFolder?.value || state.currentFolder || "");
          const root = buildFolderTreeFromPaths(state.folders || []);
          const openSet = state.saveFolderOpenSet || (state.saveFolderOpenSet = new Set());
          openSet.add(""); // root open

          treeEl.innerHTML = "";
          const frag = document.createDocumentFragment();

          function sortKids(map){
            return Array.from(map.values()).sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), undefined, { sensitivity:"base" }));
          }

          function mkNode(node, depth){
            const hasKids = node.children && node.children.size>0;
            const isOpen = openSet.has(node.path);

            const row = document.createElement("div");
            row.className = "folder-node";
            row.dataset.folder = node.path || "";
            row.style.paddingLeft = (8 + depth*6) + "px";
            if (String(node.path||"") === cur) row.classList.add("active");

            const twisty = document.createElement("span");
            twisty.className = "twisty";
            twisty.textContent = hasKids ? (isOpen ? "▾" : "▸") : "";
            twisty.addEventListener("click", (e)=>{
              e.preventDefault(); e.stopPropagation();
              if (!hasKids) return;
              if (isOpen) openSet.delete(node.path);
              else openSet.add(node.path);
              renderSaveVaultFolderTree();
            });
            row.appendChild(twisty);

            const icon = document.createElement("span");
            icon.className = "icon";
            icon.textContent = "📁";
            row.appendChild(icon);

            const name = document.createElement("span");
            name.className = "name";
            name.textContent = node.isRoot ? "/ (root)" : node.name;
            row.appendChild(name);

            row.addEventListener("click", ()=>{
              if (els.saveVaultFolder) els.saveVaultFolder.value = node.path || "";
              if (els.saveVaultFolderBtn){
                const v = String(node.path||"");
                els.saveVaultFolderBtn.textContent = v ? v : "(root)";
              }
              closeSaveVaultFolderPicker();
            });

            frag.appendChild(row);

            if (hasKids && openSet.has(node.path)){
              sortKids(node.children).forEach(ch => mkNode(ch, depth+1));
            }
          }

          mkNode(root, 0);
          treeEl.appendChild(frag);
        }

function setCookie(name, value) {
          try {
            document.cookie = `${name}=${encodeURIComponent(value)}; Path=/; SameSite=Lax`;
          } catch {}
        }

        function setToken(t) {
          try {
            if (t) localStorage.setItem(LS.TOKEN, t);
            else localStorage.removeItem(LS.TOKEN);
          } catch {}
          if (t) setCookie("pdfrealm_token", t);
          state.token = t || "";
          setAuthUI();
        }

        function updateAccountDot() {
          const dot = document.getElementById("accountDot");
          if (!dot) return;
          if (state.token) dot.classList.add("dot-logged-in");
          else dot.classList.remove("dot-logged-in");
        }

        async function loginFromModal() {
          const status = document.getElementById("loginStatus");
          const email = (document.getElementById("loginEmail")?.value || "").trim();
          const password = (document.getElementById("loginPassword")?.value || "").trim();
          if (!email || !password) {
            if (status) status.textContent = "Enter email + password.";
            return;
          }
          try {
            if (status) status.textContent = "Logging in...";
            const r = await fetch("/api/login", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ email, password })
            });
            const out = await r.json().catch(() => ({}));
            if (!r.ok) throw new Error(out?.error || out?.message || "Login failed.");
            const token = out?.token || out?.access_token || out?.accessToken || "";
            if (!token) throw new Error("No token returned by server.");
            setToken(token);
            if (status) status.textContent = "Logged in.";
            closeModal("accountModal");
            await loadList();
          } catch (e) {
            if (status) status.textContent = e.message || "Login failed.";
          }
        }
const state = {
          token: sanitizeToken(getStoredToken()),
          authed: false,
          guestMode: false,
          tool: "docx",
          sort: (localStorage.getItem("df_sort") || "name_asc"),
          view: (localStorage.getItem("df_view") || "list"),
          filter: (localStorage.getItem("df_filter") || "all"),
          quickOpen: (localStorage.getItem("df_quickOpen") !== "0"),
          stars: (function(){ try { return JSON.parse(localStorage.getItem("df_stars")||"{}") || {}; } catch (e) { return {}; } })(),
          pins: (function(){ try { return JSON.parse(localStorage.getItem("df_pins")||"[]") || []; } catch (e) { return []; } })(),
          recentFolders: (function(){ try { return JSON.parse(localStorage.getItem("df_recentFolders")||"[]") || []; } catch (e) { return []; } })(),
          lastOpened: (function(){ try { return JSON.parse(localStorage.getItem("df_lastOpened")||"{}") || {}; } catch (e) { return {}; } })(),
          tags: (function(){ try { return JSON.parse(localStorage.getItem("df_tags")||"{}") || {}; } catch (e) { return {}; } })(),
          detailsOpen: (localStorage.getItem("df_detailsOpen") === "1"),
          activity: (function(){ try { return JSON.parse(localStorage.getItem("df_activity")||"{}") || {}; } catch (e) { return {}; } })(),
          selectedId: null,
          selectedIds: new Set(),
          selectionAnchorIndex: -1,
          visibleIds: [],
          hoverEnabled: true,
          currentFileId: "",
          currentFileName: "",
          items: [],
          folders: [],
          currentFolder: "",
          lastNonTrashFolder: "",
          currentIframeUrl: "",
          pop: null,
          treeListCache: {},
          treeListInflight: {},
        };
        try { window.state = state; } catch(e) {}


      // ---------- Star helpers (no-break) ----------
      function persistStars(){
        try { localStorage.setItem("df_stars", JSON.stringify(state.stars || {})); } catch(e){}
      }
      function isStarred(id){
        const key = String(id || "");
        return !!(state.stars && state.stars[key]);
      }
      function setStarred(id, val){
        const key = String(id || "");
        state.stars = state.stars || {};
        if (val) state.stars[key] = 1;
        else delete state.stars[key];
        persistStars();
      }
      function toggleStarred(id){
        const key = String(id || "");
        setStarred(key, !isStarred(key));
        return isStarred(key);
      }

      
      // Icon helper
      function icoFor(name){
        const n = String(name || "").toLowerCase();
        const ext = (n.split(".").pop() || "").trim();
        if (ext === "pdf") return "📕";
        if (ext === "doc" || ext === "docx" || ext === "rtf") return "📝";
        if (ext === "xls" || ext === "xlsx" || ext === "csv") return "📊";
        if (ext === "ppt" || ext === "pptx") return "📽️";
        if (["png","jpg","jpeg","gif","webp","svg","bmp","tif","tiff"].includes(ext)) return "🖼️";
        if (["zip","rar","7z","tar","gz"].includes(ext)) return "🗜️";
        if (["txt","md","log"].includes(ext)) return "📄";
        if (["json","xml","yaml","yml"].includes(ext)) return "🧩";
        return "📄";
      }

      // Recent-folder helper (safe; used by folder tree navigation)
      function trackRecentFolder(path){
        const p = String(path || "");
        if (!p) return;
        state.recentFolders = Array.isArray(state.recentFolders) ? state.recentFolders : [];
        const next = [p, ...state.recentFolders.filter(x => String(x||"") !== p)];
        state.recentFolders = next.slice(0, 10);
        savePrefs();
        try { renderPinnedChips && renderPinnedChips(); } catch(e){}
      }

// Date/size helpers (server may send different shapes)
      function dfToMs(v){
        if (!v) return 0;
        if (typeof v === "number") return v < 1e12 ? (v * 1000) : v; // seconds vs ms
        if (typeof v === "string") {
          const t = Date.parse(v);
          return isNaN(t) ? 0 : t;
        }
        if (typeof v === "object") {
          try {
            if (v instanceof Date) return v.getTime();
          } catch(e) {}
          // Firestore-like timestamps
          if (typeof v.seconds === "number") return (v.seconds * 1000) + Math.floor((v.nanos || 0) / 1e6);
          if (typeof v._seconds === "number") return (v._seconds * 1000) + Math.floor((v._nanoseconds || 0) / 1e6);
        }
        return 0;
      }

      function getDate(it){
        try {
          const v = it && (it.updatedAt || it.modifiedAt || it.mtime || it.lastModified || it.updated || it.modified || it.createdAt || it.created || it.timestamp || it.time);
          return dfToMs(v) || 0;
        } catch(e) { return 0; }
      }

      function getSize(it){
        try {
          const v = it && (it.size || it.bytes || it.length || it.contentLength || (it.meta && it.meta.size));
          if (typeof v === "number") return v;
          if (typeof v === "string") {
            const n = parseInt(v, 10);
            return isNaN(n) ? 0 : n;
          }
          return 0;
        } catch(e) { return 0; }
      }

      function fmtDate(ms){
        try {
          const t = Number(ms) || 0;
          if (!t) return "";
          const now = Date.now();
          const diff = Math.max(0, now - t);
          const min = 60 * 1000, hr = 60 * min, day = 24 * hr;
          if (diff < 45 * 1000) return "just now";
          if (diff < 60 * min) return Math.round(diff / min) + "m ago";
          if (diff < 24 * hr) return Math.round(diff / hr) + "h ago";
          if (diff < 7 * day) return Math.round(diff / day) + "d ago";
          const d = new Date(t);
          return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
        } catch(e) { return ""; }
      }

      // ---------------------------------------------




      // ---------- Segmented button helpers (no-break) ----------
      function setSegActive(filter){
        try {
          const f = String(filter || "all");
          const filterMap = {
            all: "filterAllBtn",
            recent: "filterRecentBtn",
            starred: "filterStarBtn",
            trash: "filterTrashBtn",
          };
          const activeFilterId = filterMap[f] || "filterAllBtn";
          ["filterAllBtn","filterRecentBtn","filterStarBtn","filterTrashBtn"].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            const on = (id === activeFilterId);
            el.classList.toggle("active", on);
            el.setAttribute("aria-selected", on ? "true" : "false");
          });

          const listBtn = document.getElementById("viewListBtn");
          const gridBtn = document.getElementById("viewGridBtn");
          const isGrid = (state && state.view === "grid");
          if (listBtn) {
            listBtn.classList.toggle("active", !isGrid);
            listBtn.setAttribute("aria-selected", !isGrid ? "true" : "false");
          }
          if (gridBtn) {
            gridBtn.classList.toggle("active", isGrid);
            gridBtn.setAttribute("aria-selected", isGrid ? "true" : "false");
          }
        } catch(e) {}
      }
      // ---------------------------------------------------------
        function setStatus(msg, kind){
          els.status.textContent = msg || "";
          els.status.className = "status " + (kind || "");
        }

        function getStoredToken() {
          const ls = localStorage.getItem(LS.TOKEN);
          if (ls) {
            // Ensure PDFStudio (iframe) can read auth from cookie
            if (!document.cookie.match(/(?:^|;\s*)pdfrealm_token=/)) {
              try { setCookie("pdfrealm_token", ls); } catch {}
            }
            return ls;
          }

          // Fallback: cookie token (shared across pages). If present, also persist to localStorage
          // so tools that only read localStorage (e.g., PDFStudio paywall flows) see you as logged in.
          const m = document.cookie.match(/(?:^|;\s*)pdfrealm_token=([^;]+)/);
          if (m && m[1]) {
            const t = decodeURIComponent(m[1]);
            try { localStorage.setItem(LS.TOKEN, t); } catch {}
            return t;
          }
          return "";
        }

        function sanitizeToken(t){
          t = String(t || "").trim();
          if (!t) return "";
          const low = t.toLowerCase();
          if (low === "null" || low === "undefined") return "";
          return t;
        }

        function isAuthed(){
          try { return !!(state && (state.token || state.authed)); } catch(e){ return false; }
        }


        function setAuthUI() {
          const ok = !!state.token;
          const isTrashView = String(state.currentFolder || "") === "_Trash";
          els.authPill.textContent = ok ? "Auth: signed in" : "Auth: sign in required";
          els.authPill.style.color = ok ? "#9ae6b4" : "#feb2b2";
          els.openSelBtn.disabled = !ok || !state.selectedId;
          els.renameSelBtn.disabled = !ok || !state.selectedId;
          els.moveSelBtn.disabled = !ok || !state.selectedId;
          els.trashSelBtn.disabled = !ok || !state.selectedId;
          if (els.restoreSelBtn) {
            els.restoreSelBtn.style.display = isTrashView ? "inline-flex" : "none";
            els.restoreSelBtn.disabled = !ok || !state.selectedId || !isTrashView;
          }
          if (els.emptyTrashBtn) {
            els.emptyTrashBtn.style.display = isTrashView ? "inline-flex" : "none";
            // we enable it later based on whether trash has items
            els.emptyTrashBtn.disabled = !ok || !isTrashView;
          }
          els.deleteSelBtn.disabled = !ok || !state.selectedId;
          els.refreshBtn.disabled = !ok;
          els.openIdBtn.disabled = !ok;
          els.folderSelect.disabled = !ok;
          if (!ok) setStatus("Sign in first. (Uses pdfrealm_token).", "err");
          updateAccountDot();
          try { if (els.logoutBtn) els.logoutBtn.style.display = ok ? "inline-flex" : "none"; } catch(e){}
        }

        async function apiFetch(url, opts={}) {
          // Robust fetch wrapper:
          // - supports Bearer token OR cookie auth
          // - avoids stale/invalid Bearer token breaking cookie sessions
          // - retries once without Authorization on 401
          const makeHeaders = (useAuth=true) => {
            const headers = new Headers(opts.headers || {});
            const tok = sanitizeToken(state.token);
            if (useAuth && tok) headers.set("Authorization", `Bearer ${tok}`);
            // only set Content-Type for non-FormData bodies
            if (!headers.has("Content-Type") && opts.body && !(opts.body instanceof FormData)) {
              headers.set("Content-Type", "application/json");
            }
            return headers;
          };

          const doFetch = async (useAuth=true) => {
            const headers = makeHeaders(useAuth);
            const resp = await fetch(url, { credentials: "include", ...opts, headers });
            const text = await resp.text();
            let data = null;
            try { data = text ? JSON.parse(text) : null; } catch { data = { raw: text }; }
            return { resp, data };
          };

          // First attempt (with Authorization if we have a token)
          let { resp, data } = await doFetch(true);

          // If Bearer token is stale/invalid but cookies are valid, retry without Authorization
          if (resp.status === 401 && sanitizeToken(state.token)) {
            try {
              ({ resp, data } = await doFetch(false));
              if (resp.ok) {
                // Token likely stale; clear it so we don't break future requests
                try { state.token = ""; localStorage.removeItem(LS.TOKEN); } catch(e){}
              }
            } catch {}
          }

          if (resp.ok) {
            try { state.authed = true; } catch(e){}
            return data;
          }

          // Mark as not authed on 401
          if (resp.status === 401) {
            try { state.authed = false; } catch(e){}
          }

          const errMsg = (data && (data.error || data.message)) ? (data.error || data.message) : (`HTTP ${resp.status}`);
          throw new Error(errMsg);
        }


        function vaultPing(){
          try{
            localStorage.setItem("pdfrealm_vault_changed", String(Date.now()));
            try { new BroadcastChannel("pdfrealm_vault").postMessage({ t: Date.now(), from: "office" }); } catch(e){}
          }catch(e){}
        }

        // Auto-broadcast vault changes after successful Vault mutations (keeps Vault tab in sync)
        (function(){
          const _fetch = window.fetch ? window.fetch.bind(window) : null;
          if (!_fetch) return;
          window.fetch = async function(...args){
            const resp = await _fetch(...args);
            try{
              const u = args && args[0] ? (typeof args[0] === "string" ? args[0] : (args[0].url || "")) : "";
              if (resp && resp.ok && typeof u === "string" && u.includes("/api/vault/")) {
                if (/(\/api\/vault\/(upload|file\/[^/]+\/overwrite|file\/move|folder(\/move)?|file\/[^/]+)$)/.test(u)) {
                  vaultPing();
                }
              }
            }catch(e){}
            return resp;
          };
        })();

        // Collabora expects WOPISrc to be URL-encoded. If it is not, Collabora may return 400.
        function normalizeOfficeUrl(raw) {
          try {
            const u = new URL(raw, window.location.origin);
            const w = u.searchParams.get("WOPISrc");
            if (w) u.searchParams.set("WOPISrc", w); // re-set to force proper encoding on serialization
            const tok = u.searchParams.get("access_token");
            if (tok) u.searchParams.set("access_token", tok);
            return u.toString();
          } catch (e) {
            try {
              // best-effort fallback
              const m = String(raw || "").match(/WOPISrc=([^&]+)/i);
              if (!m) return raw;
              const w = decodeURIComponent(m[1]);
              return String(raw).replace(/WOPISrc=([^&]+)/i, "WOPISrc=" + encodeURIComponent(w));
            } catch {
              return raw;
            }
          }
        }

        function matchesTool(name){
          const n = String(name||"").toLowerCase();
          if (state.tool === "pdf") return n.endsWith(".pdf");
          if (state.tool === "docx") return n.endsWith(".docx") || n.endsWith(".doc") || n.endsWith(".odt") || n.endsWith(".fodt") || n.endsWith(".rtf");
          if (state.tool === "pptx") return n.endsWith(".pptx") || n.endsWith(".ppt") || n.endsWith(".odp") || n.endsWith(".fodp");
          if (state.tool === "xlsx") return n.endsWith(".xlsx") || n.endsWith(".xls") || n.endsWith(".ods") || n.endsWith(".fods");
          // fallback: office docs
          return n.endsWith(".docx") || n.endsWith(".xlsx") || n.endsWith(".pptx");
        }

        


        function matchesToolItem(it){
          try{
            if (!it) return false;
            if (it.isFolder) return false;
            const name = String(it.name || it.filename || "");
            const n = name.toLowerCase();
            const mime = String(it.mimeType || it.mime || "").toLowerCase();
            // Primary: extension
            if (matchesTool(n)) return true;
            // Secondary: mime type (handles files saved without extension)
            if (state.tool === "pdf") return mime.includes("application/pdf");
            if (state.tool === "docx") return mime.includes("officedocument.wordprocessingml") || mime.includes("application/msword") || mime.includes("text/rtf");
            if (state.tool === "pptx") return mime.includes("officedocument.presentationml") || mime.includes("application/vnd.ms-powerpoint");
            if (state.tool === "xlsx") return mime.includes("officedocument.spreadsheetml") || mime.includes("application/vnd.ms-excel");
            return false;
          }catch(e){ return false; }
        }
function selectionCount(){
  try { return state.selectedIds ? state.selectedIds.size : (state.selectedId ? 1 : 0); } catch(e) { return state.selectedId ? 1 : 0; }
}
function getSelectedIds(){
  try { return Array.from(state.selectedIds || []); } catch(e) { return state.selectedId ? [state.selectedId] : []; }
}
function setPrimarySelected(id){
  state.selectedId = id || null;
}
function syncToolbar(){
  const c = selectionCount();
  const hasAny = isAuthed() && c > 0;
  const hasOne = isAuthed() && c === 1;
  const inTrash = false; // Trash disabled

  if (els.openSelBtn) els.openSelBtn.disabled = !hasAny;
  if (els.renameSelBtn) els.renameSelBtn.disabled = !hasOne;
  if (els.moveSelBtn) els.moveSelBtn.disabled = !hasOne;
  if (els.trashSelBtn) els.trashSelBtn.disabled = !hasOne;
  if (els.restoreSelBtn) els.restoreSelBtn.disabled = !hasOne || !inTrash;
  if (els.emptyTrashBtn) { els.emptyTrashBtn.disabled = true; els.emptyTrashBtn.hidden = true; }
  if (els.deleteSelBtn) els.deleteSelBtn.disabled = !hasOne;

  if (els.saveBtn) {
    const can = isAuthed() && (!!state.currentFileId || c > 0);
    els.saveBtn.disabled = !can;
  }
  updateBulkBar();
}

function updateBulkBar(){
  if (!els.bulkBar) return;
  const c = selectionCount();
  const show = isAuthed() && c > 1;
  els.bulkBar.hidden = !show;
  if (!show){
    if (els.bulkPop) els.bulkPop.hidden = true;
    return;
  }
  if (els.bulkCount) els.bulkCount.textContent = `${c} selected`;
}

function clearSelection(){
  state.selectedIds = new Set();
  state.selectedId = null;
  state.selectionAnchorIndex = -1;
  closeDetailsPane();
  renderDetailsPane();
  syncToolbar();
  renderList();
}

function selectOnly(id){
  state.selectedIds = new Set();
  if (id) state.selectedIds.add(id);
  setPrimarySelected(id);
  // open details for single selection only
  if (id && window.innerWidth >= 980) openDetailsPane();
  else if (!id) closeDetailsPane();
  renderDetailsPane();
  syncToolbar();
  renderList();
}

function toggleSelect(id){
  if (!id) return;
  if (!state.selectedIds) state.selectedIds = new Set();
  if (state.selectedIds.has(id)) state.selectedIds.delete(id);
  else state.selectedIds.add(id);

  // Primary = last toggled ON, or any remaining selection
  if (state.selectedIds.has(id)) setPrimarySelected(id);
  else setPrimarySelected(Array.from(state.selectedIds)[state.selectedIds.size-1] || null);

  // Multi-select => details pane off (cleaner + avoids confusion)
  if (selectionCount() !== 1) closeDetailsPane();
  else if (state.selectedId && window.innerWidth >= 980) openDetailsPane();
  renderDetailsPane();
  syncToolbar();
  renderList();
}

function rangeSelect(fromIndex, toIndex){
  const ids = Array.isArray(state.visibleIds) ? state.visibleIds : [];
  if (!ids.length) return;
  const a = Math.max(0, Math.min(fromIndex, toIndex));
  const b = Math.min(ids.length-1, Math.max(fromIndex, toIndex));
  if (!state.selectedIds) state.selectedIds = new Set();
  for (let i=a; i<=b; i++) state.selectedIds.add(ids[i]);
  setPrimarySelected(ids[toIndex] || ids[b] || ids[a] || state.selectedId);

  if (selectionCount() !== 1) closeDetailsPane();
  else if (state.selectedId && window.innerWidth >= 980) openDetailsPane();
  renderDetailsPane();
  syncToolbar();
  renderList();
}

// Back-compat: existing calls expect setSelected(id) to select a single item.
function setSelected(id){
  selectOnly(id);
}

function savePrefs(){

          try {
            localStorage.setItem("df_pins", JSON.stringify(state.pins || []));
            localStorage.setItem("df_recentFolders", JSON.stringify(state.recentFolders || []));
            localStorage.setItem("df_lastOpened", JSON.stringify(state.lastOpened || {}));
            localStorage.setItem("df_tags", JSON.stringify(state.tags || {}));
            localStorage.setItem("df_detailsOpen", state.detailsOpen ? "1" : "0");
            localStorage.setItem("df_activity", JSON.stringify(state.activity || {}));
          } catch (e) {}
        }

        function openDetailsPane(mode){
          if (!els.detailsPane || !els.explorerWrap) return;
          state.detailsOpen = true;
          els.explorerWrap.classList.add("with-details");
          els.detailsPane.hidden = false;
          savePrefs();
          // Focus helpers for toolbar actions
          if (mode === "rename" && els.detailsNameInput){
            requestAnimationFrame(() => { els.detailsNameInput.focus(); els.detailsNameInput.select(); });
          }
          if (mode === "move" && (els.detailsFolderInput || els.detailsFolderSelect)){
            requestAnimationFrame(() => { (els.detailsFolderInput || els.detailsFolderSelect).focus(); });
          }
        }
        function closeDetailsPane(){
          if (!els.detailsPane || !els.explorerWrap) return;
          state.detailsOpen = false;
          els.explorerWrap.classList.remove("with-details");
          els.detailsPane.hidden = true;
          savePrefs();
        }

        function ensureDetailsPane(){
          if (!els.detailsPane || !els.explorerWrap) return;
          if (state.detailsOpen && state.selectedId) openDetailsPane();
          else if (!state.selectedId) closeDetailsPane();
          else closeDetailsPane();
        }

        function renderPinnedFolders(){
          if (!els.pinnedFolders) return;
          const pins = Array.isArray(state.pins) ? state.pins : [];
          els.pinnedFolders.innerHTML = "";
          const cur = String(state.currentFolder || "");
          pins.slice(0, 20).forEach(p => {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "chip" + (p === cur ? " active" : "");
            b.textContent = p ? ("/" + p) : "/ (root)";
            
            b.dataset.folder = p || "";
            b.classList.add("folder-drop-target");
b.addEventListener("click", () => {
              state.currentFolder = p || "";
              if (els.folderSelect) els.folderSelect.value = state.currentFolder;
              pushRecentFolder(state.currentFolder);
              loadList().catch(()=>{});
            });
            els.pinnedFolders.appendChild(b);
          });
          // If no pins, show a subtle hint
          if (!pins.length){
            const hint = document.createElement("div");
            hint.className = "muted small";
            hint.textContent = "Pin folders for 1‑click access.";
            els.pinnedFolders.appendChild(hint);
          }
          if (els.pinFolderBtn){
            const isPinned = pins.includes(cur);
            els.pinFolderBtn.textContent = isPinned ? "Unpin" : "Pin";
          }
        }

        function pushRecentFolder(folder){
          const f = String(folder || "");
          if (!f && f !== "") return;
          const cur = f;
          const arr = Array.isArray(state.recentFolders) ? state.recentFolders : [];
          const next = [cur].concat(arr.filter(x => x !== cur)).slice(0, 10);
          state.recentFolders = next;
          savePrefs();
          renderRecentFolders();
        }

        
        // --- Folder Tree (Finder-style) ---
        function buildFolderTreeFromPaths(paths){
          const root = { name:"/", path:"", children:new Map(), isRoot:true };
          (paths||[]).forEach(p=>{
            const norm = String(p||"").replace(/^\/+|\/+$/g,"");
            if (!norm) return;
            const parts = norm.split("/").filter(Boolean);
            let cur = root;
            let acc = "";
            for (const part of parts){
              acc = acc ? (acc + "/" + part) : part;
              if (!cur.children.has(part)){
                cur.children.set(part, { name:part, path:acc, children:new Map() });
              }
              cur = cur.children.get(part);
            }
          });
          return root;
        }

        function getTreeOpenSet(){
          try {
            const raw = localStorage.getItem("docforge_tree_open");
            const arr = raw ? JSON.parse(raw) : [];
            return new Set(Array.isArray(arr)?arr:[]);
          } catch(e){ return new Set(); }
        }
        function saveTreeOpenSet(set){
          try { localStorage.setItem("docforge_tree_open", JSON.stringify(Array.from(set))); } catch(e){}
        }

                async function ensureTreeFolderList(folder){
          const key = String(folder ?? "");
          if (state.treeListCache[key] && Array.isArray(state.treeListCache[key].items)) return state.treeListCache[key].items;
          if (state.treeListInflight[key]) return state.treeListInflight[key];
          const p = (async ()=>{
            try{
              const r = await apiFetch("/api/vault/list?folder=" + encodeURIComponent(key) + "&_=" + Date.now());
              const items = (r && r.items) ? r.items : [];
              state.treeListCache[key] = { items, at: Date.now() };
              return items;
            } catch(e){
              state.treeListCache[key] = { items: [], at: Date.now(), error: String((e && e.message) || e) };
              return [];
            } finally {
              delete state.treeListInflight[key];
            }
          })();
          state.treeListInflight[key] = p;
          return p;
        }

function renderFolderTree(){
    // Logged out: Vault is an upsell; use the Non-account Folder below
    if (!state.token){
      try{
        els.folderTree.innerHTML = `
          <div style="padding:12px 12px; font-size:12px; opacity:.85; line-height:1.35;">
            <b>Vault Folder</b> is cloud storage. Sign in to use it.<br/>
            Use <b>Non-account Folder</b> below for local imported files.
          </div>
        `;
      }catch(e){}
      return;
    }

          if (!els.folderTree) return;
          const openSet = getTreeOpenSet();
          const cur = String(state.currentFolder||"");
          const root = buildFolderTreeFromPaths(state.folders||[]);
          // Always show root open
          openSet.add("");

          els.folderTree.innerHTML = "";
          const frag = document.createDocumentFragment();

          function mkNode(node, depth){
            const hasKids = node.children && node.children.size>0;
            const isOpen = openSet.has(node.path);
            const row = document.createElement("div");
            row.className = "folder-node folder-drop-target";
            row.dataset.folder = node.path || "";
            row.style.paddingLeft = (8 + depth*6) + "px";
            if (String(node.path||"") === cur) row.classList.add("active");

            const twisty = document.createElement("span");
            twisty.className = "twisty";
            const cached = state.treeListCache[String(node.path||"")];
            const cachedItems = cached && Array.isArray(cached.items) ? cached.items : null;
            const toolFilteredFiles = cachedItems ? cachedItems.filter(it => !it.isFolder && matchesToolItem(it)) : null;
            const hasFiles = toolFilteredFiles ? toolFilteredFiles.length > 0 : false;
            const canToggle = hasKids || hasFiles || (cachedItems === null);

            twisty.textContent = canToggle ? (isOpen ? "▾" : "▸") : "";
            row.appendChild(twisty);

            const icon = document.createElement("span");
            icon.className = "icon";
            icon.textContent = node.isTrash ? "🗑" : "📁";
            row.appendChild(icon);

            const name = document.createElement("span");
            name.className = "name";
            name.textContent = node.isRoot ? "/ (root)" : node.name;
            row.appendChild(name);

            // Click: twisty toggles; row navigates (and opens if collapsed)
            row.addEventListener("click", async (e)=>{
              const target = e.target;
              const clickedTwisty = target && target.classList && target.classList.contains("twisty");

              if (clickedTwisty && canToggle){
                if (openSet.has(node.path)){
                  openSet.delete(node.path);
                } else {
                  openSet.add(node.path);
                  await ensureTreeFolderList(node.path || "");
                }
                saveTreeOpenSet(openSet);
                renderFolderTree();
                return;
              }

              // Row click: open (if collapsed) then navigate
              if (canToggle && !openSet.has(node.path)){
                openSet.add(node.path);
                saveTreeOpenSet(openSet);
                ensureTreeFolderList(node.path || "").then(()=>renderFolderTree()).catch(()=>{});
              }

              if (String(node.path||"") !== String(state.currentFolder||"")){
                state.currentFolder = node.path || "";
                try { els.folderSelect.value = state.currentFolder; } catch(e){}
                try { trackRecentFolder(state.currentFolder); } catch(e){}
                savePrefs();
                await loadList();
              }
              renderFolderTree();
            });

            const wrap = document.createElement("div");
            wrap.appendChild(row);

            if (isOpen){
              const childrenWrap = document.createElement("div");
              childrenWrap.className = "folder-children";

              // Subfolders
              if (hasKids){
                // sort children alphabetically
                const kids = Array.from(node.children.values()).sort((a,b)=>String(a.name).localeCompare(String(b.name)));
                kids.forEach(k=> childrenWrap.appendChild(mkNode(k, depth+1)));
              }

              // Files (loaded on-demand)
              const cache = state.treeListCache[String(node.path||"")];
              const cacheItems = cache && Array.isArray(cache.items) ? cache.items : null;
              const files = cacheItems
                ? cacheItems
                    .filter(it => !it.isFolder && matchesToolItem(it))
                    .sort((a,b)=>String(a.name||a.filename||"").localeCompare(String(b.name||b.filename||"")))
                : null;

              if (files && files.length){
                files.forEach(it=>{
                  const fRow = document.createElement("div");
                  fRow.className = "file-node";
                  if (state.selectedId && String(state.selectedId) === String(it.id)) fRow.classList.add("active");
                  fRow.style.paddingLeft = (8 + (depth+1)*6) + "px";

                  // Drag & drop: allow moving files by dragging onto folder nodes.
                  // Uses the same payload shape as the existing bulk drag/drop handler.
                  try{
                    fRow.draggable = true;
                    fRow.addEventListener("dragstart", (e)=>{
                      try{
                        const payload = { ids: [String(it.id || "")] };
                        e.dataTransfer.effectAllowed = "move";
                        e.dataTransfer.setData("application/json", JSON.stringify(payload));
                        e.dataTransfer.setData("text/plain", String(it.id || ""));
                      }catch(err){}
                      try{ fRow.classList.add("dragging"); }catch(err){}
                    });
                    fRow.addEventListener("dragend", ()=>{
                      try{ fRow.classList.remove("dragging"); }catch(err){}
                    });
                  }catch(e){}

                  const blank = document.createElement("span");
                  blank.className = "twisty";
                  blank.textContent = "";
                  fRow.appendChild(blank);

                  const fic = document.createElement("span");
                  fic.className = "icon";
                  fic.textContent = icoFor(it.name || it.filename || "");
                  fRow.appendChild(fic);

                  const fn = document.createElement("span");
                  fn.className = "name";
                  fn.textContent = it.name || it.filename || ("File " + it.id);
                  fRow.appendChild(fn);

                  fRow.addEventListener("click", async (e)=>{
                    e.stopPropagation();
                    const folderPath = node.path || "";
                    if (String(state.currentFolder||"") !== String(folderPath)){
                      state.currentFolder = folderPath;
                      try { els.folderSelect.value = state.currentFolder; } catch(e){}
                      try { trackRecentFolder(state.currentFolder); } catch(e){}
                      savePrefs();
                      await loadList();
                    }
                    selectOnly(it.id);
                    if (state.quickOpen) openSelected();
                    renderFolderTree();
                  });

                  fRow.addEventListener("dblclick", async (e)=>{
                    e.stopPropagation();
                    const folderPath = node.path || "";
                    if (String(state.currentFolder||"") !== String(folderPath)){
                      state.currentFolder = folderPath;
                      try { els.folderSelect.value = state.currentFolder; } catch(e){}
                      try { trackRecentFolder(state.currentFolder); } catch(e){}
                      savePrefs();
                      await loadList();
                    }
                    selectOnly(it.id);
                    openSelected();
                    renderFolderTree();
                  });

                  // Hover: show locked action popout to the right
                  fRow.addEventListener("mouseenter", (e)=>{
                    try { treePop.cancelHide(); } catch(err){}
                    try { treePop.show({ item: it, folderPath: (node.path || ""), anchorEl: fRow }); } catch(err){}
                  });
                  fRow.addEventListener("mousemove", (e)=>{
                    try { treePop.cancelHide(); treePop.position(); } catch(err){}
                  });
                  fRow.addEventListener("mouseleave", (e)=>{
                    try { treePop.scheduleHide(); } catch(err){}
                  });



                  childrenWrap.appendChild(fRow);
                });
              } else if (cacheItems === null){
                // Trigger a background fetch the first time this folder is expanded
                ensureTreeFolderList(node.path || "").then(()=>renderFolderTree()).catch(()=>{});
              }

              if (childrenWrap.childNodes.length){
                wrap.appendChild(childrenWrap);
              }
            }
            return wrap;
          }

          // Root node
          frag.appendChild(mkNode({ ...root, isRoot:true }, 0));

          els.folderTree.appendChild(frag);

          // Bind drop targets (reuse existing binder)
          try {
            document.querySelectorAll("#folderTree .folder-drop-target").forEach(el => bindDropTarget(el, "folder"));
          } catch(e){}
        }

function renderRecentFolders(){
          if (!els.recentFolders || !els.recentFoldersRow) return;
          const arr = Array.isArray(state.recentFolders) ? state.recentFolders : [];
          els.recentFolders.innerHTML = "";
          const show = arr.filter(Boolean).slice(0, 8);
          if (!show.length){
            els.recentFoldersRow.style.display = "none";
            return;
          }
          els.recentFoldersRow.style.display = "";
          const cur = String(state.currentFolder || "");
          show.forEach(p => {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "chip" + (p === cur ? " active" : "");
            b.textContent = "/" + p;
            
            b.dataset.folder = p || "";
            b.classList.add("folder-drop-target");
b.addEventListener("click", () => {
              state.currentFolder = p;
              if (els.folderSelect) els.folderSelect.value = p;
              loadList().catch(()=>{});
            });
            els.recentFolders.appendChild(b);
          });
        }

        function fillDetailsFolderSelect(){
          if (!els.detailsFolderSelect) return;
          els.detailsFolderSelect.innerHTML = "";
          const rootOpt = document.createElement("option");
          rootOpt.value = "";
          rootOpt.textContent = "/ (root)";
          els.detailsFolderSelect.appendChild(rootOpt);
          (state.folders || []).forEach(p => {
            const opt = document.createElement("option");
            opt.value = p;
            opt.textContent = "/" + p;
            els.detailsFolderSelect.appendChild(opt);
          });
        }

        function renderDetailsPane(){
          if (!els.detailsPane || !els.detailsInfo) return;
          const id = state.selectedId;
          if (!id){
            els.detailsInfo.textContent = "Select a file to see details.";
            try { setDetailsPreview("", null); } catch(e) {}
            try { renderActivityPane(""); } catch(e) {}
            try { renderDuplicatesPane(""); } catch(e) {}
            return;
          }
          const it = (state.items || []).find(x => (x.id || x.key) === id) || null;
          const name = it ? (it.name || it.filename || String(id)) : String(id);
          if (els.detailsNameInput) els.detailsNameInput.value = name;
          if (els.detailsFolderSelect){
            // keep options in sync with server folder list
            fillDetailsFolderSelect();
            els.detailsFolderSelect.value = state.currentFolder || "";
          }
          if (els.detailsFolderInput) els.detailsFolderInput.value = "";

          // star state
          const isStar = !!(state.stars && state.stars[String(id)]);
          if (els.detailsStarBtn){
            els.detailsStarBtn.textContent = isStar ? "★" : "☆";
            els.detailsStarBtn.classList.toggle("starred", isStar);
          }

          // tags
          const tags = (state.tags && state.tags[String(id)]) ? String(state.tags[String(id)]) : "";
          if (els.detailsTagsInput) els.detailsTagsInput.value = tags;

          // info
          const size = (it && (it.size ?? it.bytes ?? it.length ?? it.fileSize)) ? Number(it.size ?? it.bytes ?? it.length ?? it.fileSize) : 0;
          const raw = it ? (it.updatedAt ?? it.modifiedAt ?? it.updated_at ?? it.modified_at ?? it.createdAt ?? it.created_at ?? it.timestamp ?? null) : null;
          const t = raw ? Date.parse(raw) : 0;
          const mod = (t && isFinite(t)) ? new Date(t).toLocaleString() : "—";
          const opened = (state.lastOpened && state.lastOpened[String(id)]) ? new Date(Number(state.lastOpened[String(id)])).toLocaleString() : "—";
          els.detailsInfo.innerHTML =
            "<div><b>" + escapeHtml(name) + "</b></div>" +
            "<div>Folder: <span class='muted'>" + escapeHtml(state.currentFolder ? ("/" + state.currentFolder) : "/ (root)") + "</span></div>" +
            "<div>Modified: <span class='muted'>" + escapeHtml(mod) + "</span></div>" +
            "<div>Last opened: <span class='muted'>" + escapeHtml(opened) + "</span></div>" +
            "<div>Size: <span class='muted'>" + escapeHtml(formatBytes(size)) + "</span></div>" +
            "<div class='muted'>ID: " + escapeHtml(String(id)) + "</div>";

          
          // preview + activity + duplicates
          try { setDetailsPreview(id, it); } catch(e){}
          try { renderActivityPane(id); } catch(e){}
          try { renderDuplicatesPane(id); } catch(e){}
          if (els.detailsPermLabel) els.detailsPermLabel.textContent = "Private (Vault)";
// enable/disable details buttons
          const dis = !id;
          if (els.detailsOpenBtn) els.detailsOpenBtn.disabled = dis;
          if (els.detailsRenameBtn) els.detailsRenameBtn.disabled = dis;
          if (els.detailsMoveBtn) els.detailsMoveBtn.disabled = dis;
          if (els.detailsTrashBtn) els.detailsTrashBtn.disabled = dis;
          if (els.detailsDeleteBtn) els.detailsDeleteBtn.disabled = dis;
        }


        function logActivity(fileId, action, meta){
          const id = String(fileId || "");
          if (!id) return;
          state.activity = state.activity || {};
          const arr = Array.isArray(state.activity[id]) ? state.activity[id] : [];
          const evt = { t: Date.now(), action: String(action||"").slice(0,80), meta: meta || null };
          const next = [evt].concat(arr).slice(0, 25);
          state.activity[id] = next;
          savePrefs();
        }

        function renderActivityPane(fileId){
          if (!els.detailsActivity) return;
          const id = String(fileId||"");
          const arr = (state.activity && Array.isArray(state.activity[id])) ? state.activity[id] : [];
          els.detailsActivity.innerHTML = "";
          if (!arr.length){
            const empty = document.createElement("div");
            empty.className = "muted small";
            empty.textContent = "No recent activity yet.";
            els.detailsActivity.appendChild(empty);
            return;
          }
          arr.slice(0, 10).forEach(evt => {
            const d = new Date(Number(evt.t || 0));
            const wrap = document.createElement("div");
            wrap.className = "activity-item";
            const top = document.createElement("div");
            top.className = "top";
            const what = document.createElement("div");
            what.className = "what";
            what.textContent = evt.action || "Activity";
            const when = document.createElement("div");
            when.textContent = isFinite(d.getTime()) ? d.toLocaleString() : "";
            top.appendChild(what);
            top.appendChild(when);
            wrap.appendChild(top);
            if (evt.meta){
              const meta = document.createElement("div");
              meta.className = "meta";
              meta.textContent = typeof evt.meta === "string" ? evt.meta : JSON.stringify(evt.meta);
              wrap.appendChild(meta);
            }
            els.detailsActivity.appendChild(wrap);
          });
        }

        function isPdf(name){ return String(name||"").toLowerCase().endsWith(".pdf"); }
        function isImage(name){
          const n = String(name||"").toLowerCase();
          return n.endsWith(".png") || n.endsWith(".jpg") || n.endsWith(".jpeg") || n.endsWith(".webp") || n.endsWith(".gif");
        }

        function setDetailsPreview(fileId, item){
          if (!els.detailsPreview) return;
          const id = String(fileId||"");
          if (!id){ els.detailsPreview.innerHTML = '<div class="preview-placeholder">Select a file to preview.</div>'; return; }
          const name = item ? (item.name || item.filename || "") : "";
          // Use same-origin proxy so it works with PDF.js + avoids S3 CORS.
          const proxyUrl = "/api/vault/file-proxy/" + encodeURIComponent(id);

          if (isPdf(name)){
            // Lightweight: use browser PDF renderer for a quick first-page preview.
            els.detailsPreview.innerHTML = '<iframe title="PDF preview" loading="lazy" referrerpolicy="no-referrer" src="' + proxyUrl + '#page=1&zoom=page-fit"></iframe>';
          } else if (isImage(name)){
            els.detailsPreview.innerHTML = '<img alt="Preview" loading="lazy" referrerpolicy="no-referrer" src="' + proxyUrl + '" />';
          } else {
            const ext = (name.split(".").pop() || "").toUpperCase();
            els.detailsPreview.innerHTML = '<div class="preview-placeholder"><div style="font-weight:800; font-size:20px; margin-bottom:6px;">' + escapeHtml(ext || "FILE") + '</div><div>Preview not available for this type yet.</div></div>';
          }
        }

        async function copySignedDownloadLink(fileId){
          const id = String(fileId||"");
          if (!id) return;
          if (els.detailsCopyLinkBtn) els.detailsCopyLinkBtn.disabled = true;
          try {
            const r = await apiFetch("/api/vault/file/" + encodeURIComponent(id), { method: "GET" });
            const url = r && r.url ? String(r.url) : "";
            if (!r || !r.ok || !url) throw new Error((r && r.error) || "No download URL");
            await navigator.clipboard.writeText(url);
            setStatus("Copied temporary download link (10 min).", "ok");
            logActivity(id, "Copied download link", null);
          } catch (e) {
            setStatus("Copy link failed: " + (e.message || e), "err");
          } finally {
            if (els.detailsCopyLinkBtn) els.detailsCopyLinkBtn.disabled = false;
          }
        }

        function normBaseName(name){
          let n = String(name||"").trim().toLowerCase();
          // remove extension
          n = n.replace(/\.[a-z0-9]{1,6}$/i, "");
          // remove common copy suffixes: (1), copy, copy 2, - copy
          n = n.replace(/\s*\(\d+\)\s*$/,"");
          n = n.replace(/\s*-\s*copy\s*\d*\s*$/,"");
          n = n.replace(/\s*copy\s*\d*\s*$/,"");
          return n.trim();
        }

        function findDuplicatesFor(fileId){
          const id = String(fileId||"");
          const it = (state.items || []).find(x => (x.id||x.key) === id) || null;
          if (!it) return [];
          const name = it.name || it.filename || "";
          const base = normBaseName(name);
          const size = Number(it.size ?? it.bytes ?? it.length ?? it.fileSize ?? 0) || 0;
          const matches = (state.items || []).filter(x => {
            const xid = String(x.id||x.key||"");
            if (!xid || xid === id) return false;
            const xn = x.name || x.filename || "";
            const xb = normBaseName(xn);
            const xs = Number(x.size ?? x.bytes ?? x.length ?? x.fileSize ?? 0) || 0;
            if (!base || !xb) return false;
            // match base name and similar size (exact or within 2%)
            const sizeClose = size && xs ? (Math.abs(xs - size) <= Math.max(1024, size * 0.02)) : false;
            return (xb === base) && (sizeClose || xs === size);
          });
          return matches.slice(0, 8);
        }

        function renderDuplicatesPane(fileId){
          if (!els.detailsDupes) return;
          const id = String(fileId||"");
          if (!id){ els.detailsDupes.textContent = "—"; return; }
          const dups = findDuplicatesFor(id);
          if (!dups.length){
            els.detailsDupes.innerHTML = '<div class="muted small">No obvious duplicates found.</div>';
            return;
          }
          const wrap = document.createElement("div");
          wrap.className = "activity-list";
          dups.forEach(d => {
            const row = document.createElement("div");
            row.className = "activity-item";
            const nm = d.name || d.filename || "Untitled";
            row.innerHTML = '<div class="top"><div class="what">' + escapeHtml(nm) + '</div><div class="muted small">' + escapeHtml(formatBytes(Number(d.size ?? d.bytes ?? 0) || 0)) + '</div></div>';
            row.addEventListener("click", () => { setSelected(d.id || d.key); });
            wrap.appendChild(row);
          });
          els.detailsDupes.innerHTML = "";
          els.detailsDupes.appendChild(wrap);
        }
        async function applyDetailsRename(){
          if (!state.selectedId) return;
          const it = (state.items || []).find(x => x.id === state.selectedId);
          const currentName = (it && (it.name || it.filename)) || "";
          const newName = String(els.detailsNameInput?.value || "").trim();
          if (!newName || newName === currentName) return;
          setStatus("Renaming...", "");
          const r = await vaultMove({ id: state.selectedId, newName });
          if (!r || !r.ok) { setStatus("Rename failed: " + ((r && r.error) || "unknown error"), "err"); return; }
          await loadList();
          setStatus("Renamed.", "ok");
          try { logActivity(state.selectedId, "Renamed", { to: newName }); } catch(e) {}
          renderDetailsPane();
        }

        async function applyDetailsMove(){
          if (!state.selectedId) return;
          const typed = String(els.detailsFolderInput?.value || "").trim();
          const selected = String(els.detailsFolderSelect?.value || "").trim();
          const toFolderPath = typed || selected || "";
          setStatus("Moving...", "");
          const r = await vaultMove({ id: state.selectedId, toFolderPath });
          if (!r || !r.ok) { setStatus("Move failed: " + ((r && r.error) || "unknown error"), "err"); return; }
          state.currentFolder = toFolderPath;
          if (els.folderSelect) els.folderSelect.value = state.currentFolder;
          pushRecentFolder(state.currentFolder);
          await loadList();
          setStatus("Moved.", "ok");
          try { logActivity(state.selectedId, "Moved", { toFolderPath }); } catch(e) {}
          renderDetailsPane();
        }

        function renderBreadcrumbs(){
          if (!els.breadcrumbs) return;
          const folder = String(state.currentFolder || "");
          els.breadcrumbs.innerHTML = "";
          const parts = folder ? folder.split("/").filter(Boolean) : [];
          const mk = (label, value) => {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "crumb";
            b.textContent = label;
            
            b.dataset.folder = value || "";
            b.classList.add("folder-drop-target");
b.addEventListener("click", () => {
              state.currentFolder = value || "";
              if (els.folderSelect) els.folderSelect.value = state.currentFolder;
              pushRecentFolder(state.currentFolder);
              loadList().catch(()=>{});
            });
            return b;
          };
          els.breadcrumbs.appendChild(mk("/", ""));
          let acc = "";
          parts.forEach((p, idx) => {
            const sep = document.createElement("span");
            sep.className = "crumb sep";
            sep.textContent = "›";
            els.breadcrumbs.appendChild(sep);
            acc = acc ? (acc + "/" + p) : p;
            els.breadcrumbs.appendChild(mk(p, acc));
          });
        }


        function openPdfInFrame(fileId){

          const id = String(fileId||"").trim();
          state.currentFileId = id;
          const it = state.items.find(x => (x.id||x.key) === id) || null;
          state.currentFileName = (it && (it.name || it.filename)) ? (it.name || it.filename) : (state.currentFileName || "document");
          if (!id) return;

          // Load PDFStudio inside the right-side preview iframe
          // (PDFStudio will fetch/render the PDF using the auth cookie.)
          const url = "/pdfstudio.html?embed=1&fileId=" + encodeURIComponent(id) + "&name=" + encodeURIComponent(state.currentFileName || "document.pdf") + "&folderPath=" + encodeURIComponent((state.currentFolder ?? "")) + "&folder=" + encodeURIComponent((state.currentFolder ?? ""));
          state.currentIframeUrl = url;
          els.frame.src = url;
          setStatus("PDFStudio loaded.", "ok");
        }

        
function openSelected(){
  const ids = getSelectedIds();
  const id = state.selectedId || ids[0];
  if (!id) return;

  // Track last opened (used by Recent sort/filter)
  try { state.lastOpened[String(id)] = Date.now(); savePrefs(); } catch(e) {}
  try { logActivity(id, "Opened", null); } catch(e) {}

  if (ids.length > 1){
    setStatus(`Opened 1 of ${ids.length} selected.`, "ok");
  }

  if (state.tool === "pdf") {
    openPdfStudio(id);
    return;
  }
  openFile(id);
}

function openSelectedNewTab(){
  const ids = getSelectedIds();
  const id = state.selectedId || ids[0];
  if (!id) return;

  // Track last opened (used by Recent sort/filter)
  try { state.lastOpened[String(id)] = Date.now(); savePrefs(); } catch(e){}

  openFileNewTab(id);
}

async function openFileNewTab(fileId){
  const id = String(fileId||"").trim();
  if (!id) return;

  // PDFStudio tool opens in a new tab
  if (state.tool === "pdf"){
    const it = state.items.find(x => (x.id||x.key) === id) || null;
    const name = (it && (it.name || it.filename)) ? (it.name || it.filename) : "document.pdf";
    const url = "/pdfstudio.html?embed=0&fileId=" + encodeURIComponent(id) + "&name=" + encodeURIComponent(name) + "&folderPath=" + encodeURIComponent((state.currentFolder ?? "")) + "&folder=" + encodeURIComponent((state.currentFolder ?? ""));
    window.open(url, "_blank", "noopener");
    return;
  }

  setStatus("Opening editor (new tab)...", "");
  try {
    const r = await apiFetch("/api/office/session", {
      method: "POST",
      body: JSON.stringify({ fileId: id })
    });
    const rawUrl = (r && (r.iframeUrl || r.url)) ? (r.iframeUrl || r.url) : "";
    if (!r || !r.ok || !rawUrl) throw new Error((r && r.error) || "Failed to create session");
    const fixedUrl = normalizeOfficeUrl(rawUrl);
    window.open(fixedUrl, "_blank", "noopener");
    setStatus("Opened in new tab.", "ok");
  } catch(e){
    setStatus("Open failed: " + e.message, "bad");
  }
}



function renderList() {
  const q = String(els.searchInput?.value || "").toLowerCase().trim();
  if (els.fileList) els.fileList.innerHTML = "";

  // Tool filter (docx/pptx/xlsx/pdf)
  const baseItems = (state.items || []).filter(it => matchesToolItem(it));

  // Folder filter chips (All / Recent / Starred / Trash)
  let items = baseItems.slice();
  const filter = String(state.filter || "all");

  const now = Date.now();
  const WEEK_MS = 7 * 24 * 60 * 60 * 1000;

  if (filter === "trash") {
    const inTrashFolder = String(state.currentFolder || "") === "_Trash";
    if (!inTrashFolder) {
      state.currentFolder = "_Trash";
      if (els.folderSelect) els.folderSelect.value = "_Trash";
      loadList().catch(()=>{});
      return;
    }
  } else if (filter === "recent") {
    items = items.filter(it => {
      const id = it.id || it.key || "";
      const dt = getDate(it) || (state.lastOpened && state.lastOpened[String(id)]) || 0;
      return dt && (now - dt) <= WEEK_MS;
    });
  } else if (filter === "star") {
    items = items.filter(it => isStarred(it.id || it.key));
  }

  // Search
  if (q) {
    items = items.filter(it => String(it.name||it.filename||"").toLowerCase().includes(q));
  }

  // Sort
  const sort = String(state.sort || "name_asc");
  items.sort((a,b) => {
    const an = String(a.name||a.filename||"").toLowerCase();
    const bn = String(b.name||b.filename||"").toLowerCase();
    const ao = (state.lastOpened && state.lastOpened[String(a.id||a.key||"")]) || 0;
    const bo = (state.lastOpened && state.lastOpened[String(b.id||b.key||"")]) || 0;
    const ad = Math.max(getDate(a), ao), bd = Math.max(getDate(b), bo);
    const asz = getSize(a), bsz = getSize(b);

    if (sort === "name_desc") return bn.localeCompare(an);
    if (sort === "date_desc") return (bd - ad) || an.localeCompare(bn);
    if (sort === "date_asc") return (ad - bd) || an.localeCompare(bn);
    if (sort === "size_desc") return (bsz - asz) || an.localeCompare(bn);
    if (sort === "size_asc") return (asz - bsz) || an.localeCompare(bn);
    return an.localeCompare(bn);
  });

  // View class
  if (els.fileList) {
    els.fileList.classList.toggle("grid", state.view === "grid");
  }
  setSegActive(filter);

  // Track visible ids for shift-range selection
  state.visibleIds = items.map(it => (it.id || it.key || "")).filter(Boolean);

  if (!items.length) {
    const empty = document.createElement("div");
    empty.className = "muted small";
    empty.style.padding = "8px 4px";
    empty.textContent = state.tool === "pdf" ? "No PDFs found in this folder." : "No matching documents found in this folder.";
    els.fileList.appendChild(empty);
    return;
  }

  const isMulti = selectionCount() > 1;

  items.slice(0, 400).forEach((it, idx) => {
    const id = it.id || it.key || "";
    const name = it.name || it.filename || String(id);

    const row = document.createElement("div");
    const selected = !!(state.selectedIds && state.selectedIds.has(id));
    row.className = "file-item" + (selected ? " selected" : "");
    row.title = name;
    row.dataset.id = id;
    row.dataset.idx = String(idx);

    // Checkbox selection (multi-select)
    const chk = document.createElement("input");
    chk.type = "checkbox";
    chk.className = "file-check";
    chk.checked = selected;
    chk.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleSelect(id);
      state.selectionAnchorIndex = idx;
    });

    const ico = document.createElement("div");
    ico.className = "file-ico";
    ico.textContent = icoFor(name);

    const main = document.createElement("div");
    main.className = "file-main";

    const nm = document.createElement("div");
    nm.className = "file-name";
    nm.textContent = name;

    const sub = document.createElement("div");
    sub.className = "file-sub";
    const meta = [];
    const dms = getDate(it);
    const sz = getSize(it);
    if (sz) meta.push(formatBytes(sz));
    if (dms) meta.push("Updated " + fmtDate(dms));
    if (!meta.length) meta.push("ID " + String(id).slice(0,8) + "…");
    sub.textContent = meta.join(" • ");

    main.appendChild(nm);
    main.appendChild(sub);

    const quick = document.createElement("div");
    quick.className = "file-quick";

    const openBtn = document.createElement("button");
    openBtn.className = "mini-btn";
    openBtn.textContent = "Open";
    openBtn.addEventListener("click", (e) => { e.stopPropagation(); selectOnly(id); if (e.metaKey || e.ctrlKey) { openSelectedNewTab(); } else { openSelected(); } });

    const starBtn = document.createElement("button");
    starBtn.className = "mini-icon" + (isStarred(id) ? " starred" : "");
    starBtn.textContent = isStarred(id) ? "★" : "☆";
    starBtn.title = isStarred(id) ? "Unstar" : "Star";
    starBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const key = String(id);
      state.stars = state.stars || {};
      if (state.stars[key]) delete state.stars[key];
      else state.stars[key] = { name, at: Date.now() };
      try { localStorage.setItem("df_stars", JSON.stringify(state.stars)); } catch {}
      renderList();
      renderDetailsPane();
    });

    const renBtn = document.createElement("button");
    renBtn.className = "mini-icon";
    renBtn.textContent = "✎";
    renBtn.title = "Rename";
    renBtn.addEventListener("click", (e) => { e.stopPropagation(); selectOnly(id); openDetailsPane("rename"); renderDetailsPane(); });

    const movBtn = document.createElement("button");
    movBtn.className = "mini-icon";
    movBtn.textContent = "⇄";
    movBtn.title = "Move";
    movBtn.addEventListener("click", (e) => { e.stopPropagation(); selectOnly(id); openDetailsPane("move"); renderDetailsPane(); });

    const trBtn = document.createElement("button");
    trBtn.className = "mini-icon danger";
    trBtn.textContent = "🗑";
    trBtn.title = "Trash";
    trBtn.addEventListener("click", (e) => { e.stopPropagation(); selectOnly(id); trashSelected(); });

    quick.appendChild(openBtn);
    quick.appendChild(starBtn);
    quick.appendChild(renBtn);
    quick.appendChild(movBtn);
    quick.appendChild(trBtn);

    row.appendChild(chk);
    row.appendChild(ico);
    row.appendChild(main);
    row.appendChild(quick);

    // Hover preview (only when details pane closed to avoid redundancy)
    row.addEventListener("mouseenter", (e) => { scheduleHoverPreview(it, e); });
    row.addEventListener("mousemove", (e) => { state._hoverPos = { x: e.clientX, y: e.clientY }; positionHoverPreview(e.clientX, e.clientY); });
    row.addEventListener("mouseleave", () => { cancelHoverPreview(); hideHoverPreview(); });

    row.addEventListener("click", (e) => {
      const metaKey = e.ctrlKey || e.metaKey;
      const shiftKey = e.shiftKey;

      if (shiftKey && state.selectionAnchorIndex >= 0) {
        rangeSelect(state.selectionAnchorIndex, idx);
      } else if (metaKey) {
        toggleSelect(id);
        state.selectionAnchorIndex = idx;
      } else {
        selectOnly(id);
        state.selectionAnchorIndex = idx;
      }

      if (state.quickOpen && !shiftKey && !metaKey) {
        // mimic PDFfiller: single click opens
        openSelected();
      }
    });

    row.addEventListener("dblclick", (e) => {
      e.preventDefault();
      selectOnly(id);
      openSelected();
    });

    els.fileList.appendChild(row);
  });

  // Bulk bar state update
  syncToolbar();
}

// --- Hover preview helpers ---
function cancelHoverPreview(){
  if (state._hoverTimer) { clearTimeout(state._hoverTimer); state._hoverTimer = null; }
  state._hoverItem = null;
}
function scheduleHoverPreview(item, e){
  if (!els.hoverPreview || !state.hoverEnabled) return;
  // If details pane is open and wide, hover preview is redundant
  if (els.detailsPane && !els.detailsPane.hidden && window.innerWidth >= 980) return;

  cancelHoverPreview();
  state._hoverItem = item;

  const x = e.clientX, y = e.clientY;
  state._hoverPos = { x, y };
  // position will be applied when shown

  state._hoverTimer = setTimeout(() => {
    if (state._hoverItem !== item) return;
    showHoverPreview(item);
  }, 320);
}
function positionHoverPreview(x, y){
  if (!els.hoverPreview || els.hoverPreview.hidden) return;
  const pad = 12;
  const w = els.hoverPreview.offsetWidth || 280;
  const h = els.hoverPreview.offsetHeight || 360;
  const vw = window.innerWidth, vh = window.innerHeight;

  let left = x + 16;
  let top = y + 16;

  if (left + w + pad > vw) left = Math.max(pad, x - w - 16);
  if (top + h + pad > vh) top = Math.max(pad, y - h - 16);

  els.hoverPreview.style.left = left + "px";
  els.hoverPreview.style.top = top + "px";
}
function hideHoverPreview(){
  if (!els.hoverPreview) return;
  els.hoverPreview.hidden = true;
  if (els.hpBody) els.hpBody.innerHTML = '<div class="hp-ph">Preview</div>';
}
function showHoverPreview(it){
  if (!els.hoverPreview) return;
  const id = it.id || it.key || "";
  const name = it.name || it.filename || String(id);
  if (!id) return;

  els.hoverPreview.hidden = false;
  try { if (state._hoverPos) positionHoverPreview(state._hoverPos.x, state._hoverPos.y); } catch(e) {}
  if (els.hpIco) els.hpIco.textContent = icoFor(name);
  if (els.hpTitle) els.hpTitle.textContent = name;

  const lower = String(name).toLowerCase();
  const proxyUrl = "/api/vault/file-proxy/" + encodeURIComponent(id);

  if (els.hpBody){
    if (lower.match(/\.(png|jpg|jpeg|gif|webp|svg)$/)){
      els.hpBody.innerHTML = `<img src="${proxyUrl}" alt="preview" />`;
    } else if (lower.endsWith(".pdf")){
      // Use browser pdf renderer; keep it lightweight
      els.hpBody.innerHTML = `<iframe src="${proxyUrl}#page=1&toolbar=0&navpanes=0&view=FitH"></iframe>`;
    } else {
      els.hpBody.innerHTML = `<div class="hp-ph">No preview for this file type.</div>`;
    }
  }
}



        function formatBytes(b){
          const n = Number(b||0);
          if (!isFinite(n) || n <= 0) return "0 B";
          const u = ["B","KB","MB","GB","TB"];
          let i = 0, v = n;
          while (v >= 1024 && i < u.length-1) { v /= 1024; i++; }
          return `${v.toFixed(i===0?0:1)} ${u[i]}`;
        }

        async function loadFolders() {
          try {
            const r = await apiFetch("/api/vault/folders");
            const folders = ((r && r.folders) ? r.folders : []).filter(p => String(p||"") !== "_Trash");
            if (String(state.currentFolder||"") === "_Trash") state.currentFolder = "";
            state.folders = folders;
            // fill dropdown
            els.folderSelect.innerHTML = "";
            const rootOpt = document.createElement("option");
            rootOpt.value = "";
            rootOpt.textContent = "/ (root)";
            els.folderSelect.appendChild(rootOpt);
            folders.forEach(p => {
              const opt = document.createElement("option");
              opt.value = p;
              opt.textContent = "/" + p;
              els.folderSelect.appendChild(opt);
            });
            els.folderSelect.value = state.currentFolder || "";
            try { fillDetailsFolderSelect(); } catch(e){}
            try { renderPinnedFolders(); } catch(e){}
            try { renderFolderTree(); } catch(e){}
            try { renderDetailsPane(); } catch(e){}
          } catch (e) {
            setStatus('Failed to load folders: ' + (e && e.message ? e.message : String(e||'')), 'err');
          }
        }

        async function loadList() {
          setStatus("Loading files...", "");
          try {
            const folder = state.currentFolder || "";
            const url = "/api/vault/list?folder=" + encodeURIComponent(folder) + "&_=" + Date.now();
            const r = await apiFetch(url);
            state.items = (r && r.items) ? r.items : [];
            try { state.treeListCache[String(folder)] = { items: state.items, at: Date.now() }; } catch(e){}
            renderBreadcrumbs();
            renderPinnedFolders();
            renderRecentFolders();
            renderList();
            renderDetailsPane();
            ensureDetailsPane();
            // Trash-only UI
            try {
              const inTrash = String(folder) === "_Trash";
              if (els.emptyTrashBtn) {
                els.emptyTrashBtn.disabled = !state.token || !inTrash || (state.items || []).length === 0;
              }
              if (els.restoreSelBtn) {
                els.restoreSelBtn.disabled = !state.token || !inTrash || !state.selectedId;
              }
            } catch(e) {}
            setStatus("Ready.", "ok");
          } catch (e) {
            setStatus("Failed to load Vault list: " + e.message, "err");
          }
        }

        async function createNew(kind) {
          setStatus("Creating new " + kind.toUpperCase() + "...", "");
          try {
            const folderPath = state.currentFolder || "";
            const r = await apiFetch("/api/office/new", {
              method: "POST",
              body: JSON.stringify({ kind, folderPath })
            });
            if (!r || !r.ok) throw new Error((r && r.error) || "Failed to create file");
            await loadList();
            await openFile(r.fileId);
          } catch (e) {
            setStatus("Create failed: " + e.message, "err");
          }
        }

        
        async function vaultMove(payload) {
          const res = await apiFetch("/api/vault/file/move", {
            method: "POST",
            body: JSON.stringify(payload || {})
          });
          try{
            if (res && res.ok){
              const to = payload && payload.toFolderPath != null ? String(payload.toFolderPath) : null;
              let from = null;
              try{
                const hit = (state.items||[]).find(it => String(it.id) === String(payload && payload.id));
                if (hit && hit.folderPath != null) from = String(hit.folderPath);
              } catch(e){}
              if (from == null) from = String(state.currentFolder || "");
              if (from != null) delete state.treeListCache[String(from)];
              if (to != null) delete state.treeListCache[String(to)];
              // Trash view can change too
              delete state.treeListCache["_Trash"];
              renderFolderTree();
            }
          } catch(e){}
          return res;
        }

        async function renameSelected() {
          if (!state.selectedId) return;
          openDetailsPane("rename");
          renderDetailsPane();
        }

        async function moveSelected() {
          if (!state.selectedId) return;
          openDetailsPane("move");
          renderDetailsPane();
        }

        async function trashSelected() {
          if (!state.selectedId) return;
          const fileId = String(state.selectedId);
          setStatus("Sending to Trash...", "");
          const r = await vaultMove({ id: state.selectedId, toFolderPath: "_Trash" });
          if (!r || !r.ok) { setStatus("Trash failed: " + ((r && r.error) || "unknown error"), "err"); return; }
          state.selectedId = null;
          syncToolbar();
          await loadList();
          setStatus("Moved to Trash.", "ok");
          try { logActivity(fileId, "Trashed", null); } catch(e) {}
        }

        async function restoreSelected() {
          if (!state.selectedId) return;
          const inTrash = false; // Trash disabled
          if (!inTrash) return;
          const fileId = String(state.selectedId);
          const target = (String(state.lastNonTrashFolder || "") && String(state.lastNonTrashFolder) !== "_Trash")
            ? String(state.lastNonTrashFolder)
            : "Working Folder";
          setStatus("Restoring...", "");
          const r = await vaultMove({ id: state.selectedId, toFolderPath: target });
          if (!r || !r.ok) { setStatus("Restore failed: " + ((r && r.error) || "unknown error"), "err"); return; }
          state.selectedId = null;
          syncToolbar();
          await loadList();
          setStatus("Restored.", "ok");
          try { logActivity(fileId, "Restored", null); } catch(e) {}
        }

        async function emptyTrash() {
          const inTrash = false; // Trash disabled
          if (!inTrash) return;
          if (!confirm("Empty Trash? This will permanently delete all files currently in Trash.")) return;
          setStatus("Emptying Trash...", "");
          try {
            const r = await apiFetch("/api/vault/trash/empty", { method: "POST" });
            if (!r || !r.ok) throw new Error((r && r.error) || "Empty Trash failed");
            state.selectedId = null;
            syncToolbar();
            await loadFolders();
            await loadList();
            setStatus("Trash emptied.", "ok");
          } catch (e) {
            setStatus("Empty Trash failed: " + e.message, "err");
          }
        }

        async function deleteSelected() {
          if (!state.selectedId) return;
          const fileId = String(state.selectedId);
          const inTrash = false; // Trash disabled
          const msg = inTrash
            ? "Permanently delete this file? This cannot be undone."
            : "Delete sends files to Trash. Permanently delete only from inside the _Trash folder.\n\nMove to Trash now?";
          if (!confirm(msg)) return;

          if (!inTrash) return trashSelected();

          setStatus("Deleting...", "");
          try {
            const r = await apiFetch("/api/vault/file/" + encodeURIComponent(state.selectedId), { method: "DELETE" });
            if (!r || !r.ok) throw new Error((r && r.error) || "Delete failed");
            state.selectedId = null;
            syncToolbar();
            await loadList();
            setStatus("Deleted.", "ok");
            try { logActivity(fileId, "Deleted", null); } catch(e) {}
          } catch (e) {
            setStatus("Delete failed: " + e.message, "err");
          }
        }

function openPdfStudio(fileId){
          const id = String(fileId||"").trim();
          if (!id) return;
          state.currentFileId = id;
          const it = state.items.find(x => (x.id||x.key) === id) || null;
          state.currentFileName = (it && (it.name || it.filename)) ? (it.name || it.filename) : (state.currentFileName || "document.pdf");
          const url = "/pdfstudio.html?embed=1&fileId=" + encodeURIComponent(id) + "&name=" + encodeURIComponent(state.currentFileName || "document.pdf") + "&folderPath=" + encodeURIComponent((state.currentFolder ?? "")) + "&folder=" + encodeURIComponent((state.currentFolder ?? ""));
          state.currentIframeUrl = url;
          els.frame.src = url;
          setStatus("PDFStudio loaded.", "ok");
        }

async function openFile(fileId) {
          const id = String(fileId||"").trim();
          if (!id) return;

          // PDFStudio mode: show PDFs in the previewer iframe
          if (state.tool === "pdf") {
            openPdfInFrame(id);
            return;
          }

          setStatus("Opening editor...", "");
          try {
            const r = await apiFetch("/api/office/session", {
              method: "POST",
              body: JSON.stringify({ fileId: id })
            });
            const rawUrl = (r && (r.iframeUrl || r.url)) ? (r.iframeUrl || r.url) : "";
            if (!r || !r.ok || !rawUrl) throw new Error((r && r.error) || "Failed to create session");
const fixedUrl = normalizeOfficeUrl(rawUrl);
            state.currentIframeUrl = fixedUrl;
els.frame.src = fixedUrl;
setStatus("Editor loaded.", "ok");
          } catch (e) {
            setStatus("Open failed: " + e.message, "err");
          }
        }

        function clearFrame() {
          els.frame.src = "about:blank";
          state.currentIframeUrl = "";
          setStatus("Cleared.", "");
        }

        function popout() {
          if (!state.currentIframeUrl) {
            setStatus("Open a file first.", "err");
            return;
          }
          try {
            if (state.pop && !state.pop.closed) {
              state.pop.focus();
              return;
            }
            state.pop = window.open(state.currentIframeUrl, "pdfrealm_office_popout", "noopener,noreferrer,width=1200,height=800");
            if (!state.pop) setStatus("Popout blocked by browser.", "err");
          } catch (e) {
            setStatus("Popout failed: " + e.message, "err");
          }
        }

        // events

        // account modal events
        const accountBtn = document.getElementById("accountLoginBtn");
        const accountClose = document.getElementById("accountModalClose");
        const loginBtn = document.getElementById("loginSubmitBtn");

        if (accountBtn) accountBtn.addEventListener("click", () => openModal("accountModal"));
        if (accountClose) accountClose.addEventListener("click", () => closeModal("accountModal"));
        if (loginBtn) loginBtn.addEventListener("click", loginFromModal);

        // tool tabs
        state.tool = state.tool || "docx";
        function syncTabs() {
          const btns = Array.from(els.toolTabs.querySelectorAll(".tab-btn"));
          btns.forEach(b => {
            const t = b.getAttribute("data-tool");
            const on = t === state.tool;
            b.classList.toggle("active", on);
            b.setAttribute("aria-selected", on ? "true" : "false");
          });
          if (els.newBtn) els.newBtn.textContent = "Tool";
          // PDFStudio doesn't create office docs
          if (els.newBtn) els.newBtn.disabled = !state.token || state.tool === "pdf";
        }
        els.toolTabs.addEventListener("click", (e) => {
          const b = e.target && e.target.closest && e.target.closest(".tab-btn");
          if (!b) return;
          state.tool = b.getAttribute("data-tool") || "docx";
          state.selectedId = null;
          syncTabs();
          syncToolbar();
          renderBreadcrumbs();
          renderList();
        });

        els.newBtn?.addEventListener("click", () => { try { setMain("files"); } catch(e){} });
els.refreshBtn.addEventListener("click", () => loadList());
        els.searchInput?.addEventListener("input", () => renderList());
        

        // explorer controls
        function setFilter(f){
          state.filter = String(f || "all");
          try { localStorage.setItem("df_filter", state.filter); } catch {}
          renderList();
        }
        
        const gridPopout = document.getElementById("gridPopout");
        const gridPopoutBody = document.getElementById("gridPopoutBody");
        const gridPopoutClose = document.getElementById("gridPopoutClose");

        function openGridPopout(){
          if (!gridPopout || !gridPopoutBody || !els.fileList || !els.bulkBar) {
            state.view = "grid";
            renderList();
            return;
          }
          if (!state._gridHome) state._gridHome = { parent: els.fileList.parentNode, next: els.fileList.nextSibling };
          if (!state._bulkHome) state._bulkHome = { parent: els.bulkBar.parentNode, next: els.bulkBar.nextSibling };

          // Move list + bulk bar into the popout so it feels like a dedicated view.
          gridPopout.hidden = false;
          document.body.classList.add("grid-popout-open");
          state.view = "grid";
          gridPopoutBody.appendChild(els.fileList);
          gridPopoutBody.appendChild(els.bulkBar);
          renderList();

          // button state
          if (els.viewListBtn) els.viewListBtn.classList.remove("active");
          if (els.viewGridBtn) els.viewGridBtn.classList.add("active");
        }

        function closeGridPopout(){
          if (!gridPopout || !els.fileList || !els.bulkBar) return;

          // Restore list + bulk bar back to the Files pane
          if (state._gridHome && state._gridHome.parent) {
            const { parent, next } = state._gridHome;
            if (next) parent.insertBefore(els.fileList, next); else parent.appendChild(els.fileList);
          }
          if (state._bulkHome && state._bulkHome.parent) {
            const { parent, next } = state._bulkHome;
            if (next) parent.insertBefore(els.bulkBar, next); else parent.appendChild(els.bulkBar);
          }
          gridPopout.hidden = true;
          document.body.classList.remove("grid-popout-open");
          state.view = "list";
          renderList();

          if (els.viewGridBtn) els.viewGridBtn.classList.remove("active");
          if (els.viewListBtn) els.viewListBtn.classList.add("active");
        }

        function setView(v){
          const wantGrid = (v === "grid");
          if (wantGrid) openGridPopout();
          else closeGridPopout();
          try { localStorage.setItem("df_view", state.view); } catch {}
        }

        function setSort(s){
          state.sort = String(s || "name_asc");
          try { localStorage.setItem("df_sort", state.sort); } catch {}
          renderList();
        }
        function setQuickOpen(on){
          state.quickOpen = !!on;
          try { localStorage.setItem("df_quickOpen", state.quickOpen ? "1" : "0"); } catch {}
        }

        if (els.sortSelect) {
          els.sortSelect.value = state.sort || "name_asc";
          els.sortSelect.addEventListener("change", () => setSort(els.sortSelect.value));
        }
        if (els.quickOpenChk) {
          els.quickOpenChk.checked = !!state.quickOpen;
          els.quickOpenChk.addEventListener("change", () => setQuickOpen(els.quickOpenChk.checked));
        }
        if (els.viewListBtn) els.viewListBtn.addEventListener("click", () => setView("list"));
        if (els.viewGridBtn) els.viewGridBtn.addEventListener("click", () => setView("grid"));
        if (gridPopoutClose) gridPopoutClose.addEventListener("click", () => setView("list"));
        document.addEventListener("keydown", (e) => { if (e.key === "Escape" && gridPopout && !gridPopout.hidden) setView("list"); });

        if (els.filterAllBtn) els.filterAllBtn.addEventListener("click", () => setFilter("all"));
        if (els.filterRecentBtn) els.filterRecentBtn.addEventListener("click", () => setFilter("recent"));
        if (els.filterStarBtn) els.filterStarBtn.addEventListener("click", () => setFilter("star"));
        if (els.filterTrashBtn) els.filterTrashBtn.addEventListener("click", () => setFilter("trash"));

        if (els.uploadBtn && els.uploadInput) {
          els.uploadBtn.addEventListener("click", () => {
            /* logged out imports locally */
            els.uploadInput.value = "";
            els.uploadInput.click();
          });
          els.uploadInput.addEventListener("change", async () => {
            const files = Array.from(els.uploadInput.files || []);
            if (!files.length) return;

            // Logged out: import locally (Non-account Folder)
            if (!state.token){
              try{
                await guestImportFiles(files, (guestState && guestState.currentFolder) ? guestState.currentFolder : "");
                setStatus("Imported locally", "");
              }catch(e){
                setStatus("Import failed", e && e.message ? e.message : String(e));
              }finally{
                try{ els.uploadInput.value = ""; }catch(e){}
              }
              return;
            }

            // Logged in: upload to Vault
            try {
              setStatus("Uploading...", "");
              for (const f of files){
                const fd = new FormData();
                fd.append("file", f, f.name);
                fd.append("folderPath", state.currentFolder || "");
                const resp = await fetch("/api/vault/upload", {
                  method: "POST",
                  headers: (state.token ? { "Authorization": "Bearer " + state.token } : {}),
            credentials: "same-origin",
                  body: fd
                });
                const j = await resp.json().catch(()=> ({}));
                if (!resp.ok || !j.ok) throw new Error(j.error || ("Upload failed ("+resp.status+")"));
              }
              await loadList();
              setStatus("Uploaded", "");
            } catch (e) {
              setStatus("Upload failed", e && e.message ? e.message : String(e));
            } finally {
              try { els.uploadInput.value = ""; } catch(e){}
            }
          });
        }

        if (els.newFolderBtn) {
          els.newFolderBtn.addEventListener("click", async () => {
            if (!state.token) return openModal("accountModal");
            const base = String(state.currentFolder || "");
            const name = await uxPrompt({ title: "New folder", label: "Folder name", placeholder: "e.g., Working Folder", okText: "Create" });
            if (!name) return;
            const folderPath = base ? (base + "/" + name) : name;
            try {
              setStatus("Creating folder...", "");
              const r = await apiFetch("/api/vault/folder", {
                method: "POST",
                body: JSON.stringify({ folderPath })
              });
              if (!r || !r.ok) throw new Error((r && r.error) || "Folder create failed");
              await loadFolders();
              state.currentFolder = folderPath;
              if (els.folderSelect) els.folderSelect.value = folderPath;
              await loadList();
              setStatus("Folder created.", "ok");
            } catch (e) {
              setStatus("Folder create failed: " + (e.message || e), "err");
            }
          });
        }

        // keyboard shortcuts (when focus isn't in a text input)
        window.addEventListener("keydown", (e) => {
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
          const typing = tag === "input" || tag === "textarea" || (document.activeElement && document.activeElement.isContentEditable);
          if (typing) return;

          if (e.key === "Enter" && state.selectedId) { e.preventDefault(); openSelected(); }
          if (e.key === "F2" && state.selectedId) { e.preventDefault(); renameSelected(); }
          if (e.key === "Delete" && state.selectedId) { e.preventDefault(); trashSelected(); }
        });

els.folderSelect.addEventListener("change", () => {
          const next = els.folderSelect.value || "";
          if (String(next) !== "_Trash") state.lastNonTrashFolder = next;
          state.currentFolder = next;
          try { setAuthUI(); } catch(e) {}
          renderBreadcrumbs();
          pushRecentFolder(state.currentFolder);
          setAuthUI();
          loadList();
        });

        // Folder tree collapse
        if (els.folderTreeCollapseBtn && els.folderTree){
          els.folderTreeCollapseBtn.addEventListener("click", () => {
            const collapsed = els.folderTree.classList.toggle("collapsed");
            els.folderTreeCollapseBtn.textContent = collapsed ? "▸" : "▾";
            try { localStorage.setItem("docforge_tree_collapsed", collapsed ? "1" : "0"); } catch(e){}
          });
          try {
            const v = localStorage.getItem("docforge_tree_collapsed");
            if (v === "1"){ els.folderTree.classList.add("collapsed"); els.folderTreeCollapseBtn.textContent = "▸"; }
          } catch(e){}
        }

        els.openIdBtn.addEventListener("click", () => {
          const id = els.openIdInput.value;
          if (state.tool === "pdf") return openPdfInFrame(id);
          return openFile(id);
        });
        els.clearBtn.addEventListener("click", () => clearFrame());
        els.popoutBtn.addEventListener("click", () => popout());
        // --- Save flow: Download locally and/or Save back into Vault ---
        function openModal(id){
          const el = document.getElementById(id);
          if (!el) return;
          el.style.display = "flex";
        }
        function closeModal(id){
          const el = document.getElementById(id);
          if (!el) return;
          el.style.display = "none";
        }
        function setSaveStatus(msg, kind){
          if (!els.saveStatus) return;
          els.saveStatus.textContent = msg || "";
          els.saveStatus.className = "status " + (kind || "");
        }
        function syncSaveOptions(){
          const isPdfTool = (state.tool === "pdf");

          // Only show encryption for PDFStudio
          const encRow = document.getElementById("saveEncryptRow");
          if (encRow) encRow.style.display = isPdfTool ? "flex" : "none";
          if (!isPdfTool && els.saveEncryptChk) els.saveEncryptChk.checked = false;

          const vaultOn = !!els.saveVaultChk?.checked;
          if (els.vaultSaveOptions) els.vaultSaveOptions.style.display = vaultOn ? "block" : "none";


          // If the current open file is local/non-account, Vault "overwrite" doesn't apply.
          try{
            const curId = getSaveFileId();
            const isLocalForVault = String(curId||"").startsWith("g_") || String(state.currentIframeUrl||"").startsWith("blob:");
            const overwriteRadio = document.querySelector('input[name="vaultSaveMode"][value="overwrite"]');
            const copyRadio = document.querySelector('input[name="vaultSaveMode"][value="copy"]');
            if (overwriteRadio && copyRadio){
              if (isLocalForVault){
                overwriteRadio.disabled = true;
                overwriteRadio.title = "Overwrite is only available for files already stored in Vault.";
                // If overwrite was selected, force copy
                if (overwriteRadio.checked) copyRadio.checked = true;
              } else {
                overwriteRadio.disabled = false;
                overwriteRadio.title = "";
              }
            }
          }catch(e){}


          
          // If user is encrypting or changing the filename, prefer "Save as a new copy" so it shows up in Vault.
          try{
            const overwriteRadio = document.querySelector('input[name="vaultSaveMode"][value="overwrite"]');
            const copyRadio = document.querySelector('input[name="vaultSaveMode"][value="copy"]');
            const origName = String(state.currentFileName || "");
            const typedName = String(els.saveVaultName?.value || "");
            const nameChanged = !!(origName && typedName && typedName.trim() && typedName.trim() !== origName);
            const encRequested = (!!els.saveEncryptChk?.checked) && isPdfTool;
            if (vaultOn && overwriteRadio && copyRadio && (encRequested || nameChanged)) {
              if (overwriteRadio.checked) copyRadio.checked = true;
            }

            // Auto-suffix encrypted copies unless user already customized the name
            if (vaultOn && encRequested && copyRadio && copyRadio.checked && els.saveVaultName) {
              const nm = String(els.saveVaultName.value || "").trim();
              const base = nm || (origName || "document.pdf");
              const isPdf = /\.pdf$/i.test(base);
              const hasSuffix = /_encrypted(\.|$)/i.test(base);
              if (isPdf && !hasSuffix && !nameChanged) {
                els.saveVaultName.value = base.replace(/\.pdf$/i, "_encrypted.pdf");
              }
            }
          }catch(e){}
const encOn = (!!els.saveEncryptChk?.checked) && isPdfTool;
          if (els.saveEncryptPwRow) els.saveEncryptPwRow.style.display = encOn ? "block" : "none";
          if (!encOn && els.saveEncryptPw) els.saveEncryptPw.value = "";
          if (!encOn && els.saveEncryptPw2) els.saveEncryptPw2.value = "";

                    if (!encOn && els.saveEncryptCurrPw) els.saveEncryptCurrPw.value = "";
const anyDest = (!!els.saveLocalChk?.checked) || (!!els.saveVaultChk?.checked);
          if (els.saveConfirmBtn){
            els.saveConfirmBtn.disabled = !anyDest;
            els.saveConfirmBtn.title = anyDest ? "" : "Choose at least one destination.";
          }
        }
        async function ensureSaveFoldersLoaded(){
          const opts = ["", ...(state.folders||[])];
          if (els.saveVaultFolder){
            els.saveVaultFolder.innerHTML = opts.map(p => {
              const label = p ? p : "(root)";
              return `<option value="${escapeHtml(p)}">${escapeHtml(label)}</option>`;
            }).join("");
            if (state.currentFolder != null) els.saveVaultFolder.value = state.currentFolder;
            if (els.saveVaultFolderBtn){
              const v = String(els.saveVaultFolder.value||"");
              els.saveVaultFolderBtn.textContent = v ? v : "(root)";
            }

          }
        }
        function escapeHtml(str){
          return String(str||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
        }
        function getSaveFileId(){
          return state.currentFileId || state.selectedId || "";
        }
        function guessMime(name){
          const n = String(name||"").toLowerCase();
          if (n.endsWith(".pdf")) return "application/pdf";
          if (n.endsWith(".docx")) return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          if (n.endsWith(".pptx")) return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
          if (n.endsWith(".xlsx")) return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
          return "application/octet-stream";
        }
        
        

        function ensureToolExt(name, tool){
          let n = String(name || "").trim();
          if (!n) n = "document";
          const lower = n.toLowerCase();
          const t = String(tool || "").toLowerCase();
          // If user already typed an extension, keep it.
          if (/\.[a-z0-9]{1,8}$/i.test(n)) return n;
          if (t === "pdf") return n + ".pdf";
          if (t === "docx") return n + ".docx";
          if (t === "pptx") return n + ".pptx";
          if (t === "xlsx") return n + ".xlsx";
          return n;
        }
async function encryptBytesForSave(bytes, filename){
          const pw = String(els.saveEncryptPw?.value || "").trim();
          const pw2 = String(els.saveEncryptPw2?.value || "").trim();
          const curr = String(els.saveEncryptCurrPw?.value || "").trim();
          if (!pw) throw new Error("Please enter a password.");
          if (pw2 && pw !== pw2) throw new Error("Passwords do not match.");
          const token = state.token || "";
          const fd = new FormData();
          const inU8 = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
          fd.append("file", new Blob([inU8], { type: "application/pdf" }), filename || "document.pdf");
          fd.append("password", pw);


          if (curr) fd.append("inputPassword", curr);
          const resp = await fetch("/api/encrypt", {
            method: "POST",
            headers: token ? { "Authorization": "Bearer " + token } : {},
            body: fd,
            credentials: "same-origin"
          });

          const ct = (resp.headers.get("content-type") || "").toLowerCase();
          if (!resp.ok){
            if (ct.includes("application/json")){
              const j = await resp.json().catch(()=>null);
              throw new Error((j && j.error) ? j.error : ("Encrypt failed ("+resp.status+")"));
            }
            const t = await resp.text().catch(()=>"");
            throw new Error("Encrypt failed ("+resp.status+"): " + (t||""));
          }

          if (ct && !ct.includes("application/pdf")){
            if (ct.includes("application/json")){
              const j = await resp.json().catch(()=>null);
              throw new Error((j && j.error) ? j.error : "Encrypt returned JSON, not a PDF.");
            }
            const t = await resp.text().catch(()=>"");
            throw new Error("Encrypt returned a non-PDF response (" + (ct || "unknown") + "): " + (t||""));
          }

          const u = new Uint8Array(await resp.arrayBuffer());
          const h = String.fromCharCode(u[0]||0, u[1]||0, u[2]||0, u[3]||0);
          if (h !== "%PDF"){
            let preview = "";
            try{ preview = new TextDecoder().decode(u.slice(0, 200)); }catch{}
            throw new Error("Encrypt response was not a valid PDF (missing %PDF header)." + (ct ? (" Content-Type: " + ct + ".") : "") + (preview ? (" Preview: " + preview.replace(/\s+/g, " ").slice(0, 140)) : ""));
          }

          return u;
        }

function downloadBytes(outBytes, filename, outMime){
          const u8 = (outBytes instanceof Uint8Array) ? outBytes : new Uint8Array(outBytes);
          const blob = new Blob([u8], { type: outMime || "application/octet-stream" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename || "download";
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        }
        function requestPdfStudioExport(timeoutMs){
          return new Promise((resolve, reject) => {
            const w = els.frame?.contentWindow;
            if (!w) return reject(new Error("No iframe."));
            const nonce = Math.random().toString(36).slice(2);
            const onMsg = (ev) => {
              const d = ev.data || {};
              if (d && d.type === "PDFSTUDIO_EXPORT_RESULT" && d.nonce === nonce) {
                window.removeEventListener("message", onMsg);
                if (!d.ok) return reject(new Error(d.error || "Export failed"));
                return resolve(d.bytes);
              }

        // When PDFStudio signals DONE (it doesn't save on its own in Office mode),
        // export the current edited PDF bytes and sync them into the Vault.
        window.addEventListener("message", async (ev) => {
          const d = ev && ev.data ? ev.data : null;
          if (!d || typeof d !== "object") return;
          if (d.type !== "PDFSTUDIO_DONE") return;

          // Only accept same-origin messages (or 'null' for some local dev setups)
          try{
            if (ev.origin && ev.origin !== "null" && ev.origin !== window.location.origin) return;
          }catch(_e){}

          try{
            // If we're not in the PDF tool, ignore.
            if (String(state.tool||"") !== "pdf") return;

            const bytes = await requestPdfStudioExport(25000);
            if (!bytes || !bytes.byteLength) throw new Error("Missing exported bytes.");

            const id = getSaveFileId();
            const filename = (state.currentFileName || "document.pdf");
            const mime = "application/pdf";

            // If we have a real Vault file open, overwrite it; otherwise upload a copy into the current folder.
            let savedId = null;
            let savedFolder = String(state.currentFolder || "");
            const isLocalId = !id || String(id).startsWith("g_") || String(state.currentIframeUrl||"").startsWith("blob:");

            if (!isLocalId) {
              await overwriteVault(bytes, id, filename, mime);
              savedId = id;
            } else {
              const j = await uploadCopyToVault(bytes, filename, savedFolder, mime);
              savedId = (j && (j.id || (j.file && j.file.id) || (j.item && j.item.id))) || null;

              // prefer server folderPath if present
              const serverFolder =
                (j && (j.folderPath || j.folder ||
                  (j.file && (j.file.folderPath || j.file.folder)) ||
                  (j.item && (j.item.folderPath || j.item.folder))
                )) || savedFolder || "";
              savedFolder = String(serverFolder || savedFolder);

              if (String(savedFolder) !== String(state.currentFolder || "")) {
                state.currentFolder = savedFolder;
                try { els.folderSelect.value = state.currentFolder; } catch (e) {}
                try { pushRecentFolder(state.currentFolder); } catch (e) {}
                try { renderBreadcrumbs(); } catch (e) {}
                try { savePrefs(); } catch (e) {}
              }
            }

            try { vaultPing(); } catch(e){}
            // Bust caches and refresh UI so Vault reflects the save immediately
            try { delete state.treeListCache[String(savedFolder || "")]; } catch (e) {}
            try { delete state.treeListInflight[String(savedFolder || "")]; } catch (e) {}
            try { delete state.treeListCache[String(state.currentFolder || "")]; } catch (e) {}
            try { delete state.treeListCache[""]; } catch (e) {}

            await loadList();
            try { await ensureTreeFolderList(String(savedFolder || "")); } catch (e) {}
            try { renderFolderTree(); } catch (e) {}
            if (savedId) { try { selectOnly(String(savedId)); } catch (e) {} }

            try { if (typeof window.setStatus === "function") window.setStatus("Synced to Vault.", "ok"); } catch(e){}
          }catch(e){
            console.error(e);
            try { if (typeof window.setStatus === "function") window.setStatus("Vault sync failed: " + (e.message||String(e)), "bad"); } catch(_e){}
          }
        });
            };
            window.addEventListener("message", onMsg);
            w.postMessage({ type: "PDFSTUDIO_EXPORT", nonce }, "*");
            setTimeout(() => {
              window.removeEventListener("message", onMsg);
              reject(new Error("Export timeout"));
            }, timeoutMs || 1200);
          });
        }
        async function getBytesForSave(){
  const id = getSaveFileId();

  // If PDFStudio iframe is open, export bytes from it even if no Vault file is selected.
  // (We can still save by uploading a copy into Vault.)
  if (state.tool === "pdf") {
    const bytes = await requestPdfStudioExport(20000);
    if (!bytes || !bytes.byteLength) throw new Error("Missing exported bytes.");
    return { bytes, mime: "application/pdf" };
  }

  if (!id) throw new Error("No file selected/open.");

  const resp = await fetch("/api/vault/file-proxy/" + encodeURIComponent(id), {
    headers: (state.token ? { "Authorization": "Bearer " + state.token } : {}),
            credentials: "same-origin"
  });
  if (!resp.ok) throw new Error("Download failed ("+resp.status+").");
  const ab = await resp.arrayBuffer();
  const ct = resp.headers.get("content-type") || guessMime(state.currentFileName);
  return { bytes: ab, mime: ct };
}

        async function uploadCopyToVault(bytes, filename, folderPath, mime){
          const blob = new Blob([bytes], { type: mime || "application/octet-stream" });
          const fd = new FormData();
          fd.append("file", blob, filename || "document");
          fd.append("folderPath", folderPath || "");
                    fd.append("folder", folderPath || "");
const resp = await fetch("/api/vault/upload", {
            method: "POST",
            headers: (state.token ? { "Authorization": "Bearer " + state.token } : {}),
            credentials: "same-origin",
            body: fd
          });
          const j = await resp.json().catch(()=> ({}));
          if (!resp.ok || !j.ok) throw new Error(j.error || ("Upload failed ("+resp.status+")"));
          return j;
        }
        async function overwriteVault(bytes, id, filename, mime){
          const blob = new Blob([bytes], { type: mime || "application/octet-stream" });
          const fd = new FormData();
          fd.append("file", blob, filename || "document");
          const resp = await fetch("/api/vault/file/" + encodeURIComponent(id) + "/overwrite", {
            method: "POST",
            headers: (state.token ? { "Authorization": "Bearer " + state.token } : {}),
            credentials: "same-origin",
            body: fd
          });
          const j = await resp.json().catch(()=> ({}));
          if (!resp.ok || !j.ok) throw new Error(j.error || ("Overwrite failed ("+resp.status+")"));
          return j;
        }

        els.saveBtn.addEventListener("click", async () => {
          if (!state.token) return openModal("accountModal");
          await ensureSaveFoldersLoaded();
          syncSaveOptions();
          if (els.saveVaultName && !els.saveVaultName.value) {
            const base = state.currentFileName || (state.tool==="pdf" ? "document.pdf" : "document");
            els.saveVaultName.value = base;
          }
          setSaveStatus("", "");
          if (els.saveEncryptChk) els.saveEncryptChk.checked = false;
          if (els.saveEncryptPw) els.saveEncryptPw.value = "";
          if (els.saveEncryptPw2) els.saveEncryptPw2.value = "";
          if (els.saveEncryptCurrPw) els.saveEncryptCurrPw.value = "";
          syncSaveOptions();
          openModal("saveModal");
        });
        if (els.saveModalClose) if (els.saveModalClose) els.saveModalClose.addEventListener("click", () => { closeSaveVaultFolderPicker(); closeModal("saveModal"); });
        if (els.saveCancelBtn) els.saveCancelBtn.addEventListener("click", () => { closeSaveVaultFolderPicker(); closeModal("saveModal"); });
        els.saveVaultChk.addEventListener("change", syncSaveOptions);
        if (els.saveLocalChk) els.saveLocalChk.addEventListener("change", syncSaveOptions);
        if (els.saveEncryptChk) els.saveEncryptChk.addEventListener("change", syncSaveOptions);
        if (els.saveVaultFolderBtn) els.saveVaultFolderBtn.addEventListener("click", (e)=>{ e.preventDefault(); toggleSaveVaultFolderPicker(); });
        if (els.saveVaultFolderDropClose) els.saveVaultFolderDropClose.addEventListener("click", (e)=>{ e.preventDefault(); closeSaveVaultFolderPicker(); });
        if (els.saveVaultFolder) els.saveVaultFolder.addEventListener("change", ()=>{ if (els.saveVaultFolderBtn){ const v = String(els.saveVaultFolder.value||""); els.saveVaultFolderBtn.textContent = v ? v : "(root)"; } });


        if (els.saveConfirmBtn) els.saveConfirmBtn.addEventListener("click", async () => {
          try {
            setSaveStatus("Saving...", "");
            const wantLocal = !!els.saveLocalChk?.checked;
            const wantVault = !!els.saveVaultChk?.checked;
            if (!wantLocal && !wantVault) throw new Error("Choose at least one destination.");
            const id = getSaveFileId();
            if (!id && state.tool !== "pdf") throw new Error("No file selected/open.");
            const { bytes, mime } = await getBytesForSave();
            const rawFilename = (els.saveVaultName?.value || state.currentFileName || "document").trim() || "document";
            const filename = ensureToolExt(rawFilename, state.tool);
            try { state.currentFileName = filename; } catch(e){}

            let outBytes = bytes;
            let outMime = mime;

            if (els.saveEncryptChk?.checked){
              // Encryption only supported for PDFs
              const isPdf = (String(outMime||"").toLowerCase().includes("application/pdf")) || /\.pdf$/i.test(filename);
              if (!isPdf) throw new Error("Encryption is currently available for PDFs only.");
              setSaveStatus("Encrypting...", "");
              try{
                outBytes = await encryptBytesForSave(outBytes, filename);
                outMime = "application/pdf";
              }catch(err){
                const msg = String(err?.message || err || "");
                if (/qpdf|aes-?256|not available/i.test(msg)){
                  // Server-side encryption is not available in some environments; continue without encryption.
                  setSaveStatus("Encryption isn’t available here. Saving without encryption.", "");
                } else {
                  throw err;
                }
              }
            }

            if (wantLocal) downloadBytes(outBytes, filename, outMime);
// Vault save + refresh UI (so the left explorer updates immediately)
let savedVaultId = null;
let savedVaultFolder = null;
if (wantVault) {
  const requestedFolder = String(els.saveVaultFolder?.value || "");
  let mode = (document.querySelector('input[name="vaultSaveMode"]:checked')?.value) || "overwrite";

  // If the current open file is a local/non-account file, we cannot "overwrite" in Vault.
  const isLocalId = (!id) || String(id||"").startsWith("g_") || String(state.currentIframeUrl||"").startsWith("blob:");
  if (isLocalId && mode === "overwrite") mode = "copy";
  // If user is encrypting or changing the filename, "overwrite" will not create a new entry (and cannot rename).
  // In those cases, default to saving a new copy so it appears in Vault immediately.
  try{
    const origName = String(state.currentFileName || "");
    const typedName = String(filename || "");
    const nameChanged = !!(origName && typedName && typedName.trim() && typedName.trim() !== origName);
    const encRequested = !!els.saveEncryptChk?.checked;
    const folderChanged = (requestedFolder && String(requestedFolder) !== String(state.currentFolder || ""));
    if ((encRequested || nameChanged || folderChanged) && mode === "overwrite") mode = "copy";
  }catch(e){}


  if (mode === "overwrite") {
    await overwriteVault(outBytes, id, filename, outMime);
    savedVaultId = id;
    savedVaultFolder = String(state.currentFolder || "");
  } else {
    const j = await uploadCopyToVault(outBytes, filename, requestedFolder, outMime);

    savedVaultId = (j && (j.id || (j.file && j.file.id) || (j.item && j.item.id))) || null;

    // Prefer folder info returned by the server (source of truth), fallback to requestedFolder
    const serverFolder =
      (j && (j.folderPath || j.folder ||
        (j.file && (j.file.folderPath || j.file.folder)) ||
        (j.item && (j.item.folderPath || j.item.folder))
      )) || requestedFolder || "";
    savedVaultFolder = String(serverFolder || "");

    // Switch view to the destination folder so you can see the new file immediately
    if (String(savedVaultFolder) !== String(state.currentFolder || "")) {
      state.currentFolder = savedVaultFolder;
      try { els.folderSelect.value = state.currentFolder; } catch (e) {}
      try { pushRecentFolder(state.currentFolder); } catch (e) {}
      try { renderBreadcrumbs(); } catch (e) {}
      try { savePrefs(); } catch (e) {}
    }
  }

  // Invalidate folder tree caches so the left explorer refreshes
  try { delete state.treeListCache[String(savedVaultFolder || "")]; } catch (e) {}
  try { delete state.treeListInflight[String(savedVaultFolder || "")]; } catch (e) {}
  try { delete state.treeListCache[String(state.currentFolder || "")]; } catch (e) {}
  try { delete state.treeListCache[""]; } catch (e) {}

  // Ensure the destination folder path is expanded in the left tree
  try {
    const openSet = getTreeOpenSet();
    openSet.add("");
    const fp = String(savedVaultFolder || "");
    if (fp) {
      let acc = "";
      fp.split("/").filter(Boolean).forEach((part) => {
        acc = acc ? (acc + "/" + part) : part;
        openSet.add(acc);
      });
    }
    saveTreeOpenSet(openSet);
  } catch (e) {}

    if (wantVault) { try { vaultPing(); } catch (e) {} }
// Refresh list + tree and select the saved file
  await loadList();
  try { await ensureTreeFolderList(String(savedVaultFolder || "")); } catch (e) {}
  try { renderFolderTree(); } catch (e) {}
  if (savedVaultId) { try { selectOnly(String(savedVaultId)); } catch (e) {} }

  if (savedVaultId) {
    try {
      state.currentFileId = String(savedVaultId);
      state.currentFileName = filename;
    } catch(e){}
    try {
      // Attach the editor to the Vault-backed id (prevents repeated "copy" saves creating duplicates)
      if (state.tool === "pdf") {
        openPdfInFrame(String(savedVaultId));
      } else {
        openFile(String(savedVaultId));
      }
    } catch(e){}
  }

}
setSaveStatus("Saved.", "ok");
            setTimeout(() => closeModal("saveModal"), 450);
            if (!wantVault) loadList().catch(()=>{});
} catch (e) {
            setSaveStatus(e.message || String(e), "err");
          }
        });

        // selection toolbar

        // --- Bulk selection & actions (v4) ---
        function selectAllVisible(){
          const ids = Array.isArray(state.visibleIds) ? state.visibleIds : [];
          if (!ids.length) return;
          state.selectedIds = new Set(ids);
          state.selectedId = ids[0] || state.selectedId;
          state.selectionAnchorIndex = 0;
          closeDetailsPane();
          renderDetailsPane();
          syncToolbar();
          renderList();
        }

        function showBulkPop(title, build){
          if (!els.bulkPop || !els.bulkPopTitle || !els.bulkPopBody) return;
          els.bulkPopTitle.textContent = title || "Bulk action";
          els.bulkPopBody.innerHTML = "";
          const body = document.createElement("div");
          if (typeof build === "function") build(body);
          els.bulkPopBody.appendChild(body);
          els.bulkPop.hidden = false;
        }
        function hideBulkPop(){
          if (els.bulkPop) els.bulkPop.hidden = true;
        }

        async function bulkMoveTo(folderPath){
          const ids = getSelectedIds();
          if (!ids.length) return;
          setStatus(`Moving ${ids.length} file(s)...`, "");
          let ok = 0;
          for (const id of ids){
            try {
              await vaultMove({ id, toFolderPath: folderPath });
              ok++;
              try { logActivity(id, "Moved", folderPath); } catch(e){}
            } catch(e) {}
          }
          hideBulkPop();
          setStatus(`Moved ${ok}/${ids.length}.`, "ok");
          clearSelection();
          loadList().catch(()=>{});
        }

        async function bulkTrash(){
          const ids = getSelectedIds();
          if (!ids.length) return;
          setStatus(`Trashing ${ids.length} file(s)...`, "");
          let ok = 0;
          for (const id of ids){
            try {
              await vaultMove({ id, toFolderPath: "_Trash" });
              ok++;
              try { logActivity(id, "Trashed", null); } catch(e){}
            } catch(e) {}
          }
          hideBulkPop();
          setStatus(`Trashed ${ok}/${ids.length}.`, "ok");
          clearSelection();
          loadList().catch(()=>{});
        }

        async function bulkDeleteConfirmed(){
          const ids = getSelectedIds();
          if (!ids.length) return;
          setStatus(`Deleting ${ids.length} file(s)...`, "");
          let ok = 0;
          for (const id of ids){
            try {
              await apiFetch("/api/vault/file/" + encodeURIComponent(id), { method: "DELETE" });
              ok++;
              try { logActivity(id, "Deleted", null); } catch(e){}
            } catch(e) {}
          }
          hideBulkPop();
          setStatus(`Deleted ${ok}/${ids.length}.`, "ok");
          clearSelection();
          loadList().catch(()=>{});
        }

        function bulkDelete(){
          const ids = getSelectedIds();
          if (!ids.length) return;
          showBulkPop(`Delete ${ids.length} file(s)?`, (body) => {
            const msg = document.createElement("div");
            msg.className = "muted small";
            msg.style.lineHeight = "1.35";
            msg.textContent = "This permanently deletes the selected files. This cannot be undone.";
            body.appendChild(msg);

            const actions = document.createElement("div");
            actions.className = "pop-actions";
            const cancel = document.createElement("button");
            cancel.className = "btn btn-secondary";
            cancel.type = "button";
            cancel.textContent = "Cancel";
            cancel.addEventListener("click", () => hideBulkPop());

            const del = document.createElement("button");
            del.className = "btn btn-danger";
            del.type = "button";
            del.textContent = "Delete";
            del.addEventListener("click", () => bulkDeleteConfirmed());

            actions.appendChild(cancel);
            actions.appendChild(del);
            body.appendChild(actions);
          });
        }

        function bulkMove(){
          const ids = getSelectedIds();
          if (!ids.length) return;
          showBulkPop(`Move ${ids.length} file(s)`, (body) => {
            const row = document.createElement("div");
            row.className = "row";
            row.style.alignItems = "center";

            const sel = document.createElement("select");
            sel.className = "input";
            sel.style.flex = "1";
            const root = document.createElement("option");
            root.value = "";
            root.textContent = "/ (root)";
            sel.appendChild(root);
            (state.folders || []).forEach(p => {
              const o = document.createElement("option");
              o.value = p;
              o.textContent = "/" + p;
              sel.appendChild(o);
            });

            const input = document.createElement("input");
            input.className = "input";
            input.placeholder = "Or type folder path (e.g. forms/2026)";
            input.style.flex = "1";

            row.appendChild(sel);
            row.appendChild(input);

            const actions = document.createElement("div");
            actions.className = "pop-actions";
            const cancel = document.createElement("button");
            cancel.className = "btn btn-secondary";
            cancel.type = "button";
            cancel.textContent = "Cancel";
            cancel.addEventListener("click", () => hideBulkPop());

            const go = document.createElement("button");
            go.className = "btn btn-primary";
            go.type = "button";
            go.textContent = "Move";
            go.addEventListener("click", () => {
              const v = String(input.value || sel.value || "").trim();
              bulkMoveTo(v);
            });

            actions.appendChild(cancel);
            actions.appendChild(go);

            body.appendChild(row);
            body.appendChild(actions);
            setTimeout(() => input.focus(), 20);
          });
        }

        function bulkToggleStar(){
          const ids = getSelectedIds();
          if (!ids.length) return;
          const allStar = ids.every(id => isStarred(id));
          ids.forEach(id => {
            const it = (state.items || []).find(x => (x.id||x.key) === id);
            const name = it?.name || it?.filename || id;
            const key = String(id);
            if (allStar) {
              if (state.stars[key]) delete state.stars[key];
            } else {
              state.stars[key] = { name, at: Date.now() };
            }
          });
          try { localStorage.setItem("df_stars", JSON.stringify(state.stars || {})); } catch {}
          setStatus(allStar ? "Unstarred selection." : "Starred selection.", "ok");
          renderList();
          renderDetailsPane();
          updateBulkBar();
        }

        function bulkTag(){
          const ids = getSelectedIds();
          if (!ids.length) return;
          showBulkPop(`Tag ${ids.length} file(s)`, (body) => {
            const input = document.createElement("input");
            input.className = "input";
            input.placeholder = "comma,separated,tags";
            input.style.width = "100%";
            body.appendChild(input);

            const actions = document.createElement("div");
            actions.className = "pop-actions";

            const cancel = document.createElement("button");
            cancel.className = "btn btn-secondary";
            cancel.type = "button";
            cancel.textContent = "Cancel";
            cancel.addEventListener("click", () => hideBulkPop());

            const apply = document.createElement("button");
            apply.className = "btn btn-primary";
            apply.type = "button";
            apply.textContent = "Apply";
            apply.addEventListener("click", () => {
              const t = String(input.value || "").trim();
              ids.forEach(id => {
                state.tags[String(id)] = t;
                try { logActivity(id, "Tagged", t); } catch(e){}
              });
              savePrefs();
              hideBulkPop();
              setStatus("Tags applied.", "ok");
              renderDetailsPane();
            });

            actions.appendChild(cancel);
            actions.appendChild(apply);
            body.appendChild(actions);
            setTimeout(() => input.focus(), 20);
          });
        }

        // Bulk bar wiring
        if (els.bulkClearBtn) els.bulkClearBtn.addEventListener("click", () => clearSelection());
        if (els.bulkSelectAllBtn) els.bulkSelectAllBtn.addEventListener("click", () => selectAllVisible());
        if (els.bulkOpenBtn) els.bulkOpenBtn.addEventListener("click", () => openSelected());
        if (els.bulkMoveBtn) els.bulkMoveBtn.addEventListener("click", () => bulkMove());
        if (els.bulkTrashBtn) els.bulkTrashBtn.addEventListener("click", () => bulkTrash());
        if (els.bulkDeleteBtn) els.bulkDeleteBtn.addEventListener("click", () => bulkDelete());
        if (els.bulkStarBtn) els.bulkStarBtn.addEventListener("click", () => bulkToggleStar());
        if (els.bulkTagBtn) els.bulkTagBtn.addEventListener("click", () => bulkTag());

        // Close bulk pop if clicking elsewhere
        document.addEventListener("click", (e) => {
          if (!els.bulkPop || els.bulkPop.hidden) return;
          const within = els.bulkPop.contains(e.target) || (els.bulkBar && els.bulkBar.contains(e.target));
          if (!within) hideBulkPop();
        });

        // Keyboard shortcuts: Esc clears, Ctrl/Cmd+A selects visible
        document.addEventListener("keydown", (e) => {
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
          const typing = (tag === "input" || tag === "textarea" || document.activeElement?.isContentEditable);
          if (typing) return;

          if (e.key === "Escape") { if (selectionCount() > 0) { e.preventDefault(); clearSelection(); } }
          if ((e.ctrlKey || e.metaKey) && (e.key === "a" || e.key === "A")) {
            e.preventDefault();
            selectAllVisible();
          }
        });

        els.openSelBtn.addEventListener("click", () => openSelected());
        els.renameSelBtn.addEventListener("click", () => renameSelected());
        els.moveSelBtn.addEventListener("click", () => moveSelected());
        els.trashSelBtn.addEventListener("click", () => trashSelected());
        if (els.restoreSelBtn) els.restoreSelBtn.addEventListener("click", () => restoreSelected());
        if (els.emptyTrashBtn) els.emptyTrashBtn.addEventListener("click", () => emptyTrash());
        els.deleteSelBtn.addEventListener("click", () => deleteSelected());

        // pinned folders
        if (els.pinFolderBtn){
          els.pinFolderBtn.addEventListener("click", () => {
            const cur = String(state.currentFolder || "");
            const pins = Array.isArray(state.pins) ? state.pins : [];
            const idx = pins.indexOf(cur);
            if (idx >= 0) pins.splice(idx, 1);
            else pins.unshift(cur);
            state.pins = pins.slice(0, 20);
            savePrefs();
            renderPinnedFolders();
          });
        }

        // details pane wiring
        if (els.detailsCloseBtn) els.detailsCloseBtn.addEventListener("click", () => closeDetailsPane());
        if (els.detailsRenameBtn) els.detailsRenameBtn.addEventListener("click", () => applyDetailsRename());
        if (els.detailsMoveBtn) els.detailsMoveBtn.addEventListener("click", () => applyDetailsMove());
        if (els.detailsOpenBtn) els.detailsOpenBtn.addEventListener("click", () => openSelected());
        if (els.detailsTrashBtn) els.detailsTrashBtn.addEventListener("click", () => trashSelected());
        if (els.detailsDeleteBtn) els.detailsDeleteBtn.addEventListener("click", () => deleteSelected());

        if (els.detailsPreviewOpenBtn) els.detailsPreviewOpenBtn.addEventListener("click", () => openSelected());
        if (els.detailsCopyLinkBtn) els.detailsCopyLinkBtn.addEventListener("click", () => copySignedDownloadLink(state.selectedId));
        if (els.detailsFindDupesBtn) els.detailsFindDupesBtn.addEventListener("click", () => renderDuplicatesPane(state.selectedId));
        if (els.detailsClearActivityBtn) els.detailsClearActivityBtn.addEventListener("click", () => {
          if (!state.selectedId) return;
          const id = String(state.selectedId);
          state.activity = state.activity || {};
          delete state.activity[id];
          savePrefs();
          renderActivityPane(id);
          setStatus("Activity cleared.", "ok");
        });

        if (els.detailsStarBtn){
          els.detailsStarBtn.addEventListener("click", () => {
            if (!state.selectedId) return;
            const id = String(state.selectedId);
            state.stars = state.stars || {};
            state.stars[id] = !state.stars[id];
            try { localStorage.setItem("df_stars", JSON.stringify(state.stars)); } catch(e){}
            renderList();
            renderDetailsPane();
          });
        }

        if (els.detailsTagsInput){
          const saveTags = () => {
            if (!state.selectedId) return;
            const id = String(state.selectedId);
            const v = String(els.detailsTagsInput.value || "").trim();
            state.tags = state.tags || {};
            if (v) state.tags[id] = v;
            else delete state.tags[id];
            savePrefs();
            renderDetailsPane();
          };
          els.detailsTagsInput.addEventListener("change", saveTags);
          els.detailsTagsInput.addEventListener("blur", saveTags);
          els.detailsTagsInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter"){ e.preventDefault(); saveTags(); }
          });
        }

        // close details on ESC
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && state.detailsOpen){
            closeDetailsPane();
          }
        });



        // --- DocForge v5: Bulk drag/drop move + keyboard nav + type-to-search ---
        (function(){
          // Helpers
          function isTypingTarget(){
            const el = document.activeElement;
            if (!el) return false;
            const tag = (el.tagName || "").toLowerCase();
            return tag === "input" || tag === "textarea" || el.isContentEditable;
          }
          function getRows(){
            return Array.from((els.fileList || document.getElementById("fileList") || document.body).querySelectorAll(".file-item[data-id]"));
          }
          function setKbdFocus(idx){
            const rows = getRows();
            if (!rows.length){ state.kbdIndex = 0; return; }
            const i = Math.max(0, Math.min(idx, rows.length - 1));
            state.kbdIndex = i;
            rows.forEach(r => r.classList.remove("kbd-focus"));
            const row = rows[i];
            if (row){
              row.classList.add("kbd-focus");
              try { row.scrollIntoView({ block: "nearest" }); } catch(e) {}
            }
          }
          function syncKbdFocusFromPrimary(){
            const rows = getRows();
            if (!rows.length) return;
            const sel = state.selectedId ? String(state.selectedId) : "";
            if (sel){
              const i = rows.findIndex(r => r.dataset.id === sel);
              if (i >= 0) state.kbdIndex = i;
            }
            setKbdFocus(state.kbdIndex || 0);
          }
          function ensureRowsDraggable(){
            getRows().forEach(r => r.setAttribute("draggable", "true"));
          }

          // Drag & drop targets (folders + trash)
          function bindDropTarget(el, kind){
            if (!el || el.dataset.ddBound === "1") return;
            el.dataset.ddBound = "1";
            el.addEventListener("dragover", (e) => { e.preventDefault(); e.dataTransfer.dropEffect = "move"; el.classList.add("drag-over"); });
            el.addEventListener("dragleave", () => el.classList.remove("drag-over"));
            el.addEventListener("drop", async (e) => {
              e.preventDefault();
              el.classList.remove("drag-over");
              let payload = null;
              try { payload = JSON.parse(e.dataTransfer.getData("application/json") || "{}"); } catch(_){}
              const ids = (payload && Array.isArray(payload.ids)) ? payload.ids : [];
              if (!ids.length) return;

              // Set selection to dragged ids for consistency (bulk actions already rely on state selection)
              try {
                state.selectedIds = new Set(ids);
                state.selectedId = ids[0] || null;
                syncToolbar();
                renderDetailsPane();
                updateBulkBar();
                renderList();
              } catch(e){}

              if (kind === "trash"){
                const ok = confirm(`Send ${ids.length} file(s) to Trash?`);
                if (!ok) return;
                await bulkTrash();
                return;
              }

              const folder = String(el.dataset.folder || "");
              if (folder === String(state.currentFolder || "")) return;
              await bulkMoveTo(folder);
            });
          }

          function attachDropTargets(){
            // Folder chips (pinned + recent + breadcrumbs)
            document.querySelectorAll(".folder-drop-target").forEach(el => bindDropTarget(el, "folder"));
            // Trash filter button
            document.querySelectorAll(".trash-drop-target").forEach(el => bindDropTarget(el, "trash"));
          }

          // Delegate dragstart from list
          const listEl = els.fileList || document.getElementById("fileList");
          if (listEl){
            listEl.addEventListener("dragstart", (e) => {
              const row = e.target && e.target.closest ? e.target.closest(".file-item[data-id]") : null;
              if (!row) return;
              const id = row.dataset.id;
              if (!id) return;

              // If dragging an unselected row, select only it first (like Finder)
              const isSelected = !!(state.selectedIds && state.selectedIds.has(id));
              if (!isSelected) selectOnly(id);

              const ids = getSelectedIds();

              // Drag preview (multi-file badge)
              try {
                const count = ids.length;
                const ghost = document.createElement("div");
                ghost.className = "drag-ghost";
                const badge = document.createElement("span");
                badge.className = "badge";
                badge.textContent = `${count} item${count===1?"":"s"}`;
                const label = document.createElement("span");
                label.textContent = count===1 ? (row.querySelector(".file-name")?.textContent || "File") : "Move files";
                ghost.appendChild(badge);
                ghost.appendChild(label);
                document.body.appendChild(ghost);
                if (e.dataTransfer && e.dataTransfer.setDragImage){
                  e.dataTransfer.setDragImage(ghost, 16, 16);
                }
                setTimeout(()=>{ try{ ghost.remove(); }catch(e){} }, 0);
              } catch(e){}

              try {
                row.classList.add("dragging");
                e.dataTransfer.effectAllowed = "move";
                e.dataTransfer.setData("application/json", JSON.stringify({ ids }));
              } catch(_){}
            });
            listEl.addEventListener("dragend", () => {
              getRows().forEach(r => r.classList.remove("dragging"));
            });
          }

          // Keyboard nav + type-to-search
          document.addEventListener("keydown", (e) => {
            if (isTypingTarget()) return;

            // Type-to-search (Finder-style)
            if (!e.ctrlKey && !e.metaKey && !e.altKey && e.key && e.key.length === 1){
              const ch = e.key;
              if (/[\w\-\.\s]/.test(ch)){
                const now = Date.now();
                if (!state._typeAt || (now - state._typeAt) > 900) state._typeBuf = "";
                state._typeAt = now;
                state._typeBuf = (state._typeBuf || "") + ch;

                if (els.searchInput){
                  els.searchInput.value = state._typeBuf;
                  renderList();
                  // focus first result
                  setTimeout(() => setKbdFocus(0), 0);
                  els.searchInput.focus();
                  e.preventDefault();
                  return;
                }
              }
            }

            const rows = getRows();
            if (!rows.length) return;

            if (e.key === "ArrowDown"){
              e.preventDefault();
              setKbdFocus((state.kbdIndex || 0) + 1);
              const row = rows[state.kbdIndex] || null;
              if (row){
                setPrimarySelected(row.dataset.id);
                renderDetailsPane();
                syncToolbar();
              }
              return;
            }
            if (e.key === "ArrowUp"){
              e.preventDefault();
              setKbdFocus((state.kbdIndex || 0) - 1);
              const row = rows[state.kbdIndex] || null;
              if (row){
                setPrimarySelected(row.dataset.id);
                renderDetailsPane();
                syncToolbar();
              }
              return;
            }
            if (e.key === "Enter"){
              e.preventDefault();
              const row = rows[state.kbdIndex] || null;
              if (row){
                // Keep multi-selection intact; just ensure primary points at focused row
                setPrimarySelected(row.dataset.id);
                syncToolbar();
                openSelected();
              }
              return;
            }
            if (e.key === " "){
              e.preventDefault();
              const row = rows[state.kbdIndex] || null;
              if (row){
                toggleSelect(row.dataset.id);
                // restore focus (toggleSelect re-renders)
                setTimeout(() => syncKbdFocusFromPrimary(), 0);
              }
              return;
            }
            if (e.key === "Delete" || e.key === "Backspace"){
              const n = selectionCount();
              if (n <= 0) return;
              e.preventDefault();
              if (n === 1) {
                if (confirm("Send this file to Trash?")) trashSelected();
              } else {
                if (confirm(`Send ${n} files to Trash?`)) bulkTrash();
              }
              return;
            }
            // Quick focus search
            if ((e.ctrlKey || e.metaKey) && (e.key === "f" || e.key === "F")){
              if (els.searchInput){ e.preventDefault(); els.searchInput.focus(); els.searchInput.select(); }
              return;
            }
          });

          // Keep keyboard focus in sync when clicking rows
          if (listEl){
            listEl.addEventListener("click", (e) => {
              const row = e.target && e.target.closest ? e.target.closest(".file-item[data-id]") : null;
              if (!row) return;
              // after click handlers possibly re-render, sync later
              setTimeout(() => syncKbdFocusFromPrimary(), 0);
            }, true);
          }

          // Wrap key renderers to re-attach dnd targets
          try {
            const _renderPinnedFolders = renderPinnedFolders;
            renderPinnedFolders = function(){ _renderPinnedFolders.apply(this, arguments); attachDropTargets(); };
          } catch(e){}
          try {
            const _renderRecentFolders = renderRecentFolders;
            renderRecentFolders = function(){ _renderRecentFolders.apply(this, arguments); attachDropTargets(); };
          } catch(e){}
          try {
            const _renderBreadcrumbs = renderBreadcrumbs;
            renderBreadcrumbs = function(){ _renderBreadcrumbs.apply(this, arguments); attachDropTargets(); };
          } catch(e){}

          // Wrap list renderer so it always stays draggable + keyboard-focusable
          try {
            const _renderList = renderList;
            renderList = function(){
              _renderList.apply(this, arguments);
              ensureRowsDraggable();
              syncKbdFocusFromPrimary();
              attachDropTargets();
            };
          } catch(e){}

          // First-time bind
          setTimeout(() => { ensureRowsDraggable(); attachDropTargets(); syncKbdFocusFromPrimary(); }, 50);
        })();


        // init
        setAuthUI();
        if (typeof syncTabs === "function") syncTabs();
        syncToolbar();

        // Load Vault folders + list even when using cookie-based auth (no Bearer token).
        // If not authenticated, the API will 401 and we show a status message.
        loadFolders()
          .then(() => {
            renderBreadcrumbs();
            renderPinnedFolders();
            renderRecentFolders();
            ensureDetailsPane();
            return loadList();
          })
          .catch((e) => {
            setStatus("Failed to load Vault: " + (e && e.message ? e.message : String(e || "")), "err");
          });

// --- Cross-tab/Window refresh: when PDFStudio saves, refresh the current folder list ---
(function setupVaultSync(){
  let refreshTimer = null;

  function requestRefresh(){
    if (!state) return;
    // Only refresh if we are authenticated (token or cookie-session).
    if (!isAuthed()) return;
    try {
      if (refreshTimer) clearTimeout(refreshTimer);
      refreshTimer = setTimeout(async () => {
        try{
          // Invalidate folder tree/list caches so new folders/files appear immediately
          try { state.treeListCache = {}; } catch(e){}
          try { state.treeListInflight = {}; } catch(e){}

          // Refresh folders (left tree) and files (main list)
          if (typeof loadFolders === "function") {
            try { await loadFolders(); } catch(e){}
          }
          if (typeof loadList === "function") {
            try { await loadList(); } catch(e){}
          } else if (typeof renderList === "function") {
            try { renderList(); } catch(e){}
          }
        }catch(_e){}
      }, 140);
    } catch(e){}
  }

// BroadcastChannel (same-origin tabs)
  try {
    const bc = new BroadcastChannel("pdfrealm_vault");
    bc.onmessage = function(ev){ requestRefresh(); };
  } catch(e){}

  // localStorage ping (fallback)
  try {
    window.addEventListener("storage", function(e){
      if (e && e.key === "pdfrealm_vault_changed") requestRefresh();
    });
  } catch(e){}

  // focus/visibility fallback
  try {
    window.addEventListener("focus", requestRefresh);
    document.addEventListener("visibilitychange", function(){
      if (!document.hidden) requestRefresh();
    });
  } catch(e){}
})();

      })();
</script>
  
    

  <!-- Hover preview (appears on file hover) -->
  <div id="hoverPreview" class="hover-preview" hidden>
    <div class="hp-head">
      <div class="hp-ico" id="hpIco">PDF</div>
      <div class="hp-title" id="hpTitle">Preview</div>
    </div>
    <div class="hp-body" id="hpBody">
      <div class="hp-ph">Preview</div>
    </div>
  </div>


<script>
document.addEventListener('DOMContentLoaded', () => {
  const suiteTabBtn = document.getElementById('suiteTabBtn');
  const filesTabBtn = document.getElementById('filesTabBtn');
  const suitePane = document.getElementById('officeSuitePane');
  const filesPane = document.getElementById('filesPane');
  const suiteToFilesBtn = document.getElementById('suiteToFilesBtn');
  const filesToSuiteBtn = document.getElementById('filesToSuiteBtn');
  const suiteAddPdfBtn = document.getElementById('suiteAddPdfBtn');

  const uploadBtn = document.getElementById('uploadBtn');
  const modePill = document.getElementById('modePill');
  const toolTabs = document.getElementById('toolTabs');

  function setMain(which){
    const isSuite = which === 'suite';
    if (suitePane) suitePane.style.display = isSuite ? '' : 'none';
    if (filesPane) filesPane.style.display = isSuite ? 'none' : '';
    if (suiteTabBtn){
      suiteTabBtn.classList.toggle('active', isSuite);
      suiteTabBtn.setAttribute('aria-selected', isSuite ? 'true' : 'false');
    }
    if (filesTabBtn){
      filesTabBtn.classList.toggle('active', !isSuite);
      filesTabBtn.setAttribute('aria-selected', !isSuite ? 'true' : 'false');
    }
  }

  function getActiveTool(){
    const active = toolTabs ? toolTabs.querySelector('.tab-btn.active,[aria-selected="true"].tab-btn') : null;
    return active ? active.getAttribute('data-tool') : null;
  }

  function labelForTool(t){
    return ({docx:'Docx', pptx:'PPTX', xlsx:'ExcelX', pdf:'PDFStudio'})[t] || 'Docx';
  }

  function syncMode(){
    if (!modePill) return;
    const t = getActiveTool() || 'docx';
    modePill.textContent = 'Mode: ' + labelForTool(t);
  }

  suiteTabBtn?.addEventListener('click', () => setMain('suite'));
  filesTabBtn?.addEventListener('click', () => setMain('files'));

  // Enter selected tool (switch to Files view with tool filter active)
  suiteToFilesBtn?.addEventListener('click', async () => {
    try{
      const t = getActiveTool?.() || state.tool || 'pdf';
      state.tool = t;
      try { syncMode?.(); } catch(e){}
      // refresh list with new tool filter
      if (typeof loadList === 'function') await loadList();
      else if (typeof renderList === 'function') renderList();
    } catch(e){}
    setMain('files');
  });

  filesToSuiteBtn?.addEventListener('click', () => setMain('suite'));
toolTabs?.addEventListener('click', async () => {
    try{
      const t = getActiveTool?.() || state.tool || 'pdf';
      state.tool = t;
      setTimeout(syncMode, 0);
      // if user is in Files view, refresh list immediately
      const isSuiteVisible = suitePane && suitePane.style.display !== 'none';
      if (!isSuiteVisible){
        if (typeof loadList === 'function') await loadList();
        else if (typeof renderList === 'function') renderList();
      }
    } catch(e){ setTimeout(syncMode, 0); }
  }, true);
// Always land on Office Suite when DocForge opens
  setMain('suite');

  // Default program on the Office Suite screen = PDFStudio
  const pdfBtn = toolTabs?.querySelector('[data-tool="pdf"]');
  if (pdfBtn && !pdfBtn.classList.contains('active')) {
    pdfBtn.click();
  }
  syncMode();
});
</script>


<!-- Grid popout (large, stays put) -->
<div class="grid-popout" id="gridPopout" hidden>
  <div class="grid-popout-card">
    <div class="grid-popout-head">
      <div class="grid-popout-title">Grid view</div>
      <button class="btn btn-secondary" id="gridPopoutClose" type="button" title="Close grid view">Close</button>
    </div>
    <div class="grid-popout-body" id="gridPopoutBody"></div>
  </div>
</div>


<!-- Tree hover popout (files inside folders) -->
<div id="treeFilePopout" class="tree-file-popout" hidden>
  <div class="tree-file-popout-card" role="dialog" aria-label="File actions">
    <div class="tree-file-popout-head">
      <div id="treeFilePopoutTitle" class="tree-file-popout-title">File</div>
      <div id="treeFilePopoutSub" class="tree-file-popout-sub"></div>
    </div>
    
    <div class="tree-file-popout-preview">
      <iframe id="treeFilePopoutFrame" title="Preview" loading="lazy"></iframe>
      <img id="treeFilePopoutImg" alt="Preview" hidden />
      <div id="treeFilePopoutGeneric" class="generic" hidden>Preview unavailable</div>
    </div>
<div class="tree-file-popout-actions">
      <button class="btn" id="treePopOpenBtn" type="button">Open</button>
      <button class="btn" id="treePopRenameBtn" type="button">Rename</button>
      <button class="btn" id="treePopMoveBtn" type="button">Move</button>
      <button class="btn" id="treePopTrashBtn" type="button">Trash</button>
      <button class="btn danger" id="treePopDeleteBtn" type="button">Delete</button>
      <button class="btn" id="treePopQuickToolsBtn" type="button">Quick Tools</button>
      <button class="btn" id="treePopSaveVaultBtn" type="button" style="display:none;">Save to Vault</button>
    </div>
  

<!-- Tree hover popout (Quick Tools) -->
<div id="treeQuickToolsPopout" class="tree-quicktools-popout" hidden>
  <div class="tree-quicktools-card" role="dialog" aria-label="Quick tools">
    <div class="tree-quicktools-head">
      <div class="tree-quicktools-title">Quick Tools</div>
    </div>
    <div class="tree-quicktools-grid" aria-label="Quick tools grid">
      <button class="qt-tile" type="button">Merge</button>
      <button class="qt-tile" type="button">Split / Extract</button>

      <button class="qt-tile" type="button">Reorder</button>
      <button class="qt-tile" type="button">Rotate</button>
      <button class="qt-tile" type="button">Delete Pages</button>

      <button class="qt-tile" type="button">Compress</button>
      <button class="qt-tile" type="button">Watermark</button>
      <button class="qt-tile" type="button">Page Numbers</button>

      <button class="qt-tile" type="button">Timestamp</button>
      <button class="qt-tile" type="button">Bates</button>
      <button class="qt-tile" type="button">Redact</button>

      <button class="qt-tile" type="button">Flatten</button>
      <button class="qt-tile" type="button">Metadata</button>
      <button class="qt-tile" type="button">Remove Blanks</button>

      <button class="qt-tile" type="button">Encrypt</button>
      <button class="qt-tile" type="button">Quick Sign</button>
      <button class="qt-tile" type="button">OCR</button>

      <button class="qt-tile" type="button">Doc Builder</button>
      <button class="qt-tile" type="button">Word → PDF</button>
      <button class="qt-tile" type="button">Images → PDF</button>

      <button class="qt-tile" type="button">JPG → PDF</button>
      <button class="qt-tile" type="button">PNG → PDF</button>
      <button class="qt-tile" type="button">TIFF → PDF</button>

      <button class="qt-tile" type="button">SVG → PDF</button>
      <button class="qt-tile" type="button">PDF → Word</button>
      <button class="qt-tile" type="button">PDF → JPG</button>

      <button class="qt-tile" type="button">PDF → PNG</button>
      <button class="qt-tile" type="button">JPG → PNG</button>
      <button class="qt-tile" type="button">PNG → JPG</button>

      <button class="qt-tile" type="button">DOCX → PNG</button>
    </div>
  </div>
</div>

</div>
</div>


<script>
/* ==========================================================
   Guest Import + Local Folder Tree (SESSION-ONLY)
   - Fixes broken prior patch (syntax errors)
   - Does NOT touch encryption logic or Vault API paths
   - Guest files live in memory (lost on refresh/close)
   - Guest PDFs open in PDFStudio via blob=... (still supports encrypted PDFs)
========================================================== */
(function(){
  // Wait until the main app script has set up window.state / window.els
  function ready(fn){
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", fn);
    else fn();
  }

  ready(function(){
    const state = window.state || (window.state = {});
    const els = window.els || (window.els = {});

    // -----------------------
    // Session-only guest store
    // -----------------------
    const guest = window.__guestSessionStore || (window.__guestSessionStore = {
      folders: new Set(["_Trash"]),
      files: new Map(),         // id -> { meta, file }
      objectUrls: new Map(),    // id -> blob url
    });

    const guestState = window.guestState || (window.guestState = {
      currentFolder: "",
      collapsed: false
    });

    function uuid(){
      try { return crypto.randomUUID(); }
      catch(e){ return "g_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); }
    }

    function normalizeFolder(p){
      let s = String(p||"").trim();
      s = s.replace(/\\/g, "/");
      s = s.replace(/^\/+/, "").replace(/\/+$/, "");
      return s;
    }

    function ensureDefaults(){
      guest.folders.add("_Trash");
    }
// -----------------------
// Guest temporary storage (keeps imports across refresh in THIS TAB only)
// - Metadata: sessionStorage
// - File blobs: IndexedDB
// When a new tab session starts (no sessionStorage), we wipe leftover blobs.
// -----------------------
const GUEST_META_KEY = "pdfrealm_guest_meta_v1";
const GUEST_DB_NAME = "pdfrealm_guest_files_v1";
const GUEST_DB_STORE = "files";

function _readGuestMeta(){
  try{
    const raw = sessionStorage.getItem(GUEST_META_KEY);
    return raw ? JSON.parse(raw) : null;
  }catch(e){ return null; }
}

function _writeGuestMeta(){
  try{
    const meta = {
      folders: Array.from(guest.folders || []),
      files: Array.from(guest.files.values()).map(r => r && r.meta ? r.meta : null).filter(Boolean),
      currentFolder: guestState.currentFolder || ""
    };
    sessionStorage.setItem(GUEST_META_KEY, JSON.stringify(meta));
  }catch(e){}
}

function _guestDbOpen(){
  return new Promise((resolve, reject)=>{
    let req;
    try{ req = indexedDB.open(GUEST_DB_NAME, 1); }
    catch(e){ reject(e); return; }
    req.onupgradeneeded = ()=>{
      const db = req.result;
      if (!db.objectStoreNames.contains(GUEST_DB_STORE)){
        db.createObjectStore(GUEST_DB_STORE);
      }
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error || new Error("IndexedDB open failed"));
  });
}

async function _guestDbPut(id, file){
  const db = await _guestDbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(GUEST_DB_STORE, "readwrite");
    tx.objectStore(GUEST_DB_STORE).put(file, id);
    tx.oncomplete = ()=>{ try{ db.close(); }catch(e){}; resolve(true); };
    tx.onerror = ()=>{ try{ db.close(); }catch(e){}; reject(tx.error || new Error("IndexedDB put failed")); };
  });
}

async function _guestDbGet(id){
  const db = await _guestDbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(GUEST_DB_STORE, "readonly");
    const req = tx.objectStore(GUEST_DB_STORE).get(id);
    req.onsuccess = ()=>{ try{ db.close(); }catch(e){}; resolve(req.result || null); };
    req.onerror = ()=>{ try{ db.close(); }catch(e){}; reject(req.error || new Error("IndexedDB get failed")); };
  });
}

async function _guestDbClearAll(){
  const db = await _guestDbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(GUEST_DB_STORE, "readwrite");
    tx.objectStore(GUEST_DB_STORE).clear();
    tx.oncomplete = ()=>{ try{ db.close(); }catch(e){}; resolve(true); };
    tx.onerror = ()=>{ try{ db.close(); }catch(e){}; reject(tx.error || new Error("IndexedDB clear failed")); };
  });
}

async function _restoreGuestFromSession(){
  const meta = _readGuestMeta();
  if (!meta){
    try{ await _guestDbClearAll(); }catch(e){}
    return;
  }

  try{ guest.folders = new Set(Array.isArray(meta.folders) ? meta.folders : ["_Trash"]); }catch(e){}
  try{ guest.folders.add("_Trash"); }catch(e){}

  try{
    guest.files = new Map();
    const files = Array.isArray(meta.files) ? meta.files : [];
    for (const fm of files){
      if (!fm || !fm.id) continue;
      try{
        const blob = await _guestDbGet(fm.id);
        if (blob){
          guest.files.set(fm.id, { meta: fm, file: blob });
        }
      }catch(e){}
    }
  }catch(e){}

  try{
    guestState.currentFolder = normalizeFolder(meta.currentFolder || "");
    state.currentFolder = guestState.currentFolder;
  }catch(e){}
}

// restore on load (best-effort)
try{ _restoreGuestFromSession().then(()=>{ try{ renderGuestTree(); }catch(e){}; }); }catch(e){}


    async function ensureObjectUrl(id){
      const sid = String(id||"");
      if (!sid) return "";
      if (guest.objectUrls.has(sid)) return guest.objectUrls.get(sid);
      const rec = guest.files.get(sid);
      if (!rec || !rec.file) return "";
      const url = URL.createObjectURL(rec.file);
      guest.objectUrls.set(sid, url);
      return url;
    }

    // Expose helpers used elsewhere in office.html (and in PDF preview fallback logic)
    window.guestObjectUrlFor = ensureObjectUrl;

    // -----------------------
    // Guest import (PDF only)
    // -----------------------
    window.guestImportFiles = async function(files, folderPath){
      ensureDefaults();
      const folder = normalizeFolder(folderPath);
      const list = Array.from(files || []);
      for (const f of list){
        if (!f) continue;
        const name = String(f.name || "document.pdf");
        const lower = name.toLowerCase();
        const type = String(f.type||"").toLowerCase();
        const isPdf = lower.endsWith(".pdf") || type.includes("pdf");
        if (!isPdf) continue;

        const id = "g_" + uuid();
        const mimeType = type || "application/pdf";
        const meta = {
          id,
          name,
          filename: name,
          mimeType,
          size: Number(f.size||0),
          updatedAt: new Date().toISOString(),
          folder: folder,
          isGuest: true
        };
        guest.files.set(id, { meta, file: f });
        // keep across refresh in this tab
        try{ await _guestDbPut(id, f); }catch(e){}
        // eager url for snappy preview/open
        try { await ensureObjectUrl(id); } catch(e){}
      }

      try{ _writeGuestMeta(); }catch(e){}

      // Refresh listing immediately if logged out
      try{
        if (typeof window.loadList === "function"){
          // keep state.currentFolder aligned with guest folder
          state.currentFolder = folder;
          guestState.currentFolder = folder;
          state.guestMode = true;
          await window.loadList();
        }
      }catch(e){}
    };

    // -----------------------
    // Guest folders
    // -----------------------
    async function guestCreateFolder(folderPath){
      ensureDefaults();
      const p = normalizeFolder(folderPath);
      if (!p) return;
      guest.folders.add(p);
    }
    window.guestCreateFolder = guestCreateFolder;

    // Build a tree structure from "a/b/c" paths
    function buildTree(){
      ensureDefaults();
      const root = { name:"/", path:"", kids: new Map() };

      function addPath(path){
        const parts = normalizeFolder(path).split("/").filter(Boolean);
        let node = root;
        let acc = "";
        for (const part of parts){
          acc = acc ? (acc + "/" + part) : part;
          if (!node.kids.has(part)) node.kids.set(part, { name: part, path: acc, kids: new Map() });
          node = node.kids.get(part);
        }
      }

      // Include all folders and also folders implied by files
      for (const f of guest.folders) addPath(f);
      for (const rec of guest.files.values()){
        const folder = normalizeFolder(rec?.meta?.folder || "");
        if (folder) addPath(folder);
      }
      return root;
    }

    function getGuestTreeOpenSet(){
      try{
        const raw = sessionStorage.getItem("pdfrealm_guest_tree_open_v1");
        const arr = raw ? JSON.parse(raw) : [];
        return new Set(Array.isArray(arr) ? arr : []);
      }catch(e){ return new Set(); }
    }
    function saveGuestTreeOpenSet(set){
      try{ sessionStorage.setItem("pdfrealm_guest_tree_open_v1", JSON.stringify(Array.from(set))); }catch(e){}
    }
    function el(tag, attrs={}, children=[]){
      const n = document.createElement(tag);
      for (const [k,v] of Object.entries(attrs||{})){
        if (k === "class") n.className = v;
        else if (k === "text") n.textContent = v;
        else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
        else n.setAttribute(k, String(v));
      }
      for (const c of children) n.appendChild(c);
      return n;
    }

    // -----------------------
// Wire Import PDF button (always local)
// -----------------------
try{
  const _guestImportBtn = document.getElementById("guestImportPdfBtn");
  const _guestImportInput = document.getElementById("guestImportPdfInput");
  if (_guestImportBtn && _guestImportInput){
    _guestImportBtn.addEventListener("click", (e)=>{
      e.preventDefault(); e.stopPropagation();
      state.guestMode = true;
      try{ _guestImportInput.value = ""; }catch(_){}
      _guestImportInput.click();
    });
    _guestImportInput.addEventListener("change", async ()=>{
      const files = Array.from(_guestImportInput.files || []);
      if (!files.length) return;
      state.guestMode = true;
      try{
        await window.guestImportFiles(files, guestState.currentFolder || "");
        try{
          const pdfBtn = document.querySelector('.tab-btn[data-tool="pdf"]');
          if (pdfBtn && String(state.tool||"") !== "pdf") pdfBtn.click();
        }catch(e){}
        try{ if (typeof setStatus === "function") setStatus("Imported locally.", "ok"); }catch(e){}
        try{ renderGuestTree(); }catch(e){}
      }catch(err){
        try{ if (typeof setStatus === "function") setStatus("Import failed: " + ((err && err.message) ? err.message : String(err)), ""); }catch(e){}
      }finally{
        try{ _guestImportInput.value = ""; }catch(_){}
      }
    });
  }
}catch(e){}

function renderGuestTree(){
  const host = document.getElementById("guestFolderTree");
  const wrap = document.getElementById("guestFolderTreeWrap");
  if (!host || !wrap) return;

  host.innerHTML = "";
  const tree = buildTree();

  const openSet = getGuestTreeOpenSet();
  openSet.add(""); // root always open

  function mkNode(node, depth){
    const row = document.createElement("div");
    row.className = "folder-node";
    row.dataset.folder = node.path || "";
    row.style.paddingLeft = (8 + depth*6) + "px";
    if (normalizeFolder(node.path||"") === normalizeFolder(guestState.currentFolder||"")) row.classList.add("active");

    const hasKids = node.kids && node.kids.size>0;
    const isOpen = openSet.has(node.path||"");

    const twisty = document.createElement("span");
    twisty.className = "twisty";
    twisty.textContent = hasKids ? (isOpen ? "▾" : "▸") : "";
    row.appendChild(twisty);

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "folder-name";
    btn.textContent = node.name === "/" ? "/" : node.name;
    btn.title = node.path ? node.path : "/";
    btn.addEventListener("click", async (e)=>{
      e.preventDefault();
      e.stopPropagation();
      const p = normalizeFolder(node.path);
      guestState.currentFolder = p;
      state.currentFolder = p;
      state.guestMode = true;
      try { if (els.folderSelect) els.folderSelect.value = p; } catch(e){}
      try { if (typeof window.loadList === "function") await window.loadList(); } catch(e){}
      renderGuestTree();
    });
    row.appendChild(btn);

    if (hasKids){
      twisty.style.cursor = "pointer";
      twisty.addEventListener("click", (e)=>{
        e.preventDefault(); e.stopPropagation();
        const k = node.path || "";
        if (openSet.has(k)) openSet.delete(k); else openSet.add(k);
        saveGuestTreeOpenSet(openSet);
        renderGuestTree();
      });
    }

    host.appendChild(row);

    if (hasKids && isOpen){
      const kids = Array.from(node.kids.values()).sort((a,b)=>a.name.localeCompare(b.name));
      for (const k of kids) mkNode(k, depth+1);
    }
  }

  mkNode(tree, 0);
}

    // -----------------------
    // Logged-out loadList override
    // -----------------------
    const originalLoadList = window.loadList;
    window.loadList = async function(){
      if (state.token && !state.guestMode) return originalLoadList ? originalLoadList() : undefined;

      ensureDefaults();
      const folder = normalizeFolder(state.currentFolder || guestState.currentFolder || "");
      guestState.currentFolder = folder;
      state.currentFolder = folder;

      // produce items array for current folder
      const items = [];
      for (const rec of guest.files.values()){
        const meta = rec.meta || {};
        if (normalizeFolder(meta.folder || "") === folder){
          items.push(meta);
        }
      }
      state.items = items;

      // If your UI expects folders list, populate it (excluding _Trash from dropdown)
      state.folders = Array.from(guest.folders).filter(p => normalizeFolder(p) !== "_Trash");

      // Try to keep dropdown coherent (optional)
      try{
        if (els.folderSelect){
          // Only repopulate if it looks empty or if we're logged out
          els.folderSelect.innerHTML = "";
          const rootOpt = document.createElement("option");
          rootOpt.value = "";
          rootOpt.textContent = "/ (root)";
          els.folderSelect.appendChild(rootOpt);
          for (const p of state.folders.sort((a,b)=>a.localeCompare(b))){
            const opt = document.createElement("option");
            opt.value = p;
            opt.textContent = p;
            els.folderSelect.appendChild(opt);
          }
          els.folderSelect.value = folder;
        }
      }catch(e){}

      // Call existing render pipeline
      try{ if (typeof window.renderBreadcrumbs === "function") window.renderBreadcrumbs(); }catch(e){}
      try{ if (typeof window.renderPinnedFolders === "function") window.renderPinnedFolders(); }catch(e){}
      try{ if (typeof window.renderRecentFolders === "function") window.renderRecentFolders(); }catch(e){}
      try{ if (typeof window.renderList === "function") window.renderList(); }catch(e){}
      try{ if (typeof window.renderDetailsPane === "function") window.renderDetailsPane(); }catch(e){}
      try{ if (typeof window.ensureDetailsPane === "function") window.ensureDetailsPane(); }catch(e){}
      try{ renderGuestTree(); }catch(e){}
    };

    // -----------------------
    // PDF open override for guest items
    // -----------------------
    const originalOpenFileNewTab = window.openFileNewTab;
    window.openFileNewTab = async function(fileId){
      const id = String(fileId||"").trim();
      if (!id) return;
      if (String(state.tool||"") === "pdf" && id.startsWith("g_")){
        const it = (state.items || []).find(x => String(x.id||x.key||"") === id) || null;
        const name = it && (it.name || it.filename) ? (it.name || it.filename) : "document.pdf";
        const blobUrl = await ensureObjectUrl(id);
        if (!blobUrl){
          try{ if (typeof window.setStatus === "function") window.setStatus("PDF missing from session memory.", "bad"); }catch(e){}
          return;
        }
        const url = "/pdfstudio.html?embed=0&blob=" + encodeURIComponent(blobUrl) + "&name=" + encodeURIComponent(name);
        window.open(url, "_blank", "noopener");
        return;
      }
      return originalOpenFileNewTab ? originalOpenFileNewTab(fileId) : undefined;
    };


    // -----------------------
    // Logged-out "New folder" should create local folder
    // -----------------------
    if (els.newFolderBtn){
      els.newFolderBtn.addEventListener("click", async (e)=>{
        if (state.token) return; // allow original vault behavior when logged in
        e.preventDefault();
        e.stopPropagation();

        const name = prompt("New folder name:");
        if (!name) return;
        const base = normalizeFolder(guestState.currentFolder || "");
        const full = base ? (base + "/" + name) : name;
        await guestCreateFolder(full);
        guestState.currentFolder = full;
        state.currentFolder = full;
        await window.loadList();
      }, true);
    }

    // Collapse local tree
    const collapseBtn = document.getElementById("guestFolderTreeCollapseBtn");
    if (collapseBtn){
      collapseBtn.addEventListener("click", ()=>{
        guestState.collapsed = !guestState.collapsed;
        const host = document.getElementById("guestFolderTree");
        if (host) host.style.display = guestState.collapsed ? "none" : "block";
      });
    }

    // Initial render if logged out
    try{
      if (typeof window.loadList === "function") window.loadList();
      renderGuestTree();
    }catch(e){}
  });
})();
</script>

</body>
</html>