<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDFStudio</title>
  <link rel="stylesheet" href="/styles.css" />
  <style>
    :root{
      --ps-bg: rgba(0,0,0,0.35);
      --ps-card: rgba(255,255,255,0.03);
      --ps-line: rgba(255,255,255,0.12);
      --ps-line2: rgba(255,255,255,0.08);
      --ps-accent: rgba(255, 165, 0, 0.95);
    }
    html,body{height:100%; margin:0;}
    body{background: #000;}
    .ps-shell{height:100%; display:flex; flex-direction:column;}
    .ps-top{
      display:flex; align-items:center; gap:10px;
      padding:10px 10px;
      border-bottom:1px solid var(--ps-line2);
      background: rgba(0,0,0,0.86);
      position: sticky; top:0; z-index:50;
    }
    
    .ps-top-left{display:flex; align-items:center; gap:10px;}
    .ps-top-title{font-weight:700; letter-spacing:0.2px; font-size:16px;}
    .ps-top-spacer{flex:1;}
    .ps-top-actions{display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;}

    .ps-brand{display:flex; align-items:center; gap:10px; min-width: 220px;}
    .ps-dot{
      width:28px; height:28px; border-radius:8px;
      background: rgba(255,255,255,0.06);
      border:1px solid var(--ps-line);
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
    }
    .ps-title{display:flex; flex-direction:column; line-height:1.1;}
    .ps-title strong{font-size:0.95rem;}
    .ps-title span{font-size:0.78rem; color: var(--muted);}
    .ps-toolbar{
      display:flex; align-items:center; gap:6px; flex-wrap:wrap;
      padding:0 6px;
      border-left:1px solid var(--ps-line2);
      margin-left: 6px;
    }
    .ps-btn{
      border:1px solid var(--ps-line);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border-radius:10px;
      padding:8px 10px;
      font-weight:700;
      font-size: 0.88rem;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      user-select:none;
    }
    .ps-btn:hover{background: rgba(255,255,255,0.06);}
    .ps-btn.active{
      border-color: rgba(96,165,250,0.85);
      box-shadow: 0 0 0 1px rgba(96,165,250,0.35);
      background: rgba(255,255,255,0.06);
    }
    .ps-btn.primary{
      border-color: rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.06);
    }
    .ps-btn.done{
      border-color: rgba(0,0,0,0.0);
      background: var(--ps-accent);
      color: #1b1200;
      font-weight: 900;
      padding: 8px 14px;
      border-radius: 12px;
    }
    .ps-btn.done:hover{filter: brightness(1.03);}
    .ps-sep{width:1px; height:30px; background: var(--ps-line2); margin:0 4px;}
    .ps-spacer{flex:1;}
    .ps-right{display:flex; align-items:center; gap:8px;}
    .ps-chip{
      border:1px solid var(--ps-line);
      background: rgba(0,0,0,0.35);
      color: var(--muted);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.82rem;
      font-weight: 700;
    }
    .ps-main{flex:1; display:flex; min-height:0;}
    .ps-side{
      width: 240px;
      border-right:1px solid var(--ps-line2);
      background: rgba(15,22,36,0.70);
      display:flex; flex-direction:column;
      min-height:0;
    }
    .ps-side-head{
      padding:10px;
      border-bottom:1px solid var(--ps-line2);
      display:flex; align-items:center; justify-content:space-between; gap:8px;
    }
    .ps-side-body{padding:10px; overflow:auto;}
    .thumb{
      border:1px solid var(--ps-line2);
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
      padding: 8px;
      margin-bottom: 10px;
      cursor:pointer;
      position: relative;
      user-select: none;
    }
    .thumb.dragover{ outline: 2px dashed rgba(96,165,250,0.55); outline-offset: 2px; }
    .thumb.dragging{ opacity: 0.65; }
    .thumb-meta{
      position:absolute;
      top:6px;
      left:6px;
      right:6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      pointer-events:none;
    }
    .thumb-num{
      pointer-events:none;
      font-size:12px;
      padding:3px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
    }
    .thumb-del{
      pointer-events:auto;
      width: 26px;
      height: 26px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .thumb-del:hover{ background: rgba(255,255,255,0.10); }
    .thumb.active{border-color: rgba(96,165,250,0.75); box-shadow: 0 0 0 1px rgba(96,165,250,0.25);}
    .thumb canvas{width:100%; height:auto; display:block; border-radius: 8px;}
    .ps-canvaswrap{
      flex:1;
      overflow:auto;
      background: rgba(0,0,0,0.25);
      position:relative;
    }
    .page{
      position:relative;
      margin: 18px auto;
      width: fit-content;
      border:1px solid var(--ps-line2);
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
      box-shadow: 0 10px 35px rgba(0,0,0,0.25);
    }
    .page canvas{display:block; border-radius: 14px;}
    .overlay{
      position:absolute; inset:0;
      border-radius:14px;
      overflow:hidden;
      pointer-events: none; /* enabled when edit mode is on */
    }
    .overlay.editing{pointer-events: auto;}
    .ann{
      position:absolute;
      border: 1px dashed rgba(255,255,255,0.25);
      border-radius: 8px;
      padding: 6px 8px;
      color: #0b1220;
      background: rgba(255,255,255,0.0);
      cursor: move;
      user-select:none;
      box-sizing:border-box;
    }
    .ann.text{color: rgba(255,255,255,0.95); background: rgba(0,0,0,0.0); border-color: rgba(255,255,255,0.18);}
    .ann.textbox{color: rgba(255,255,255,0.95); background: rgba(0,0,0,0.12); border:1px solid rgba(255,255,255,0.25);}
    .ann.highlight{background: rgba(255, 242, 0, 0.28); border: 1px solid rgba(255, 242, 0, 0.35);}
    .ann.blackout{background: rgba(0,0,0,0.96); border: 1px solid rgba(255,255,255,0.10);}
    .ann.stamp{color: rgba(255,255,255,0.95); background: rgba(0,0,0,0.0); border-color: rgba(255,255,255,0.18); font-weight:900;}
    .ann.image{border:1px solid rgba(255,255,255,0.20); padding:0; overflow:hidden; background: rgba(255,255,255,0.03);}
    .ann.image img{width:100%; height:100%; object-fit:contain; display:block;}
    .ann.note{background: rgba(255, 196, 0, 0.18); border:1px solid rgba(255, 196, 0, 0.35); color: rgba(255,255,255,0.95);}
    .ann.selected{outline: 2px solid rgba(96,165,250,0.9); outline-offset: 1px; border-style: solid;}
    .handle{
      position:absolute; width:10px; height:10px;
      border-radius:3px;
      background: rgba(96,165,250,0.95);
      border:1px solid rgba(0,0,0,0.25);
      display:none;
    }
    .ann.selected .handle{display:block;}
    .handle.br{right:-5px; bottom:-5px; cursor: nwse-resize;}
    .handle.tr{right:-5px; top:-5px; cursor: nesw-resize;}
    .handle.bl{left:-5px; bottom:-5px; cursor: nesw-resize;}
    .handle.tl{left:-5px; top:-5px; cursor: nwse-resize;}
    .ps-modal{
      position: fixed; inset:0; z-index: 100;
      background: rgba(0,0,0,0.55);
      display:none; align-items:center; justify-content:center;
      padding: 20px;
    }
    .ps-modal.show{display:flex;}
    .ps-card{
      width: min(760px, 96vw);
      background: rgba(15,22,36,0.98);
      border: 1px solid var(--ps-line);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.45);
      padding: 14px;
    }
    .ps-card h3{margin:0 0 8px 0;}
    .ps-grid{display:grid; grid-template-columns: 1fr 1fr; gap: 10px;}
    .ps-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .ps-input{
      width:100%;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 10px;
      outline:none;
    }
    .ps-small{font-size:0.86rem; color: var(--muted);}
    .ps-status{
      position: fixed; left: 12px; bottom: 12px; z-index: 120;
      background: rgba(15,22,36,0.92);
      border: 1px solid var(--ps-line);
      border-radius: 12px;
      padding: 10px 12px;
      color: var(--text);
      max-width: min(560px, 90vw);
      display:none;
    }
    .ps-status.show{display:block;}
    .ps-status.ok{border-color: rgba(34,197,94,0.35);}
    .ps-status.err{border-color: rgba(239,68,68,0.45);}
    .ps-status.warn{border-color: rgba(245,158,11,0.45);}

    /* Vector lines and ink live in a layer */
    .vec{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .vec.editing{pointer-events:auto;}
    .vec svg{position:absolute; inset:0;}
    .searchbar{
      display:none;
      position: fixed;
      top: 62px;
      right: 12px;
      z-index: 110;
      background: rgba(15,22,36,0.96);
      border:1px solid var(--ps-line);
      border-radius: 14px;
      padding: 10px;
      width: min(420px, 92vw);
      box-shadow: 0 16px 50px rgba(0,0,0,0.4);
    }
    .searchbar.show{display:block;}
    .result{
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 8px 10px;
      margin-top: 8px;
      cursor:pointer;
    }
    .result:hover{background: rgba(255,255,255,0.05);}
    @media (max-width: 980px){
      .ps-side{display:none;}
      .ps-brand{min-width:auto;}
    }
  
    .propsbar{
      display:flex; gap:10px; flex-wrap:wrap;
      padding:10px 12px; border-top:1px solid rgba(255,255,255,0.10);
      border-bottom:1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.35);
      align-items:center;
    }
    .propsgrp{display:flex; gap:8px; align-items:center; padding:6px 8px; border:1px solid rgba(255,255,255,0.10); border-radius:10px; background: rgba(255,255,255,0.03);}
    .prop-label{font-size:12px; opacity:0.85;}
    .propsbar select,.propsbar input[type="number"]{
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:10px;
      padding:6px 8px;
      height:32px;
      font-size:12px;
      outline:none;
    }
    .propsbar input[type="color"]{
      width:38px; height:32px; padding:0;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background: transparent;
    }
    .propsbar .chk{display:flex; align-items:center; gap:6px; font-size:12px; opacity:0.9;}


    .ps-props{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      padding:8px 10px;
      border-top:1px solid rgba(255,255,255,0.08);
      border-bottom:1px solid rgba(255,255,255,0.08);
      background:rgba(18,18,22,0.92);
      position:sticky;
      top:44px;
      z-index:50;
    }
    .ps-propgrp{display:flex;align-items:center;gap:6px;padding:2px 6px;border:1px solid rgba(255,255,255,0.10);border-radius:10px;}
    .ps-propgrp label{font-size:12px;opacity:0.8;margin-right:2px;white-space:nowrap;}
    .ps-propgrp select,.ps-propgrp input[type="number"]{background:#0e0e12;border:1px solid rgba(255,255,255,0.12);color:#fff;border-radius:8px;padding:4px 6px;font-size:12px;}
    .ps-propgrp input[type="color"]{width:30px;height:22px;border:none;background:transparent;padding:0;}
    .ps-propgrp input[type="range"]{width:110px;}
    .ps-propgrp .ps-chk{display:flex;align-items:center;gap:4px;}
    .ps-propgrp .ps-mini{width:70px;}


    /* Right-click context properties menu */
    .ps-hidden{ display:none !important; }
    .ps-ctxmenu{
      position:fixed;
      z-index:9999;
      width:320px;
      background:rgba(18,18,22,0.98);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,0.45);
      padding:10px;
      color:#fff;
    }
    .ps-ctxhead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:2px 2px 10px 2px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      margin-bottom:10px;
    }
    .ps-ctxtitle{ font-size:13px; opacity:0.9; }
    .ps-ctxbtn{
      background:transparent;
      color:#fff;
      border:1px solid rgba(255,255,255,0.18);
      border-radius:10px;
      padding:4px 8px;
      cursor:pointer;
    }
    .ps-ctxgrid{
      display:grid;
      grid-template-columns: 78px 1fr;
      gap:8px 10px;
      align-items:center;
    }
    .ps-ctxgrid label{
      font-size:12px;
      opacity:0.8;
      white-space:nowrap;
    }
    .ps-ctxgrid select,
    .ps-ctxgrid input[type="number"]{
      background:#0e0e12;
      border:1px solid rgba(255,255,255,0.12);
      color:#fff;
      border-radius:10px;
      padding:6px 8px;
      font-size:12px;
      width:100%;
    }
    .ps-ctxgrid input[type="color"]{
      width:42px;
      height:26px;
      border:none;
      background:transparent;
      padding:0;
    }
    .ps-ctxgrid input[type="range"]{ width:100%; }
    .ps-ctxactions{
      display:flex;
      justify-content:flex-end;
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(255,255,255,0.10);
    }
    .ps-ctxdanger{
      background:#2a0f14;
      border:1px solid rgba(255,80,110,0.35);
      color:#ffd7df;
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
    }

  
    
    /* Fields dropdown (matches toolbar design) */
    .tool-dd{ position:relative; display:inline-flex; }
    .tool-dd-menu{
      position:absolute;
      top:44px;
      left:0;
      min-width:220px;
      background: rgba(15,22,36,0.98);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:14px;
      box-shadow:0 16px 50px rgba(0,0,0,0.45);
      padding:8px;
      z-index:2000;
      display:none;
      backdrop-filter: blur(10px);
    }
    .tool-dd.open .tool-dd-menu{ display:block; }
    .tbtn-menu{
      width:100%;
      justify-content:flex-start;
      border-radius:12px;
      padding:10px 10px;
      font-size:0.88rem;
    }
    .tbtn-menu + .tbtn-menu{ margin-top:6px; }

    .ann.field{
      border-style: dashed;
      border-color: rgba(96,165,250,0.55);
      background: rgba(96,165,250,0.08);
    }
    .ann.field .field-label{
      position:absolute;
      top:-18px;
      left:0;
      font-size:11px;
      opacity:0.9;
      background: rgba(15,22,36,0.92);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:10px;
      padding:2px 6px;
      pointer-events:none;
      white-space:nowrap;
      max-width: 260px;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .ann.field .field-value{
      font-size:12px;
      opacity:0.92;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }



/* ===== DocForge shell additions (no-break) ===== */
.ps-main{ display:flex; gap:0; }
.ps-center{ flex:1; min-width:0; display:flex; flex-direction:column; min-height:0; }
.ps-center .ps-canvaswrap{ flex:1; min-height:0; }

.ps-right{
  width: 360px;
  min-width: 360px;
  border-left: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.02);
  display:flex;
  flex-direction:column;
  min-height:0;
}
.ps-right.collapsed{ width:0; min-width:0; border-left:none; padding:0; overflow:hidden; }
.ps-right-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}
.ps-right-body{ padding:12px; overflow:auto; min-height:0; display:flex; flex-direction:column; gap:12px; }

.sa-section{
  border:1px solid rgba(255,255,255,0.10);
  border-radius: 12px;
  background: rgba(0,0,0,0.12);
  padding: 10px;
}
.sa-title{ font-weight:800; margin-bottom:6px; }
.sa-muted{ font-size:12px; opacity:0.80; }
.sa-divider{ height:1px; background: rgba(255,255,255,0.10); margin:10px 0; }

.rp-form{ display:flex; flex-direction:column; gap:8px; }
.rp-label{ font-size:12px; opacity:0.85; }
.rp-check{ display:flex; align-items:center; gap:8px; font-size:13px; }
.rp-grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
.rp-actions{ display:flex; gap:8px; margin-top:6px; }

.ps-bottom{
  position: sticky;
  bottom: 0;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding: 8px 12px;
  border-top: 1px solid rgba(255,255,255,0.10);
  background: rgba(9,9,11,0.92);
  backdrop-filter: blur(6px);
}
.ps-bottom-left,.ps-bottom-center,.ps-bottom-right{ display:flex; align-items:center; gap:8px; }

    /* Alignment guides (DocForge) */
    .vec svg .df-guide {
      stroke: rgba(0,180,255,0.85);
      stroke-width: 1;
      stroke-dasharray: 4 4;
      pointer-events: none;
    }


    /* DocForge v5: marquee selection */
    .df-marquee{
      position:absolute;
      border:1px dashed rgba(0,180,255,0.95);
      background: rgba(0,180,255,0.12);
      pointer-events:none;
      z-index: 50;
      border-radius: 6px;
      box-sizing: border-box;
    }

    /* Group selection box (DocForge v6) */
    .df-groupbox{
      position:absolute;
      border: 2px dashed rgba(96,165,250,0.92);
      border-radius: 8px;
      pointer-events:none;
      z-index: 49;
      box-sizing: border-box;
    }
    .df-groupbox .handle{
      display:block !important;
      pointer-events:auto;
    }
    .df-groupbox .handle.br{cursor:nwse-resize;}
    .df-groupbox .handle.tr{cursor:nesw-resize;}
    .df-groupbox .handle.bl{cursor:nesw-resize;}
    .df-groupbox .handle.tl{cursor:nwse-resize;}


/* DocForge v9: tab order badges */
.df-tab-badge{
  position:absolute;
  left: -10px;
  top: -10px;
  width: 22px;
  height: 22px;
  border-radius: 999px;
  background: rgba(0,180,255,0.92);
  border: 1px solid rgba(255,255,255,0.25);
  color: rgba(0,0,0,0.92);
  font-weight: 900;
  font-size: 12px;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  z-index: 60;
  box-shadow: 0 8px 20px rgba(0,0,0,0.35);
}

/* DocForge v9: batch progress card */
.df-batch{
  margin-top: 10px;
  padding: 10px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.04);
  border-radius: 12px;
}
.df-batch .df-batch-top{display:flex; align-items:center; gap:8px; justify-content:space-between;}
.df-batch .df-batch-title{font-weight:800;}
.df-batch .df-batch-sub{font-size: 12px; opacity: 0.85; margin-top:4px;}
.df-batch .df-bar{
  height: 8px;
  border-radius: 999px;
  background: rgba(255,255,255,0.10);
  overflow:hidden;
  margin-top: 10px;
}
.df-batch .df-bar > div{
  height: 100%;
  width: 0%;
  background: rgba(0,180,255,0.92);
  border-radius: 999px;
  transition: width 120ms linear;
}


/* DocForge patch v10: hide legacy top column; controls moved to right panel */
.ps-top{display:none !important;}


/* ==== DocForge v11: Compact Ribbon + Legacy Tools Drawer (no-break) ==== */
.ps-top{display:none !important;} /* already hidden in v10; keep enforced */
.ps-ribbon{
  position: sticky;
  top: 0;
  z-index: 90;
  display:flex;
  align-items:center;
  gap:6px;
  padding: 8px 10px;
  background: rgba(10,14,24,0.92);
  border-bottom: 1px solid var(--ps-line2);
  backdrop-filter: blur(10px);
}
.ps-ribbon .rb-btn{
  border:1px solid var(--ps-line);
  background: rgba(255,255,255,0.04);
  color: var(--text);
  border-radius: 10px;
  height: 34px;
  padding: 0 10px;
  font-weight: 800;
  cursor: pointer;
  display:inline-flex;
  align-items:center;
  gap:8px;
}
.ps-ribbon .rb-btn:hover{background: rgba(255,255,255,0.07);}
.ps-ribbon .rb-btn.active{
  border-color: rgba(255,255,255,0.22);
  background: rgba(255,255,255,0.08);
}
.ps-ribbon .rb-icon{font-size: 0.95rem; opacity: 0.95;}
.ps-ribbon .rb-label{font-size: 0.85rem; opacity: 0.95;}
.ps-ribbon .rb-sep{width:1px; height:26px; background: rgba(255,255,255,0.10); margin: 0 6px;}
.ps-ribbon .rb-grow{flex:1;}
.ps-ribbon .rb-pill{
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.03);
  padding: 6px 10px;
  border-radius: 999px;
  font-weight: 800;
  font-size: 0.85rem;
  color: var(--text);
  opacity: 0.92;
}

/* Hide legacy toolbar/props in normal view; accessible via drawer */
#toolbar, #propsBar{display:none !important;}

/* Drawer */
#legacyDrawerOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  z-index: 220;
  display:none;
}
#legacyDrawerOverlay.open{display:block;}
#legacyDrawer{
  position: absolute;
  right: 12px;
  top: 64px;
  width: min(760px, calc(100vw - 24px));
  max-height: calc(100vh - 88px);
  background: rgba(10,14,24,0.98);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 16px;
  box-shadow: 0 14px 50px rgba(0,0,0,0.55);
  overflow: hidden;
}
#legacyDrawer .ld-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 12px 12px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}
#legacyDrawer .ld-title{
  font-weight: 900;
  letter-spacing: 0.2px;
}
#legacyDrawer .ld-sub{
  font-size: 0.82rem;
  opacity: 0.8;
  margin-top: 2px;
}
#legacyDrawer .ld-close{
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.04);
  color: var(--text);
  border-radius: 12px;
  padding: 8px 10px;
  cursor:pointer;
  font-weight: 900;
}
#legacyDock{
  padding: 12px;
  overflow: auto;
  max-height: calc(100vh - 88px - 56px);
}

#legacyDock #toolbar, #legacyDock #propsBar{
  display:flex !important;
}
#legacyDock #propsBar{
  margin-top: 10px;
}


  #saveStateLabel{display:none !important;}
</style>

<script type="module">


  
import * as pdfjsLib from "/vendor/pdf.mjs";
  pdfjsLib.GlobalWorkerOptions.workerSrc = "/vendor/pdf.worker.mjs";
  window.pdfjsLib = pdfjsLib;

</script>
<script src="/vendor/pdf-lib.min.js"></script>


<script>
  // Global helper used by various build variants
  window.setText = window.setText || function(id, v){
    const el = document.getElementById(id);
    if (el) el.textContent = v;
  };
</script>

</head>
<body>
<div class="ps-shell">
  <div class="ps-top">

    <div class="ps-top-left">
      <div class="ps-top-title">Editor</div>
    </div>
    <div class="ps-top-spacer"></div>
<div class="ps-top-actions">
      <button class="ps-btn primary" id="mergeUploadBtn" title="Merge or upload">Merge or upload</button>
      <button class="ps-btn primary" id="findAnotherBtn" title="Find another form">Find another form</button>
      <button class="ps-btn primary" id="shareBtn" title="Share">Share</button>

      <span class="ps-chip">
        <label style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
          <span>Edit PDF</span>
          <input id="editToggle" type="checkbox" checked />
        </label>
      </span>

      <button class="ps-btn done" id="doneBtn">DONE</button>
    </div>
  </div>

    
  <!-- DocForge v11: Compact Ribbon (no-break; proxies legacy toolbar actions) -->
  <div class="ps-ribbon" id="compactRibbon" aria-label="Compact tools">
    <button class="rb-btn" data-proxy="undo" title="Undo"><span class="rb-icon">‚Ü∂</span><span class="rb-label">Undo</span></button>
    <button class="rb-btn" data-proxy="redo" title="Redo"><span class="rb-icon">‚Ü∑</span><span class="rb-label">Redo</span></button>
    <div class="rb-sep"></div>

    <button class="rb-btn" data-proxy="select" title="Select"><span class="rb-icon">üñ±</span><span class="rb-label">Select</span></button>
    <button class="rb-btn" data-proxy="text" title="Text"><span class="rb-icon">T</span><span class="rb-label">Text</span></button>
    <button class="rb-btn" data-proxy="check" title="Checkbox"><span class="rb-icon">‚òë</span><span class="rb-label">Check</span></button>
    <button class="rb-btn" data-proxy="date" title="Date"><span class="rb-icon">üìÖ</span><span class="rb-label">Date</span></button>
    <button class="rb-btn" data-proxy="sign" title="Signature"><span class="rb-icon">‚úç</span><span class="rb-label">Sign</span></button>
    <button class="rb-btn" data-proxy="initials" title="Initials"><span class="rb-icon">‚ìò</span><span class="rb-label">Init</span></button>
    <div class="rb-sep"></div>

    <button class="rb-btn" data-proxy="highlight" title="Highlight"><span class="rb-icon">üñç</span><span class="rb-label">Highlight</span></button>
    <button class="rb-btn" data-proxy="draw" title="Draw"><span class="rb-icon">‚úè</span><span class="rb-label">Draw</span></button>
    <button class="rb-btn" data-proxy="erase" title="Erase"><span class="rb-icon">üßΩ</span><span class="rb-label">Erase</span></button>
    <button class="rb-btn" data-proxy="search" title="Search"><span class="rb-icon">üîé</span><span class="rb-label">Search</span></button>

    <div class="rb-grow"></div>
    <button class="rb-btn" id="openToolsDrawer" title="More tools"><span class="rb-icon">‚ò∞</span><span class="rb-label">Tools</span></button>
  </div>

<div class="ps-toolbar" id="toolbar">
      <button class="ps-btn" data-tool="undo" title="Undo">‚Ü∂</button>
      <button class="ps-btn" data-tool="redo" title="Redo">‚Ü∑</button>
      <div class="ps-sep"></div>

      <div class="tool-dd" id="fieldsDD">
        <button class="ps-btn primary" id="fieldsBtn" title="Form Fields">Fields ‚ñæ</button>
        <div class="tool-dd-menu" id="fieldsMenu">
          <button class="ps-btn tbtn-menu" data-fieldtool="field_text">Text Field</button>
          <button class="ps-btn tbtn-menu" data-fieldtool="field_checkbox">Checkbox</button>
          <button class="ps-btn tbtn-menu" data-fieldtool="field_radio">Radio Group</button>
          <button class="ps-btn tbtn-menu" data-fieldtool="field_dropdown">Dropdown</button>
          <button class="ps-btn tbtn-menu" data-fieldtool="field_date">Date Field</button>
          <div style="height:1px; background: rgba(255,255,255,0.10); margin:8px 0;"></div>
          <button class="ps-btn tbtn-menu" data-fieldtool="detect_fields">Detect existing fields</button>
          <button class="ps-btn tbtn-menu" data-fieldtool="autogen_fields">Auto-generate fields</button>
        </div>
      </div>


    <div class="ps-props" id="propsBar" aria-label="Properties">
      <div class="ps-propgrp">
        <label for="propFont">Font</label>
        <select id="propFont">
          <option value="Helvetica">Helvetica</option>
          <option value="Times-Roman">Times</option>
          <option value="Courier">Courier</option>
        </select>
      </div>
      <div class="ps-propgrp">
        <label for="propSize">Size</label>
        <input class="ps-mini" id="propSize" type="number" min="6" max="128" step="1" value="16">
      </div>
      <div class="ps-propgrp">
        <span class="ps-chk"><input id="propBold" type="checkbox"><label for="propBold">Bold</label></span>
        <span class="ps-chk"><input id="propItalic" type="checkbox"><label for="propItalic">Italic</label></span>
      </div>

      <div class="ps-propgrp">
        <label for="propTextColor">Text</label>
        <input id="propTextColor" type="color" value="#000000">
      </div>

      <div class="ps-propgrp">
        <label for="propFillColor">Fill</label>
        <input id="propFillColor" type="color" value="#000000">
        <label for="propFillOpacity">Opacity</label>
        <input id="propFillOpacity" type="range" min="0" max="1" step="0.01" value="0.12">
      </div>

      <div class="ps-propgrp">
        <label for="propStrokeColor">Stroke</label>
        <input id="propStrokeColor" type="color" value="#000000">
        <label for="propStrokeOpacity">Opacity</label>
        <input id="propStrokeOpacity" type="range" min="0" max="1" step="0.01" value="0.90">
        <label for="propStrokeWidth">Width</label>
        <input class="ps-mini" id="propStrokeWidth" type="number" min="1" max="30" step="1" value="2">
      </div>

      <div class="ps-propgrp">
        <label for="propHiColor">Highlight</label>
        <input id="propHiColor" type="color" value="#000000">
        <label for="propHiOpacity">Opacity</label>
        <input id="propHiOpacity" type="range" min="0" max="1" step="0.01" value="0.28">
      </div>
    </div>


      <button class="ps-btn active" data-tool="select" title="Select">üñ±Ô∏è</button>
      <button class="ps-btn" data-tool="text" title="Text">T</button>
      <button class="ps-btn" data-tool="sign" title="Sign">‚úçÔ∏è</button>
      <button class="ps-btn" data-tool="initials" title="Initials">üÖò</button>
      <button class="ps-btn" data-tool="erase" title="Erase">üßΩ</button>
      <button class="ps-btn" data-tool="image" title="Image">üñºÔ∏è</button>
      <button class="ps-btn" data-tool="check" title="Check">‚úì</button>
      <button class="ps-btn" data-tool="cross" title="Cross">‚úó</button>
      <button class="ps-btn" data-tool="circle" title="Circle">‚óØ</button>
      <button class="ps-btn" data-tool="table" title="Table">‚ñ¶</button>
      <button class="ps-btn" data-tool="textbox" title="Text Box">‚ñ≠T</button>
      <button class="ps-btn" data-tool="date" title="Date">üìÖ</button>
      <button class="ps-btn" data-tool="blackout" title="Blackout">‚¨õ</button>
      <button class="ps-btn" data-tool="highlight" title="Highlight">üñçÔ∏è</button>
      <button class="ps-btn" data-tool="draw" title="Draw">‚úé</button>
      <button class="ps-btn" data-tool="line" title="Line">Ôºè</button>
      <button class="ps-btn" data-tool="arrow" title="Arrow">‚ûù</button>
      <button class="ps-btn" data-tool="sticky" title="Sticky Note">üóíÔ∏è</button>
      <button class="ps-btn" data-tool="watermark" title="Watermark">üÖ¶</button>
      <button class="ps-btn" data-tool="comment" title="Comments">üí¨</button>
      <button class="ps-btn" data-tool="search" title="Search">üîé</button>
      <button class="ps-btn" data-tool="settings" title="Settings">‚öôÔ∏è</button>
    </div>

  <div class="ps-main">
    <aside class="ps-side">
      <div class="ps-side-head">
        <strong>Pages</strong>
        <div class="ps-row">
          <button class="ps-btn" id="zoomOutBtn" title="Zoom Out">‚àí</button>
          <button class="ps-btn" id="zoomInBtn" title="Zoom In">+</button>
        </div>
      </div>
      <div class="ps-side-body" id="thumbs"></div>
    </aside>

    <div class="ps-center" id="psCenter">
    <div class="ps-canvaswrap" id="viewport">
      <!-- pages rendered here -->
    </div>
  </div>

    <aside class="ps-right" id="psRight" aria-label="DocForge panel">
      <div class="ps-right-head">
        <strong>Properties</strong>
        <div class="ps-row" style="gap:6px;">
          <button class="ps-btn" id="rightCollapseBtn" title="Collapse panel">‚ü´</button>
        </div>
      </div>

      <div class="ps-right-body" id="rightBody">
        <div class="sa-section" id="smartActions"></div>

        
<div class="sa-section" id="selectionPanel" style="display:none;">
          <div class="sa-title">Selected</div>
          <div class="sa-muted" id="selSummary">‚Äî</div>

          <div id="multiSelectPanel" style="display:none;">
  <div class="sa-title">Arrange</div>
  <div class="rp-grid3">
    <button class="ps-btn" id="alignLeftBtn" title="Align left">‚ü∏</button>
    <button class="ps-btn" id="alignHCenterBtn" title="Align center">‚áî</button>
    <button class="ps-btn" id="alignRightBtn" title="Align right">‚üπ</button>

    <button class="ps-btn" id="alignTopBtn" title="Align top">‚ü∞</button>
    <button class="ps-btn" id="alignVCenterBtn" title="Align middle">‚áï</button>
    <button class="ps-btn" id="alignBottomBtn" title="Align bottom">‚ü±</button>

    <button class="ps-btn" id="distribHBtn" title="Distribute horizontally">‚â°</button>
    <button class="ps-btn" id="distribVBtn" title="Distribute vertically">‚ãÆ</button>
    <button class="ps-btn" id="selectAllPageBtn" title="Select all on this page">All</button>
  </div>

  <div class="ps-row" style="margin-top:8px; gap:8px;">
    <button class="ps-btn" id="copySelBtn">Copy</button>
    <button class="ps-btn" id="pasteSelBtn">Paste</button>
    <input class="ps-mini" id="pastePageInput" style="width:72px;" type="number" min="1" step="1" placeholder="Page #">
    <button class="ps-btn" id="pasteToPageBtn" title="Paste to page number">Paste ‚Üí</button>
  </div>
<div class="ps-row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
  <button class="ps-btn" id="rotateGroupLeftBtn" title="Rotate selection 90¬∞ left">‚ü≤ 90¬∞</button>
  <button class="ps-btn" id="rotateGroupRightBtn" title="Rotate selection 90¬∞ right">‚ü≥ 90¬∞</button>
  <div style="flex:1;"></div>
</div>

<div class="ps-row" style="margin-top:8px; gap:8px; align-items:center; flex-wrap:wrap;">
  <span class="ps-small" style="min-width:38px;">Gap</span>
  <input class="ps-mini" id="gapPxInput" style="width:72px;" type="number" min="0" step="1" value="8">
  <button class="ps-btn" id="applyGapHBtn" title="Apply fixed horizontal gap">Gap H</button>
  <button class="ps-btn" id="applyGapVBtn" title="Apply fixed vertical gap">Gap V</button>
</div>

  <div class="sa-divider" style="margin-top:10px;"></div>
</div>

<div class="sa-divider"></div>

          <div id="fieldPropsPanel" style="display:none;">
            <div class="sa-title">Field properties</div>

            <div class="rp-form">
              <label class="rp-label" for="rpFieldKind">Type</label>
              <select id="rpFieldKind" class="ps-input">
                <option value="field_text">Text</option>
                <option value="field_date">Date</option>
                <option value="field_checkbox">Checkbox</option>
                <option value="field_dropdown">Dropdown</option>
                <option value="field_radio">Radio</option>
                <option value="field_signature">Signature</option>
              </select>

              <label class="rp-label" for="rpFieldName">Name</label>
              <input id="rpFieldName" class="ps-input" placeholder="field_name" />

              <label class="rp-check">
                <input id="rpFieldRequired" type="checkbox" />
                <span>Required</span>
              </label>

              <div class="rp-grid2">
                <div>
                  <div class="ps-small">Font</div>
                  <select id="rpFont" class="ps-input">
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times-Roman">Times</option>
                    <option value="Courier">Courier</option>
                  </select>
                </div>
                <div>
                  <div class="ps-small">Size</div>
                  <input id="rpSize" class="ps-input" type="number" min="6" max="96" />
                </div>
              </div>

              <div class="rp-grid2">
                <label class="rp-check">
                  <input id="rpBold" type="checkbox" />
                  <span>Bold</span>
                </label>
                <label class="rp-check">
                  <input id="rpItalic" type="checkbox" />
                  <span>Italic</span>
                </label>
              </div>

              <div class="rp-grid2">
                <div>
                  <div class="ps-small">Text</div>
                  <input id="rpTextColor" class="ps-input" type="color" value="#000000" />
                </div>
                <div>
                  <div class="ps-small">Fill</div>
                  <input id="rpFillColor" class="ps-input" type="color" value="#000000" />
                </div>
              </div>

              <div class="rp-grid2">
                <div>
                  <div class="ps-small">Fill opacity</div>
                  <input id="rpFillOpacity" class="ps-input" type="range" min="0" max="1" step="0.01" />
                </div>
                <div>
                  <div class="ps-small">Stroke width</div>
                  <input id="rpStrokeWidth" class="ps-input" type="number" min="0" max="20" />
                </div>
              </div>

              <div class="rp-grid2">
                <div>
                  <div class="ps-small">Stroke</div>
                  <input id="rpStrokeColor" class="ps-input" type="color" value="#000000" />
                </div>
                <div>
                  <div class="ps-small">Stroke opacity</div>
                  <input id="rpStrokeOpacity" class="ps-input" type="range" min="0" max="1" step="0.01" />
                </div>
              </div>

              <div id="rpOptionsWrap" style="display:none;">
                <div class="ps-small">Options (one per line)</div>
                <textarea id="rpOptions" class="ps-input" rows="4" placeholder="Option 1&#10;Option 2"></textarea>
              </div>

              <div class="rp-actions">
                <button class="ps-btn" id="jumpToPropsBtn" title="Scroll to legacy props bar">Legacy props</button>
                                <button class="ps-btn" id="alignLabelBtn" title="Align to nearest label text">Align label</button>
<button class="ps-btn" id="duplicateSelectedBtn" title="Duplicate selected field">Duplicate</button>
                <button class="ps-btn danger" id="deleteSelectedBtn">Delete</button>
              </div>
            </div>
          </div>

          <div id="nonFieldActions" style="display:none;">
            <button class="ps-btn" id="jumpToPropsBtn2">Legacy props</button>
            <button class="ps-btn" id="duplicateSelectedBtn2">Duplicate</button>
            <button class="ps-btn danger" id="deleteSelectedBtn2">Delete</button>
          </div>
        </div>

        
      </div>
    </aside>

  </div>

  <div class="ps-bottom" id="psBottom" aria-label="Viewer controls">
    <div class="ps-bottom-left">
      <button class="ps-btn" id="scrollPrevBtn" title="Previous page">‚óÄ</button>
      <input class="ps-mini" id="pageJumpInput" value="1" inputmode="numeric" style="width:56px; text-align:center;" />
      <span class="ps-small" id="pageCountLabel">/ ‚Äî</span>
      <button class="ps-btn" id="scrollNextBtn" title="Next page">‚ñ∂</button>
    </div>

    <div class="ps-bottom-center">
      <button class="ps-btn" id="zoomOutBtn2" title="Zoom Out">‚àí</button>
      <span class="ps-small" id="zoomLabel">100%</span>
      <button class="ps-btn" id="zoomInBtn2" title="Zoom In">+</button>
      <span class="ps-sep"></span>
      <button class="ps-btn" id="fitWidthBtn" title="Fit width">Fit Width</button>
      <button class="ps-btn" id="fitPageBtn" title="Fit page">Fit Page</button>
    </div>

    <div class="ps-bottom-right">
      <span class="ps-small" id="saveStateLabel">Ready</span>
    </div>
  </div>

</div>

<!-- Search panel -->
<div class="searchbar" id="searchBar">
  <div class="ps-row">
    <input class="ps-input" id="searchInput" placeholder="Search text‚Ä¶" />
    <button class="ps-btn" id="searchGo">Find</button>
    <button class="ps-btn" id="searchClose">Close</button>
  </div>
  <div class="ps-small" id="searchHint">Search scans may return limited results unless OCR is available.</div>
  <div id="searchResults"></div>
</div>

<!-- Settings modal -->
<div class="ps-modal" id="settingsModal">
  <div class="ps-card">
    <div class="ps-row" style="justify-content:space-between;">
      <h3 style="margin:0;">Settings</h3>
      <button class="ps-btn" id="settingsClose">Close</button>
    </div>
    <div class="ps-grid" style="margin-top:10px;">
      <div>
        <div class="ps-small">Default font size</div>
        <input class="ps-input" id="setFontSize" type="number" min="6" max="72" />
      </div>
      <div>
        <div class="ps-small">Default stroke width</div>
        <input class="ps-input" id="setStrokeWidth" type="number" min="1" max="20" />
      </div>
      <div>
        <div class="ps-small">Watermark text (optional)</div>
        <input class="ps-input" id="setWatermarkText" placeholder="e.g., CONFIDENTIAL" />
      </div>
      <div>
        <div class="ps-small">Watermark opacity (0‚Äì1)</div>
        <input class="ps-input" id="setWatermarkOpacity" type="number" min="0" max="1" step="0.05" />
      </div>
    </div>
    <div class="ps-row" style="margin-top:12px;">
      <label class="ps-chip" style="cursor:pointer;">
        <input id="setSnap" type="checkbox" />
        <span style="margin-left:8px;">Snap to grid</span>
      </label>
      <span class="ps-small">Changes apply immediately. Undo/Redo still works.</span>
    </div>
  </div>
</div>

<!-- Simple menu modal for Merge/Upload -->
<div class="ps-modal" id="muModal">
  <div class="ps-card">
    <div class="ps-row" style="justify-content:space-between;">
      <h3 style="margin:0;">Merge or upload</h3>
      <button class="ps-btn" id="muClose">Close</button>
    </div>

    <div class="ps-row" style="margin-top:10px;">
      <button class="ps-btn primary" id="muUploadBtn">Upload PDF to Vault</button>
      <input id="muUploadInput" type="file" accept="application/pdf" style="display:none;" />
      <button class="ps-btn primary" id="muMergeBtn">Merge PDFs (local files)</button>
      <input id="muMergeInput" type="file" accept="application/pdf" multiple style="display:none;" />
    </div>
    <div class="ps-small" style="margin-top:10px;">
      Upload saves a new PDF into your Vault. Merge creates a merged PDF and then uploads it into your Vault.
    </div>
  </div>
</div>

<!-- Status -->
<div class="ps-status" id="status"></div>
<!-- Libraries -->
<script src="/vendor/pdf-lib.min.js"></script>

<script type="module">


// --- PDF.js module bootstrap (local vendor) ---
import * as _pdfjsLib from "/vendor/pdf.mjs";
_pdfjsLib.GlobalWorkerOptions.workerSrc = "/vendor/pdf.worker.mjs";
// Make available to any legacy code that expects a global
window.pdfjsLib = _pdfjsLib;
// Local alias (the code below references `pdfjsLib`)
const pdfjsLib = _pdfjsLib;

(() => {
  // -------------------------------
  // Helpers
  // -------------------------------
  const $ = (id) => document.getElementById(id);
  const qs = (sel, root=document) => root.querySelector(sel);
  const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function getCookie(name){
    const m = document.cookie.match(new RegExp("(?:^|;\\s*)" + name.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&") + "=([^;]+)"));
    return m ? decodeURIComponent(m[1]) : "";
  }
  function getToken(){
    return getCookie("pdfrealm_token") || getCookie("token") || getCookie("auth_token") || "";
  }
  function getParam(k){
    const u = new URL(location.href);
    return u.searchParams.get(k) || "";
  }
  
  function getParamMaybe(k){
    const u = new URL(location.href);
    return u.searchParams.has(k) ? u.searchParams.get(k) : null;
  }

function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

  function showStatus(msg, kind="ok", ms=2600){
    const el = $("status");
    el.className = "ps-status show " + (kind||"");
    el.textContent = msg;
    if (ms > 0) setTimeout(() => el.classList.remove("show"), ms);
  }


  function hostPost(msg){
    try{
      if (window.parent && window.parent !== window) window.parent.postMessage(msg, "*");
      else if (window.opener) window.opener.postMessage(msg, "*");
    }catch(_e){}
  }

  async function openPdfFromBytes(bytesUint8, filename){
    try{
      state.fileId = ""; // guest / direct open
      state.filename = filename || state.filename || "document.pdf";
      state.pdfBytes = (bytesUint8 instanceof Uint8Array) ? bytesUint8 : new Uint8Array(bytesUint8 || []);
      state._pdfBytesMaster = state.pdfBytes.slice(); // keep original source for decrypt
      state._isEncryptedMaster = false; // will be set by PDF.js if password required
      state._openPw = String(state._openPw || "").trim();

      window.setText("docSub", state.filename);
      showStatus("Opening‚Ä¶", "ok", 0);
      state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster);
      await renderAll();
      ensureUiReady();
      try{ updatePropsUI(); }catch(e){}
      showStatus("Loaded.", "ok", 1400);
      hostPost({ type: "PDFSTUDIO_STATUS", text: "Loaded" });
      return true;
    }catch(e){
      console.error(e);
      showStatus(String(e?.message || e || "Failed to open PDF."), "err", 7000);
      hostPost({ type: "PDFSTUDIO_STATUS", text: "Error" });
      return false;
    }
  }

  function _remapObjectsAfterDeletePage(deletedPage){
    if (!Array.isArray(state.objects)) return;
    state.objects = state.objects
      .filter(o => (o.page || 0) !== deletedPage)
      .map(o => {
        if ((o.page || 0) > deletedPage) o.page = (o.page || 0) - 1;
        return o;
      });
  }

  function _remapObjectsAfterReorder(mapOldToNew){
    if (!Array.isArray(state.objects)) return;
    for (const o of state.objects){
      const p = o.page || 0;
      if (mapOldToNew[p]) o.page = mapOldToNew[p];
    }
  }

  async function _rebuildPdfByPageOrder(newOrder){
    // newOrder: array of old page numbers in the desired new sequence (1-indexed page numbers)
    const { PDFDocument } = PDFLib;
    await ensureEditablePdfBytes();
    const srcDoc = await PDFDocument.load(state.pdfBytes);
    const outDoc = await PDFDocument.create();
    const indices = newOrder.map(p => p - 1);
    const copied = await outDoc.copyPages(srcDoc, indices);
    copied.forEach(p => outDoc.addPage(p));
    const outBytes = await outDoc.save();
    state.pdfBytes = new Uint8Array(outBytes);
    state._pdfBytesMaster = state.pdfBytes.slice();
    state._isEncryptedMaster = false;
    state._openPw = "";
  }

  async function deletePage(pageNum){
    if (!state.pdf || !state.pdf.numPages) return;
    const n = state.pdf.numPages;
    if (pageNum < 1 || pageNum > n) return;
    if (n === 1){
      showStatus("Can't delete the only page.", "err", 2200);
      return;
    }
    showStatus("Deleting page‚Ä¶", "ok", 0);
    const order = [];
    for (let p = 1; p <= n; p++) if (p !== pageNum) order.push(p);
    await _rebuildPdfByPageOrder(order);
    _remapObjectsAfterDeletePage(pageNum);
    state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster);
    await renderAll();
    showStatus("Page deleted.", "ok", 1200);
  }

  async function reorderPages(fromPage, toPage){
    if (!state.pdf || !state.pdf.numPages) return;
    const n = state.pdf.numPages;
    if (fromPage === toPage) return;
    if (fromPage < 1 || fromPage > n || toPage < 1 || toPage > n) return;

    showStatus("Reordering‚Ä¶", "ok", 0);
    const order = Array.from({ length: n }, (_, i) => i + 1);
    const [moved] = order.splice(fromPage - 1, 1);
    order.splice(toPage - 1, 0, moved);

    // Build old->new mapping for annotations
    const mapOldToNew = {};
    order.forEach((oldPage, idx) => { mapOldToNew[oldPage] = idx + 1; });

    await _rebuildPdfByPageOrder(order);
    _remapObjectsAfterReorder(mapOldToNew);

    state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster);
    await renderAll();
    showStatus("Reordered.", "ok", 1200);
  }

  async function appendPdfFiles(files){
    // files: [{ bytes: ArrayBuffer, name: string }]
    const { PDFDocument } = PDFLib;

    showStatus("Combining‚Ä¶", "ok", 0);

    // base doc: if none loaded, start from first file
    let baseBytes = state.pdfBytes;
    if (!baseBytes || !state.pdf){
      const first = files.shift();
      if (!first) return;
      const ok = await openPdfFromBytes(new Uint8Array(first.bytes), first.name || "document.pdf");
      if (!ok) return;
      baseBytes = state.pdfBytes;
    }

    await ensureEditablePdfBytes();
    let baseDoc = await PDFDocument.load(state.pdfBytes);

    for (const f of files){
      let srcBytes = new Uint8Array(f.bytes);// Prepare each appended PDF for pdf-lib (decrypt if needed, normalize if needed)
try{
  await PDFDocument.load(srcBytes);
}catch(e){
  const enc = _isPdfLibEncryptedError(e);
  if (enc){
    let lastErr = e;
    let pw = "";
    for (let attempt = 0; attempt < 5; attempt++){
      const nextPw = await promptOpenPassword(attempt ? "incorrect" : "need");
      if (!nextPw) throw new Error("Password required for " + (f.name || "an added PDF") + ".");
      pw = String(nextPw).trim();
      try{
        srcBytes = await preparePdfBytesWithQpdf(srcBytes, pw);
        await PDFDocument.load(srcBytes);
        lastErr = null;
        break;
      }catch(err){
        lastErr = err;
        const msg = String(err && (err.message || err) || "");
        const code = err && err.code ? String(err.code) : "";
        if (code === "INVALID_PASSWORD" || /invalid password/i.test(msg) || /password.*invalid/i.test(msg)) continue;
        throw err;
      }
    }
    if (lastErr) throw lastErr;
  }else{
    // Not encrypted; normalize via qpdf (object streams etc)
    srcBytes = await preparePdfBytesWithQpdf(srcBytes, "");
    await PDFDocument.load(srcBytes);
  }
}

      const srcDoc = await PDFDocument.load(srcBytes);
      const copied = await baseDoc.copyPages(srcDoc, srcDoc.getPageIndices());
      copied.forEach(p => baseDoc.addPage(p));
    }

    const out = await baseDoc.save();
    state.pdfBytes = new Uint8Array(out);
    state._pdfBytesMaster = state.pdfBytes.slice();
    state._isEncryptedMaster = false;
    state._openPw = "";

    state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster);
    await renderAll();
    showStatus("Combined.", "ok", 1400);
  }

  // Drag/drop ordering for thumbs
  let _thumbDragFrom = null;
  function setupThumbDnD(thumbEl){
    thumbEl.draggable = true;
    thumbEl.addEventListener("dragstart", (ev) => {
      _thumbDragFrom = parseInt(thumbEl.dataset.page || "0", 10) || null;
      thumbEl.classList.add("dragging");
      try{ ev.dataTransfer.setData("text/plain", String(_thumbDragFrom || "")); }catch(_e){}
      ev.dataTransfer.effectAllowed = "move";
    });
    thumbEl.addEventListener("dragend", () => {
      thumbEl.classList.remove("dragging");
      qsa(".thumb").forEach(t => t.classList.remove("dragover"));
      _thumbDragFrom = null;
    });
    thumbEl.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      thumbEl.classList.add("dragover");
      ev.dataTransfer.dropEffect = "move";
    });
    thumbEl.addEventListener("dragleave", () => thumbEl.classList.remove("dragover"));
    thumbEl.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      thumbEl.classList.remove("dragover");
      const to = parseInt(thumbEl.dataset.page || "0", 10) || null;
      const from = _thumbDragFrom;
      if (!from || !to || from === to) return;
      await reorderPages(from, to);
    });
  }
  // -------------------------------
  // State
  // -------------------------------
  const state = {
    fileId: getParam("fileId"),
    blobUrl: getParamMaybe("blob") || getParamMaybe("blobUrl") || "",
    filename: getParam("name") || "",
    folderKey: (function(){
      const f = getParamMaybe("folder");
      if (f !== null) return f; // preserve empty string for Vault Home
      const fp = getParamMaybe("folderPath");
      if (fp !== null) return fp;
      return null;
    })(),

    pdfBytes: null,
    pdf: null,          // pdf.js doc
    pageViews: [],      // {pageNum, viewport, canvas, overlay, vecLayer}
    thumbs: [],
    zoom: 1.15,
    tool: "select",
    edit: true,
    selectedId: null,
    dragging: null,     // {id, startX, startY, orig, mode:"move"|"resize", corner}
    drawing: null,      // for draw/rect/line/arrow
    objects: [],        // annotations
    history: [],
    redo: [],
    guidesByPage: {},
    showTabOrder: false,
    dfBatch: null,
    signatureDataUrl: null,
    defaults: {
      fontSize: 16,
      fontFamily: "Helvetica",
      bold: false,
      italic: false,
      textColor: "#000000",
      fillColor: "#000000",
      fillOpacity: 0.12,
      strokeColor: "#000000",
      strokeOpacity: 0.90,
      highlightColor: "#000000",
      highlightOpacity: 0.28,
      noteColor: "#000000",
      noteOpacity: 0.18,
      strokeWidth: 2,
      snap: false
    },
    watermark: { text:"", opacity:0.12 }
  };

  
async function hydrateVaultMeta(){
  try{
    if (!state.fileId) return;
    const token = getToken();
    const r = await fetch("/api/vault/file/" + encodeURIComponent(state.fileId), {
      method: "GET",
      headers: token ? { "Authorization": "Bearer " + token } : {},
      credentials: "same-origin"
    });
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.ok) return;
    if (j.folderPath !== undefined && j.folderPath !== null){
      // preserve empty string for Vault Home
      state.folderKey = String(j.folderPath);
    }
    if ((!state.filename || !String(state.filename).trim()) && j.filename){
      state.filename = String(j.filename);
    }
  }catch(_e){}
}function currentFolderKey(){
    // Keep empty string as a valid "Vault Home" key.
    return (state.folderKey === null || state.folderKey === undefined) ? "" : state.folderKey;
  }

  function notifyVaultChanged(meta){
    // Best-effort cross-tab sync for Office/Vault explorers
    try { localStorage.setItem("pdfrealm_vault_changed", String(Date.now())); } catch(_e){}
    try {
      const ch = new BroadcastChannel("pdfrealm_vault");
      ch.postMessage({ type: "vault_changed", ts: Date.now(), meta: meta || null });
      ch.close();
    } catch(_e){}
    try { window.parent && window.parent !== window && window.parent.postMessage({ type:"vault_changed", ts: Date.now(), meta: meta || null }, "*"); } catch(_e){}
    try { window.opener && window.opener.postMessage({ type:"vault_changed", ts: Date.now(), meta: meta || null }, "*"); } catch(_e){}
  }


  function snap(v){
  if (!state.defaults.snap) return v;
  const g = 0.01; // 1% grid
  return Math.round(v / g) * g;
}

  // Alignment snap (DocForge no-break): snaps to nearby object edges/centers while dragging.
  function dfAlignSnap(pv, movingObj, nx, ny){
    if (!state.defaults.snap) return { nx, ny, guides: null }; // piggyback on existing Snap toggle
    const W = pv.viewport?.width || 1;
    const H = pv.viewport?.height || 1;
    const tolX = 6 / W; // 6px tolerance
    const tolY = 6 / H;

    const page = movingObj.page;
    const others = state.objects.filter(o => o && o.id !== movingObj.id && o.page === page && o.type !== "draw" && o.type !== "line" && o.type !== "arrow");

    // Candidate guides: other edges + centers, plus page edges/center
    const xGuides = [0, 0.5, 1];
    const yGuides = [0, 0.5, 1];
    for (const o of others){
      if (o.nx == null || o.ny == null || o.nw == null || o.nh == null) continue;
      xGuides.push(o.nx, o.nx + o.nw, o.nx + o.nw/2);
      yGuides.push(o.ny, o.ny + o.nh, o.ny + o.nh/2);
    }

    const w = movingObj.nw ?? 0.1;
    const h = movingObj.nh ?? 0.03;

    // Moving object's edges/center
    const candX = [
      { kind:"left", v: nx, apply:(g)=>g },
      { kind:"center", v: nx + w/2, apply:(g)=>g - w/2 },
      { kind:"right", v: nx + w, apply:(g)=>g - w }
    ];
    const candY = [
      { kind:"top", v: ny, apply:(g)=>g },
      { kind:"middle", v: ny + h/2, apply:(g)=>g - h/2 },
      { kind:"bottom", v: ny + h, apply:(g)=>g - h }
    ];

    let bestX = null;
    for (const c of candX){
      for (const g of xGuides){
        const d = g - c.v;
        const ad = Math.abs(d);
        if (ad <= tolX && (!bestX || ad < bestX.ad)){
          bestX = { ad, g };
        }
      }
    }

    let bestY = null;
    for (const c of candY){
      for (const g of yGuides){
        const d = g - c.v;
        const ad = Math.abs(d);
        if (ad <= tolY && (!bestY || ad < bestY.ad)){
          bestY = { ad, g };
        }
      }
    }

    const out = { nx, ny, guides: null };
    const guides = { xs: [], ys: [] };

    if (bestX){
      // prefer aligning moving left to guide, else center, else right
      const left = bestX.g;
      // choose smallest adjustment among left/center/right by recomputing
      let bestAdj = null;
      for (const c of candX){
        const d = bestX.g - c.v;
        const ad = Math.abs(d);
        if (ad <= tolX && (!bestAdj || ad < bestAdj.ad)){
          bestAdj = { ad, nx: c.apply(bestX.g) };
        }
      }
      if (bestAdj){
        out.nx = bestAdj.nx;
        guides.xs.push(bestX.g);
      }
    }

    if (bestY){
      let bestAdj = null;
      for (const c of candY){
        const d = bestY.g - c.v;
        const ad = Math.abs(d);
        if (ad <= tolY && (!bestAdj || ad < bestAdj.ad)){
          bestAdj = { ad, ny: c.apply(bestY.g) };
        }
      }
      if (bestAdj){
        out.ny = bestAdj.ny;
        guides.ys.push(bestY.g);
      }
    }

    if (guides.xs.length || guides.ys.length) out.guides = guides;
    return out;
  }


  function pushHistory(){
    state.history.push(JSON.stringify({objects: state.objects, watermark: state.watermark}));
    if (state.history.length > 80) state.history.shift();
    state.redo.length = 0;
  }
  function undo(){
    if (!state.history.length) return showStatus("Nothing to undo.", "warn");
    const cur = JSON.stringify({objects: state.objects, watermark: state.watermark});
    state.redo.push(cur);
    const prev = state.history.pop();
    const parsed = JSON.parse(prev);
    state.objects = parsed.objects || [];
    state.watermark = parsed.watermark || state.watermark;
    renderOverlays();
    showStatus("Undone.", "ok", 1000);
  }
  function redo(){
    if (!state.redo.length) return showStatus("Nothing to redo.", "warn");
    const cur = JSON.stringify({objects: state.objects, watermark: state.watermark});
    state.history.push(cur);
    const next = state.redo.pop();
    const parsed = JSON.parse(next);
    state.objects = parsed.objects || [];
    state.watermark = parsed.watermark || state.watermark;
    renderOverlays();
    showStatus("Redone.", "ok", 1000);
  }

  function setTool(t){
    if (t === "undo") return undo();
    if (t === "redo") return redo();
    if (t === "settings") return openSettings();
    if (t === "search") return toggleSearch(true);
    if (t === "watermark") return promptWatermark();
    if (t === "comment") return openComments();
    if (t === "erase") { state.tool = "erase"; }
    else state.tool = t;

    qsa("#toolbar .ps-btn").forEach(b => {
      const on = (b.dataset.tool === state.tool);
      if (b.dataset.tool === "undo" || b.dataset.tool === "redo" || b.dataset.tool === "settings" || b.dataset.tool === "search" || b.dataset.tool === "watermark" || b.dataset.tool === "comment") return;
      b.classList.toggle("active", on);
    });
  }


  // --- Fields dropdown wiring ---
  function initFieldsDropdown(){
    if (state._fieldsDdWired) return;
    state._fieldsDdWired = true;
    const dd = document.getElementById("fieldsDD");
    const btn = document.getElementById("fieldsBtn");
    const menu = document.getElementById("fieldsMenu");
    if (!dd || !btn || !menu) return;

    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      dd.classList.toggle("open");
    });

    menu.addEventListener("click", (e)=>{
      const t = e.target;
      const key = t && t.getAttribute ? t.getAttribute("data-fieldtool") : null;
      if (!key) return;
      e.preventDefault();
      e.stopPropagation();
      dd.classList.remove("open");
      if (key === "detect_fields"){
        dd.classList.remove("open");
        detectExistingPdfFields().catch(err => console.error(err));
        return;
      }
      if (key === "autogen_fields"){
        dd.classList.remove("open");
        autoGenerateFieldsFromText().catch(err => console.error(err));
        return;
      }

      // Set the active tool to this field tool
      setTool(key);
    });

    document.addEventListener("mousedown", (e)=>{
      if (!dd.classList.contains("open")) return;
      if (!dd.contains(e.target)) dd.classList.remove("open");
    });
  }

  function isFieldTool(t){
    return typeof t === "string" && t.startsWith("field_");
  }
  

  function mapWidgetToKind(ann){
    // pdf.js widget fields: fieldType can be 'Tx', 'Btn', 'Ch', 'Sig' (varies)
    const ft = (ann.fieldType || ann.fieldTypeName || ann.fieldTypeNameRaw || ann.fieldTypeRaw || "").toString();
    const subtype = (ann.subtype || ann.annotationSubtype || "").toString();
    // Best-effort mapping
    if (ft === "Tx") return "field_text";
    if (ft === "Sig") return "field_signature";
    if (ft === "Ch") return "field_dropdown";
    if (ft === "Btn"){
      // determine checkbox vs radio if possible
      const isRadio = !!ann.radioButton || (ann.fieldFlags && (ann.fieldFlags & (1<<15))); // best effort
      return isRadio ? "field_radio" : "field_checkbox";
    }
    // fallback based on appearance/value hints
    if ((ann.checkBox || ann.checkBoxExportValue) || (ann.exportValue && ann.exportValue !== "")) return "field_checkbox";
    return "field_text";
  }

  function makeFieldName(kind, pageNum){
    const base = kind.replace("field_","").toUpperCase();
    return `${base}_${pageNum}_${Math.floor(Math.random()*1e6).toString(16)}`;
  }

  function createField(kind, pv, pos){
    // Default size in normalized coords
    let nw = 0.28, nh = 0.06;
    if (kind === "field_checkbox" || kind === "field_radio") { nw = 0.04; nh = 0.04; }
    if (kind === "field_date") { nw = 0.22; nh = 0.06; }
    if (kind === "field_dropdown") { nw = 0.30; nh = 0.06; }

    const o = {
      id: uid(),
      type: "field",
      fieldKind: kind,
      page: pv.pageNum,
      nx: snap(pos.x),
      ny: snap(pos.y),
      nw,
      nh,
      name: makeFieldName(kind, pv.pageNum),
      value: "",
      required: false,
      options: (kind === "field_dropdown" || kind === "field_radio") ? ["Option 1","Option 2"] : [],
      // styling
      fontSize: state.defaults.fontSize,
      fontFamily: state.defaults.fontFamily,
      bold: state.defaults.bold,
      italic: state.defaults.italic,
      textColor: state.defaults.textColor,
      fillColor: state.defaults.fillColor,
      fillOpacity: 0.08,
      strokeColor: state.defaults.strokeColor,
      strokeOpacity: 0.55,
      strokeWidth: 2
    };
    state.objects.push(o);
    return o;
  }

  function fieldKey(o){
    // stable key to prevent dupes
    const name = (o.name || "").trim();
    const r = [o.page, name, Math.round((o.nx||0)*1000), Math.round((o.ny||0)*1000), Math.round((o.nw||0)*1000), Math.round((o.nh||0)*1000)].join("|");
    return r;
  }

  async function detectExistingPdfFields(){
    // Detect widget annotations and create overlay field objects for any we haven't already represented
    const existing = new Set(state.objects.filter(o => o.type === "field").map(fieldKey));
    let added = 0;

    for (const pv of state.pageViews){
      let annots = [];
      try{
        annots = await pv.page.getAnnotations({ intent: "display" });
      }catch{
        try{ annots = await pv.page.getAnnotations(); }catch{ annots = []; }
      }
      for (const a of annots){
        const isWidget = (a.subtype === "Widget") || (a.annotationType === 20) || (String(a.type||"").toLowerCase() === "widget");
        if (!isWidget) continue;
        if (!a.rect || a.rect.length !== 4) continue;

        // Convert PDF rect to viewport (canvas) coords, then normalize
        const vr = pv.viewport.convertToViewportRectangle(a.rect);
        const x1 = Math.min(vr[0], vr[2]);
        const y1 = Math.min(vr[1], vr[3]);
        const x2 = Math.max(vr[0], vr[2]);
        const y2 = Math.max(vr[1], vr[3]);

        const nx = clamp01(x1 / pv.viewport.width);
        const ny = clamp01(y1 / pv.viewport.height);
        const nw = clamp01((x2 - x1) / pv.viewport.width);
        const nh = clamp01((y2 - y1) / pv.viewport.height);

        const kind = mapWidgetToKind(a);
        const name = (a.fieldName || a.fieldFullName || a.fieldId || a.id || "").toString() || makeFieldName(kind, pv.pageNum);

        const o = {
          id: uid(),
          type: "field",
          fieldKind: kind,
          page: pv.pageNum,
          nx: snap(nx),
          ny: snap(ny),
          nw: snap(Math.max(0.01, nw)),
          nh: snap(Math.max(0.01, nh)),
          name,
          value: (a.fieldValue ?? a.value ?? "").toString(),
          required: !!a.required,
          options: Array.isArray(a.options) ? a.options.map(x => (x?.exportValue ?? x?.displayValue ?? x?.value ?? x).toString()) : [],
          autoDetected: true,
          // styling
          fontSize: state.defaults.fontSize,
          fontFamily: state.defaults.fontFamily,
          bold: false,
          italic: false,
          textColor: state.defaults.textColor,
          fillColor: state.defaults.fillColor,
          fillOpacity: 0.08,
          strokeColor: state.defaults.strokeColor,
          strokeOpacity: 0.55,
          strokeWidth: 2
        };

        const k = fieldKey(o);
        if (existing.has(k)) continue;
        existing.add(k);
        state.objects.push(o);
        added++;
      }
    }

    if (added){
      showStatus(`Detected ${added} form field${added===1?"":"s"} from the PDF.`, "ok", 2200);
      renderOverlays();
    }
  }

  // -------------------------------
  // Auto-generate fields (heuristics)
  // -------------------------------
  async function autoGenerateFieldsIfNeeded(){
    const hasAnyField = state.objects.some(o => o && o.type === "field");
    if (hasAnyField) return 0;

    // quick check: does the doc look like a form? (lots of underscores / checkbox glyphs / trailing colons)
    let score = 0;
    for (const pv of state.pageViews){
      try{
        const tc = await pv.page.getTextContent({ disableCombineTextItems: false });
        for (const it of (tc.items||[])){
          const s = (it.str||"").trim();
          if (!s) continue;
          if (s.includes("____")) score += 2;
          if (s.includes("‚òê") || s.includes("‚ñ°") || s.includes("[ ]")) score += 2;
          if (s.endsWith(":")) score += 1;
          if (score >= 10) break;
        }
      }catch{}
      if (score >= 10) break;
    }
    if (score < 6) return 0;

    return await autoGenerateFieldsFromText();
  }

  async function autoGenerateFieldsFromText(){
    // Generates overlay field objects from visible text using simple rules:
    // - label ending with ":" => text field to the right
    // - "____" runs => text field over the underscores
    // - checkbox glyphs => checkbox field
    const existing = new Set(state.objects.filter(o => o.type === "field").map(fieldKey));
    let created = 0;

    const addField = (o) => {
      const k = fieldKey(o);
      if (existing.has(k)) return false;
      existing.add(k);
      state.objects.push(o);
      created++;
      return true;
    };

    for (const pv of state.pageViews){
      let tc;
      try{
        tc = await pv.page.getTextContent({ disableCombineTextItems: false });
      }catch{ continue; }

      const vw = pv.viewport.width;
      const vh = pv.viewport.height;

      for (const it of (tc.items||[])){
        const raw = (it.str||"");
        const s = raw.trim();
        if (!s) continue;

        // base point in viewport coords (top-left origin)
        const [vx, vy] = pv.viewport.convertToViewportPoint(it.transform[4], it.transform[5]);
        const w = Math.max(1, it.width || 1);
        const h = Math.max(10, it.height || 10);

        // pdf.js gives baseline-ish y; nudge up so our box aligns with text band
        const yTop = clampNum(vy - h, 0, vh - 1);
        const xLeft = clampNum(vx, 0, vw - 1);

        // Checkboxes
        if (s.includes("‚òê") || s.includes("‚ñ°") || s.includes("[ ]")){
          const box = {
            id: uid(),
            type: "field",
            fieldKind: "field_checkbox",
            page: pv.pageNum,
            nx: snap(clamp01(xLeft / vw)),
            ny: snap(clamp01(yTop / vh)),
            nw: snap(clamp01(16 / vw)),
            nh: snap(clamp01(16 / vh)),
            name: `chk_${pv.pageNum}_${created+1}`,
            value: "Off",
            required: false,
            options: [],
            autoDetected: true,
            // styling
            fontSize: state.defaults.fontSize,
            fontFamily: state.defaults.fontFamily,
            bold: false,
            italic: false,
            textColor: state.defaults.textColor,
            fillColor: state.defaults.fillColor,
            fillOpacity: 0.08,
            strokeColor: state.defaults.strokeColor,
            strokeOpacity: 0.55,
            strokeWidth: 2
          };
          addField(box);
          continue;
        }

        // Underscore runs
        if (s.includes("____") && w >= 30){
          const fw = clampNum(w, 60, vw - xLeft - 8);
          const fh = clampNum(h + 8, 18, 28);
          const kind = /date/i.test(s) ? "field_date" : "field_text";
          const f = {
            id: uid(),
            type: "field",
            fieldKind: kind,
            page: pv.pageNum,
            nx: snap(clamp01(xLeft / vw)),
            ny: snap(clamp01(yTop / vh)),
            nw: snap(clamp01(fw / vw)),
            nh: snap(clamp01(fh / vh)),
            name: `${kind}_${pv.pageNum}_${created+1}`,
            value: "",
            required: false,
            options: [],
            autoDetected: true,
            // styling
            fontSize: state.defaults.fontSize,
            fontFamily: state.defaults.fontFamily,
            bold: false,
            italic: false,
            textColor: state.defaults.textColor,
            fillColor: state.defaults.fillColor,
            fillOpacity: 0.08,
            strokeColor: state.defaults.strokeColor,
            strokeOpacity: 0.55,
            strokeWidth: 2
          };
          addField(f);
          continue;
        }

        // Label with colon: put a field to the right
        if (s.endsWith(":") && s.length >= 2 && s.length <= 50){
          const pad = 10;
          const fx = clampNum(xLeft + w + pad, 0, vw - 1);
          const fw = clampNum(Math.min(220, vw - fx - 12), 80, vw - fx - 12);
          const fh = clampNum(h + 10, 18, 28);
          const kind = /date/i.test(s) ? "field_date" : "field_text";
          const f = {
            id: uid(),
            type: "field",
            fieldKind: kind,
            page: pv.pageNum,
            nx: snap(clamp01(fx / vw)),
            ny: snap(clamp01(yTop / vh)),
            nw: snap(clamp01(fw / vw)),
            nh: snap(clamp01(fh / vh)),
            name: `${kind}_${pv.pageNum}_${created+1}`,
            value: "",
            required: false,
            options: [],
            autoDetected: true,
            // styling
            fontSize: state.defaults.fontSize,
            fontFamily: state.defaults.fontFamily,
            bold: false,
            italic: false,
            textColor: state.defaults.textColor,
            fillColor: state.defaults.fillColor,
            fillOpacity: 0.08,
            strokeColor: state.defaults.strokeColor,
            strokeOpacity: 0.55,
            strokeWidth: 2
          };
          addField(f);
          continue;
        }
      }
    }

    if (created){
      showStatus(`Auto-generated ${created} fields (heuristic).`, "ok", 3000);
      pushHistory();
      renderOverlays();
      updatePropsUI();
    }else{
      showStatus("No obvious form fields found to auto-generate.", "warn", 2500);
    }
    return created;
  }
function setEdit(on){
    state.edit = !!on;
    for (const pv of state.pageViews){
      pv.overlay.classList.toggle("editing", state.edit);
      pv.vecLayer.classList.toggle("editing", state.edit);
    }
    if (!state.edit) clearSelection();
  }

  // -------------------------------
  // Load + Render PDF
  // -------------------------------
  async function fetchPdfBytes(){
    // Guest/session PDFs can be passed in via blob=... (origin-scoped object URL)
    if (state.blobUrl){
      const r = await fetch(state.blobUrl);
      if (!r.ok) {
        const txt = await r.text().catch(()=> "");
        throw new Error("Failed to load PDF (" + r.status + "). " + (txt || ""));
      }
      const buf = await r.arrayBuffer();
      return new Uint8Array(buf);
    }
    if (!state.fileId) throw new Error("Missing fileId");
    const token = getToken();
    const url = "/api/vault/file-proxy/" + encodeURIComponent(state.fileId);
    const r = await fetch(url, {
      method: "GET",
      headers: token ? { "Authorization": "Bearer " + token } : {},
      credentials: "same-origin"
    });
    if (!r.ok) {
      const txt = await r.text().catch(()=>"");
      throw new Error("Failed to load PDF (" + r.status + "). " + (txt || ""));
    }
    return new Uint8Array(await r.arrayBuffer());
  }

  function _looksLikePdf(u8){
    try{
      if (!u8 || u8.length < 4) return false;
      return (u8[0] === 0x25 && u8[1] === 0x50 && u8[2] === 0x44 && u8[3] === 0x46); // %PDF
    }catch(_e){
      return false;
    }
  }

  
  // -------------------------------
  // Encrypted PDF password prompt (main preview)
  // -------------------------------
  function _isPasswordError(e){
    try{
      if (!e) return false;
      if (e.name === "PasswordException") return true;
      const msg = String(e.message || e);
      return msg.includes("PasswordException") || /password/i.test(msg);
    }catch(_e){ return false; }
  }

  function _isIncorrectPassword(e){
    try{
      const msg = String((e && (e.message||e)) || "");
      return /incorrect/i.test(msg);
    }catch(_e){ return false; }
  }

  function promptOpenPassword(reason){
    return new Promise((resolve) => {
      const modal = $("psOpenPwModal");
      const inp = $("psOpenPwInput");
      const msg = $("psOpenPwMsg");
      const err = $("psOpenPwErr");
      const btnOk = $("psOpenPwOk");
      const btnCancel = $("psOpenPwCancel");
      const btnClose = $("psOpenPwClose");

      if (!modal || !inp || !btnOk || !btnCancel || !btnClose) {
        // Fallback to native prompt if modal missing
        const pw = window.prompt(reason === "incorrect" ? "Incorrect password. Enter password:" : "Enter PDF password:");
        resolve(pw ? String(pw) : null);
        return;
      }

      // reset
      inp.value = "";
      err.style.display = (reason === "incorrect") ? "block" : "none";
      msg.textContent = "This PDF is encrypted. Enter the password to open it.";

      modal.style.display = "flex";
      setTimeout(() => { try{ inp.focus(); }catch(_e){} }, 20);

      let done = false;
      const cleanup = () => {
        if (done) return;
        done = true;
        modal.style.display = "none";
        btnOk.removeEventListener("click", onOk);
        btnCancel.removeEventListener("click", onCancel);
        btnClose.removeEventListener("click", onCancel);
        inp.removeEventListener("keydown", onKey);
      };

      const onOk = () => {
        const pw = String(inp.value || "").trim();
        cleanup();
        resolve(pw || null);
      };
      const onCancel = () => {
        cleanup();
        resolve(null);
      };
      const onKey = (ev) => {
        if (ev.key === "Enter") { ev.preventDefault(); onOk(); }
        if (ev.key === "Escape") { ev.preventDefault(); onCancel(); }
      };

      btnOk.addEventListener("click", onOk);
      btnCancel.addEventListener("click", onCancel);
      btnClose.addEventListener("click", onCancel);
      inp.addEventListener("keydown", onKey);
    });
  }

  async function loadPdfWithPasswordPrompt(bytesMaster){
    // IMPORTANT: PDF.js may transfer (detach) the underlying ArrayBuffer to the worker.
    // If we retry after a password prompt, we must provide a FRESH copy each attempt.
    const master = (bytesMaster instanceof Uint8Array)
      ? bytesMaster
      : new Uint8Array(bytesMaster || []);

    let pw = String(state._openPw || "").trim();
    for (let attempt = 0; attempt < 6; attempt++){
      try{
        const data = master.slice(); // fresh copy for this attempt
        const opts = { data };
        if (pw) opts.password = pw;

        const task = pdfjsLib.getDocument(opts);
        const pdf = await task.promise;

        // If a password was provided or requested, the original bytes are encrypted.
        if (pw) state._isEncryptedMaster = true;

        // store for subsequent loads in this session
        state._openPw = pw;
        return pdf;
      }catch(e){
        if (!_isPasswordError(e)) throw e;
        state._isEncryptedMaster = true;
        const reason = _isIncorrectPassword(e) ? "incorrect" : "need";
        const nextPw = await promptOpenPassword(reason);
        if (!nextPw) throw new Error("Password required to open this PDF.");
        pw = String(nextPw).trim();
      }
    }
    throw new Error("Failed to open encrypted PDF (too many attempts).");
  }

  async function ensureBasePdfBytes(){
    // Some auth/proxy errors can return HTML/JSON. That breaks PDFLib with "No PDF header found".
    if (_looksLikePdf(state.pdfBytes)) return;

    // Attempt a fresh refetch once
    if (state.fileId){
      const fresh = await fetchPdfBytes();
      if (_looksLikePdf(fresh)){
        state.pdfBytes = fresh;
        state._pdfBytesMaster = (state.pdfBytes instanceof Uint8Array) ? new Uint8Array(state.pdfBytes) : new Uint8Array(state.pdfBytes || []);
        try{ state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster); }catch(_e){}
        return;
      }
    }

    let preview = "";
    try{
      const src = (state.pdfBytes instanceof Uint8Array) ? state.pdfBytes : new Uint8Array(state.pdfBytes || []);
      preview = new TextDecoder().decode(src.slice(0, 200));
    }catch(_e){}
    throw new Error("Base document isn't a valid PDF (no %PDF header). " + (preview ? ("Preview: " + preview.replace(/\s+/g, " ").slice(0, 140)) : ""));
  }
  async function preparePdfBytesWithQpdf(bytesUint8, password){
  const fd = new FormData();
  const name = state.filename || "document.pdf";
  fd.append("file", new Blob([bytesUint8], { type: "application/pdf" }), name);
  if (password) fd.append("password", password || "");
  const res = await fetch("/api/pdfstudio/prepare", { method: "POST", body: fd });
  if (!res.ok){
    let j = null;
    let t = "";
    try{ j = await res.json(); }catch(_e){ try{ t = await res.text(); }catch(__e){} }
    const msg = (j && (j.error || j.details)) ? String(j.error || j.details) : (t ? String(t).slice(0, 220) : "");
    const err = new Error((j && j.error) ? String(j.error) : ("Prepare failed. " + msg));
    if (j && j.code) err.code = j.code;
    throw err;
  }
  const ab = await res.arrayBuffer();
  return new Uint8Array(ab);
}

async function decryptPdfBytesWithQpdf(bytesUint8, password){
  // Back-compat wrapper used throughout PDFStudio: decrypt + normalize to be pdf-lib friendly.
  return await preparePdfBytesWithQpdf(bytesUint8, password);
}


  function _isPdfLibEncryptedError(err){
    const s = String(err && (err.message || err) || "");
    return /encrypted|password/i.test(s);
  }

  async function ensureEditablePdfBytes(){
  // Ensure we have a valid PDF byte buffer before PDF-lib operations (export, combine, delete, reorder)
  await ensureBasePdfBytes();

  const { PDFDocument } = PDFLib;

  // If PDF-lib can already load it, we're good
  try{
    await PDFDocument.load(state.pdfBytes);
    return;
  }catch(e){
    // If it looks encrypted (or we know the master is encrypted), we'll ask for a password and prepare it.
    const src = (state._pdfBytesMaster instanceof Uint8Array)
      ? state._pdfBytesMaster
      : new Uint8Array(state.pdfBytes || []);

    const isEncrypted = !!(state._isEncryptedMaster || _isPdfLibEncryptedError(e));

    if (isEncrypted){
      let pw = String(state._openPw || "").trim();
      let lastErr = e;

      for (let attempt = 0; attempt < 5; attempt++){
        if (!pw){
          const nextPw = await promptOpenPassword(attempt ? "incorrect" : "need");
          if (!nextPw) throw new Error("Password required to decrypt this PDF.");
          pw = String(nextPw).trim();
        }

        showStatus("Decrypting‚Ä¶", "ok", 0);
        try{
          const prepared = await preparePdfBytesWithQpdf(src, pw);
          state.pdfBytes = prepared;
          state._pdfBytesMaster = prepared.slice();
          state._isEncryptedMaster = false;
          state._openPw = pw;

          // Validate load
          await PDFDocument.load(state.pdfBytes);

          showStatus("Decrypted.", "ok", 1200);
          return;
        }catch(err){
          lastErr = err;
          const msg = String(err && (err.message || err) || "");
          const code = err && err.code ? String(err.code) : "";

          // Invalid/required password -> reprompt
          if (code === "INVALID_PASSWORD" || /invalid password/i.test(msg) || /password.*invalid/i.test(msg)){
            pw = "";
            continue;
          }
          if (code === "PASSWORD_REQUIRED" || /password required/i.test(msg)){
            pw = "";
            continue;
          }

          throw err;
        }
      }

      throw lastErr;
    }

    // Not encrypted but pdf-lib can't parse it (object streams / odd PDFs). Normalize via qpdf.
    showStatus("Preparing‚Ä¶", "ok", 0);
    const prepared = await preparePdfBytesWithQpdf(src, "");
    state.pdfBytes = prepared;
    state._pdfBytesMaster = prepared.slice();
    state._isEncryptedMaster = false;

    // Validate load
    await PDFDocument.load(state.pdfBytes);

    showStatus("Prepared.", "ok", 900);
    return;
  }
}


  function wireHostBridge(){
    if (state._hostBridgeWired) return;
    state._hostBridgeWired = true;

    // Let the parent know we're ready to receive bytes.
    hostPost({ type: "PDFSTUDIO_READY" });

    window.addEventListener("message", async (ev) => {
      const d = ev.data || {};
      const t = d.type;
      if (!t) return;

      // Accept same-origin messages (and allow 'null' for some local dev setups)
      try{
        if (ev.origin && ev.origin !== "null" && ev.origin !== window.location.origin) return;
      }catch(_e){}

      // Parent asks for current status
      if (t === "PDFSTUDIO_STATUS"){
        hostPost({ type: "PDFSTUDIO_STATUS", text: (state.pdf ? "Loaded" : "Ready") });
        return;
      }

      // Open a PDF from raw bytes
      if (t === "PDFSTUDIO_OPEN_BYTES"){
        try{
          if (!d.bytes) throw new Error("Missing PDF bytes");
          const name = d.name || d.filename || "document.pdf";
          const u8 = (d.bytes instanceof Uint8Array) ? d.bytes : new Uint8Array(d.bytes);
          await openPdfFromBytes(u8, name);
        }catch(e){
          console.error(e);
          showStatus(String(e?.message || e || "Failed to open PDF."), "err", 7000);
          hostPost({ type: "PDFSTUDIO_STATUS", text: "Error" });
        }
        return;
      }

      // Append additional PDFs to the current document (stack/\"combine\")
      if (t === "PDFSTUDIO_MERGE_FILES"){
        try{
          const files = Array.isArray(d.files) ? d.files : [];
          if (!files.length) return;
          await appendPdfFiles(files.map(f => ({ name: f.name || f.filename || "file.pdf", bytes: f.bytes })));
        }catch(e){
          console.error(e);
          showStatus(String(e?.message || e || "Failed to combine PDFs."), "err", 7000);
        }
        return;
      }

      // Export edited PDF bytes back to the parent
      if (t === "PDFSTUDIO_EXPORT"){
        try{
          if (!state.pdf) throw new Error("No PDF loaded.");
          const out = await buildEditedPdfBytes({ silent: true });
          const ab = out.buffer.slice(out.byteOffset, out.byteOffset + out.byteLength);
          ev.source && ev.source.postMessage({
            type: "PDFSTUDIO_EXPORT_RESULT",
            ok: true,
            nonce: d.nonce || null,
            bytes: ab,
            mime: "application/pdf",
            filename: (state.filename || "edited.pdf")
          }, "*", [ab]);
        }catch(e){
          console.error(e);
          ev.source && ev.source.postMessage({
            type: "PDFSTUDIO_EXPORT_RESULT",
            ok: false,
            nonce: d.nonce || null,
            error: String(e?.message || e || "Export failed.")
          }, "*");
        }
        return;
      }
    });
  }


  async function hydrateFromVaultMetaIfNeeded(){
    try{
      if (!state.fileId) return;
      const hasFolderParam = (getParamMaybe("folder") !== null) || (getParamMaybe("folderPath") !== null);
      const hasNameParam = Boolean(getParamMaybe("name")) || Boolean(getParamMaybe("filename")) || Boolean(getParamMaybe("title")) || Boolean(getParamMaybe("name"));
      // Only hydrate if key info is missing
      if (hasFolderParam && state.folderKey !== null && state.folderKey !== undefined && state.filename) return;

      const token = getToken();
      const r = await fetch("/api/vault/meta/" + encodeURIComponent(state.fileId), {
        method: "GET",
        headers: token ? { "Authorization": "Bearer " + token } : {},
        credentials: "same-origin"
      });
      const j = await r.json().catch(()=>null);
      if (!r.ok || !j || !j.ok) return;

      if (!hasFolderParam) {
        const fp = (j.folderPath === "_Trash") ? "" : (j.folderPath ?? "");
        state.folderKey = fp;
      }
      if (!state.filename) {
        state.filename = (j.name || j.filename || state.filename || "").toString();
      }
    }catch(_e){}
  }


  async function init(){
    try{      wireHostBridge();
      ensureUiReady();
      window.setText("docSub", state.fileId ? "Loading PDF‚Ä¶" : "Ready.");
      await hydrateFromVaultMetaIfNeeded();
      if (!state.fileId) {
        // Guest mode: open from blobUrl if present, otherwise wait for host messages
        if (state.blobUrl){
          showStatus("Loading PDF‚Ä¶", "ok", 0);
          const ab = await fetch(state.blobUrl).then(r => r.arrayBuffer());
          await openPdfFromBytes(new Uint8Array(ab), state.filename || "document.pdf");
          return;
        }
        showStatus("Ready. Use Upload/Add PDFs above.", "ok", 2200);
        hostPost({ type: "PDFSTUDIO_READY" });
        return;
      }
      await hydrateVaultMeta();
      state.pdfBytes = await fetchPdfBytes();
      state._pdfBytesMaster = (state.pdfBytes instanceof Uint8Array) ? new Uint8Array(state.pdfBytes) : new Uint8Array(state.pdfBytes || []);
      state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster);

      // derive title if not provided
      window.setText("docTitle", state.filename ? state.filename : "PDFStudio");
      window.setText("docSub", `${state.pdf.numPages} pages`);

      pushHistory(); // base state

      await renderAll();
      // Host integration (Office wrapper): allow parent to request an export of the edited PDF bytes
      if (!state._hostExportWired){
        state._hostExportWired = true;
        window.addEventListener("message", async (ev) => {
          const d = ev.data || {};
          if (!d.type) return;

          if (d.type === "PDFSTUDIO_EXPORT"){
            try{
              const out = await buildEditedPdfBytes({ silent: true });
              const ab = out.buffer.slice(out.byteOffset, out.byteOffset + out.byteLength);
              ev.source && ev.source.postMessage({
                type: "PDFSTUDIO_EXPORT_RESULT",
                ok: true,
                nonce: d.nonce || null,
                bytes: ab,
                mime: "application/pdf",
                filename: (state.filename || "edited.pdf")
              }, "*", [ab]);
            }catch(e){
              console.error(e);
              ev.source && ev.source.postMessage({
                type: "PDFSTUDIO_EXPORT_RESULT",
                ok: false,
                nonce: d.nonce || null,
                error: String(e?.message || e || "Export failed.")
              }, "*");
            }
            return;
          }

          if (d.type === "PDFSTUDIO_OPEN_BYTES"){
            const bytes = d.bytes;
            const name = d.name || d.filename || "document.pdf";
            try{
              await openPdfFromBytes(new Uint8Array(bytes), name);
            }catch(e){
              console.error(e);
              showStatus(String(e?.message || e || "Failed to open PDF."), "err", 7000);
            }
            return;
          }

          if (d.type === "PDFSTUDIO_MERGE_FILES"){
            // "Combine" behavior: append selected PDFs to the current document (stack them)
            const files = Array.isArray(d.files) ? d.files : [];
            if (!files.length) return;
            try{
              await appendPdfFiles(files);
            }catch(e){
              console.error(e);
              showStatus(String(e?.message || e || "Failed to combine PDFs."), "err", 7000);
            }
            return;
          }

          if (d.type === "PDFSTUDIO_STATUS"){
            hostPost({ type: "PDFSTUDIO_STATUS", text: (state.pdf ? "Loaded" : "Ready") });
            return;
          }
        });
      }

updatePropsUI();
      wireUI();
      wireDocForgeUI();
      initFieldsDropdown();
      showStatus("Ready.", "ok", 1200);
    }catch(e){
      window.setText("docSub", "Failed to load.");
      showStatus(String(e.message || e), "err", 9000);
      console.error(e);
    }
  }

  async function renderAll(){
    state.pageViews = [];
    $("viewport").innerHTML = "";
    $("thumbs").innerHTML = "";

    for (let p = 1; p <= state.pdf.numPages; p++){
      const page = await state.pdf.getPage(p);
      const viewport = page.getViewport({ scale: state.zoom });

    const pageDiv = document.createElement("div");
      pageDiv.className = "page";
      pageDiv.dataset.page = String(p);

      const canvas = document.createElement("canvas");
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      // Overlay
      const overlay = document.createElement("div");
      overlay.className = "overlay";
      overlay.dataset.page = String(p);

      // Vector layer (svg)
      const vecLayer = document.createElement("div");
      vecLayer.className = "vec";
      vecLayer.dataset.page = String(p);
      vecLayer.innerHTML = `<svg width="${viewport.width}" height="${viewport.height}" viewBox="0 0 ${viewport.width} ${viewport.height}"></svg>`;

      pageDiv.appendChild(canvas);
      pageDiv.appendChild(vecLayer);
      pageDiv.appendChild(overlay);
      $("viewport").appendChild(pageDiv);

      const ctx = canvas.getContext("2d", { alpha: false });
      await page.render({ canvasContext: ctx, viewport }).promise;

      // Thumb (click + delete + drag reorder)
      const thumb = document.createElement("div");
      thumb.className = "thumb" + (p === 1 ? " active" : "");
      thumb.dataset.page = String(p);

      const meta = document.createElement("div");
      meta.className = "thumb-meta";
      const num = document.createElement("span");
      num.className = "thumb-num";
      num.textContent = String(p);
      const del = document.createElement("button");
      del.className = "thumb-del";
      del.type = "button";
      del.title = "Delete page";
      del.textContent = "√ó";
      del.addEventListener("click", (e) => { e.stopPropagation(); deletePage(p); });
      meta.appendChild(num);
      meta.appendChild(del);
      thumb.appendChild(meta);

      const tcanvas = document.createElement("canvas");
      const tscale = Math.min(0.3, 150 / Math.max(viewport.width, viewport.height));
      const tv = page.getViewport({ scale: tscale });
      tcanvas.width = tv.width;
      tcanvas.height = tv.height;
      thumb.appendChild(tcanvas);
      $("thumbs").appendChild(thumb);
      await page.render({ canvasContext: tcanvas.getContext("2d", { alpha:false }), viewport: tv }).promise;

      const pv = { pageNum: p, viewport, page, pageDiv, canvas, overlay, vecLayer };
      state.pageViews.push(pv);

      // attach events on overlay
      overlay.addEventListener("mousedown", (ev) => onPointerDown(ev, pv));
      overlay.addEventListener("mousemove", (ev) => onPointerMove(ev, pv));
      overlay.addEventListener("mouseup", (ev) => onPointerUp(ev, pv));
      overlay.addEventListener("mouseleave", (ev) => onPointerUp(ev, pv));
      overlay.addEventListener("dblclick", (ev) => onDoubleClick(ev, pv));

      thumb.addEventListener("click", () => scrollToPage(p));
      setupThumbDnD(thumb);
    }

    setEdit($("editToggle").checked);
    renderOverlays();
  }

  function scrollToPage(p){
    const el = qs(`.page[data-page="${p}"]`);
    if (!el) return;
    qsa(".thumb").forEach(t => t.classList.toggle("active", t.dataset.page === String(p)));
    el.scrollIntoView({ behavior: "smooth", block: "start" });
  }

  // -------------------------------
  // Overlay Objects
  // normalized coordinates: nx, ny, nw, nh (top-left based)
  // for lines: nx1, ny1, nx2, ny2
  // for draw: points: [{x,y}]
  // -------------------------------
  function clearSelection(){
    state.selectedIds = [];
    state.selectedId = null;
    qsa(".ann").forEach(el => el.classList.remove("selected"));
    updatePropsUI();
    try{ dfUpdateRightPanel(true); }catch(e){}
  }

  function select(id, additive=false){
    if (!id) return;

    if (!additive){
      state.selectedIds = [id];
    } else {
      const o = objById(id);
      if (state.selectedIds.length){
        const base = objById(state.selectedIds[0]);
        if (base && o && base.page !== o.page){
          state.selectedIds = [id];
        } else {
          const idx = state.selectedIds.indexOf(id);
          if (idx >= 0) state.selectedIds.splice(idx, 1);
          else state.selectedIds.push(id);

          if (state.selectedIds.length === 0){
            state.selectedId = null;
            qsa(".ann").forEach(el => el.classList.remove("selected"));
            updatePropsUI();
            try{ dfUpdateRightPanel(true); }catch(e){}
            return;
          }
        }
      } else {
        state.selectedIds = [id];
      }
    }

    state.selectedId = state.selectedIds[state.selectedIds.length - 1] || null;

    const set = new Set(state.selectedIds);
    qsa(".ann").forEach(el => el.classList.toggle("selected", set.has(el.dataset.id)));
    updatePropsUI();
    try{ dfUpdateRightPanel(true); }catch(e){}
  }

function objById(id){ return state.objects.find(o => o.id === id); }


  function currentStyleTarget(){
    return state.selectedId ? objById(state.selectedId) : null;
  }

  function updatePropsUI(){
    const o = currentStyleTarget();
    const src = o ? {
      fontFamily: o.fontFamily ?? state.defaults.fontFamily,
      fontSize: o.fontSize ?? state.defaults.fontSize,
      bold: o.bold ?? state.defaults.bold,
      italic: o.italic ?? state.defaults.italic,
      textColor: o.textColor ?? state.defaults.textColor,
      fillColor: o.fillColor ?? state.defaults.fillColor,
      fillOpacity: (o.fillOpacity != null ? o.fillOpacity : state.defaults.fillOpacity),
      strokeColor: o.strokeColor ?? state.defaults.strokeColor,
      strokeOpacity: (o.strokeOpacity != null ? o.strokeOpacity : state.defaults.strokeOpacity),
      strokeWidth: (o.strokeWidth != null ? o.strokeWidth : state.defaults.strokeWidth),
      highlightColor: o.highlightColor ?? state.defaults.highlightColor,
      highlightOpacity: (o.highlightOpacity != null ? o.highlightOpacity : state.defaults.highlightOpacity)
    } : state.defaults;

    if ($("propFont")) $("propFont").value = src.fontFamily || "Helvetica";
    if ($("propSize")) $("propSize").value = String(src.fontSize || 16);
    if ($("propBold")) $("propBold").checked = !!src.bold;
    if ($("propItalic")) $("propItalic").checked = !!src.italic;

    if ($("propTextColor")) $("propTextColor").value = src.textColor || "#000000";
    if ($("propFillColor")) $("propFillColor").value = src.fillColor || "#000000";
    if ($("propFillOpacity")) $("propFillOpacity").value = String(src.fillOpacity ?? 0.12);

    if ($("propStrokeColor")) $("propStrokeColor").value = src.strokeColor || "#000000";
    if ($("propStrokeOpacity")) $("propStrokeOpacity").value = String(src.strokeOpacity ?? 0.90);
    if ($("propStrokeWidth")) $("propStrokeWidth").value = String(src.strokeWidth ?? 2);

    if ($("propHiColor")) $("propHiColor").value = src.highlightColor || "#000000";
    if ($("propHiOpacity")) $("propHiOpacity").value = String(src.highlightOpacity ?? 0.28);
  }

  function applyPropChange(key, value){
    const o = currentStyleTarget();
    if (o){
      pushHistory();
      o[key] = value;
    } else {
      state.defaults[key] = value;
    }
    renderOverlays();
  }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }

  function xyToNorm(pv, clientX, clientY){
    const r = pv.overlay.getBoundingClientRect();
    const x = (clientX - r.left) / r.width;
    const y = (clientY - r.top) / r.height;
    return { x: clamp01(x), y: clamp01(y), w: r.width, h: r.height, rect: r };
  }

  function createRect(type, pv, start, end, extra={}){
    const x1 = Math.min(start.x, end.x);
    const y1 = Math.min(start.y, end.y);
    const x2 = Math.max(start.x, end.x);
    const y2 = Math.max(start.y, end.y);
    const o = {
      id: uid(),
      type,
      page: pv.pageNum,
      nx: snap(x1),
      ny: snap(y1),
      nw: snap(Math.max(0.002, x2 - x1)),
      nh: snap(Math.max(0.002, y2 - y1)),
      ...extra
    };
    if (type === "highlight"){
      o.highlightColor = o.highlightColor || state.defaults.highlightColor;
      o.highlightOpacity = (o.highlightOpacity != null ? o.highlightOpacity : state.defaults.highlightOpacity);
    }
    state.objects.push(o);
    return o;
  }

  function createText(type, pv, pos, text){
    const o = {
      id: uid(),
      type,
      page: pv.pageNum,
      nx: snap(pos.x),
      ny: snap(pos.y),
      nw: 0.24,
      nh: 0.06,
      text: text || "Text",
      fontSize: state.defaults.fontSize,
      fontFamily: state.defaults.fontFamily,
      bold: state.defaults.bold,
      italic: state.defaults.italic,
      textColor: state.defaults.textColor,
      fillColor: state.defaults.fillColor,
      fillOpacity: state.defaults.fillOpacity,
      strokeColor: state.defaults.strokeColor,
      strokeOpacity: state.defaults.strokeOpacity
    };
    state.objects.push(o);
    return o;
  }

  function createStamp(pv, pos, symbol){
    const o = {
      id: uid(),
      type: "stamp",
      stamp: symbol,
      page: pv.pageNum,
      nx: snap(pos.x),
      ny: snap(pos.y),
      nw: 0.06,
      nh: 0.06,
      fontSize: Math.max(18, state.defaults.fontSize + 6)
    };
    state.objects.push(o);
    return o;
  }

  function createImage(pv, pos, dataUrl, kind="image"){
    const o = {
      id: uid(),
      type: kind,
      page: pv.pageNum,
      nx: snap(pos.x),
      ny: snap(pos.y),
      nw: 0.28,
      nh: 0.18,
      dataUrl
    };
    state.objects.push(o);
    return o;
  }

  function createLine(type, pv, start, end){
    const o = {
      id: uid(),
      type,
      page: pv.pageNum,
      nx1: snap(start.x),
      ny1: snap(start.y),
      nx2: snap(end.x),
      ny2: snap(end.y),
      strokeWidth: state.defaults.strokeWidth
    };
    state.objects.push(o);
    return o;
  }

  function createDraw(pv, points){
    const o = {
      id: uid(),
      type: "draw",
      page: pv.pageNum,
      points: points.map(pt => ({ x: snap(pt.x), y: snap(pt.y) })),
      strokeWidth: state.defaults.strokeWidth
    };
    state.objects.push(o);
    return o;
  }

  function renderOverlays(){
    const _dfTabMap = state.showTabOrder ? dfBuildTabOrderMap() : null;
    // Clear DOM overlays
    for (const pv of state.pageViews){
      pv.overlay.innerHTML = "";
      const svg = qs("svg", pv.vecLayer);
      svg.innerHTML = "";
    }

    // Draw alignment guides (no-break; purely visual)
    for (const pv of state.pageViews){
      const g = state.guidesByPage?.[pv.pageNum];
      if (!g) continue;
      const svg = qs("svg", pv.vecLayer);
      const W = pv.viewport?.width || 1;
      const H = pv.viewport?.height || 1;

      const xs = Array.isArray(g.xs) ? g.xs : (g.x != null ? [g.x] : []);
      const ys = Array.isArray(g.ys) ? g.ys : (g.y != null ? [g.y] : []);
      for (const x of xs){
        const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
        ln.setAttribute("class","df-guide");
        ln.setAttribute("x1", String(x*W)); ln.setAttribute("x2", String(x*W));
        ln.setAttribute("y1","0"); ln.setAttribute("y2", String(H));
        svg.appendChild(ln);
      }
      for (const y of ys){
        const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
        ln.setAttribute("class","df-guide");
        ln.setAttribute("y1", String(y*H)); ln.setAttribute("y2", String(y*H));
        ln.setAttribute("x1","0"); ln.setAttribute("x2", String(W));
        svg.appendChild(ln);
      }
    }

    // Render rect-like/text/image/note/table objects as HTML
    for (const o of state.objects){
      const pv = state.pageViews.find(p => p.pageNum === o.page);
      if (!pv) continue;

      if (o.type === "line" || o.type === "arrow" || o.type === "draw") continue; // svg layer

      const el = document.createElement("div");
      el.className = "ann";
      el.dataset.id = o.id;

      // Position
      if (o.nx != null){
        el.style.left = (o.nx * 100) + "%";
        el.style.top = (o.ny * 100) + "%";
        el.style.width = (o.nw * 100) + "%";
        el.style.height = (o.nh * 100) + "%";
      }

      // Type styling/content
      if (o.type === "text"){
        el.classList.add("text");
        el.textContent = o.text || "";
        el.style.fontSize = (o.fontSize || state.defaults.fontSize) + "px";
      } else if (o.type === "textbox" || o.type === "field"){
        el.classList.add("textbox");
        el.textContent = o.text || "";
        el.style.fontSize = (o.fontSize || state.defaults.fontSize) + "px";
      } else if (o.type === "highlight"){
        el.classList.add("highlight");
      } else if (o.type === "blackout"){
        el.classList.add("blackout");
      } else if (o.type === "stamp"){
        el.classList.add("stamp");
        el.textContent = o.stamp || "‚úì";
        el.style.fontSize = (o.fontSize || 24) + "px";
        el.style.display = "flex";
        el.style.alignItems = "center";
        el.style.justifyContent = "center";
      } else if (o.type === "note"){
        el.classList.add("note");
        el.innerHTML = `<div style="font-weight:900; margin-bottom:4px;">üóíÔ∏è Note</div><div style="font-size:0.86rem; color: rgba(255,255,255,0.9);">${escapeHtml(o.text||"")}</div>`;
      } else if (o.type === "date"){
        el.classList.add("text");
        el.textContent = o.text || "";
        el.style.fontSize = (o.fontSize || state.defaults.fontSize) + "px";
      } else if (o.type === "table"){
        el.classList.add("textbox");
        const rows = Math.max(1, Number(o.rows||2));
        const cols = Math.max(1, Number(o.cols||2));
        const tbl = document.createElement("div");
        tbl.style.display = "grid";
        tbl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        tbl.style.width = "100%";
        tbl.style.height = "100%";
        tbl.style.gap = "0";
        tbl.style.border = "1px solid rgba(255,255,255,0.20)";
        tbl.style.borderRadius = "6px";
        tbl.style.overflow = "hidden";
        for (let i=0;i<rows*cols;i++){
          const c = document.createElement("div");
          c.style.borderRight = ((i % cols) !== cols-1) ? "1px solid rgba(255,255,255,0.18)" : "none";
          c.style.borderBottom = (Math.floor(i/cols) !== rows-1) ? "1px solid rgba(255,255,255,0.18)" : "none";
          c.style.minHeight = "10px";
          tbl.appendChild(c);
        }
        el.appendChild(tbl);
      } else if (o.type === "image" || o.type === "sign"){
        el.classList.add("image");
        const img = document.createElement("img");
        img.src = o.dataUrl || "";
        el.appendChild(img);
      } else if (o.type === "initials"){
        el.classList.add("stamp");
        el.textContent = o.text || "DK";
        el.style.fontSize = (o.fontSize || 26) + "px";
        el.style.display = "flex";
        el.style.alignItems = "center";
        el.style.justifyContent = "center";
      } else {
        el.classList.add("textbox");
        el.textContent = o.type;
      }

      // Apply per-object styles (or defaults)
      const textColor = (o.textColor || state.defaults.textColor);
      const fillColor = (o.fillColor || state.defaults.fillColor);
      const strokeColor = (o.strokeColor || state.defaults.strokeColor);
      const fillOpacity = (o.fillOpacity != null ? o.fillOpacity : state.defaults.fillOpacity);
      const strokeOpacity = (o.strokeOpacity != null ? o.strokeOpacity : state.defaults.strokeOpacity);
      const fontFamily = (o.fontFamily || state.defaults.fontFamily);
      if (o.type === "field" || o.type === "text" || o.type === "textbox" || o.type === "date" || o.type === "initials" || o.type === "stamp"){
        el.style.color = withAlpha(textColor, 0.95);
        el.style.fontFamily = cssFont(fontFamily);
        if (o.bold) el.style.fontWeight = "800";
        if (o.italic) el.style.fontStyle = "italic";
      }
      if (o.type === "textbox" || o.type === "field"){
        el.style.background = withAlpha(fillColor, fillOpacity);
        el.style.borderColor = withAlpha(strokeColor, strokeOpacity);
      }
      if (o.type === "highlight"){
        const hc = (o.highlightColor || state.defaults.highlightColor);
        const ho = (o.highlightOpacity != null ? o.highlightOpacity : state.defaults.highlightOpacity);
        el.style.background = withAlpha(hc, ho);
        el.style.borderColor = withAlpha(hc, Math.min(1, ho + 0.07));
      }
      if (o.type === "note"){
        const nc = (o.noteColor || state.defaults.noteColor);
        const no = (o.noteOpacity != null ? o.noteOpacity : state.defaults.noteOpacity);
        el.style.background = withAlpha(nc, no);
        el.style.borderColor = withAlpha(nc, Math.min(1, no + 0.17));
      }

      // tab order badge (DocForge v9)
      if (_dfTabMap && o.type === "field"){
        const b = document.createElement("div");
        b.className = "df-tab-badge";
        b.textContent = String(_dfTabMap.get(o.id) || "");
        el.appendChild(b);
      }

      // selection + handles
      const handles = ["tl","tr","bl","br"].map(c => {
        const h = document.createElement("div");
        h.className = "handle " + c;
        h.dataset.corner = c;
        el.appendChild(h);
        return h;
      });

      el.addEventListener("mousedown", (ev) => {
        if (!state.edit) return;
        ev.stopPropagation();
        const targetHandle = ev.target && ev.target.classList && ev.target.classList.contains("handle") ? ev.target : null;
        const corner = targetHandle ? targetHandle.dataset.corner : null;

        select(o.id, ev.shiftKey);
        if (state.tool === "erase") {
          pushHistory();
          state.objects = state.objects.filter(x => x.id !== o.id);
          clearSelection();
          renderOverlays();
          return;
        }

        const pos = xyToNorm(pv, ev.clientX, ev.clientY);
        state.dragging = {
          id: o.id,
          startX: pos.x,
          startY: pos.y,
          orig: JSON.parse(JSON.stringify(o)),
          mode: corner ? "resize" : "move",
          corner
        };
      });

      el.addEventListener("click", (ev) => {
        if (!state.edit) return;
        ev.stopPropagation();
        select(o.id, ev.shiftKey);
      });

      pv.overlay.appendChild(el);
    }

    // Render vector objects into SVG
    for (const o of state.objects){
      const pv = state.pageViews.find(p => p.pageNum === o.page);
      if (!pv) continue;
      const svg = qs("svg", pv.vecLayer);
      const W = pv.viewport.width, H = pv.viewport.height;

      if (o.type === "line" || o.type === "arrow"){
        const x1 = (o.nx1||0) * W, y1 = (o.ny1||0) * H;
        const x2 = (o.nx2||0) * W, y2 = (o.ny2||0) * H;
        const line = document.createElementNS("http://www.w3.org/2000/svg","line");
        line.setAttribute("x1", x1); line.setAttribute("y1", y1);
        line.setAttribute("x2", x2); line.setAttribute("y2", y2);
        line.setAttribute("stroke", withAlpha(o.strokeColor || state.defaults.strokeColor, (o.strokeOpacity != null ? o.strokeOpacity : state.defaults.strokeOpacity)));
        line.setAttribute("stroke-width", String(Math.max(1, o.strokeWidth||2)));
        line.setAttribute("stroke-linecap", "round");
        svg.appendChild(line);

        if (o.type === "arrow"){
          // add arrow head
          const dx = x2 - x1, dy = y2 - y1;
          const len = Math.max(1, Math.hypot(dx, dy));
          const ux = dx/len, uy = dy/len;
          const size = 10 + 2*(o.strokeWidth||2);
          const px = -uy, py = ux;
          const ax = x2 - ux*size, ay = y2 - uy*size;
          const p1x = ax + px*(size*0.45), p1y = ay + py*(size*0.45);
          const p2x = ax - px*(size*0.45), p2y = ay - py*(size*0.45);
          const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
          poly.setAttribute("points", `${x2},${y2} ${p1x},${p1y} ${p2x},${p2y}`);
          poly.setAttribute("fill", withAlpha(o.strokeColor || state.defaults.strokeColor, (o.strokeOpacity != null ? o.strokeOpacity : state.defaults.strokeOpacity)));
          svg.appendChild(poly);
        }
      }

      if (o.type === "draw"){
        const pts = (o.points||[]).map(pt => [pt.x*W, pt.y*H]);
        if (pts.length < 2) continue;
        const d = pts.map((p,i) => (i===0 ? `M ${p[0]} ${p[1]}` : `L ${p[0]} ${p[1]}`)).join(" ");
        const path = document.createElementNS("http://www.w3.org/2000/svg","path");
        path.setAttribute("d", d);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", withAlpha(o.strokeColor || state.defaults.strokeColor, (o.strokeOpacity != null ? o.strokeOpacity : state.defaults.strokeOpacity)));
        path.setAttribute("stroke-width", String(Math.max(1, o.strokeWidth||2)));
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        svg.appendChild(path);
      }
    }

    // Re-apply selection state
    if (state.selectedId){
      const el = qs(`.ann[data-id="${state.selectedId}"]`);
      if (!el) state.selectedId = null;
      else el.classList.add("selected");
    }

    setEdit(state.edit);
  }

  function escapeHtml(s){
    return String(s||"")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll("\"","&quot;").replaceAll("'","&#39;");
  }


  function cssFont(f){
    if (!f) return "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    if (f === "TimesRoman") return '"Times New Roman", Times, serif';
    if (f === "Courier") return '"Courier New", Courier, monospace';
    return 'Helvetica, Arial, system-ui';
  }

  function withAlpha(hex, alpha){
    const {r,g,b} = hexToRgb(hex || "#ffffff");
    return `rgba(${r},${g},${b},${clampNum(alpha,0,1)})`;
  }
  function hexToRgb(hex){
    let h = (hex||"").trim();
    if (!h) h = "#ffffff";
    if (h[0] != "#") h = "#" + h;
    if (h.length === 4){
      h = "#" + h[1]+h[1] + h[2]+h[2] + h[3]+h[3];
    }
    const n = parseInt(h.slice(1), 16);
    if (Number.isNaN(n)) return {r:255,g:255,b:255};
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgb01FromHex(hex){
    const {r,g,b} = hexToRgb(hex);
    return { r:r/255, g:g/255, b:b/255 };
  }
  // -------------------------------
  // Pointer handling (add/drag/draw)
  // -------------------------------
  function onPointerDown(ev, pv){
    if (!state.edit) return;
    // background click clears selection
    if (ev.target === pv.overlay){
      if (!ev.shiftKey) clearSelection();
    }
    const pos = xyToNorm(pv, ev.clientX, ev.clientY);

    // Form field placement
    if (isFieldTool(state.tool)) {
      pushHistory();
      const o = createField(state.tool, pv, pos);
      select(o.id);
      renderOverlays();
      return;
    }

    // Tool behaviors
    if (state.tool === "select") return;
    if (state.tool === "erase") return;

    pushHistory();

    if (state.tool === "text"){
      const t = prompt("Text:", "Text") ?? "";
      const o = createText("text", pv, pos, t);
      select(o.id);
      renderOverlays();
      return;
    }
    if (state.tool === "textbox"){
      const t = prompt("Text box:", "Text") ?? "";
      const o = createText("textbox", pv, pos, t);
      select(o.id);
      renderOverlays();
      return;
    }
    if (state.tool === "date"){
      const d = new Date();
      const txt = d.toLocaleDateString();
      const o = createText("date", pv, pos, txt);
      o.fontSize = state.defaults.fontSize;
      select(o.id);
      renderOverlays();
      return;
    }
    if (state.tool === "check") { const o = createStamp(pv, pos, "‚úì"); select(o.id); renderOverlays(); return; }
    if (state.tool === "cross") { const o = createStamp(pv, pos, "‚úó"); select(o.id); renderOverlays(); return; }
    if (state.tool === "circle") { const o = createStamp(pv, pos, "‚óØ"); select(o.id); renderOverlays(); return; }

    if (state.tool === "initials"){
      const val = (prompt("Initials:", "DK") || "").trim() || "DK";
      const o = {
        id: uid(),
        type: "initials",
        page: pv.pageNum,
        nx: snap(pos.x),
        ny: snap(pos.y),
        nw: 0.10,
        nh: 0.06,
        text: val,
        fontSize: Math.max(20, state.defaults.fontSize + 8)
      };
      state.objects.push(o);
      select(o.id);
      renderOverlays();
      return;
    }

    if (state.tool === "sticky"){
      const note = (prompt("Note:", "") || "").trim();
      const o = {
        id: uid(),
        type: "note",
        page: pv.pageNum,
        nx: snap(pos.x),
        ny: snap(pos.y),
        nw: 0.22,
        nh: 0.14,
        text: note
      };
      state.objects.push(o);
      select(o.id);
      renderOverlays();
      return;
    }

    if (state.tool === "table"){
      const rc = (prompt("Rows,Cols (e.g., 3,4):", "3,3") || "3,3").split(",");
      const rows = Math.max(1, parseInt(rc[0]||"3",10) || 3);
      const cols = Math.max(1, parseInt(rc[1]||"3",10) || 3);
      const o = {
        id: uid(),
        type: "table",
        page: pv.pageNum,
        nx: snap(pos.x),
        ny: snap(pos.y),
        nw: 0.42,
        nh: 0.22,
        rows, cols
      };
      state.objects.push(o);
      select(o.id);
      renderOverlays();
      return;
    }

    if (state.tool === "image") {
      // Choose an image for placement
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async () => {
        const f = input.files && input.files[0];
        if (!f) return;
        const dataUrl = await readAsDataURL(f);
        const o = createImage(pv, pos, dataUrl, "image");
        select(o.id);
        renderOverlays();
      };
      input.click();
      return;
    }

    if (state.tool === "sign") {
      // Place a signature image. Upload ONCE, then re-use on subsequent clicks.
      // Shift+click forces re-upload.
      const forceChoose = !!ev.shiftKey;
      if (state.signatureDataUrl && !forceChoose) {
        const o = createImage(pv, pos, state.signatureDataUrl, "sign");
        select(o.id);
        renderOverlays();
        return;
      }

      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async () => {
        const f = input.files && input.files[0];
        if (!f) return;
        const dataUrl = await readAsDataURL(f);
        state.signatureDataUrl = dataUrl;
        const o = createImage(pv, pos, dataUrl, "sign");
        select(o.id);
        renderOverlays();
      };
      input.click();
      return;
    }

    // drag-to-draw tools
    if (state.tool === "highlight" || state.tool === "blackout"){
      state.drawing = { mode: "rect", type: state.tool, start: pos, pv };
      return;
    }
    if (state.tool === "line" || state.tool === "arrow"){
      state.drawing = { mode: "line", type: state.tool, start: pos, pv };
      return;
    }
    if (state.tool === "draw"){
      state.drawing = { mode: "draw", points: [pos], pv };
      return;
    }
  }

  function onPointerMove(ev, pv){
    if (!state.edit) return;
    const pos = xyToNorm(pv, ev.clientX, ev.clientY);

    if (state.dragging){
      const o = objById(state.dragging.id);
      if (!o) return;
      const d = state.dragging;
      const dx = pos.x - d.startX;
      const dy = pos.y - d.startY;

      if (d.mode === "move"){
        let nx = snap(clamp01(d.orig.nx + dx));
        let ny = snap(clamp01(d.orig.ny + dy));

        // alignment snap + guides (piggybacks on Snap toggle)
        const as = dfAlignSnap(pv, o, nx, ny);
        nx = clamp01(as.nx);
        ny = clamp01(as.ny);

        if (as.guides){
          state.guidesByPage[pv.pageNum] = as.guides;
        } else {
          delete state.guidesByPage[pv.pageNum];
        }

        o.nx = nx;
        o.ny = ny;
      } else if (d.mode === "resize"){
        // resize: clear alignment guides (keeps behavior deterministic)
        delete state.guidesByPage[pv.pageNum];

        const minW = 0.01, minH = 0.01;
        const ox = d.orig.nx, oy = d.orig.ny, ow = d.orig.nw, oh = d.orig.nh;
        let nx=ox, ny=oy, nw=ow, nh=oh;
        const c = d.corner;
        if (c === "br"){ nw = Math.max(minW, ow + dx); nh = Math.max(minH, oh + dy); }
        if (c === "tr"){ nw = Math.max(minW, ow + dx); nh = Math.max(minH, oh - dy); ny = oy + dy; }
        if (c === "bl"){ nw = Math.max(minW, ow - dx); nh = Math.max(minH, oh + dy); nx = ox + dx; }
        if (c === "tl"){ nw = Math.max(minW, ow - dx); nh = Math.max(minH, oh - dy); nx = ox + dx; ny = oy + dy; }
        o.nx = snap(clamp01(nx));
        o.ny = snap(clamp01(ny));
        o.nw = snap(clamp01(nw));
        o.nh = snap(clamp01(nh));
      }

      renderOverlays();
      return;
    }

    if (state.drawing && state.drawing.pv.pageNum === pv.pageNum){
      if (state.drawing.mode === "rect"){
        // live preview: render a temporary box using selection id "__preview"
        const { start, type } = state.drawing;
        const tmpId = "__preview__";
        state.objects = state.objects.filter(o => o.id !== tmpId);
        const o = createRect(type, pv, start, pos, {});
        o.id = tmpId;
        renderOverlays();
        return;
      }
      if (state.drawing.mode === "line"){
        const { start, type } = state.drawing;
        const tmpId = "__preview__";
        state.objects = state.objects.filter(o => o.id !== tmpId);
        const o = createLine(type, pv, start, pos);
        o.id = tmpId;
        renderOverlays();
        return;
      }
      if (state.drawing.mode === "draw"){
        state.drawing.points.push(pos);
        // live preview path
        const tmpId = "__preview__";
        state.objects = state.objects.filter(o => o.id !== tmpId);
        const o = createDraw(pv, state.drawing.points);
        o.id = tmpId;
        renderOverlays();
        return;
      }
    }
  }

  function onPointerUp(ev, pv){
    if (!state.edit) return;

    if (state.dragging){
      // finish drag
      state.dragging = null;
      delete state.guidesByPage[pv.pageNum];
      renderOverlays();
      try{ pushHistory(); } catch(e){}
      showStatus("Updated.", "ok", 800);
      return;
    }

    if (state.drawing && state.drawing.pv.pageNum === pv.pageNum){
      const pos = xyToNorm(pv, ev.clientX, ev.clientY);

      // finalize: convert preview into real object
      const tmpId = "__preview__";
      const tmp = state.objects.find(o => o.id === tmpId);
      state.objects = state.objects.filter(o => o.id !== tmpId);
      if (state.drawing.mode === "rect"){
        const o = createRect(state.drawing.type, pv, state.drawing.start, pos, {});
        select(o.id);
      } else if (state.drawing.mode === "line"){
        const o = createLine(state.drawing.type, pv, state.drawing.start, pos);
        select(o.id);
      } else if (state.drawing.mode === "draw"){
        const o = createDraw(pv, state.drawing.points);
        select(o.id);
      }

      state.drawing = null;
      renderOverlays();
    }
  }

  function onDoubleClick(ev, pv){
    if (!state.edit) return;
    const target = ev.target.closest && ev.target.closest(".ann");
    if (!target) return;
    const id = target.dataset.id;
    const o = objById(id);
    if (!o) return;
    if (o.type === "field"){
      const newName = prompt("Field name:", o.name || "") ?? o.name;
      if (newName != null) o.name = String(newName||"").trim() || o.name;
      if (o.fieldKind === "field_dropdown" || o.fieldKind === "field_radio"){
        const cur = Array.isArray(o.options) ? o.options.join(", ") : "";
        const opt = prompt("Options (comma-separated):", cur);
        if (opt != null){
          o.options = opt.split(",").map(s=>s.trim()).filter(Boolean);
        }
      }
      const val = prompt("Value:", o.value || "");
      if (val != null) o.value = String(val);
      o.required = confirm("Required? (OK = required, Cancel = optional)");
      pushHistory();
      renderOverlays();
      return;
    }
    if (o.type === "text" || o.type === "textbox" || o.type === "date" || o.type === "initials" || o.type === "note"){
      const val = prompt("Edit:", o.text || "") ?? o.text;
      if (val == null) return;
      pushHistory();
      o.text = val;
      renderOverlays();
    }
  }

  function readAsDataURL(file){
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result||""));
      fr.onerror = reject;
      fr.readAsDataURL(file);
    });
  }

  
// -------------------------------
// Ensure UI is wired (guest + host)
// -------------------------------
function ensureUiReady(){
  if (state._uiReady) return;
  state._uiReady = true;

  try{ wireUI(); }catch(e){ console.error(e); }
  try{ wireDocForgeUI(); }catch(e){ console.error(e); }
  try{ initFieldsDropdown(); }catch(e){ console.error(e); }
  try{ updatePropsUI(); }catch(e){}
}

// -------------------------------
  // UI wiring
  // -------------------------------
  function wireUI(){
    if (state._wireUIOnce) return;
    state._wireUIOnce = true;
    // toolbar tool selection
    qsa("#toolbar .ps-btn").forEach(b => {
      b.addEventListener("click", () => {
        const t = b.dataset.tool;
        if (!t) return;
        setTool(t);
      });
    });

    $("editToggle").addEventListener("change", (e) => setEdit(e.target.checked));

    // Properties bar (applies to selected object; if none selected, sets defaults)
    if (!state._propsWired){
      state._propsWired = true;
          const prop = (id, fn) => { const el = $(id); if (!el) return; el.addEventListener("change", fn); el.addEventListener("input", fn); };
        prop("propFont", (e) => applyPropChange("fontFamily", e.target.value));
        prop("propSize", (e) => applyPropChange("fontSize", Math.max(6, Math.min(128, parseInt(e.target.value||"16",10)||16))));
        prop("propBold", (e) => applyPropChange("bold", !!e.target.checked));
        prop("propItalic", (e) => applyPropChange("italic", !!e.target.checked));
        prop("propTextColor", (e) => applyPropChange("textColor", e.target.value));
        prop("propFillColor", (e) => applyPropChange("fillColor", e.target.value));
        prop("propFillOpacity", (e) => applyPropChange("fillOpacity", clampNum(parseFloat(e.target.value||"0.12"),0,1)));
        prop("propStrokeColor", (e) => applyPropChange("strokeColor", e.target.value));
        prop("propStrokeOpacity", (e) => applyPropChange("strokeOpacity", clampNum(parseFloat(e.target.value||"0.90"),0,1)));
        prop("propStrokeWidth", (e) => applyPropChange("strokeWidth", Math.max(1, Math.min(30, parseInt(e.target.value||"2",10)||2))));
        prop("propHiColor", (e) => applyPropChange("highlightColor", e.target.value));
        prop("propHiOpacity", (e) => applyPropChange("highlightOpacity", clampNum(parseFloat(e.target.value||"0.28"),0,1)));

          // Page container
    }

    $("zoomInBtn").addEventListener("click", async () => { if (!state.pdf) return showStatus("Upload a PDF first.", "warn", 2000); state.zoom = Math.min(2.5, state.zoom + 0.1); await renderAll(); });
    $("zoomOutBtn").addEventListener("click", async () => { if (!state.pdf) return showStatus("Upload a PDF first.", "warn", 2000); state.zoom = Math.max(0.6, state.zoom - 0.1); await renderAll(); });

    // DONE button wiring lives in the save-prompt block below (so we don't double-bind)

    // Save prompt modal + save buttons (Vault Save / Local Save)
    if (!state._savePromptWired){
      state._savePromptWired = true;

      const chk = $("psEncryptChk");
      if (chk) chk.addEventListener("change", () => {
        const on = !!chk.checked;
        const row = $("psEncryptPwRow");
        if (row) row.style.display = on ? "block" : "none";
        if (!on) {
          const pw = $("psEncryptPw");
          const pw2 = $("psEncryptPw2");
          if (pw) pw.value = "";
          if (pw2) pw2.value = "";
        }
      });

      const close = () => closeSavePrompt(null);
      const closeBtn = $("psSaveClose"); if (closeBtn) closeBtn.addEventListener("click", close);
      const cancelBtn = $("psSaveCancel"); if (cancelBtn) cancelBtn.addEventListener("click", close);

      const goBtn = $("psSaveGo");
      if (goBtn) goBtn.addEventListener("click", () => {
        const doEncrypt = !!$("psEncryptChk")?.checked;
        const pw = String($("psEncryptPw")?.value || "");
        const pw2 = String($("psEncryptPw2")?.value || "");
        if (doEncrypt && !pw.trim()){
          alert("Please enter a password.");
          return;
        }
        if (doEncrypt && pw2.trim() && pw !== pw2){
          alert("Passwords do not match.");
          return;
        }
        closeSavePrompt({ encrypt: doEncrypt, password: pw });
      });


      // Download prompt wiring (for encrypted local saves)
      if (!state._dlPromptWired){
        state._dlPromptWired = true;
        const dlBtn = $("psDlBtn");
        const dlClose = $("psDlClose");
        const dlCancel = $("psDlCancel");

        const doClose = (x) => () => closeDownloadPrompt(x);

        if (dlClose) dlClose.addEventListener("click", doClose(false));
        if (dlCancel) dlCancel.addEventListener("click", doClose(false));

        if (dlBtn) dlBtn.addEventListener("click", () => {
          try{
            const bytes = state._dlBytes;
            const name = state._dlName || "document.pdf";
            downloadPdfBytes(bytes, name);
            closeDownloadPrompt(true);
          }catch(e){
            console.error(e);
            closeDownloadPrompt(false);
            showStatus("Download failed: " + (e?.message||e), "err", 9000);
          }
        });
      }

      // Saving is handled by the Office Save icon. Keep PDFStudio focused on editing.
      // DONE just signals the parent and/or closes a popout.
      const done = $("doneBtn");
      if (done) done.addEventListener("click", () => {
        try{ (window.parent || window.opener)?.postMessage({ type: "PDFSTUDIO_DONE" }, "*"); }catch(e){}
        try{ if (window.opener && !window.opener.closed) window.close(); }catch(e){}
      });
    }

// Merge/Upload modal
    $("mergeUploadBtn").addEventListener("click", () => openModal("muModal"));
    $("muClose").addEventListener("click", () => closeModal("muModal"));
    $("muUploadBtn").addEventListener("click", () => $("muUploadInput").click());
    $("muMergeBtn").addEventListener("click", () => $("muMergeInput").click());

    $("muUploadInput").addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      e.target.value = "";
      if (!f) return;
      await uploadPdfToVault(f);
      closeModal("muModal");
    });

    $("muMergeInput").addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      e.target.value = "";
      if (!files.length) return;
      await mergeLocalPdfs(files);
      closeModal("muModal");
    });

    $("findAnotherBtn").addEventListener("click", () => {
      // Return to Office/Vault view
      try { parent.location.href = "/office.html"; } catch { location.href = "/office.html"; }
    });

    $("shareBtn").addEventListener("click", () => {
      // Minimal share: copy a URL that will work for logged-in users (cookie-based)
      const u = new URL(location.href);
      navigator.clipboard?.writeText(u.toString()).then(
        () => showStatus("Link copied.", "ok"),
        () => showStatus("Copy failed.", "warn")
      );
    });


    // DocForge v10: right-panel duplicates for legacy top actions (top bar hidden)
    if ($("raMergeUpload")) $("raMergeUpload").addEventListener("click", () => $("mergeUploadBtn")?.click());
    if ($("raFindAnother")) $("raFindAnother").addEventListener("click", () => $("findAnotherBtn")?.click());
    if ($("raShare")) $("raShare").addEventListener("click", () => $("shareBtn")?.click());
    if ($("raDone")) $("raDone").addEventListener("click", () => $("doneBtn")?.click());

    // Keep edit toggles in sync (legacy + right panel)
    const syncEditToggles = (checked) => {
      const a = $("editToggle"); const b = $("raEditToggle");
      if (a && a.checked !== checked) a.checked = checked;
      if (b && b.checked !== checked) b.checked = checked;
      setEdit(!!checked);
    };
    // initialize from legacy if available
    try {
      const legacy = $("editToggle");
      const v = legacy ? !!legacy.checked : true;
      const ra = $("raEditToggle"); if (ra) ra.checked = v;
    } catch {}
    $("raEditToggle")?.addEventListener("change", (e) => syncEditToggles(e.target.checked));
    // when legacy changes, mirror into right panel
    $("editToggle")?.addEventListener("change", (e) => {
      const ra = $("raEditToggle");
      if (ra) ra.checked = !!e.target.checked;
    });

    // Settings
    $("settingsClose").addEventListener("click", () => closeModal("settingsModal"));
    $("setFontSize").value = String(state.defaults.fontSize);
    $("setStrokeWidth").value = String(state.defaults.strokeWidth);
    $("setSnap").checked = !!state.defaults.snap;
    $("setWatermarkText").value = state.watermark.text || "";
    $("setWatermarkOpacity").value = String(state.watermark.opacity ?? 0.12);

    $("setFontSize").addEventListener("input", () => { state.defaults.fontSize = clampNum($("setFontSize").value, 6, 72, 16); });
    $("setStrokeWidth").addEventListener("input", () => { state.defaults.strokeWidth = clampNum($("setStrokeWidth").value, 1, 20, 2); renderOverlays(); });
    $("setSnap").addEventListener("change", () => { state.defaults.snap = !!$("setSnap").checked; });
    $("setWatermarkText").addEventListener("input", () => { state.watermark.text = String($("setWatermarkText").value||""); });
    $("setWatermarkOpacity").addEventListener("input", () => { state.watermark.opacity = clampNum($("setWatermarkOpacity").value, 0, 1, 0.12); });

    // Search
    $("searchGo").addEventListener("click", doSearch);
    $("searchClose").addEventListener("click", () => toggleSearch(false));
    $("searchInput").addEventListener("keydown", (e) => { if (e.key === "Enter") doSearch(); });
  }

  function clampNum(v, min, max, dflt){
    const n = Number(v);
    if (!isFinite(n)) return dflt;
    return Math.max(min, Math.min(max, n));
  }

  function openModal(id){ $(id).classList.add("show"); }
  function closeModal(id){ $(id).classList.remove("show"); }

  function openSettings(){ openModal("settingsModal"); }

  function promptWatermark(){
    const t = prompt("Watermark text (blank to clear):", state.watermark.text || "") ?? state.watermark.text;
    if (t == null) return;
    pushHistory();
    state.watermark.text = String(t||"");
    renderOverlays();
    showStatus(state.watermark.text ? "Watermark set (applies on DONE)." : "Watermark cleared.", "ok", 1600);
  }

  function openComments(){
    // Simple: list notes and allow quick edit
    const notes = state.objects.filter(o => o.type === "note");
    if (!notes.length) return showStatus("No sticky notes yet.", "warn", 2200);
    const list = notes.map((n,i) => `${i+1}. Page ${n.page}: ${(n.text||"").slice(0,60)}`).join("\n");
    const pick = prompt("Notes:\n" + list + "\n\nEnter note # to edit:", "1");
    const idx = (parseInt(pick||"",10) || 0) - 1;
    if (idx < 0 || idx >= notes.length) return;
    const n = notes[idx];
    const val = prompt("Edit note:", n.text || "") ?? n.text;
    if (val == null) return;
    pushHistory();
    n.text = val;
    renderOverlays();
    scrollToPage(n.page);
  }

  // -------------------------------
  // Search (simple text search by page)
  // -------------------------------
  function toggleSearch(on){
    $("searchBar").classList.toggle("show", !!on);
    if (on) $("searchInput").focus();
  }

  async function doSearch(){
    const term = String($("searchInput").value||"").trim();
    $("searchResults").innerHTML = "";
    if (!term) return;

    showStatus("Searching‚Ä¶", "ok", 900);
    const results = [];
    for (let p=1; p<=state.pdf.numPages; p++){
      const page = await state.pdf.getPage(p);
      const tc = await page.getTextContent();
      const text = tc.items.map(it => it.str).join(" ");
      if (text.toLowerCase().includes(term.toLowerCase())){
        results.push({ page: p, snippet: makeSnippet(text, term) });
      }
      if (results.length >= 25) break;
    }

    if (!results.length){
      $("searchResults").innerHTML = `<div class="ps-small" style="margin-top:8px;">No matches found.</div>`;
      return;
    }

    for (const r of results){
      const div = document.createElement("div");
      div.className = "result";
      div.innerHTML = `<div style="font-weight:900;">Page ${r.page}</div><div class="ps-small">${escapeHtml(r.snippet)}</div>`;
      div.addEventListener("click", () => scrollToPage(r.page));
      $("searchResults").appendChild(div);
    }
  }

  function makeSnippet(text, term){
    const t = text.toLowerCase();
    const i = t.indexOf(term.toLowerCase());
    if (i < 0) return text.slice(0, 140);
    const start = Math.max(0, i - 40);
    const end = Math.min(text.length, i + term.length + 70);
    return (start>0 ? "‚Ä¶" : "") + text.slice(start, end) + (end<text.length ? "‚Ä¶" : "");
  }

  // -------------------------------

  // -------------------------------
  // Save / Export
  // -------------------------------
  async function encryptPdfBytes(bytes, password){
    const token = getToken();

    // Ensure we are sending actual PDF bytes
    let inU8 = null;
    try{
      inU8 = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
    }catch{
      throw new Error("Encrypt failed: invalid PDF bytes.");
    }

    const fd = new FormData();
    fd.append("file", new Blob([inU8], { type: "application/pdf" }), (state.filename || "document.pdf"));
    fd.append("password", String(password||""));

    const r = await fetch("/api/encrypt", {
      method: "POST",
      headers: token ? { "Authorization": "Bearer " + token } : {},
      body: fd,
      credentials: "same-origin"
    });

    const ct = (r.headers.get("content-type") || "").toLowerCase();

    // Hard fail on non-OK status
    if (!r.ok){
      if (ct.includes("application/json")){
        const j = await r.json().catch(()=>null);
        throw new Error((j && j.error) ? j.error : ("Encrypt failed (" + r.status + ")"));
      }
      const t = await r.text().catch(()=>"");
      throw new Error("Encrypt failed (" + r.status + "): " + (t||""));
    }

    // Some hosts can return HTML/JSON with 200; protect against that
    if (ct && !ct.includes("application/pdf")){
      if (ct.includes("application/json")){
        const j = await r.json().catch(()=>null);
        throw new Error((j && j.error) ? j.error : "Encrypt returned JSON, not a PDF.");
      }
      const t = await r.text().catch(()=>"");
      throw new Error("Encrypt returned a non-PDF response (" + (ct || "unknown") + "): " + (t||""));
    }

    const u = new Uint8Array(await r.arrayBuffer());
    const h = String.fromCharCode(u[0]||0, u[1]||0, u[2]||0, u[3]||0);
    if (h !== "%PDF"){
      let preview = "";
      try{ preview = new TextDecoder().decode(u.slice(0, 200)); }catch{}
      throw new Error("Encrypt response was not a valid PDF (missing %PDF header)." + (ct ? (" Content-Type: " + ct + ".") : "") + (preview ? (" Preview: " + preview.replace(/\s+/g, " ").slice(0, 140)) : ""));
    }

    return u;
  }

  function downloadPdfBytes(bytes, filename){
    const blob = new Blob([bytes], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "document.pdf";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 350);
  }

  let _savePromptResolver = null;

  function openSavePrompt(target){
    const lbl = $("psSaveTargetLabel");
    if (lbl) lbl.textContent = "Target: " + (target === "vault" ? "Vault" : "Download");

    const chk = $("psEncryptChk");
    const pwRow = $("psEncryptPwRow");
    const pw = $("psEncryptPw");
    const pw2 = $("psEncryptPw2");
    if (chk) chk.checked = false; // default NO
    if (pw) pw.value = "";
    if (pw2) pw2.value = "";
    if (pwRow) pwRow.style.display = "none";

    openModal("psSaveModal");
    return new Promise(resolve => _savePromptResolver = resolve);
  }

  
  // Encrypted downloads can get blocked if triggered after async work; use a click-based prompt.
  function openDownloadPrompt(bytes, filename){
    state._dlBytes = bytes;
    state._dlName = filename || "document.pdf";
    const modal = $("psDlModal");
    if (!modal) return Promise.resolve(false);

    modal.style.display = "flex";
    return new Promise((resolve) => { state._dlResolve = resolve; });
  }

  function closeDownloadPrompt(didDownload){
    const modal = $("psDlModal");
    if (modal) modal.style.display = "none";
    const r = state._dlResolve;
    state._dlResolve = null;
    if (typeof r === "function") r(!!didDownload);
  }

function closeSavePrompt(result){
    closeModal("psSaveModal");
    const r = _savePromptResolver;
    _savePromptResolver = null;
    if (r) r(result || null);
  }

  async function buildEditedPdfBytes({ silent = false } = {}){
    try{
      if (!silent) showStatus("Building PDF‚Ä¶", "ok", 0);

      const { PDFDocument, StandardFonts, rgb, degrees } = PDFLib;
      await ensureEditablePdfBytes();
      const pdfDoc = await PDFDocument.load(state.pdfBytes);
      const fontCache = new Map();
      async function getFontForObj(o){
        const fam = (o?.fontFamily || state.defaults.fontFamily || "Helvetica");
        const bold = !!(o?.bold ?? state.defaults.bold);
        const italic = !!(o?.italic ?? state.defaults.italic);
        let key = StandardFonts.Helvetica;
        if (fam === "Helvetica"){
          if (bold && italic) key = StandardFonts.HelveticaBoldOblique;
          else if (bold) key = StandardFonts.HelveticaBold;
          else if (italic) key = StandardFonts.HelveticaOblique;
          else key = StandardFonts.Helvetica;
        } else if (fam === "TimesRoman"){
          if (bold && italic) key = StandardFonts.TimesRomanBoldItalic;
          else if (bold) key = StandardFonts.TimesRomanBold;
          else if (italic) key = StandardFonts.TimesRomanItalic;
          else key = StandardFonts.TimesRoman;
        } else if (fam === "Courier"){
          if (bold && italic) key = StandardFonts.CourierBoldOblique;
          else if (bold) key = StandardFonts.CourierBold;
          else if (italic) key = StandardFonts.CourierOblique;
          else key = StandardFonts.Courier;
        }
        if (fontCache.has(key)) return fontCache.get(key);
        const f = await pdfDoc.embedFont(key);
        fontCache.set(key, f);
        return f;
      }
      function colorFromHex(hex){
        const {r,g,b} = rgb01FromHex(hex || "#ffffff");
        return rgb(r,g,b);
      }
function sanitizeStandardText(s){
        if (!s) return "";
        // Standard PDF fonts in pdf-lib use WinAnsi encoding; replace common Unicode symbols that would throw.
        return Array.from(String(s)).map(ch => {
          if (ch === "‚úì" || ch === "‚úî") return "v";
          if (ch === "‚úó" || ch === "‚úò") return "x";
          const cp = ch.codePointAt(0);
          // Keep within 0x00-0xFF range; anything else becomes '?'
          if (cp > 0xFF) return "?";
          return ch;
        }).join("");
      }

      

      // Apply watermark first (behind annotations)
      if (state.watermark && state.watermark.text){
        const pages = pdfDoc.getPages();
        for (const page of pages){
          const { width, height } = page.getSize();
          page.drawText(sanitizeStandardText(state.watermark.text), {
            x: width * 0.18,
            y: height * 0.52,
            size: Math.min(64, Math.max(28, width * 0.08)),
            font: await getFontForObj({fontFamily:"Helvetica"}),
            rotate: degrees(25),
            color: rgb(0.3, 0.3, 0.3),
            opacity: clampNum(state.watermark.opacity, 0, 1, 0.12),
          });
        }
      }

      // Draw annotations
      for (const o of state.objects){
        const page = pdfDoc.getPage(o.page - 1);
        if (!page) continue;
        const { width, height } = page.getSize();

        const toPdfRect = (obj) => {
          const x = (obj.nx||0) * width;
          const yTop = (obj.ny||0) * height;
          const w = (obj.nw||0) * width;
          const h = (obj.nh||0) * height;
          // pdf-lib uses bottom-left origin
          const y = height - (yTop + h);
          return { x, y, w, h };
        };

        if (o.type === "field" || o.type === "text" || o.type === "textbox" || o.type === "date" || o.type === "initials" || o.type === "stamp"){
          const r = toPdfRect(o);

          // Use Dingbats for check/cross stamps; standard fonts can't encode "‚úì"
          if (o.type === "stamp"){
            const rawStamp = (o.stamp || "‚úì");
            const y = r.y + Math.max(2, r.h - (o.fontSize||state.defaults.fontSize));
            const size = (o.fontSize || state.defaults.fontSize);

            if (rawStamp === "‚úì" || rawStamp === "‚úî"){
              const ding = await pdfDoc.embedFont(StandardFonts.ZapfDingbats);
              // In ZapfDingbats, the checkmark glyph is commonly mapped to character "3"
              page.drawText("3", { x: r.x + 3, y, size, font: ding, color: colorFromHex(o.textColor || state.defaults.textColor) });
            } else if (rawStamp === "‚úó" || rawStamp === "‚úò"){
              const ding = await pdfDoc.embedFont(StandardFonts.ZapfDingbats);
              // Cross mark glyph is commonly mapped to character "7"
              page.drawText("7", { x: r.x + 3, y, size, font: ding, color: colorFromHex(o.textColor || state.defaults.textColor) });
            } else {
              const safeStamp = sanitizeStandardText(rawStamp);
              page.drawText(safeStamp, {
                x: r.x + 3,
                y,
                size,
                font: await getFontForObj(o),
                color: colorFromHex(o.textColor || state.defaults.textColor),
              });
            }
          } else {
            const txt = sanitizeStandardText(o.text || "");
            page.drawText(txt, {
              x: r.x + 3,
              y: r.y + Math.max(2, r.h - (o.fontSize||state.defaults.fontSize)),
              size: (o.fontSize || state.defaults.fontSize),
              font: await getFontForObj(o),
              color: colorFromHex(o.textColor || state.defaults.textColor),
            });
          }
          if (o.type === "textbox" || o.type === "field"){
            page.drawRectangle({ x: r.x, y: r.y, width: r.w, height: r.h, borderWidth: 1, borderColor: rgb(1,1,1), opacity: 0.22 });
          }
        }

        if (o.type === "highlight"){
          const r = toPdfRect(o);
          page.drawRectangle({
            x: r.x, y: r.y, width: r.w, height: r.h,
            color: rgb(1, 0.95, 0.2),
            opacity: 0.35,
          });
        }

        if (o.type === "blackout"){
          const r = toPdfRect(o);
          page.drawRectangle({
            x: r.x, y: r.y, width: r.w, height: r.h,
            color: rgb(0,0,0),
            opacity: 1,
          });
        }

        if (o.type === "note"){
          const r = toPdfRect(o);
          page.drawRectangle({ x: r.x, y: r.y, width: r.w, height: r.h, color: rgb(1, 0.8, 0.1), opacity: 0.18, borderWidth:1, borderColor: rgb(1,0.85,0.3) });
          const msg = sanitizeStandardText((o.text||"").slice(0, 220));
          page.drawText("NOTE:", { x: r.x + 6, y: r.y + r.h - 18, size: 11, font: await getFontForObj(o), color: colorFromHex(o.textColor || state.defaults.textColor) });
          page.drawText(msg, { x: r.x + 6, y: r.y + r.h - 34, size: 10, font: await getFontForObj(o), color: colorFromHex(o.textColor || state.defaults.textColor), maxWidth: Math.max(10, r.w - 12) });
        }

        if (o.type === "table"){
          const r = toPdfRect(o);
          const rows = Math.max(1, Number(o.rows||2));
          const cols = Math.max(1, Number(o.cols||2));
          page.drawRectangle({ x: r.x, y: r.y, width: r.w, height: r.h, borderWidth: 1, borderColor: rgb(1,1,1), opacity: 0.18 });
          for (let c=1;c<cols;c++){
            const x = r.x + (r.w * c/cols);
            page.drawLine({ start: {x, y:r.y}, end: {x, y:r.y+r.h}, thickness: 1, color: rgb(1,1,1), opacity: 0.18 });
          }
          for (let rr=1;rr<rows;rr++){
            const y = r.y + (r.h * rr/rows);
            page.drawLine({ start: {x:r.x, y}, end: {x:r.x+r.w, y}, thickness: 1, color: rgb(1,1,1), opacity: 0.18 });
          }
        }

        if (o.type === "image" || o.type === "sign"){
          const r = toPdfRect(o);
          const dataUrl = o.dataUrl || "";
          if (!dataUrl.startsWith("data:")) continue;
          const isPng = dataUrl.startsWith("data:image/png");
          const bytes = dataUrlToBytes(dataUrl);
          const img = isPng ? await pdfDoc.embedPng(bytes) : await pdfDoc.embedJpg(bytes);
          page.drawImage(img, { x: r.x, y: r.y, width: r.w, height: r.h, opacity: 1 });
        }

        if (o.type === "line" || o.type === "arrow"){
          const x1 = (o.nx1||0) * width;
          const y1 = height - (o.ny1||0) * height;
          const x2 = (o.nx2||0) * width;
          const y2 = height - (o.ny2||0) * height;
          const thickness = Math.max(1, o.strokeWidth || state.defaults.strokeWidth);
          page.drawLine({ start: {x:x1,y:y1}, end: {x:x2,y:y2}, thickness, color: rgb(1,1,1), opacity: 0.95 });

          if (o.type === "arrow"){
            // arrow head
            const dx = x2-x1, dy = y2-y1;
            const len = Math.max(1, Math.hypot(dx,dy));
            const ux = dx/len, uy = dy/len;
            const size = 12 + thickness*2;
            const px = -uy, py = ux;
            const ax = x2 - ux*size, ay = y2 - uy*size;
            const p1x = ax + px*(size*0.45), p1y = ay + py*(size*0.45);
            const p2x = ax - px*(size*0.45), p2y = ay - py*(size*0.45);
            page.drawPolygon([{x:x2,y:y2},{x:p1x,y:p1y},{x:p2x,y:p2y}], { color: rgb(1,1,1), opacity: 0.95 });
          }
        }

        if (o.type === "draw"){
          const pts = (o.points||[]);
          if (pts.length < 2) continue;
          const thickness = Math.max(1, o.strokeWidth || state.defaults.strokeWidth);
          // Build SVG path in PDF coordinates
          const toXY = (pt) => {
            const x = pt.x * width;
            const y = height - (pt.y * height);
            return {x,y};
          };
          const p0 = toXY(pts[0]);
          let d = `M ${p0.x} ${p0.y}`;
          for (let i=1;i<pts.length;i++){
            const pi = toXY(pts[i]);
            d += ` L ${pi.x} ${pi.y}`;
          }
          page.drawSvgPath(d, { borderColor: rgb(1,1,1), borderWidth: thickness, opacity: 0.95 });
        }
      }

      const outBytes = await pdfDoc.save();
      return outBytes;
    }catch(e){
      if (!silent) showStatus(String(e.message||e), "err", 9000);
      throw e;
    }
  }

  async function saveToVault(opts){
    try{
      const outBytes = await buildEditedPdfBytes();

      // Sanity check: the built output MUST be a PDF
      const outU8 = (outBytes instanceof Uint8Array) ? outBytes : new Uint8Array(outBytes || []);
      if (!_looksLikePdf(outU8)) {
        let preview = "";
        try{ preview = new TextDecoder().decode(outU8.slice(0, 200)); }catch(_e){}
        throw new Error("Build produced non-PDF bytes (no %PDF header)." + (preview ? (" Preview: " + preview.replace(/\s+/g," ").slice(0,140)) : ""));
      }

      // Always keep Vault file editable: overwrite with the UNENCRYPTED edited PDF
      const token = getToken();
      const fd = new FormData();
      fd.append("file", new Blob([outU8], { type: "application/pdf" }), (state.filename || "edited.pdf"));

      const r = await fetch("/api/vault/file/" + encodeURIComponent(state.fileId) + "/overwrite", {
        method: "POST",
        headers: token ? { "Authorization": "Bearer " + token } : {},
        body: fd,
        credentials: "same-origin"
      });
      const j = await r.json().catch(()=>null);
      if (!r.ok || !j || !j.ok){
        throw new Error((j && (j.error||j.message)) || "Vault save failed");
      }


      notifyVaultChanged({ source:"pdfstudio", action:"overwrite", fileId: state.fileId, folder: currentFolderKey() });

      // If encryption is requested, ALSO upload an encrypted copy as a NEW Vault object
      let encId = null;
      if (opts && opts.encrypt){
        const pw = String(opts.password||"").trim();
        if (!pw) throw new Error("Password required.");

        const baseName = String(state.filename || "edited.pdf");
        const encName = baseName.toLowerCase().endsWith(".pdf")
          ? baseName.slice(0, -4) + "-encrypted.pdf"
          : (baseName + "-encrypted.pdf");

        showStatus("Encrypting‚Ä¶", "ok", 0);
        const encBytes = await encryptPdfBytes(outU8, pw);

        const fd2 = new FormData();
        fd2.append("file", new Blob([encBytes], { type: "application/pdf" }), encName);
        const fk2 = currentFolderKey();
        fd2.append("folderPath", fk2);
        fd2.append("folder", fk2);

        const r2 = await fetch("/api/vault/upload", {
          method: "POST",
          headers: token ? { "Authorization": "Bearer " + token } : {},
          body: fd2,
          credentials: "same-origin"
        });
        const j2 = await r2.json().catch(()=>null);
        if (!r2.ok || !j2 || !j2.ok){
          throw new Error((j2 && (j2.error||j2.message)) || "Encrypted Vault upload failed");
        }
        encId = j2.id || j2.object?.id || j2.file?.id || null;
      }

      notifyVaultChanged({ source:"pdfstudio", action:"upload_encrypted_copy", fileId: encId, folder: currentFolderKey() });

      // Keep editor on the unencrypted bytes (viewer/editor does not handle password prompts yet)
      state.pdfBytes = outU8;

      try{
        state.pdf = await loadPdfWithPasswordPrompt(state._pdfBytesMaster || state.pdfBytes);
      }catch(e){
        // If this ever happens, show a more useful message than PDF.js's generic one
        const h = String.fromCharCode(state.pdfBytes[0]||0, state.pdfBytes[1]||0, state.pdfBytes[2]||0, state.pdfBytes[3]||0);
        throw new Error("Saved, but viewer could not reload edited PDF. Header=" + h + ". " + String(e?.message || e));
      }

      pushHistory(); // new baseline
      await renderAll();

      notifyVaultChanged({ source:"pdfstudio", action:(opts && opts.encrypt) ? "save+encrypt" : "save", fileId: state.fileId, folder: currentFolderKey() });

      if (opts && opts.encrypt){
        showStatus("Saved to Vault + uploaded encrypted copy" + (encId ? (" (id: " + encId + ").") : "."), "ok", 6000);
      } else {
        showStatus("Saved to Vault.", "ok", 2500);
      }
    }catch(e){
      console.error(e);
      showStatus(String(e.message||e), "err", 9000);
    }
  }

  async function saveToLocal(opts){
    try{
      const outBytes = await buildEditedPdfBytes();
      let finalBytes = outBytes;

      if (opts && opts.encrypt){
        const pw = String(opts.password||"").trim();
        if (!pw) throw new Error("Password required.");
        showStatus("Encrypting‚Ä¶", "ok", 0);
        finalBytes = await encryptPdfBytes(outBytes, pw);
      }

      const u8 = (finalBytes instanceof Uint8Array) ? finalBytes : new Uint8Array(finalBytes || []);
      if (!_looksLikePdf(u8)){
        let preview = "";
        try{ preview = new TextDecoder().decode(u8.slice(0, 200)); }catch(_e){}
        throw new Error("Save output is not a valid PDF (no %PDF header)." + (preview ? (" Preview: " + preview.replace(/\s+/g," ").slice(0,140)) : ""));
      }

      const name = (state.filename || "edited.pdf");
      if (opts && opts.encrypt){
        // Use user-click prompt to avoid browser blocking downloads after async encryption
        await openDownloadPrompt(u8, name);
      } else {
        downloadPdfBytes(u8, name);
      }
      pushHistory(); // new baseline
      showStatus("Downloaded.", "ok", 2000);
    }catch(e){
      console.error(e);
      showStatus(String(e.message||e), "err", 9000);
    }
  }


  function dataUrlToBytes(dataUrl){
    const idx = dataUrl.indexOf(",");
    const b64 = dataUrl.slice(idx+1);
    const bin = atob(b64);
    const out = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
    return out;
  }

  // -------------------------------
  // Upload / Merge (Vault)
  // -------------------------------
  async function uploadPdfToVault(file){
    try{
      showStatus("Uploading‚Ä¶", "ok", 0);
      const token = getToken();
      const fd = new FormData();
      fd.append("file", file, file.name || "upload.pdf");
      const fk = currentFolderKey();
      fd.append("folderPath", fk);
      fd.append("folder", fk);
      // (optional) folderPath can be passed later; keep root for now
      const r = await fetch("/api/vault/upload", {
        method: "POST",
        headers: token ? { "Authorization": "Bearer " + token } : {},
        body: fd,
        credentials: "same-origin"
      });
      const j = await r.json().catch(()=>null);
      if (!r.ok || !j || !j.ok){
        throw new Error((j && (j.error||j.message)) || "Upload failed");
      }
      // open uploaded file
      const newId = j.id || j.object?.id || j.file?.id;
      if (!newId) throw new Error("Upload succeeded but no id returned.");
      location.href = "/pdfstudio.html?fileId=" + encodeURIComponent(newId) + "&name=" + encodeURIComponent(file.name || "upload.pdf") + "&folder=" + encodeURIComponent(currentFolderKey());
    }catch(e){
      showStatus(String(e.message||e), "err", 9000);
    }
  }

  async function mergeLocalPdfs(files){
    try{
      if (files.length < 2){
        showStatus("Select at least 2 PDFs to merge.", "warn", 3000);
        return;
      }
      showStatus("Merging‚Ä¶", "ok", 0);
      const token = getToken();
      const fd = new FormData();
      for (const f of files) fd.append("files", f, f.name);
      const r = await fetch("/api/merge", {
        method: "POST",
        headers: token ? { "Authorization": "Bearer " + token } : {},
        body: fd,
        credentials: "same-origin"
      });
      if (!r.ok){
        const t = await r.text().catch(()=>"");
        throw new Error("Merge failed (" + r.status + "): " + (t||""));
      }
      const blob = await r.blob();
      const mergedFile = new File([blob], "merged.pdf", { type: "application/pdf" });
      await uploadPdfToVault(mergedFile);
    }catch(e){
      showStatus(String(e.message||e), "err", 9000);
    }
  }

  

  // ===========================================================
  // DocForge: Right panel field props + bottom viewer bar (no-break)
  // ===========================================================
  let _dfWired = false;
  let _dfLastSel = null;
  let _dfTicking = false;

  function df$(id){ return document.getElementById(id); }

  function dfPrettyFieldKind(k){
    switch(k){
      case "field_text": return "Text";
      case "field_date": return "Date";
      case "field_checkbox": return "Checkbox";
      case "field_dropdown": return "Dropdown";
      case "field_radio": return "Radio";
      case "field_signature": return "Signature";
      default: return k || "Field";
    }
  }

  function dfActivePage(){
    const a = document.querySelector(".thumb.active");
    const p = a ? parseInt(a.dataset.page, 10) : 1;
    return Number.isFinite(p) && p > 0 ? p : 1;
  }

  function dfUpdateBottomBar(){
    const pc = state.pageViews?.length || 0;
    const p = dfActivePage();
    if (df$("pageCountLabel")) df$("pageCountLabel").textContent = `/ ${pc || "‚Äî"}`;
    if (df$("pageJumpInput") && document.activeElement !== df$("pageJumpInput")) df$("pageJumpInput").value = String(p);
    if (df$("zoomLabel")) df$("zoomLabel").textContent = `${Math.round((state.zoom || 1) * 100)}%`;
  }

  function dfUpdateSmartActions(){
  const root = df$("smartActions");
  if (!root) return;

  const fieldCount = state.objects.filter(o => o?.type === "field").length;
  const batch = state.dfBatch;

  // Keep this deterministic + no-break:
  // - If no fields exist, offer "Auto-create fields"
  // - Always offer "Detect existing fields" (re-run)
  // - Offer document/page helpers as additive actions
  root.innerHTML = "";

  const title = document.createElement("div");
  title.className = "sa-title";
  title.textContent = "Smart actions";
  root.appendChild(title);

  const sub = document.createElement("div");
  sub.className = "sa-muted";
  sub.textContent = fieldCount ? `Detected ${fieldCount} field(s).` : "No fields detected yet.";
  root.appendChild(sub);

  // Batch progress card (DocForge v9)
  if (batch && batch.running){
    const card = document.createElement("div");
    card.className = "df-batch";

    const top = document.createElement("div");
    top.className = "df-batch-top";

    const t = document.createElement("div");
    t.className = "df-batch-title";
    t.textContent = "Making document fillable‚Ä¶";

    const cancel = document.createElement("button");
    cancel.className = "ps-btn";
    cancel.textContent = "Cancel";
    cancel.addEventListener("click", ()=>{
      try{ state.dfBatch.cancel = true; }catch(e){}
    });

    top.appendChild(t);
    top.appendChild(cancel);

    const sub2 = document.createElement("div");
    sub2.className = "df-batch-sub";
    const done = Number(batch.done||0);
    const total = Number(batch.total||0) || 0;
    sub2.textContent = total ? `Page ${done} of ${total}` : "Working‚Ä¶";

    const bar = document.createElement("div");
    bar.className = "df-bar";
    const barFill = document.createElement("div");
    const pct = total ? Math.max(0, Math.min(100, Math.round((done/total)*100))) : 0;
    barFill.style.width = pct + "%";
    bar.appendChild(barFill);

    card.appendChild(top);
    card.appendChild(sub2);
    card.appendChild(bar);
    root.appendChild(card);
  }

  const row = document.createElement("div");
  row.className = "ps-row";
  row.style.marginTop = "10px";
  row.style.gap = "8px";

  const b1 = document.createElement("button");
  b1.className = "ps-btn";
  b1.textContent = "Detect fields";
  b1.disabled = !!(batch && batch.running);
  b1.addEventListener("click", async ()=>{
    try{ await detectExistingPdfFields(); updatePropsUI(); dfUpdateSmartActions(); dfUpdateRightPanel(true); }
    catch(e){ showStatus(String(e?.message||e), "err", 8000); }
  });
  row.appendChild(b1);

  const b2 = document.createElement("button");
  b2.className = "ps-btn primary";
  b2.textContent = "Auto-create fields";
  b2.disabled = (fieldCount > 0) || !!(batch && batch.running);
  b2.title = fieldCount ? "Fields already exist" : "Generate fields from labels/underscores";
  b2.addEventListener("click", async ()=>{
    try{
      pushHistory();
      const n = await autoGenerateFieldsFromText();
      await renderAll();
      showStatus(n ? `Created ${n} field(s).` : "No fields created.", n ? "ok" : "warn", 2200);
      dfUpdateSmartActions();
    }catch(e){
      showStatus(String(e?.message||e), "err", 8000);
    }
  });
  row.appendChild(b2);

  root.appendChild(row);

  const row2 = document.createElement("div");
  row2.className = "ps-row";
  row2.style.marginTop = "8px";
  row2.style.gap = "8px";
  row2.style.flexWrap = "wrap";

  const b3 = document.createElement("button");
  b3.className = "ps-btn";
  b3.textContent = "Make this page fillable";
  b3.disabled = !!(batch && batch.running);
  b3.title = "Auto-detect labels on the current page and create fields";
  b3.addEventListener("click", async ()=>{
    try{
      pushHistory();
      await dfMakeActivePageFillable({ mode: "smart" });
      renderOverlays();
      updatePropsUI();
      dfUpdateSmartActions();
      dfUpdateRightPanel(true);
    }catch(e){ showStatus(String(e?.message||e), "err", 8000); }
  });
  row2.appendChild(b3);

  const b4 = document.createElement("button");
  b4.className = "ps-btn";
  b4.textContent = "Auto-stack under labels";
  b4.disabled = !!(batch && batch.running);
  b4.title = "Align new fields into a clean column under detected labels (current page)";
  b4.addEventListener("click", async ()=>{
    try{
      pushHistory();
      await dfMakeActivePageFillable({ mode: "stack" });
      renderOverlays();
      updatePropsUI();
      dfUpdateSmartActions();
      dfUpdateRightPanel(true);
    }catch(e){ showStatus(String(e?.message||e), "err", 8000); }
  });
  row2.appendChild(b4);

  const b5 = document.createElement("button");
  b5.className = "ps-btn";
  b5.textContent = "Auto-order tab";
  b5.disabled = !!(batch && batch.running);
  b5.title = "Automatically set a sane tab order for fields on this page";
  b5.addEventListener("click", ()=>{
    try{
      pushHistory();
      dfAutoOrderTabForActivePage();
      renderOverlays();
      updatePropsUI();
      dfUpdateRightPanel(true);
      showStatus("Tab order updated.", "ok", 1200);
    }catch(e){ showStatus(String(e?.message||e), "err", 5000); }
  });
  row2.appendChild(b5);

  root.appendChild(row2);

  const row3 = document.createElement("div");
  row3.className = "ps-row";
  row3.style.marginTop = "8px";
  row3.style.gap = "8px";
  row3.style.flexWrap = "wrap";

  const b6 = document.createElement("button");
  b6.className = "ps-btn primary";
  b6.textContent = "Make entire document fillable";
  b6.disabled = !!(batch && batch.running);
  b6.title = "Runs page-by-page with progress. Undo returns everything in one step.";
  b6.addEventListener("click", async ()=>{
    try{
      await dfMakeDocumentFillable({ mode: "smart" });
      dfUpdateSmartActions();
      dfUpdateRightPanel(true);
    }catch(e){ showStatus(String(e?.message||e), "err", 8000); }
  });
  row3.appendChild(b6);

  const toggleWrap = document.createElement("label");
  toggleWrap.className = "ps-chk";
  toggleWrap.style.display = "inline-flex";
  toggleWrap.style.alignItems = "center";
  toggleWrap.style.gap = "8px";
  toggleWrap.style.marginLeft = "2px";

  const chk = document.createElement("input");
  chk.type = "checkbox";
  chk.checked = !!state.showTabOrder;
  chk.disabled = !!(batch && batch.running);
  chk.addEventListener("change", ()=>{
    state.showTabOrder = !!chk.checked;
    renderOverlays();
    dfUpdateRightPanel(true);
  });

  const lbl = document.createElement("span");
  lbl.textContent = "Show tab numbers";
  lbl.style.fontSize = "13px";
  lbl.style.opacity = "0.95";

  toggleWrap.appendChild(chk);
  toggleWrap.appendChild(lbl);
  row3.appendChild(toggleWrap);

  root.appendChild(row3);
}

  
  // --- DocForge v8: page-fill + label stacking (no-break, additive) ---
  async function dfMakeActivePageFillable(opts){
    opts = opts || {};
    const silent = !!opts.silent;
    const say = (m,k,t)=>{ if (!silent) showStatus(m,k,t); };
    const mode = String(opts.mode || "smart");
    const p = dfActivePage();
    const pv = (state.pageViews || []).find(v => v.pageNum === p);
    if (!pv?.page){
      say("Viewer not ready yet.", "warn", 1500);
      return 0;
    }

    const boxes = await dfGetTextBoxesForPage(pv);
    if (!boxes || !boxes.length){
      showStatus("Couldn't read page text for field generation.", "warn", 2000);
      return 0;
    }

    // Avoid duplicates on this page
    const existing = new Set(
      state.objects
        .filter(o => o && o.type === "field" && o.page === p)
        .map(fieldKey)
    );
    let created = 0;

    const addField = (o) => {
      const k = fieldKey(o);
      if (existing.has(k)) return false;
      existing.add(k);
      state.objects.push(o);
      created++;
      return true;
    };

    const padPx = 10;
    const padN = padPx / (pv.page.getViewport({ scale: 1 }).width || 1000);
    const marginN = 0.02;

    const makeName = (label, kind) => {
      const base = String(label || "").replace(/[:\s]+$/g,"").trim().slice(0, 48) || "Field";
      const safe = base.replace(/[^a-zA-Z0-9]+/g,"_").replace(/^_+|_+$/g,"");
      return `${safe || "Field"}_${(kind||"text").replace("field_","")}_${Math.floor(Math.random()*9000+1000)}`;
    };

    const labelBoxes = boxes.filter(b => {
      const s = String(b.str||"").trim();
      if (!s) return false;
      if (s.length > 70) return false;
      const leftish = b.x2 <= 0.75; // labels usually on left-ish
      const looks = s.endsWith(":") || /\b(name|address|phone|email|date|dob|ssn|city|state|zip|signature)\b/i.test(s);
      return leftish && looks;
    }).sort((a,b)=> (a.y1-b.y1) || (a.x1-b.x1));

    // Stack mode: align all new fields to one clean column
    if (mode === "stack"){
      if (!labelBoxes.length){
        say("No obvious labels found to stack fields under.", "warn", 2000);
        return 0;
      }

      const xStart = dfClamp01(Math.min(0.85, Math.max(0.30, Math.max(...labelBoxes.map(b => b.x2)) + padN)));
      const width = dfClamp01(Math.max(0.18, Math.min(0.55, 1 - xStart - marginN)));

      dfWithHistory(()=>{
        for (const lb of labelBoxes){
          const s = String(lb.str||"").trim();
          const lh = dfClamp01(lb.y2 - lb.y1);
          const nh = dfClamp01(Math.max(0.022, Math.min(0.05, lh * 1.35)));
          const kind = /signature/i.test(s) ? "field_signature" : (/date|dob/i.test(s) ? "field_date" : "field_text");
          const ny = dfClamp01(lb.y2 - nh * 0.85);
          addField({
            id: uid(),
            type: "field",
            fieldKind: kind,
            page: p,
            name: makeName(s, kind),
            nx: dfClamp01(xStart),
            ny: dfClamp01(ny),
            nw: dfClamp01(width),
            nh: dfClamp01(nh),
            required: false,
          });
        }
      });

      if (created){
        say(`Stacked ${created} field(s) on page ${p}.`, "ok", 2200);
        renderOverlays(); pushHistory(); updatePropsUI();
      }else{
        say("No new fields added (already present or duplicate positions).", "warn", 1800);
      }
      return created;
    }

    // Smart mode: mix of label-to-right, underscore runs, and checkbox glyphs (current page only)
    const glyphChk = /[‚òê‚ñ°]|\[ \]/;
    const underscoreRun = /_{3,}/;

    dfWithHistory(()=>{
      for (const b of boxes){
        const s = String(b.str||"").trim();
        if (!s) continue;

        const h = dfClamp01(Math.max(0.020, Math.min(0.06, (b.y2 - b.y1) * 1.4)));
        const baselineTop = dfClamp01(b.y2 - h * 0.85);

        // Checkbox glyphs
        if (glyphChk.test(s)){
          const size = dfClamp01(Math.max(0.018, Math.min(0.035, (b.y2 - b.y1) * 1.15)));
          addField({
            id: uid(),
            type: "field",
            fieldKind: "field_checkbox",
            page: p,
            name: makeName(s.replace(glyphChk, "Checkbox"), "field_checkbox"),
            nx: dfClamp01(b.x1),
            ny: dfClamp01(b.y2 - size * 0.9),
            nw: dfClamp01(size),
            nh: dfClamp01(size),
            value: "Off",
            required: false,
          });
          continue;
        }

        // Underscore blanks
        if (underscoreRun.test(s)){
          const w = dfClamp01(Math.max(0.12, Math.min(0.70, b.x2 - b.x1)));
          addField({
            id: uid(),
            type: "field",
            fieldKind: "field_text",
            page: p,
            name: makeName("Blank", "field_text"),
            nx: dfClamp01(b.x1),
            ny: dfClamp01(b.y1),
            nw: dfClamp01(w),
            nh: dfClamp01(Math.max(0.022, Math.min(0.05, (b.y2 - b.y1) * 1.5))),
            required: false,
          });
          continue;
        }

        // Label ending with ":" => field to the right
        if (s.endsWith(":") && s.length >= 2 && s.length <= 50){
          const kind = /signature/i.test(s) ? "field_signature" : (/date|dob/i.test(s) ? "field_date" : "field_text");
          const fx = dfClamp01(b.x2 + padN);
          const fw = dfClamp01(Math.max(0.16, Math.min(0.55, 1 - fx - marginN)));
          const nh = dfClamp01(Math.max(0.022, Math.min(0.05, (b.y2 - b.y1) * 1.35)));
          addField({
            id: uid(),
            type: "field",
            fieldKind: kind,
            page: p,
            name: makeName(s, kind),
            nx: fx,
            ny: dfClamp01(b.y2 - nh * 0.85),
            nw: fw,
            nh: nh,
            required: false,
          });
        }
      }
    });

    if (created){
      say(`Added ${created} field(s) on page ${p}.`, "ok", 2200);
      renderOverlays(); pushHistory(); updatePropsUI();
    }else{
      say("No new fields found to create on this page.", "warn", 1800);
    }
    return created;
  }

  function dfAutoOrderTabForActivePage(){
    const p = dfActivePage();
    // Only fields on active page
    const fields = state.objects.filter(o => o && o.type === "field" && o.page === p && o.nx != null && o.ny != null);
    if (!fields.length) return;

    // Sort by rows: y then x (top-to-bottom, left-to-right)
    const sorted = fields.slice().sort((a,b)=>{
      const dy = (a.ny - b.ny);
      if (Math.abs(dy) > 0.01) return dy;
      return (a.nx - b.nx);
    });

    // Assign tabIndex (kept as a custom property; export logic can use if desired later)
    for (let i=0;i<sorted.length;i++){
      sorted[i].tabIndex = i+1;
    }

// --- DocForge v9: document-fill batch runner (no-break, additive) ---
function dfSetActiveThumb(p){
  const sp = String(p);
  qsa(".thumb").forEach(t => t.classList.toggle("active", t.dataset.page === sp));
}

function dfBuildTabOrderMap(){
  const map = new Map();
  // For each page, prefer explicit tabIndex if present; otherwise derive by y/x.
  const byPage = new Map();
  for (const o of (state.objects || [])){
    if (!o || o.type !== "field" || !o.page) continue;
    if (!byPage.has(o.page)) byPage.set(o.page, []);
    byPage.get(o.page).push(o);
  }
  for (const [page, arr] of byPage.entries()){
    const hasExplicit = arr.some(o => Number.isFinite(Number(o.tabIndex)));
    const sorted = arr.slice().sort((a,b)=>{
      if (hasExplicit){
        const ta = Number.isFinite(Number(a.tabIndex)) ? Number(a.tabIndex) : 1e9;
        const tb = Number.isFinite(Number(b.tabIndex)) ? Number(b.tabIndex) : 1e9;
        if (ta !== tb) return ta - tb;
      }
      // fallback: visual order
      const ay = a.ny ?? 0, byy = b.ny ?? 0;
      if (ay !== byy) return ay - byy;
      const ax = a.nx ?? 0, bx = b.nx ?? 0;
      return ax - bx;
    });
    let i = 1;
    for (const o of sorted){
      map.set(o.id, i++);
    }
  }
  return map;
}

async function dfMakeDocumentFillable(opts){
  opts = opts || {};
  const mode = String(opts.mode || "smart");

  if (!state.pdf || !(state.pdf.numPages > 0)){
    showStatus("No PDF loaded.", "warn", 2000);
    return 0;
  }

  // One-step undo for the whole batch
  pushHistory();

  const prevActive = dfActivePage();

  state.dfBatch = { running: true, cancel: false, done: 0, total: state.pdf.numPages, created: 0 };
  dfUpdateSmartActions();
  dfUpdateRightPanel(true);

  let totalCreated = 0;

  try{
    for (let p = 1; p <= state.pdf.numPages; p++){
      if (state.dfBatch.cancel) break;

      state.dfBatch.done = p;
      dfUpdateSmartActions();

      // Activate thumb (so dfActivePage() works) without scrolling
      dfSetActiveThumb(p);

      // Silent generation per page; no spammy status toasts
      const created = await dfMakeActivePageFillable({ mode, silent: true });
      totalCreated += (created || 0);
      state.dfBatch.created = totalCreated;

      // Progressive preview: just re-render overlays (PDF canvases unchanged)
      renderOverlays();
      dfUpdateBottomBar();
    }
  } finally {
    // Restore active page selection
    dfSetActiveThumb(prevActive);
    state.dfBatch.running = false;
    dfUpdateSmartActions();
    dfUpdateRightPanel(true);
  }

  if (state.dfBatch.cancel){
    showStatus(`Canceled. Created ${totalCreated} field(s).`, "warn", 2600);
  } else {
    showStatus(totalCreated ? `Created ${totalCreated} field(s) across the document.` : "No fields created.", totalCreated ? "ok" : "warn", 2600);
  }

  return totalCreated;
}

  }

  function dfUpdateRightPanel(force=false){
    const ids = dfGetSelectedIds();
    const key = ids.slice().sort().join(",") || "‚Äî";
    if (!force && key === _dfLastSel) return;
    _dfLastSel = key;

    const panel = df$("selectionPanel");
    const sum = df$("selSummary");
    const fp = df$("fieldPropsPanel");
    const nf = df$("nonFieldActions");
    const ms = df$("multiSelectPanel");

    if (!ids.length){
      if (panel) panel.style.display = "none";
      return;
    }

    if (panel) panel.style.display = "";
    if (sum){
      const objs = dfSelectedObjects();
      const p = objs[0]?.page || dfActivePage();
      sum.textContent = ids.length === 1 ? `1 item ‚Ä¢ Page ${p}` : `${ids.length} items ‚Ä¢ Page ${p}`;
    }

    if (ms) ms.style.display = (ids.length >= 2) ? "" : "none";

    if (ids.length === 1){
      const o = objById(ids[0]);
      if (o && o.type === "field"){
        if (fp) fp.style.display = "";
        if (nf) nf.style.display = "none";
        dfSyncRightInputsFromObject(o);
      } else {
        if (fp) fp.style.display = "none";
        if (nf) nf.style.display = "";
      }
    } else {
      if (fp) fp.style.display = "none";
      if (nf) nf.style.display = "";
    }
  }

function dfSyncRightInputsFromObject(o){
    if (!o) return;
    const src = {
      fieldKind: o.fieldKind || "field_text",
      name: o.name || "",
      required: !!o.required,
      fontFamily: o.fontFamily ?? state.defaults.fontFamily,
      fontSize: o.fontSize ?? state.defaults.fontSize,
      bold: !!(o.bold ?? state.defaults.bold),
      italic: !!(o.italic ?? state.defaults.italic),
      textColor: o.textColor ?? state.defaults.textColor,
      fillColor: o.fillColor ?? state.defaults.fillColor,
      fillOpacity: (o.fillOpacity != null ? o.fillOpacity : state.defaults.fillOpacity),
      strokeColor: o.strokeColor ?? state.defaults.strokeColor,
      strokeOpacity: (o.strokeOpacity != null ? o.strokeOpacity : state.defaults.strokeOpacity),
      strokeWidth: (o.strokeWidth != null ? o.strokeWidth : state.defaults.strokeWidth),
      options: Array.isArray(o.options) ? o.options : []
    };

    if (df$("rpFieldKind")) df$("rpFieldKind").value = src.fieldKind;
    if (df$("rpFieldName")) df$("rpFieldName").value = src.name;
    if (df$("rpFieldRequired")) df$("rpFieldRequired").checked = src.required;

    if (df$("rpFont")) df$("rpFont").value = src.fontFamily;
    if (df$("rpSize")) df$("rpSize").value = String(src.fontSize);

    if (df$("rpBold")) df$("rpBold").checked = src.bold;
    if (df$("rpItalic")) df$("rpItalic").checked = src.italic;

    if (df$("rpTextColor")) df$("rpTextColor").value = src.textColor || "#000000";
    if (df$("rpFillColor")) df$("rpFillColor").value = src.fillColor || "#000000";
    if (df$("rpFillOpacity")) df$("rpFillOpacity").value = String(src.fillOpacity ?? 0.12);

    if (df$("rpStrokeColor")) df$("rpStrokeColor").value = src.strokeColor || "#000000";
    if (df$("rpStrokeOpacity")) df$("rpStrokeOpacity").value = String(src.strokeOpacity ?? 0.90);
    if (df$("rpStrokeWidth")) df$("rpStrokeWidth").value = String(src.strokeWidth ?? 2);

    const needsOptions = (src.fieldKind === "field_dropdown" || src.fieldKind === "field_radio");
    if (df$("rpOptionsWrap")) df$("rpOptionsWrap").style.display = needsOptions ? "" : "none";
    if (needsOptions && df$("rpOptions")) df$("rpOptions").value = src.options.join("\n");
  }

  function dfApplyToSelected(mutator){
    if (!state.selectedId) return;
    const o = objById(state.selectedId);
    if (!o) return;
    pushHistory();
    mutator(o);
    renderOverlays();
    updatePropsUI(); // keep legacy props bar in sync
    dfUpdateSmartActions();
    dfUpdateRightPanel(true);
  }

  // -------------------------------
  // Multi-selection helpers (no-break)
  // -------------------------------
  function dfGetSelectedIds(){
    if (Array.isArray(state.selectedIds) && state.selectedIds.length) return state.selectedIds.slice();
    return state.selectedId ? [state.selectedId] : [];
  }

  function dfSetSelectedIds(ids){
    const uniq = [];
    const seen = new Set();
    for (const id of (ids||[])){
      if (!id || seen.has(id)) continue;
      seen.add(id);
      uniq.push(id);
    }
    state.selectedIds = uniq;
    state.selectedId = uniq.length ? uniq[uniq.length - 1] : null;

    const set = new Set(uniq);
    qsa(".ann").forEach(el => el.classList.toggle("selected", set.has(el.dataset.id)));
    updatePropsUI();
    dfUpdateRightPanel(true);
  }

  function dfSelectedObjects(){
    return dfGetSelectedIds().map(objById).filter(Boolean);
  }

  function dfWithHistory(mut){
    pushHistory();
    mut();
    renderOverlays();
    updatePropsUI();
    dfUpdateSmartActions();
    dfUpdateRightPanel(true);
  }

  function dfAlignSelection(kind){
    const objs = dfSelectedObjects().filter(o => o.nx != null && o.ny != null && o.nw != null && o.nh != null);
    if (objs.length < 2) return;
    const page = objs[0].page;
    const same = objs.filter(o => o.page === page);
    if (same.length < 2) return;

    const left = Math.min(...same.map(o => o.nx));
    const right = Math.max(...same.map(o => o.nx + o.nw));
    const top = Math.min(...same.map(o => o.ny));
    const bottom = Math.max(...same.map(o => o.ny + o.nh));
    const cx = (left + right) / 2;
    const cy = (top + bottom) / 2;

    dfWithHistory(()=>{
      for (const o of same){
        if (kind === "left") o.nx = clamp01(left);
        if (kind === "hcenter") o.nx = clamp01(cx - o.nw/2);
        if (kind === "right") o.nx = clamp01(right - o.nw);

        if (kind === "top") o.ny = clamp01(top);
        if (kind === "vcenter") o.ny = clamp01(cy - o.nh/2);
        if (kind === "bottom") o.ny = clamp01(bottom - o.nh);
      }
    });
  }

  function dfDistributeSelection(axis){
    const objs = dfSelectedObjects().filter(o => o.nx != null && o.ny != null && o.nw != null && o.nh != null);
    if (objs.length < 3) return;
    const page = objs[0].page;
    const same = objs.filter(o => o.page === page);
    if (same.length < 3) return;

    if (axis === "h"){
      const sorted = same.slice().sort((a,b)=> (a.nx - b.nx));
      const left = Math.min(...sorted.map(o=>o.nx));
      const right = Math.max(...sorted.map(o=>o.nx + o.nw));
      const totalW = sorted.reduce((sum,o)=>sum+o.nw,0);
      const gap = (right - left - totalW) / (sorted.length - 1);
      if (!isFinite(gap)) return;

      dfWithHistory(()=>{
        let x = left;
        for (const o of sorted){
          o.nx = clamp01(x);
          x += o.nw + gap;
        }
      });
    } else {
      const sorted = same.slice().sort((a,b)=> (a.ny - b.ny));
      const top = Math.min(...sorted.map(o=>o.ny));
      const bottom = Math.max(...sorted.map(o=>o.ny + o.nh));
      const totalH = sorted.reduce((sum,o)=>sum+o.nh,0);
      const gap = (bottom - top - totalH) / (sorted.length - 1);
      if (!isFinite(gap)) return;

      dfWithHistory(()=>{
        let y = top;
        for (const o of sorted){
          o.ny = clamp01(y);
          y += o.nh + gap;
        }
      });
    }
  }

  
// DocForge v7: rotate selection (90¬∞), fixed-gap spacing, align-to-label
function dfRotatePoint90(x, y, cx, cy, dir){
  const dx = x - cx;
  const dy = y - cy;
  if (dir === "right"){
    return { x: cx + dy, y: cy - dx };
  }
  // left (CCW)
  return { x: cx - dy, y: cy + dx };
}

function dfRotateSelection90(dir){
  const objsAll = dfSelectedObjects();
  if (!objsAll.length) return;

  const same = dfSamePageSelection(objsAll);
  if (!same.page){
    showStatus("Rotate works when the selection is on a single page.", "warn", 2000);
    return;
  }

  const objs = same.list;
  const bb = dfBBoxForObjects(objs);
  if (!bb) return;

  const cx = bb.x + bb.w/2;
  const cy = bb.y + bb.h/2;

  dfWithHistory(()=>{
    // rotate each object about group center
    for (const o of objs){
      if (!o) continue;

      // rect-like
      if (o.nx != null && o.ny != null && o.nw != null && o.nh != null){
        const ocx = o.nx + o.nw/2;
        const ocy = o.ny + o.nh/2;
        const p = dfRotatePoint90(ocx, ocy, cx, cy, dir);
        const newW = o.nh;
        const newH = o.nw;
        o.nw = clampNum(newW, 0.002, 1);
        o.nh = clampNum(newH, 0.002, 1);
        o.nx = p.x - o.nw/2;
        o.ny = p.y - o.nh/2;
        // keep within bounds (will be refined with group shift below)
        o.nx = clamp01(o.nx);
        o.ny = clamp01(o.ny);
        continue;
      }

      // line/arrow endpoints
      if (o.nx1 != null && o.ny1 != null && o.nx2 != null && o.ny2 != null){
        const p1 = dfRotatePoint90(o.nx1, o.ny1, cx, cy, dir);
        const p2 = dfRotatePoint90(o.nx2, o.ny2, cx, cy, dir);
        o.nx1 = clamp01(p1.x); o.ny1 = clamp01(p1.y);
        o.nx2 = clamp01(p2.x); o.ny2 = clamp01(p2.y);
        continue;
      }

      // draw points
      if (Array.isArray(o.points) && o.points.length){
        o.points = o.points.map(pt=>{
          const p = dfRotatePoint90(pt.x, pt.y, cx, cy, dir);
          return { x: clamp01(p.x), y: clamp01(p.y) };
        });
      }
    }

    // bounds-safe shift (keep entire rotated group inside page)
    const bb2 = dfBBoxForObjects(objs);
    if (!bb2) return;

    let dx = 0, dy = 0;
    if (bb2.x < 0) dx = -bb2.x;
    if (bb2.y < 0) dy = -bb2.y;
    if (bb2.x + bb2.w > 1) dx = Math.min(dx, 1 - (bb2.x + bb2.w));
    if (bb2.y + bb2.h > 1) dy = Math.min(dy, 1 - (bb2.y + bb2.h));

    if (dx || dy){
      for (const o of objs){
        if (o.nx != null){ o.nx = clamp01(o.nx + dx); }
        if (o.ny != null){ o.ny = clamp01(o.ny + dy); }
        if (o.nx1 != null){ o.nx1 = clamp01(o.nx1 + dx); o.nx2 = clamp01(o.nx2 + dx); }
        if (o.ny1 != null){ o.ny1 = clamp01(o.ny1 + dy); o.ny2 = clamp01(o.ny2 + dy); }
        if (Array.isArray(o.points)){
          o.points = o.points.map(pt=>({ x: clamp01(pt.x + dx), y: clamp01(pt.y + dy) }));
        }
      }
    }
  });

  showStatus("Rotated 90¬∞.", "ok", 900);
}

function dfApplyGapSelection(axis){
  const gapPx = clampNum(parseFloat(df$("gapPxInput")?.value || "8"), 0, 400, 8);

  const objsAll = dfSelectedObjects().filter(o => o.nx != null && o.ny != null && o.nw != null && o.nh != null);
  if (objsAll.length < 2) return;

  const same = dfSamePageSelection(objsAll);
  if (!same.page){
    showStatus("Gap tools work when the selection is on a single page.", "warn", 2000);
    return;
  }

  const pv = (state.pageViews || []).find(v => v.pageNum === same.page);
  if (!pv?.viewport){
    say("Viewer not ready yet.", "warn", 1500);
    return;
  }

  const gapN = axis === "h"
    ? (gapPx / (pv.viewport.width || 1000))
    : (gapPx / (pv.viewport.height || 1000));

  const objs = same.list.slice().sort((a,b)=> axis === "h" ? (a.nx - b.nx) : (a.ny - b.ny));

  dfWithHistory(()=>{
    if (axis === "h"){
      let x = clamp01(objs[0].nx);
      for (const o of objs){
        o.nx = clamp01(x);
        x += (o.nw || 0) + gapN;
      }
    } else {
      let y = clamp01(objs[0].ny);
      for (const o of objs){
        o.ny = clamp01(y);
        y += (o.nh || 0) + gapN;
      }
    }

    // bounds-safe shift entire group if needed
    const bb = dfBBoxForObjects(objs);
    if (!bb) return;
    let dx = 0, dy = 0;
    if (bb.x < 0) dx = -bb.x;
    if (bb.y < 0) dy = -bb.y;
    if (bb.x + bb.w > 1) dx = Math.min(dx, 1 - (bb.x + bb.w));
    if (bb.y + bb.h > 1) dy = Math.min(dy, 1 - (bb.y + bb.h));
    if (dx || dy){
      for (const o of objs){
        o.nx = clamp01(o.nx + dx);
        o.ny = clamp01(o.ny + dy);
      }
    }
  });

  showStatus(axis === "h" ? "Applied horizontal gap." : "Applied vertical gap.", "ok", 900);
}

async function dfGetTextBoxesForPage(pv){
  try{
    if (!pv?.page) return [];
    // cache per page instance
    if (pv._dfTextBoxes && pv._dfTextBoxesVersion === (state.fileId || state.filename || "doc")) return pv._dfTextBoxes;

    const tc = await pv.page.getTextContent({ disableCombineTextItems: false });
    const base = pv.page.getViewport({ scale: 1 });
    const util = (window.pdfjsLib && window.pdfjsLib.Util) ? window.pdfjsLib.Util : null;

    const out = [];
    for (const it of (tc.items || [])){
      const str = String(it.str || "").trim();
      if (!str) continue;

      // Try to map into viewport coords (scale 1)
      let x = 0, y = 0;
      let w = Number(it.width || 0);
      let h = Number(it.height || 0);

      try{
        const t = it.transform || [1,0,0,1,0,0];
        const m = util ? util.transform(base.transform, t) : t;
        x = m[4]; y = m[5];
        // approximate height if missing
        const fh = Math.hypot(m[2] || 0, m[3] || 0);
        if (!h || !isFinite(h)) h = fh || 10;
      }catch{}

      // convert baseline to box
      let x1 = x;
      let y2 = y;
      let y1 = y2 - h;
      let x2 = x1 + (w || (str.length * 6));

      // normalize
      const nx1 = dfClamp01(x1 / base.width);
      const nx2 = dfClamp01(x2 / base.width);
      const ny1 = dfClamp01(y1 / base.height);
      const ny2 = dfClamp01(y2 / base.height);

      out.push({ str, x1: nx1, y1: ny1, x2: nx2, y2: ny2 });
    }

    pv._dfTextBoxes = out;
    pv._dfTextBoxesVersion = (state.fileId || state.filename || "doc") || "doc";
    return out;
  }catch{
    return [];
  }
}

async function dfAlignSelectedToLabel(){
  const objs = dfSelectedObjects().filter(o => o.type === "field" && o.nx != null && o.ny != null && o.nw != null && o.nh != null);
  if (objs.length !== 1){
    showStatus("Select a single field to align to its label.", "warn", 2000);
    return;
  }

  const o = objs[0];
  const pv = (state.pageViews || []).find(v => v.pageNum === o.page);
  if (!pv?.page){
    say("Viewer not ready yet.", "warn", 1500);
    return;
  }

  const boxes = await dfGetTextBoxesForPage(pv);
  if (!boxes.length){
    showStatus("No text found to align to on this page.", "warn", 2000);
    return;
  }

  const fx1 = o.nx, fy1 = o.ny, fx2 = o.nx + o.nw, fy2 = o.ny + o.nh;
  const fcx = (fx1 + fx2) / 2;
  const fcy = (fy1 + fy2) / 2;

  let best = null;
  let bestScore = 1e9;

  for (const b of boxes){
    const bcx = (b.x1 + b.x2)/2;
    const bcy = (b.y1 + b.y2)/2;

    // same-ish row
    const rowTol = 0.03;
    if (Math.abs(bcy - fcy) > rowTol) continue;

    // label should be left of the field
    if (b.x2 > fx1) continue;

    const dist = fx1 - b.x2;
    if (dist < 0 || dist > 0.6) continue;

    // scoring: closer is better; colon-ended gets a bonus
    let score = dist;
    if (b.str.endsWith(":")) score -= 0.02;
    if (b.str.length > 30) score += 0.02;

    if (score < bestScore){
      bestScore = score;
      best = b;
    }
  }

  if (!best){
    showStatus("Couldn't find a nearby label to the left.", "warn", 2200);
    return;
  }

  // padding in normalized coords (based on current viewport px)
  const padPx = 8;
  const padN = padPx / ((pv.viewport && pv.viewport.width) ? pv.viewport.width : 1000);

  dfWithHistory(()=>{
    // x: label end + padding
    const newX = clamp01(best.x2 + padN);
    o.nx = clamp01(newX);

    // y: align to label baseline (best.y2)
    const targetTop = clamp01(best.y2 - (o.nh * 0.85));
    o.ny = targetTop;
    // bounds safety
    if (o.nx + o.nw > 1) o.nx = clamp01(1 - o.nw);
    if (o.ny + o.nh > 1) o.ny = clamp01(1 - o.nh);
  });

  showStatus("Aligned to label.", "ok", 900);
}

  function dfCopySelection(){
    const objs = dfSelectedObjects();
    if (!objs.length) return;
    const payload = objs.map(o => JSON.parse(JSON.stringify(o)));
    state.clipboard = { objects: payload, at: Date.now(), fromPage: objs[0].page || 1 };
    try{ localStorage.setItem("pdfstudio_clipboard", JSON.stringify(state.clipboard)); }catch(e){}
    showStatus(`Copied ${payload.length} item(s).`, "ok", 1200);
  }

  function dfPasteSelection(){
    let clip = state.clipboard;
    if (!clip){
      try{ clip = JSON.parse(localStorage.getItem("pdfstudio_clipboard")||"null"); }catch(e){}
    }
    if (!clip || !Array.isArray(clip.objects) || !clip.objects.length) return;

    const targetPage = dfActivePage();
    const offset = 0.02;
    const newIds = [];

    dfWithHistory(()=>{
      for (const src of clip.objects){
        const o = JSON.parse(JSON.stringify(src));
        o.id = uid();
        o.page = targetPage;

        if (o.nx != null) o.nx = clamp01(o.nx + offset);
        if (o.ny != null) o.ny = clamp01(o.ny + offset);
        if (o.nx1 != null) o.nx1 = clamp01(o.nx1 + offset);
        if (o.ny1 != null) o.ny1 = clamp01(o.ny1 + offset);
        if (o.nx2 != null) o.nx2 = clamp01(o.nx2 + offset);
        if (o.ny2 != null) o.ny2 = clamp01(o.ny2 + offset);

        if (Array.isArray(o.points)){
          o.points = o.points.map(pt => ({ x: clamp01(pt.x + offset), y: clamp01(pt.y + offset) }));
        }

        if (o.type === "field"){
          o.name = makeFieldName(o.fieldKind || "field_text", targetPage);
        }

        state.objects.push(o);
        newIds.push(o.id);
      }
    });

    dfSetSelectedIds(newIds);
    showStatus(`Pasted ${newIds.length} item(s).`, "ok", 1200);
  }

  function dfSelectAllOnActivePage(){
    const p = dfActivePage();
    const ids = state.objects.filter(o => o && o.page === p && o.id && o.type !== "draw").map(o => o.id);
    if (!ids.length) return;
    dfSetSelectedIds(ids);
    showStatus(`Selected ${ids.length} item(s) on page ${p}.`, "ok", 1200);
  }

  function dfWireRightPanel(){

    if (_dfWired) return;
    _dfWired = true;

    // collapse persistence
    const right = df$("psRight");
    const saved = localStorage.getItem("df_right_collapsed");
    if (right && saved === "1") right.classList.add("collapsed");

    df$("rightCollapseBtn")?.addEventListener("click", ()=>{
      if (!right) return;
      const nowCollapsed = right.classList.toggle("collapsed");
      localStorage.setItem("df_right_collapsed", nowCollapsed ? "1" : "0");
    });

    const legacyScroll = ()=> df$("propsBar")?.scrollIntoView({ block: "nearest" });

    df$("jumpToPropsBtn")?.addEventListener("click", legacyScroll);
    df$("jumpToPropsBtn2")?.addEventListener("click", legacyScroll);

    const doDelete = async ()=>{
      const ids = dfGetSelectedIds();
      if (!ids.length) return;

      pushHistory();
      state.objects = state.objects.filter(o => !ids.includes(o.id));
      state.selectedIds = [];
      state.selectedId = null;

      await renderAll();
      dfUpdateSmartActions();
      dfUpdateRightPanel(true);
    };
    df$("deleteSelectedBtn")?.addEventListener("click", doDelete);
    df$("deleteSelectedBtn2")?.addEventListener("click", doDelete);

    const doDuplicate = ()=>{
      const ids = dfGetSelectedIds();
      if (!ids.length) return;

      const objs = ids.map(objById).filter(Boolean);
      if (!objs.length) return;

      const newIds = [];
      dfWithHistory(()=>{
        for (const src of objs){
          const o = JSON.parse(JSON.stringify(src));
          o.id = uid();
          if (o.type === "field"){
            o.name = makeFieldName(o.fieldKind || "field_text", o.page || dfActivePage());
          }
          if (o.nx != null) o.nx = clamp01(o.nx + 0.015);
          if (o.ny != null) o.ny = clamp01(o.ny + 0.015);
          if (o.nx1 != null) o.nx1 = clamp01(o.nx1 + 0.015);
          if (o.ny1 != null) o.ny1 = clamp01(o.ny1 + 0.015);
          if (o.nx2 != null) o.nx2 = clamp01(o.nx2 + 0.015);
          if (o.ny2 != null) o.ny2 = clamp01(o.ny2 + 0.015);
          if (Array.isArray(o.points)){
            o.points = o.points.map(pt=>({x: clamp01(pt.x + 0.015), y: clamp01(pt.y + 0.015)}));
          }
          state.objects.push(o);
          newIds.push(o.id);
        }
      });
      dfSetSelectedIds(newIds);
      showStatus(`Duplicated ${newIds.length} item(s).`, "ok", 1000);
    };
    df$("duplicateSelectedBtn")?.addEventListener("click", doDuplicate);
    df$("duplicateSelectedBtn2")?.addEventListener("click", doDuplicate);
// Multi-select arrange + clipboard
df$("alignLeftBtn")?.addEventListener("click", ()=> dfAlignSelection("left"));
df$("alignHCenterBtn")?.addEventListener("click", ()=> dfAlignSelection("hcenter"));
df$("alignRightBtn")?.addEventListener("click", ()=> dfAlignSelection("right"));
df$("alignTopBtn")?.addEventListener("click", ()=> dfAlignSelection("top"));
df$("alignVCenterBtn")?.addEventListener("click", ()=> dfAlignSelection("vcenter"));
df$("alignBottomBtn")?.addEventListener("click", ()=> dfAlignSelection("bottom"));
df$("distribHBtn")?.addEventListener("click", ()=> dfDistributeSelection("h"));
df$("distribVBtn")?.addEventListener("click", ()=> dfDistributeSelection("v"));
df$("copySelBtn")?.addEventListener("click", ()=> dfCopySelection());
df$("pasteSelBtn")?.addEventListener("click", ()=> dfPasteSelection());
df$("selectAllPageBtn")?.addEventListener("click", ()=> dfSelectAllOnActivePage());
df$("rotateGroupLeftBtn")?.addEventListener("click", ()=> dfRotateSelection90("left"));
df$("rotateGroupRightBtn")?.addEventListener("click", ()=> dfRotateSelection90("right"));
df$("applyGapHBtn")?.addEventListener("click", ()=> dfApplyGapSelection("h"));
df$("applyGapVBtn")?.addEventListener("click", ()=> dfApplyGapSelection("v"));
df$("alignLabelBtn")?.addEventListener("click", ()=> { dfAlignSelectedToLabel().catch(()=>{}); });



    // Field property bindings
    df$("rpFieldKind")?.addEventListener("change", (e)=>{
      const kind = String(e.target.value || "field_text");
      dfApplyToSelected((o)=>{
        if (o.type !== "field") return;
        o.fieldKind = kind;
        if ((kind === "field_dropdown" || kind === "field_radio") && (!Array.isArray(o.options) || o.options.length === 0)){
          o.options = ["Option 1","Option 2"];
        }
        if (kind === "field_checkbox") o.value = o.value || "Off";
      });
    });

    df$("rpFieldName")?.addEventListener("input", (e)=>{
      const name = String(e.target.value || "");
      dfApplyToSelected((o)=>{ if (o.type === "field") o.name = name; });
    });

    df$("rpFieldRequired")?.addEventListener("change", (e)=>{
      const v = !!e.target.checked;
      dfApplyToSelected((o)=>{ if (o.type === "field") o.required = v; });
    });

    df$("rpFont")?.addEventListener("change", (e)=> applyPropChange("fontFamily", String(e.target.value || "Helvetica")));
    df$("rpSize")?.addEventListener("change", (e)=> applyPropChange("fontSize", clampNum(parseFloat(e.target.value), 6, 96)));
    df$("rpBold")?.addEventListener("change", (e)=> applyPropChange("bold", !!e.target.checked));
    df$("rpItalic")?.addEventListener("change", (e)=> applyPropChange("italic", !!e.target.checked));

    df$("rpTextColor")?.addEventListener("change", (e)=> applyPropChange("textColor", String(e.target.value || "#000000")));
    df$("rpFillColor")?.addEventListener("change", (e)=> applyPropChange("fillColor", String(e.target.value || "#000000")));
    df$("rpFillOpacity")?.addEventListener("input", (e)=> applyPropChange("fillOpacity", clampNum(parseFloat(e.target.value), 0, 1)));

    df$("rpStrokeColor")?.addEventListener("change", (e)=> applyPropChange("strokeColor", String(e.target.value || "#000000")));
    df$("rpStrokeOpacity")?.addEventListener("input", (e)=> applyPropChange("strokeOpacity", clampNum(parseFloat(e.target.value), 0, 1)));
    df$("rpStrokeWidth")?.addEventListener("change", (e)=> applyPropChange("strokeWidth", clampNum(parseFloat(e.target.value), 0, 20)));

    df$("rpOptions")?.addEventListener("input", (e)=>{
      const raw = String(e.target.value || "");
      const lines = raw.split("\n").map(s=>s.trim()).filter(Boolean);
      dfApplyToSelected((o)=>{
        if (o.type !== "field") return;
        if (o.fieldKind !== "field_dropdown" && o.fieldKind !== "field_radio") return;
        o.options = lines.length ? lines : ["Option 1","Option 2"];
      });
    });
  }

  function dfWireBottomBar(){
    // Zoom buttons just forward to existing controls (no-break)
    df$("zoomOutBtn2")?.addEventListener("click", ()=> df$("zoomOutBtn")?.click());
    df$("zoomInBtn2")?.addEventListener("click", ()=> df$("zoomInBtn")?.click());

    df$("scrollPrevBtn")?.addEventListener("click", ()=>{
      const p = dfActivePage();
      scrollToPage(Math.max(1, p - 1));
      dfUpdateBottomBar();
    });
    df$("scrollNextBtn")?.addEventListener("click", ()=>{
      const pc = state.pageViews?.length || 1;
      const p = dfActivePage();
      scrollToPage(Math.min(pc, p + 1));
      dfUpdateBottomBar();
    });

    const jump = ()=>{
      const pc = state.pageViews?.length || 1;
      const val = parseInt(df$("pageJumpInput")?.value || "1", 10);
      const p = Number.isFinite(val) ? Math.min(pc, Math.max(1, val)) : 1;
      scrollToPage(p);
      dfUpdateBottomBar();
    };
    df$("pageJumpInput")?.addEventListener("change", jump);
    df$("pageJumpInput")?.addEventListener("keydown", (e)=>{ if (e.key === "Enter") jump(); });

    // Fit Width / Fit Page (safe: uses base viewport)
    df$("fitWidthBtn")?.addEventListener("click", async ()=>{
      try{
        const pv = state.pageViews?.[0];
        if (!pv?.page) return;
        const base = pv.page.getViewport({ scale: 1 });
        const vw = df$("viewport")?.clientWidth || 900;
        const target = (vw - 24) / base.width;
        state.zoom = clampNum(target, 0.6, 3.0);
        await renderAll();
        dfUpdateBottomBar();
      }catch(e){ showStatus(String(e?.message||e), "err", 8000); }
    });

    df$("fitPageBtn")?.addEventListener("click", async ()=>{
      try{
        const pv = state.pageViews?.[0];
        if (!pv?.page) return;
        const base = pv.page.getViewport({ scale: 1 });
        const vw = df$("viewport")?.clientWidth || 900;
        const vh = df$("viewport")?.clientHeight || 600;
        const target = Math.min((vw - 24) / base.width, (vh - 24) / base.height);
        state.zoom = clampNum(target, 0.6, 3.0);
        await renderAll();
        dfUpdateBottomBar();
      }catch(e){ showStatus(String(e?.message||e), "err", 8000); }
    });
  }

  function wireDocForgeUI(){
    dfWireRightPanel();
    dfWireBottomBar();
    dfUpdateSmartActions();
    dfUpdateBottomBar();

    // Keep right panel + bottom bar synced without touching core selection code
    if (_dfTicking) return;
    _dfTicking = true;

    const tick = ()=>{
      try{
        dfUpdateBottomBar();
        dfUpdateRightPanel(false);
      }catch{}
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);

    // Also hook legacy props UI refresh so right panel stays in sync
    if (typeof updatePropsUI === "function" && !updatePropsUI.__dfWrapped){
      const _orig = updatePropsUI;
      updatePropsUI = function(){
        _orig();
        dfUpdateRightPanel(true);
      };
      updatePropsUI.__dfWrapped = true;
    }

    // Keyboard shortcuts (no-break)
    if (!window.__dfKeysWired){
      window.__dfKeysWired = true;

      const isTypingTarget = (el)=>{
        if (!el) return false;
        const tag = (el.tagName || "").toLowerCase();
        if (tag === "input" || tag === "textarea" || tag === "select") return true;
        if (el.isContentEditable) return true;
        return false;
      };

      const clearGuidesSoon = ()=>{
        // clear any visual guides shortly after keyboard nudges
        window.clearTimeout(window.__dfGuideT);
        window.__dfGuideT = window.setTimeout(()=>{
          try{
            if (state?.guidesByPage){
              for (const k of Object.keys(state.guidesByPage)) delete state.guidesByPage[k];
              renderOverlays();
            }
          }catch{}
        }, 150);
      };

      window.addEventListener("keydown", (e)=>{
        try{
          if (isTypingTarget(document.activeElement)) return;

          const meta = e.metaKey || e.ctrlKey;

// Copy / Paste
if (meta && (e.key === "c" || e.key === "C")){
  if (dfGetSelectedIds().length){
    e.preventDefault();
    dfCopySelection();
    return;
  }
}
if (meta && (e.key === "v" || e.key === "V")){
  e.preventDefault();
  dfPasteSelection();
  return;
}

          // Duplicate
          if (meta && (e.key === "d" || e.key === "D")){
            const btn = df$("duplicateSelectedBtn") || df$("duplicateSelectedBtn2");
            if (btn){
              e.preventDefault();
              btn.click();
              return;
            }
          }

          // Delete
          if (e.key === "Delete" || e.key === "Backspace"){
            const btn = df$("deleteSelectedBtn") || df$("deleteSelectedBtn2");
            if (btn && dfGetSelectedIds().length){
              e.preventDefault();
              btn.click();
              return;
            }
          }

          // Nudge
          if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "ArrowUp" || e.key === "ArrowDown"){
            const ids = dfGetSelectedIds();
            if (!ids.length) return;

            const objs = ids.map(objById).filter(o => o && o.nx != null && o.ny != null);
            if (!objs.length) return;

            const page = objs[0].page;
            const pv = state.pageViews?.find(p=>p.pageNum === page) || state.pageViews?.[0];
            if (!pv?.viewport) return;

            const stepPx = e.shiftKey ? 10 : 1;
            const dx = (e.key === "ArrowLeft" ? -stepPx : e.key === "ArrowRight" ? stepPx : 0) / (pv.viewport.width || 1);
            const dy = (e.key === "ArrowUp" ? -stepPx : e.key === "ArrowDown" ? stepPx : 0) / (pv.viewport.height || 1);

            dfWithHistory(()=>{
              for (const o of objs){
                if (o.page !== page) continue;
                let nx = clamp01(o.nx + dx);
                let ny = clamp01(o.ny + dy);

                // grid snap
                nx = snap(nx);
                ny = snap(ny);

                // alignment snap + guides (piggybacks on Snap toggle)
                const as = dfAlignSnap(pv, o, nx, ny);
                nx = clamp01(as.nx);
                ny = clamp01(as.ny);

                if (as.guides) state.guidesByPage[o.page] = as.guides;
                else delete state.guidesByPage[o.page];

                o.nx = nx;
                o.ny = ny;
              }
            });

            renderOverlays()
/* -------------------------------------------------------------
   DocForge v5 (no-break): marquee selection + multi-move bounds-safe
   - Shift+Drag on empty space: add to selection (same-page only)
   - Drag on empty space: box select (same-page only)
   - Multi-move keeps relative spacing, bounds-safe, reuses existing snap+guides
-------------------------------------------------------------- */
(function(){
  try{
    if (!state) return;
    if (!Array.isArray(state.selectedIds)) state.selectedIds = [];
    state.marquee = null;

    function dfSetSelection(ids){
      state.selectedIds = (ids || []).slice();
      state.selectedId = state.selectedIds[state.selectedIds.length - 1] || null;
      const set = new Set(state.selectedIds);
      qsa(".ann").forEach(el => el.classList.toggle("selected", set.has(el.dataset.id)));
      updatePropsUI();
      try{ dfUpdateRightPanel(true); }catch(e){}
    }

    function dfEnsureMarquee(pv){
      let el = pv.overlay.querySelector(".df-marquee");
      if (!el){
        el = document.createElement("div");
        el.className = "df-marquee";
        el.style.display = "none";
        pv.overlay.appendChild(el);
      }
      return el;
    }

    function dfClamp01(v){ return Math.max(0, Math.min(1, v)); }

    // Wrap pointer handlers (no break: preserve old behavior for non-select tools)
    const _down = onPointerDown;
    const _move = onPointerMove;
    const _up   = onPointerUp;

    onPointerDown = function(ev, pv){
      try{
        if (!state.edit) return;
        if (state.tool === "select" && ev.target === pv.overlay && ev.button === 0){
          // existing behavior: clear unless shift
          if (!ev.shiftKey) clearSelection();

          const pos = xyToNorm(pv, ev.clientX, ev.clientY);
          state.marquee = {
            pageNum: pv.pageNum,
            additive: !!ev.shiftKey,
            sx: dfClamp01(pos.x),
            sy: dfClamp01(pos.y),
            cx: dfClamp01(pos.x),
            cy: dfClamp01(pos.y)
          };
          const box = dfEnsureMarquee(pv);
          box.style.display = "block";
          box.style.left = (pos.x * pv.viewport.width) + "px";
          box.style.top  = (pos.y * pv.viewport.height) + "px";
          box.style.width = "0px";
          box.style.height = "0px";
          ev.preventDefault();
          return;
        }
      }catch(e){}
      return _down(ev, pv);
    };

    onPointerMove = function(ev, pv){
      try{
        const pos = xyToNorm(pv, ev.clientX, ev.clientY);

        // Marquee drag
        if (state.marquee && state.marquee.pageNum === pv.pageNum){
          state.marquee.cx = dfClamp01(pos.x);
          state.marquee.cy = dfClamp01(pos.y);

          const x1 = Math.min(state.marquee.sx, state.marquee.cx);
          const y1 = Math.min(state.marquee.sy, state.marquee.cy);
          const x2 = Math.max(state.marquee.sx, state.marquee.cx);
          const y2 = Math.max(state.marquee.sy, state.marquee.cy);

          const box = dfEnsureMarquee(pv);
          box.style.display = "block";
          box.style.left = (x1 * pv.viewport.width) + "px";
          box.style.top  = (y1 * pv.viewport.height) + "px";
          box.style.width  = Math.max(1, (x2 - x1) * pv.viewport.width) + "px";
          box.style.height = Math.max(1, (y2 - y1) * pv.viewport.height) + "px";
          return;
        }

        // Multi-move: if dragging a selected object and multiple selected, move group bounds-safe
        if (state.dragging && state.dragging.mode === "move"){
          const d = state.dragging;
          if (Array.isArray(state.selectedIds) && state.selectedIds.length > 1 && state.selectedIds.includes(d.id)){
            const primary = objById(d.id);
            if (!primary) return;

            // lazily capture group originals
            if (!d.group){
              d.group = state.selectedIds
                .map(id => ({ id, orig: JSON.parse(JSON.stringify(objById(id))) }))
                .filter(x => x.orig && x.orig.page === pv.pageNum);
            }

            const dx = pos.x - d.startX;
            const dy = pos.y - d.startY;

            // tentative primary move with existing snap + alignment
            let nx = snap(clamp01(d.orig.nx + dx));
            let ny = snap(clamp01(d.orig.ny + dy));

            const as = dfAlignSnap(pv, primary, nx, ny);
            nx = clamp01(as.nx);
            ny = clamp01(as.ny);

            // compute delta AFTER snap
            let ddx = nx - d.orig.nx;
            let ddy = ny - d.orig.ny;

            // Bounds-safe delta across the whole group (keep spacing)
            let minDx = -Infinity, maxDx = Infinity, minDy = -Infinity, maxDy = Infinity;
            for (const it of d.group){
              const o0 = it.orig;
              if (!o0) continue;
              // normalized bounds within page
              const loDx = -o0.nx;
              const hiDx = (1 - o0.nw) - o0.nx;
              const loDy = -o0.ny;
              const hiDy = (1 - o0.nh) - o0.ny;
              minDx = Math.max(minDx, loDx);
              maxDx = Math.min(maxDx, hiDx);
              minDy = Math.max(minDy, loDy);
              maxDy = Math.min(maxDy, hiDy);
            }
            // clamp deltas
            ddx = Math.max(minDx, Math.min(maxDx, ddx));
            ddy = Math.max(minDy, Math.min(maxDy, ddy));

            // apply to all selected on the same page
            for (const it of d.group){
              const o0 = it.orig;
              const o = objById(it.id);
              if (!o || !o0) continue;
              o.nx = clamp01(o0.nx + ddx);
              o.ny = clamp01(o0.ny + ddy);
            }

            // alignment guides from primary
            if (as.guides){
              state.guidesByPage[pv.pageNum] = as.guides;
            } else {
              delete state.guidesByPage[pv.pageNum];
            }

            renderOverlays();
            return;
          }
        }
      }catch(e){}
      return _move(ev, pv);
    };

    onPointerUp = function(ev, pv){
      try{
        if (state.marquee && state.marquee.pageNum === pv.pageNum){
          const pos = xyToNorm(pv, ev.clientX, ev.clientY);
          state.marquee.cx = dfClamp01(pos.x);
          state.marquee.cy = dfClamp01(pos.y);

          const x1 = Math.min(state.marquee.sx, state.marquee.cx);
          const y1 = Math.min(state.marquee.sy, state.marquee.cy);
          const x2 = Math.max(state.marquee.sx, state.marquee.cx);
          const y2 = Math.max(state.marquee.sy, state.marquee.cy);

          const ids = state.objects
            .filter(o => o.page === pv.pageNum)
            .filter(o => {
              const ox1 = o.nx, oy1 = o.ny, ox2 = o.nx + o.nw, oy2 = o.ny + o.nh;
              // intersection test
              return !(ox2 < x1 || ox1 > x2 || oy2 < y1 || oy1 > y2);
            })
            .map(o => o.id);

          const additive = state.marquee.additive;
          let next = ids;
          if (additive){
            const merged = new Set([...(state.selectedIds || []), ...ids]);
            // same-page rule enforced by filtering above
            next = Array.from(merged);
          }
          dfSetSelection(next);

          const box = dfEnsureMarquee(pv);
          box.style.display = "none";
          state.marquee = null;
          renderOverlays();
          return;
        }
      }catch(e){}
      return _up(ev, pv);
    };

  }catch(e){
    console.warn("DocForge v5 patch failed", e);
  }
})();
;
            try{ if (typeof pushHistory === "function") pushHistory(); }catch(_e){}
            try{ if (typeof clearGuidesSoon === "function") clearGuidesSoon(); }catch(_e){}
            try{ if (typeof e !== "undefined" && e && e.preventDefault) e.preventDefault(); }catch(_e){}
          }
        }catch{}
      }, { passive:false });
    }
  }


// -------------------------------
  // Start
  // -------------------------------
  hostPost({ type: "PDFSTUDIO_READY" });
    init();
})();

/* ==============================================================
   DocForge v6 - no-break patch
   - Group selection box + resize handles (multi-select)
   - Resize multi-select with constraints + optional aspect lock (Shift)
   - Paste-to-page UI + keyboard paste to next/prev page
   NOTE: additive only; does not rename/remove existing elements
============================================================== */
(function(){
  try{
    if (!window.state) return;

    // --- helpers
    function dfClamp01(x){ x = Number(x); return isFinite(x) ? Math.min(1, Math.max(0, x)) : 0; }
    function dfClampNum(x, lo, hi, d){ x = Number(x); return isFinite(x) ? Math.min(hi, Math.max(lo, x)) : d; }
    function dfObjById(id){ return (state.objects || []).find(o => o && o.id === id) || null; }
    function dfSelectedObjects(){
      const ids = Array.isArray(state.selectedIds) ? state.selectedIds : (state.selectedId ? [state.selectedId] : []);
      const set = new Set(ids);
      return (state.objects || []).filter(o => o && set.has(o.id));
    }
    function dfSamePageSelection(objs){
      if (!objs.length) return { page: null, list: [] };
      const p = objs[0].page;
      const list = objs.filter(o => (o.page || 1) === p);
      return { page: p, list };
    }
    function dfGetPV(page){
      return (state.pageViews || []).find(pv => pv && pv.pageNum === page) || null;
    }
    function dfNormToPct(n){ return (dfClamp01(n) * 100) + "%"; }

    // --- group box element management
    function dfEnsureGroupBox(pv){
      if (!pv || !pv.overlay) return null;
      let gb = pv.overlay.querySelector(".df-groupbox");
      if (!gb){
        gb = document.createElement("div");
        gb.className = "df-groupbox";
        gb.innerHTML = `
          <div class="handle tl" data-corner="tl"></div>
          <div class="handle tr" data-corner="tr"></div>
          <div class="handle bl" data-corner="bl"></div>
          <div class="handle br" data-corner="br"></div>
        `;
        pv.overlay.appendChild(gb);
      }
      return gb;
    }

    function dfBBoxForObjects(objs){
      // return {x,y,w,h} in normalized coords
      let minX =  1e9, minY =  1e9, maxX = -1e9, maxY = -1e9;
      let any = false;

      for (const o of objs){
        if (!o) continue;

        // rect-like
        if (o.nx != null && o.ny != null && o.nw != null && o.nh != null){
          const x1 = o.nx, y1 = o.ny, x2 = o.nx + o.nw, y2 = o.ny + o.nh;
          minX = Math.min(minX, x1); minY = Math.min(minY, y1);
          maxX = Math.max(maxX, x2); maxY = Math.max(maxY, y2);
          any = true;
          continue;
        }

        // line/arrow endpoints
        if (o.nx1 != null && o.ny1 != null && o.nx2 != null && o.ny2 != null){
          const x1 = Math.min(o.nx1, o.nx2), y1 = Math.min(o.ny1, o.ny2);
          const x2 = Math.max(o.nx1, o.nx2), y2 = Math.max(o.ny1, o.ny2);
          minX = Math.min(minX, x1); minY = Math.min(minY, y1);
          maxX = Math.max(maxX, x2); maxY = Math.max(maxY, y2);
          any = true;
          continue;
        }

        // draw points
        if (Array.isArray(o.points) && o.points.length){
          for (const pt of o.points){
            minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y);
            maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y);
            any = true;
          }
        }
      }

      if (!any) return null;
      const x = dfClamp01(minX), y = dfClamp01(minY);
      const w = dfClampNum(maxX - minX, 0.0001, 1, 0.0001);
      const h = dfClampNum(maxY - minY, 0.0001, 1, 0.0001);
      return { x, y, w, h };
    }

    function dfRenderGroupBox(){
      try{
        // remove groupbox from all pages first (no-break, avoids stale)
        for (const pv of (state.pageViews || [])){
          const existing = pv.overlay?.querySelector(".df-groupbox");
          if (existing) existing.remove();
        }

        const objs = dfSelectedObjects();
        if (!objs.length) return;

        const same = dfSamePageSelection(objs);
        if (!same.page) return;

        // show group box only if multi-select on same page
        if (same.list.length < 2) return;

        const pv = dfGetPV(same.page);
        if (!pv) return;

        const bb = dfBBoxForObjects(same.list);
        if (!bb) return;

        const gb = dfEnsureGroupBox(pv);
        if (!gb) return;

        gb.style.left = dfNormToPct(bb.x);
        gb.style.top  = dfNormToPct(bb.y);
        gb.style.width  = dfNormToPct(bb.w);
        gb.style.height = dfNormToPct(bb.h);

        // wire handle drag once per render
        gb.querySelectorAll(".handle").forEach(h=>{
          h.onmousedown = (ev)=>{
            try{
              if (!state.edit) return;
              ev.preventDefault();
              ev.stopPropagation();

              const corner = h.dataset.corner || "br";
              const start = { corner, bb, page: same.page, shift: !!ev.shiftKey };

              // snapshot selected objects
              const ids = Array.isArray(state.selectedIds) ? state.selectedIds.slice() : [];
              const selObjs = ids.map(dfObjById).filter(Boolean).filter(o => (o.page||1) === same.page);

              if (selObjs.length < 2) return;

              // history for undo
              try{ pushHistory(); }catch(e){}

              // capture relative geometry
              const rel = selObjs.map(o=>{
                const s = JSON.parse(JSON.stringify(o));
                // compute relative metrics based on bbox
                const r = { id: o.id, type: o.type, snap: s };
                if (s.nx != null){
                  r.rx = (s.nx - bb.x) / bb.w;
                  r.ry = (s.ny - bb.y) / bb.h;
                  r.rw = s.nw / bb.w;
                  r.rh = s.nh / bb.h;
                } else if (s.nx1 != null){
                  r.rx1 = (s.nx1 - bb.x) / bb.w;
                  r.ry1 = (s.ny1 - bb.y) / bb.h;
                  r.rx2 = (s.nx2 - bb.x) / bb.w;
                  r.ry2 = (s.ny2 - bb.y) / bb.h;
                } else if (Array.isArray(s.points)){
                  r.points = s.points.map(pt => ({ x: (pt.x - bb.x)/bb.w, y: (pt.y - bb.y)/bb.h }));
                }
                return r;
              });

              state.dfGroupResize = { start, rel, page: same.page, pv, bb0: bb, lockAspect: !!ev.shiftKey };
            }catch(e){}
          };
        });

      }catch(e){}
    }

    // Hook renderOverlays (no-break) to also render group box
    if (!state._df_v6_groupbox){
      state._df_v6_groupbox = true;
      const _ro = renderOverlays;
      renderOverlays = function(){
        _ro();
        dfRenderGroupBox();
      };
    }

    // Global mousemove/up for group resize
    if (!state._df_v6_groupresize){
      state._df_v6_groupresize = true;

      window.addEventListener("mousemove", (ev)=>{
        try{
          const gr = state.dfGroupResize;
          if (!gr) return;

          const pv = gr.pv;
          const pos = xyToNorm(pv, ev.clientX, ev.clientY);

          const bb0 = gr.bb0;
          const minSize = 0.01;

          // Determine fixed corner and compute new bbox
          let x1 = bb0.x, y1 = bb0.y, x2 = bb0.x + bb0.w, y2 = bb0.y + bb0.h;
          const c = gr.start.corner;

          // moving corner: set corresponding x/y
          if (c === "tl"){ x1 = pos.x; y1 = pos.y; }
          if (c === "tr"){ x2 = pos.x; y1 = pos.y; }
          if (c === "bl"){ x1 = pos.x; y2 = pos.y; }
          if (c === "br"){ x2 = pos.x; y2 = pos.y; }

          // aspect lock (Shift): maintain bb0 ratio
          let nw = x2 - x1;
          let nh = y2 - y1;
          const ratio = bb0.w / bb0.h;

          if (gr.lockAspect){
            if (Math.abs(nw) > Math.abs(nh) * ratio){
              nh = Math.sign(nh || 1) * (Math.abs(nw) / ratio);
            } else {
              nw = Math.sign(nw || 1) * (Math.abs(nh) * ratio);
            }
            // recompute x2/y2 based on corner movement
            if (c === "tl"){ x1 = x2 - nw; y1 = y2 - nh; }
            if (c === "tr"){ x2 = x1 + nw; y1 = y2 - nh; }
            if (c === "bl"){ x1 = x2 - nw; y2 = y1 + nh; }
            if (c === "br"){ x2 = x1 + nw; y2 = y1 + nh; }
          }

          // normalize order
          const nx = Math.min(x1, x2);
          const ny = Math.min(y1, y2);
          const nW = Math.max(minSize, Math.abs(nw));
          const nH = Math.max(minSize, Math.abs(nh));

          // bounds-safe clamp bbox inside page
          let bx = nx, by = ny, bw = nW, bh = nH;
          bx = dfClamp01(bx);
          by = dfClamp01(by);
          if (bx + bw > 1){ bw = Math.max(minSize, 1 - bx); }
          if (by + bh > 1){ bh = Math.max(minSize, 1 - by); }

          // apply to objects
          const rel = gr.rel;
          for (const r of rel){
            const o = dfObjById(r.id);
            if (!o) continue;

            if (r.rx != null){
              o.nx = dfClamp01(bx + r.rx * bw);
              o.ny = dfClamp01(by + r.ry * bh);
              o.nw = dfClampNum(r.rw * bw, 0.005, 1, 0.02);
              o.nh = dfClampNum(r.rh * bh, 0.005, 1, 0.02);

              // keep inside bounds after min clamp
              if (o.nx + o.nw > 1) o.nx = Math.max(0, 1 - o.nw);
              if (o.ny + o.nh > 1) o.ny = Math.max(0, 1 - o.nh);

            } else if (r.rx1 != null){
              o.nx1 = dfClamp01(bx + r.rx1 * bw);
              o.ny1 = dfClamp01(by + r.ry1 * bh);
              o.nx2 = dfClamp01(bx + r.rx2 * bw);
              o.ny2 = dfClamp01(by + r.ry2 * bh);
            } else if (Array.isArray(r.points)){
              o.points = r.points.map(pt => ({ x: dfClamp01(bx + pt.x * bw), y: dfClamp01(by + pt.y * bh) }));
            }
          }

          // re-render overlays + groupbox
          renderOverlays();

        }catch(e){}
      }, { passive: true });

      window.addEventListener("mouseup", ()=>{
        if (state.dfGroupResize){
          state.dfGroupResize = null;
          try{ renderOverlays(); }catch(e){}
        }
      });
    }

    // --- Paste-to-page (no break): uses existing dfPasteSelection by switching active page
    function dfSetActivePage(p){
      const page = Math.max(1, parseInt(p, 10) || 1);
      const thumb = document.querySelector(`.thumb[data-page="${page}"]`);
      if (!thumb) return false;
      document.querySelectorAll(".thumb").forEach(t=> t.classList.toggle("active", t===thumb));
      return true;
    }

    function dfPasteToPage(page){
      const p = Math.max(1, parseInt(page, 10) || 1);
      if (!dfSetActivePage(p)){
        showStatus(`Page ${p} not found.`, "warn", 1400);
        return;
      }
      // If pasting to a different page, reduce the offset so it lands same place
      try{
        const clip = state.clipboard || JSON.parse(localStorage.getItem("pdfstudio_clipboard")||"null");
        if (clip && clip.fromPage && clip.fromPage !== p){
          state._dfPasteNoOffsetOnce = true;
        }
      }catch(e){}
      dfPasteSelection();
      // scroll for visibility
      try{ scrollToPage(p); }catch(e){}
    }

    // Patch dfPasteSelection to optionally skip offset once (no break)
    if (!state._df_v6_pastepatch){
      state._df_v6_pastepatch = true;
      const _paste = dfPasteSelection;
      dfPasteSelection = function(){
        // Temporarily flip offset by intercepting the clip handling inside original paste
        // We'll set a global flag and let original logic run; then clean it.
        // The original paste uses const offset=0.02; we can't edit it here,
        // but we can pre-shift clipboard objects by -0.02 to net out the offset.
        let _dfClipBackup = null;
        if (state._dfPasteNoOffsetOnce && state.clipboard?.objects?.length){
          try{
            // backup clipboard objects so normal offset behavior remains after this paste
            _dfClipBackup = JSON.parse(JSON.stringify(state.clipboard.objects));
            // counteract the +0.02 by subtracting before call (net 0 offset on paste)
            for (const o of state.clipboard.objects){
              if (o.nx != null) o.nx = dfClamp01(o.nx - 0.02);
              if (o.ny != null) o.ny = dfClamp01(o.ny - 0.02);
              if (o.nx1 != null) o.nx1 = dfClamp01(o.nx1 - 0.02);
              if (o.ny1 != null) o.ny1 = dfClamp01(o.ny1 - 0.02);
              if (o.nx2 != null) o.nx2 = dfClamp01(o.nx2 - 0.02);
              if (o.ny2 != null) o.ny2 = dfClamp01(o.ny2 - 0.02);
              if (Array.isArray(o.points)){
                o.points = o.points.map(pt => ({ x: dfClamp01(pt.x - 0.02), y: dfClamp01(pt.y - 0.02) }));
              }
            }
          }catch(e){}
        }
        const res = _paste();
        try{
          if (_dfClipBackup) state.clipboard.objects = _dfClipBackup;
        }catch(e){}
        state._dfPasteNoOffsetOnce = false;
        return res;
      };
    }

    // Wire UI if present
    const btn = df$("pasteToPageBtn");
    if (btn && !btn._dfWired){
      btn._dfWired = true;
      btn.addEventListener("click", ()=>{
        const val = df$("pastePageInput")?.value;
        dfPasteToPage(val);
      });
    }

    // Keyboard: Ctrl/Cmd+Shift+V paste to next page; Ctrl/Cmd+Alt+V paste to prev page
    if (!state._df_v6_kb){
      state._df_v6_kb = true;
      window.addEventListener("keydown", (ev)=>{
        try{
          const t = ev.target;
          if (t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable)) return;

          const mod = (ev.ctrlKey || ev.metaKey);
          if (!mod) return;

          if (ev.key.toLowerCase() === "v" && ev.shiftKey){
            ev.preventDefault();
            const p = dfActivePage();
            dfPasteToPage(p + 1);
          }
          if (ev.key.toLowerCase() === "v" && ev.altKey){
            ev.preventDefault();
            const p = dfActivePage();
            dfPasteToPage(Math.max(1, p - 1));
          }
        }catch(e){}
      });
    }

    // Keep group box in sync on selection changes (no-break)
    if (!state._df_v6_selhook){
      state._df_v6_selhook = true;
      const _sel = select;
      select = function(id, additive=false){
        const r = _sel(id, additive);
        try{ dfRenderGroupBox(); }catch(e){}
        return r;
      };
      const _clear = clearSelection;
      clearSelection = function(){
        const r = _clear();
        try{ dfRenderGroupBox(); }catch(e){}
        return r;
      };
    }

  }catch(e){}
})();

</script>

  <div id="ctxMenu" class="ps-ctxmenu ps-hidden" role="menu" aria-label="Object properties">
    <div class="ps-ctxhead">
      <div id="ctxTitle" class="ps-ctxtitle">Edit object</div>
      <button id="ctxClose" class="ps-ctxbtn" title="Close">‚úï</button>
    </div>

    <div class="ps-ctxgrid">
      <label for="ctxFont">Font</label>
      <select id="ctxFont">
        <option value="Helvetica">Helvetica</option>
        <option value="Times-Roman">Times</option>
        <option value="Courier">Courier</option>
      </select>

      <label for="ctxSize">Size</label>
      <input id="ctxSize" type="number" min="6" max="128" step="1" value="16"/>

      <label for="ctxBold">Bold</label>
      <input id="ctxBold" type="checkbox"/>

      <label for="ctxItalic">Italic</label>
      <input id="ctxItalic" type="checkbox"/>

      <label for="ctxTextColor">Text</label>
      <input id="ctxTextColor" type="color" value="#000000"/>

      <label for="ctxFillColor">Fill</label>
      <input id="ctxFillColor" type="color" value="#000000"/>

      <label for="ctxFillOpacity">Fill Œ±</label>
      <input id="ctxFillOpacity" type="range" min="0" max="1" step="0.01" value="0.12"/>

      <label for="ctxStrokeColor">Stroke</label>
      <input id="ctxStrokeColor" type="color" value="#000000"/>

      <label for="ctxStrokeOpacity">Stroke Œ±</label>
      <input id="ctxStrokeOpacity" type="range" min="0" max="1" step="0.01" value="0.90"/>

      <label for="ctxStrokeWidth">Width</label>
      <input id="ctxStrokeWidth" type="number" min="1" max="30" step="1" value="2"/>

      <label for="ctxHiColor">Highlight</label>
      <input id="ctxHiColor" type="color" value="#000000"/>

      <label for="ctxHiOpacity">Hi Œ±</label>
      <input id="ctxHiOpacity" type="range" min="0" max="1" step="0.01" value="0.28"/>
    </div>

    <div class="ps-ctxactions">
      <button id="ctxDelete" class="ps-ctxdanger">Delete</button>
    </div>
  </div>


  <!-- DocForge v11: Legacy Tools Drawer (contains original toolbar + props; no-break) -->
  <div id="legacyDrawerOverlay" role="dialog" aria-modal="true" aria-label="Tools drawer">
    <div id="legacyDrawer">
      <div class="ld-head">
        <div>
          <div class="ld-title">Tools</div>
          <div class="ld-sub">Full toolbar and legacy controls (nothing removed)</div>
        </div>
        <button class="ld-close" id="closeToolsDrawer" title="Close">‚úï</button>
      </div>
      <div id="legacyDock"></div>
    </div>
  </div>


<script>
/* ==== DocForge v11: Compact Ribbon + Tools Drawer (no-break) ==== */
(function(){
  function $(sel){ return document.querySelector(sel); }
  function $all(sel){ return Array.from(document.querySelectorAll(sel)); }

  function clickLegacyTool(tool){
    var btn = document.querySelector('#toolbar [data-tool="'+tool+'"]');
    if(btn){ btn.click(); return true; }
    return false;
  }
  function clickById(id){
    var el = document.getElementById(id);
    if(el){ el.click(); return true; }
    return false;
  }

  function setRibbonActive(tool){
    var ribbon = document.getElementById('compactRibbon');
    if(!ribbon) return;
    $all('#compactRibbon [data-proxy]').forEach(function(b){
      b.classList.toggle('active', b.getAttribute('data-proxy') === tool);
    });
  }

  function openDrawer(){
    var ov = document.getElementById('legacyDrawerOverlay');
    if(!ov) return;
    ov.classList.add('open');
  }
  function closeDrawer(){
    var ov = document.getElementById('legacyDrawerOverlay');
    if(!ov) return;
    ov.classList.remove('open');
  }

  // Move legacy toolbar + props into drawer dock (IDs unchanged)
  function dockLegacyControls(){
    var dock = document.getElementById('legacyDock');
    var tb = document.getElementById('toolbar');
    var props = document.getElementById('propsBar');
    if(!dock || !tb || !props) return;

    // Only dock once
    if(tb.parentElement === dock) return;

    dock.appendChild(tb);
    dock.appendChild(props);
  }

  function syncStatusPill(){
    var pill = document.getElementById('rbStatusPill');
    if(!pill) return;
    try{
      if(window.state && typeof window.state.currentPage === 'number' && window.state.pageCount){
        var z = (window.state.zoom ? Math.round(window.state.zoom*100) : 100);
        pill.textContent = "Pg " + (window.state.currentPage+1) + " / " + window.state.pageCount + " ‚Ä¢ " + z + "%";
      } else {
        pill.textContent = "Ready";
      }
    }catch(e){
      pill.textContent = "Ready";
    }
  }

  // Hook ribbon clicks
  function wireRibbon(){
    var ribbon = document.getElementById('compactRibbon');
    if(!ribbon) return;

    ribbon.addEventListener('click', function(ev){
      var t = ev.target.closest('[data-proxy]');
      if(t){
        var tool = t.getAttribute('data-proxy');
        if(tool === 'undo' || tool === 'redo'){
          clickLegacyTool(tool);
        }else{
          clickLegacyTool(tool);
          setRibbonActive(tool);
        }
        ev.preventDefault();
        return;
      }
      var openBtn = ev.target.closest('#openToolsDrawer');
      if(openBtn){
        dockLegacyControls();
        openDrawer();
        ev.preventDefault();
      }
    }, true);
  }

  // Wire drawer close behaviors
  function wireDrawer(){
    var ov = document.getElementById('legacyDrawerOverlay');
    var closeBtn = document.getElementById('closeToolsDrawer');
    if(closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if(ov){
      ov.addEventListener('click', function(ev){
        if(ev.target === ov) closeDrawer();
      });
      document.addEventListener('keydown', function(ev){
        if(ev.key === 'Escape' && ov.classList.contains('open')) closeDrawer();
      });
    }
  }

  // Keep ribbon active state in sync with legacy tool buttons (no-break)
  function wireLegacyToolSync(){
    var tb = document.getElementById('toolbar');
    if(!tb) return;

    tb.addEventListener('click', function(ev){
      var btn = ev.target.closest('[data-tool]');
      if(btn){
        var tool = btn.getAttribute('data-tool');
        // only highlight real tools (not undo/redo)
        if(tool && tool !== 'undo' && tool !== 'redo'){
          setRibbonActive(tool);
        }
        // status pill updates after a tick
        setTimeout(syncStatusPill, 10);
      }
    }, true);
  }

  // Sync status when render changes
  function hookRenderSync(){
    // Attempt to patch renderAll safely if it exists
    try{
      if(typeof window.renderAll === 'function' && !window.__rb_render_patched){
        var _r = window.renderAll;
        window.renderAll = function(){
          var out = _r.apply(this, arguments);
          setTimeout(syncStatusPill, 10);
          return out;
        };
        window.__rb_render_patched = true;
      }
    }catch(e){}
    setInterval(syncStatusPill, 700);
  }

  window.addEventListener('load', function(){
    dockLegacyControls();
    wireRibbon();
    wireDrawer();
    wireLegacyToolSync();
    hookRenderSync();

    // Set initial active tool if available
    try{
      if(window.state && window.state.tool){
        setRibbonActive(window.state.tool);
      }
    }catch(e){}
    syncStatusPill();

    // Ensure document controls in right panel still trigger legacy elements even when docked
    // (no changes needed; clicks are forwarded by id)
  });
})();
</script>



<!-- Open encrypted PDF password modal -->
<div class="ps-modal" id="psOpenPwModal" style="display:none;">
  <div class="ps-card" style="max-width:520px;">
    <div class="ps-row" style="justify-content:space-between;">
      <h3 style="margin:0;">Password required</h3>
      <button class="ps-btn" id="psOpenPwClose" title="Close">‚úï</button>
    </div>

    <div class="ps-small" id="psOpenPwMsg" style="margin-top:10px; opacity:0.9;">
      This PDF is encrypted. Enter the password to open it.
    </div>

    <div class="ps-small" id="psOpenPwErr" style="margin-top:10px; display:none; color:#ff6b6b; font-weight:800;">
      Incorrect password. Try again.
    </div>

    <div style="margin-top:12px;">
      <div class="ps-small">Password</div>
      <input class="ps-input" id="psOpenPwInput" type="password" placeholder="Enter password" autocomplete="current-password" />
    </div>

    <div class="ps-row" style="justify-content:flex-end; gap:10px; margin-top:16px;">
      <button class="ps-btn" id="psOpenPwCancel">Cancel</button>
      <button class="ps-btn done" id="psOpenPwOk">Open</button>
    </div>
  </div>
</div>


<!-- Save options modal -->
<div class="ps-modal" id="psSaveModal">
  <div class="ps-card" style="max-width:520px;">
    <div class="ps-row" style="justify-content:space-between;">
      <h3 style="margin:0;">Save Options</h3>
      <button class="ps-btn" id="psSaveClose">Close</button>
    </div>

    <div class="ps-small" id="psSaveTargetLabel" style="margin-top:6px; opacity:0.9;">Target: Download</div>

    <label class="ps-row" style="justify-content:flex-start; gap:10px; margin-top:14px;">
      <input type="checkbox" id="psEncryptChk" />
      <span style="font-weight:800;">Password/Encrypt file</span>
    </label>

    <div id="psEncryptPwRow" style="display:none; margin-top:10px;">
      <div class="ps-small">Password</div>
      <input class="ps-input" id="psEncryptPw" type="password" placeholder="Enter password" autocomplete="new-password" />

      <div class="ps-small" style="margin-top:8px;">Confirm password (optional)</div>
      <input class="ps-input" id="psEncryptPw2" type="password" placeholder="Re-enter password" autocomplete="new-password" />
    </div>

    <div class="ps-row" style="justify-content:flex-end; gap:10px; margin-top:16px;">
      <button class="ps-btn" id="psSaveCancel">Cancel</button>
      <button class="ps-btn done" id="psSaveGo">Continue</button>
    </div>

    <div class="ps-small" style="margin-top:12px; opacity:0.85;">Encryption uses AES-256 (qpdf) when enabled.</div>
  </div>
</div>


<!-- Download Prompt (used for encrypted Local Save to avoid browser gesture blocking) -->
<div id="psDlModal" class="ps-modal" style="display:none;">
  <div class="ps-card" style="max-width:520px;">
    <div class="ps-row" style="justify-content:space-between;">
      <h3 style="margin:0;">Download ready</h3>
      <button class="ps-btn" id="psDlClose" title="Close">‚úï</button>
    </div>

    <div class="ps-small" style="margin-top:10px; opacity:0.9;">
      Your encrypted PDF is ready. Click <b>Download</b>.
    </div>

    <div class="ps-row" style="justify-content:flex-end; gap:10px; margin-top:16px;">
      <button class="ps-btn" id="psDlCancel">Cancel</button>
      <button class="ps-btn done" id="psDlBtn">Download</button>
    </div>
  </div>
</div>

</body>
</html>