(() => {
  "use strict";

  // PDFRealm AI Operator (public QuickTools)
  // Goals:
  //  - AI Operator button always opens (robust binding)
  //  - Modal always scrollable so user can reach entire tool
  //  - When user clicks Run: PLAN then RUN
  //  - Try /api/ai/run first (avoid /execute 404 spam)
  //  - Optional document upload UI (safe if server doesn't support it)

  const state = {
    open: false,
    running: false,
    lastPlan: null,
    uploadId: null,
    uploadName: null,
    uploadPath: null,
  };

  function qs(sel, root = document) { return root.querySelector(sel); }

  function el(tag, attrs = {}, children = []) {
    const n = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs || {})) {
      if (k === "class") n.className = v;
      else if (k === "style") n.setAttribute("style", v);
      else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
      else if (v === false || v === null || typeof v === "undefined") {
        // skip
      } else {
        n.setAttribute(k, String(v));
      }
    }
    for (const c of (children || [])) {
      n.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    }
    return n;
  }

  function openModalCompat(modal) {
    if (!modal) return;
    if (typeof window.openModal === "function") {
      try { window.openModal(modal); state.open = true; return; } catch (_) {}
    }
    modal.classList.add("open");
    modal.setAttribute("aria-hidden", "false");
    state.open = true;
  }

  function closeModalCompat(modal) {
    if (!modal) return;
    if (typeof window.closeModal === "function") {
      try { window.closeModal(modal); state.open = false; return; } catch (_) {}
    }
    modal.classList.remove("open");
    modal.setAttribute("aria-hidden", "true");
    state.open = false;
  }

  function setStatus(txt) {
    const n = qs("#aiOpStatus");
    if (n) n.textContent = txt || "";
  }

  function setUploadBadge() {
    const b = qs("#aiOpUploadBadge");
    if (!b) return;
    if (state.uploadName) {
      b.textContent = `Attached: ${state.uploadName}`;
      b.style.display = "inline-flex";
    } else {
      b.textContent = "";
      b.style.display = "none";
    }
  }

  function logLine(msg, kind = "info") {
    const box = qs("#aiOpLog");
    if (!box) return;
    const line = el("div", {
      class: "aiop-line aiop-" + kind,
      style: "padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.06); white-space:pre-wrap; word-break:break-word;"
    }, [String(msg ?? "")]);
    box.prepend(line);
  }

  async function readTextSafe(r) {
    try { return await r.text(); } catch (_) { return ""; }
  }

  async function postJSON(url, payload) {
    const r = await fetch(url, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(payload || {})
    });

    const ct = (r.headers.get("content-type") || "").toLowerCase();
    let data = null;
    if (ct.includes("application/json")) {
      try { data = await r.json(); } catch (_) { data = null; }
    }
    if (data === null) {
      const t = await readTextSafe(r);
      data = t ? { text: t } : {};
    }
    return { ok: r.ok, status: r.status, data };
  }

  async function uploadFile(file) {
    if (!file) return null;

    setStatus("Uploading...");
    logLine(`Uploading: ${file.name} ...`, "info");

    const fd = new FormData();
    fd.append("file", file);

    let r;
    try {
      r = await fetch("/api/ai/upload", { method: "POST", body: fd });
    } catch (e) {
      logLine("Upload failed: " + (e?.message || String(e)), "error");
      setStatus("Upload failed");
      return null;
    }

    const ct = (r.headers.get("content-type") || "").toLowerCase();
    let data = null;
    if (ct.includes("application/json")) {
      try { data = await r.json(); } catch (_) { data = null; }
    }
    if (!data) {
      const t = await readTextSafe(r);
      data = t ? { text: t } : {};
    }

    if (!r.ok) {
      const err = data?.error || data?.message || data?.text || ("Upload failed (HTTP " + r.status + ")");
      logLine(err, "error");
      setStatus("Upload failed");
      return null;
    }

    // Accept a variety of response shapes
    state.uploadId = data.uploadId || data.id || data.fileId || null;
    state.uploadName = data.filename || data.name || file.name;
    state.uploadPath = data.tempPath || data.path || null;

    setUploadBadge();
    logLine(`Upload OK: ${state.uploadName}`, "result");
    setStatus("");
    return data;
  }

  function normalizePlan(resp) {
    if (!resp) return null;
    if (typeof resp === "string") return resp;
    if (resp.plan) return typeof resp.plan === "string" ? resp.plan : JSON.stringify(resp.plan, null, 2);
    if (resp.steps) return Array.isArray(resp.steps) ? resp.steps.map((s, i) => `${i + 1}. ${s}`).join("\n") : JSON.stringify(resp.steps, null, 2);
    if (resp.text) return String(resp.text);
    if (resp.message) return String(resp.message);
    return null;
  }

  function normalizeResult(resp) {
    if (!resp) return null;
    if (typeof resp === "string") return resp;
    for (const k of ["result", "output", "text", "message"]) {
      if (resp[k]) {
        if (typeof resp[k] === "string") return resp[k];
        return JSON.stringify(resp[k], null, 2);
      }
    }
    return JSON.stringify(resp, null, 2);
  }

  async function planThenExecute(userText) {
    const prompt = String(userText || "").trim();
    if (!prompt) {
      alert("Type a command first.");
      return;
    }

    const runBtn = qs("#aiOpRun");
    state.running = true;
    if (runBtn) runBtn.disabled = true;

    try {
      setStatus("Planning...");
      logLine("Planning...", "info");

      const common = {
        input: prompt,
        prompt,
        task: prompt,
        command: prompt,
        uploadId: state.uploadId,
        fileName: state.uploadName,
        filePath: state.uploadPath,
        tempPath: state.uploadPath
      };

      // PLAN
      const planResp = await postJSON("/api/ai/plan", common);

      if (!planResp.ok) {
        const err = planResp.data?.error || planResp.data?.message || planResp.data?.text || ("Plan failed (HTTP " + planResp.status + ")");
        logLine(err, "error");
        setStatus("Plan failed");
        return;
      }

      const planText = normalizePlan(planResp.data) || "(No plan returned)";
      state.lastPlan = planText;
      logLine("PLAN:\n" + planText, "plan");

      // EXECUTE
      setStatus("Running...");
      logLine("Running...", "info");

      // Try most likely execute endpoints in order (RUN FIRST)
      const executeEndpoints = [
        "/api/ai/run",
        "/api/ai/act",
        "/api/ai/command",
        "/api/ai/execute"
      ];

      let execOut = null;
      let lastErr = null;

      for (const ep of executeEndpoints) {
        const execResp = await postJSON(ep, {
          ...common,
          plan: planText,
          steps: planText
        });

        if (execResp.status === 404) {
          lastErr = `Endpoint not found: ${ep}`;
          continue;
        }

        if (!execResp.ok) {
          lastErr = execResp.data?.error || execResp.data?.message || execResp.data?.text || ("Run failed (HTTP " + execResp.status + ")");
          break;
        }

        const d = execResp.data || {};
        if (d.status_url || d.statusUrl) {
          const statusUrl = d.status_url || d.statusUrl;
          execOut = await pollJob(statusUrl);
        } else if (d.job_id || d.jobId || d.id) {
          const jobId = d.job_id || d.jobId || d.id;
          execOut = await pollJob(`/api/ai/jobs/${encodeURIComponent(jobId)}`);
        } else {
          execOut = normalizeResult(d);
        }

        if (execOut) break;
      }

      if (!execOut) {
        logLine(lastErr || "Run failed.", "error");
        setStatus("Run failed");
        return;
      }

      logLine("RESULT:\n" + execOut, "result");
      setStatus("Done");
    } catch (e) {
      logLine(String(e?.message || e || "Unknown error"), "error");
      setStatus("Error");
    } finally {
      state.running = false;
      if (runBtn) runBtn.disabled = false;
    }
  }

  async function pollJob(url) {
    const maxMs = 45_000;
    const start = Date.now();

    while (Date.now() - start < maxMs) {
      let r;
      try {
        r = await fetch(url, { method: "GET" });
      } catch (e) {
        return "Job poll failed: " + (e?.message || String(e));
      }

      const ct = (r.headers.get("content-type") || "").toLowerCase();
      let data = null;
      if (ct.includes("application/json")) {
        try { data = await r.json(); } catch (_) { data = null; }
      }
      if (data === null) {
        const t = await readTextSafe(r);
        return t || ("Job status HTTP " + r.status);
      }

      const status = String(data.status || data.state || "").toUpperCase();
      if (["DONE", "COMPLETED", "SUCCESS", "SUCCEEDED"].includes(status)) {
        return normalizeResult(data.result || data.output || data) || "(completed)";
      }
      if (["ERROR", "FAILED", "FAILURE"].includes(status)) {
        return "Job failed: " + (data.error || data.message || JSON.stringify(data, null, 2));
      }

      if (Math.random() < 0.25) {
        logLine("Job status: " + (status || "RUNNING") + "...", "info");
      }

      await new Promise(res => setTimeout(res, 900));
    }

    return "Job poll timed out.";
  }

  function ensureUI() {
    if (qs("#aiOperatorModal")) return;

    // Make modal always scrollable
    const modal = el("div", { id: "aiOperatorModal", class: "modal", "aria-hidden": "true", role: "dialog", "aria-modal": "true" }, [
      el("div", {
        class: "modal-card",
        style: "max-width: 920px; max-height: calc(100vh - 40px); overflow: hidden;"
      }, [
        el("div", { class: "modal-head" }, [
          el("div", { class: "mh" }, ["AI Operator"]),
          el("div", {
            id: "aiOpUploadBadge",
            style: "display:none; align-items:center; gap:8px; padding:6px 10px; border:1px solid rgba(255,255,255,0.12); border-radius:999px; color:rgba(255,255,255,0.85); font-size:12px;"
          }, [""]),
          el("button", { id: "aiOpClose", class: "btn btn-secondary", type: "button" }, ["Close"])
        ]),
        el("div", { class: "modal-body", style: "max-height: calc(100vh - 160px); overflow: auto;" }, [
          el("div", { style: "color:var(--muted); font-size:0.95rem; margin-bottom:10px;" }, [
            "Attach a document (optional), type what you want to do, then press Run. It will plan and then execute."
          ]),

          // Upload row
          el("div", { style: "display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px;" }, [
            el("input", { id: "aiOpFile", type: "file", style: "max-width: 360px;" }),
            el("button", { id: "aiOpUploadBtn", class: "btn btn-secondary", type: "button" }, ["Upload"]),
            el("div", { id: "aiOpUploadHint", style: "color:var(--muted); font-size:0.9rem;" }, [""])
          ]),

          el("textarea", {
            id: "aiOpInput",
            rows: "6",
            placeholder: "Example: Extract pages 2-4 and 9 from this PDF, then merge into a new file.",
            style: "width:100%; resize:vertical;"
          }),

          el("div", { class: "modal-row", style: "margin-top:12px; gap:10px; display:flex; align-items:center; flex-wrap:wrap;" }, [
            el("button", { id: "aiOpRun", class: "btn btn-primary", type: "button" }, ["Run"]),
            el("div", { id: "aiOpStatus", style: "color:var(--muted); font-size:0.9rem;" }, [""])
          ]),

          el("div", { class: "card", style: "margin-top:12px;" }, [
            el("div", { style: "font-weight:600; margin-bottom:8px;" }, ["Output"]),
            el("div", {
              id: "aiOpLog",
              style: "max-height: calc(100vh - 460px); min-height: 220px; overflow:auto; padding-right:6px;"
            }, [])
          ])
        ])
      ])
    ]);

    document.body.appendChild(modal);

    qs("#aiOpClose").addEventListener("click", () => closeModalCompat(modal));
    modal.addEventListener("click", (e) => { if (e.target === modal) closeModalCompat(modal); });

    qs("#aiOpRun").addEventListener("click", () => planThenExecute(qs("#aiOpInput").value));

    // Upload button
    qs("#aiOpUploadBtn").addEventListener("click", async () => {
      const f = qs("#aiOpFile").files && qs("#aiOpFile").files[0];
      if (!f) { alert("Choose a file first."); return; }
      await uploadFile(f);
    });

    // Ctrl/Cmd+Enter to run
    qs("#aiOpInput").addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        qs("#aiOpRun").click();
      }
    });

    setUploadBadge();
  }

  function openOperator() {
    ensureUI();
    openModalCompat(qs("#aiOperatorModal"));
  }

    function bindNav() {
    const handler = (e) => {
      try { e.preventDefault(); } catch (_) {}
      try { e.stopImmediatePropagation(); } catch (_) {}
      openOperator();
    };

    // Strongest: explicit id
    const nav = qs("#aiOperatorNav");
    if (nav) nav.addEventListener("click", handler, true);

    // Next: header uses data-ai-nav="1"
    const nav2 = document.querySelector("a[data-ai-nav='1']");
    if (nav2 && nav2 !== nav) nav2.addEventListener("click", handler, true);

    // Fallback: any link that includes ai=1
    document.addEventListener("click", (e) => {
      const a = e.target && e.target.closest ? e.target.closest("a[href*='ai=1']") : null;
      if (!a) return;
      handler(e);
    }, true);
  }


    // Next: your header uses data-ai-nav="1"
    const nav2 = document.querySelector("a[data-ai-nav='1']");
    if (nav2 && nav2 !== nav) {
      nav2.addEventListener("click", (e) => {
        e.preventDefault();
        openOperator();
      });
    }

    // Fallback: any link that includes ai=1
    document.addEventListener("click", (e) => {
      const a = e.target && e.target.closest ? e.target.closest("a[href*='ai=1']") : null;
      if (!a) return;
      e.preventDefault();
      openOperator();
    });
  }

  function init() {
    bindNav();

    // If user lands directly on /?ai=1, open automatically.
    try {
      const u = new URL(location.href);
      if (u.searchParams.get("ai") === "1") openOperator();
    } catch (_) {}
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();
