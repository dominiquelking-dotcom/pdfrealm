<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDFRealm – Secure Vault</title>

    <!-- Tiny empty favicon to avoid 404 -->
    <link rel="icon" href="data:;base64,=" />

    <!-- Global styles -->
    <link rel="stylesheet" href="/styles.css" />

    <!-- Header + Secure Vault specific layout -->
    <style>
      /* ===== FORCE FULL-WIDTH (no side margins) for THIS PAGE ONLY ===== */
      body { margin: 0; }

      main.wrap {
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
      }

      .vault-panel {
        width: 100%;
        max-width: 100%;
        margin: 0 !important;
        border-radius: 0;
      }

      .vault-panel .tool-header,
      .vault-panel .tool-body {
        padding-left: 18px;
        padding-right: 18px;
      }

      @media (max-width: 980px) {
        .vault-panel .tool-header,
        .vault-panel .tool-body {
          padding-left: 12px;
          padding-right: 12px;
        }
      }

      /* ===== HEADER LAYOUT (MATCH pricing.html EXACTLY) ===== */
      .brand-left {
        display: flex;
        align-items: center;
        gap: 14px;
      }

      .brand-text {
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      .brand-divider {
        width: 1px;
        align-self: stretch;
        background: var(--line);
        margin: 0 10px;
        opacity: 0.9;
      }

      .left-secure-nav {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .nav-chip {
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 0.9rem;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        cursor: default;
        opacity: 0.9;
        text-decoration: none;
        white-space: nowrap;
      }

      .nav-chip:hover { background: rgba(255, 255, 255, 0.06); }
      .nav-chip-pill {
        font-size: 0.78rem;
        color: var(--muted);
        border-radius: 999px;
        padding: 3px 8px;
        border: 1px solid var(--line);
        background: rgba(0, 0, 0, 0.3);
      }

      .nav-chip-active {
        border-color: rgba(96, 165, 250, 0.8);
        box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.4);
        opacity: 1;
      }

      .right-nav-cluster {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .top-nav {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .nav-link {
        border-radius: 999px;
        padding: 8px 14px;
        border: 1px solid transparent;
        background: transparent;
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--muted);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        text-decoration: none;
      }

      .nav-link:hover { background: rgba(255, 255, 255, 0.04); color: var(--text); }
      .nav-link-active {
        border-color: var(--line);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
      }

      .workspace-menu { position: relative; }
      .workspace-toggle { cursor: pointer; }
      .workspace-caret { font-size: 0.8rem; opacity: 0.8; }

      .workspace-dropdown {
        position: absolute;
        right: 0;
        top: 100%;
        margin-top: 8px;
        background: rgba(15, 22, 36, 0.96);
        border: 1px solid var(--line);
        border-radius: 14px;
        box-shadow: var(--shadow);
        padding: 8px;
        display: none;
        flex-direction: column;
        min-width: 280px;
        z-index: 80;
      }

      .workspace-item {
        padding: 7px 10px;
        border-radius: 10px;
        font-size: 0.92rem;
        color: var(--muted);
        text-align: left;
        border: none;
        background: transparent;
        width: 100%;
        cursor: pointer;
        text-decoration: none;
        display: block;
        white-space: nowrap;
      }

      .workspace-item:hover { background: rgba(255, 255, 255, 0.04); color: var(--text); }
      .workspace-menu.workspace-open .workspace-dropdown { display: flex; }

      @media (max-width: 980px) {
        .brand-left { flex-wrap: wrap; }
        .right-nav-cluster { gap: 10px; }
        .workspace-dropdown { right: auto; left: 0; }
      }

      /* ===== SECURE VAULT LAYOUT ===== */
      .vault-grid {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 16px;
        align-items: start;
      }

      .vault-sidebar { display: flex; flex-direction: column; gap: 10px; }

      .vault-tree {
        list-style: none;
        padding-left: 0;
        margin: 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .vault-tree li { padding: 4px 0; cursor: pointer; }

      .vault-tree li span {
        padding: 6px 8px;
        border-radius: 10px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .vault-tree li span:hover { background: rgba(255, 255, 255, 0.06); color: var(--text); }

      .vault-tree .vault-tree-root { font-weight: 800; color: var(--text); }

      .vault-tree .vault-tree-children {
        list-style: none;
        padding-left: 16px;
        margin-top: 6px;
      }

      .vault-tree .vault-selected {
        background: rgba(96, 165, 250, 0.12);
        border: 1px solid rgba(96, 165, 250, 0.35);
        color: var(--text);
      }

      .vault-main { display: flex; flex-direction: column; gap: 14px; min-width: 0; }

      /* ===== Vault section tabs ===== */
      .vault-tabs { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 2px; }

      .vault-tab {
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
        border-radius: 999px;
        padding: 10px 14px;
        font-size: 0.95rem;
        font-weight: 700;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .vault-tab:hover { background: rgba(255, 255, 255, 0.07); color: var(--text); }

      .vault-tab-active {
        color: var(--text);
        border-color: rgba(96, 165, 250, 0.8);
        box-shadow: inset 0 0 0 1px rgba(96, 165, 250, 0.25);
        background: linear-gradient(135deg, rgba(96, 165, 250, 0.18), rgba(45, 212, 191, 0.08));
      }

      .vault-section { display: none; }
      .vault-section.vault-section-active { display: block; }

      
      /* Container import row: keep file chooser and password aligned */
      .container-import-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-top: 8px;
      }
      .container-import-row .field { min-width: 0; }
      .container-import-row input[type="file"] { width: 100%; }
      @media (max-width: 980px) {
        .container-import-row { grid-template-columns: 1fr; }
      }

      /* Upload row: ensure “No file chosen” fully visible */
      .vault-upload-row { display: flex; flex-direction: column; gap: 10px; }

      .vault-upload-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        min-width: 0;
      }

      .vault-upload-controls input[type="file"] {
        flex: 1 1 auto;
        min-width: 360px;
        max-width: 100%;
      }

      @media (max-width: 980px) {
        .vault-upload-controls { flex-direction: column; align-items: stretch; }
        .vault-upload-controls input[type="file"] { min-width: 0; width: 100%; }
      }

      /* File list table */
      .vault-file-list { width: min(900px, 100%); table-layout: fixed; border-collapse: collapse; font-size: 0.95rem; }
      .vault-file-list th,
      .vault-file-list td {
        padding: 7px 10px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.35);
        text-align: left;
        vertical-align: middle;
      }
      .vault-file-list th { color: var(--muted); font-weight: 600; font-size: 0.9rem; }
      .vault-file-list tr:hover td { background: rgba(15, 23, 42, 0.65); }

      /* ===== Vault file view toggle + Grid view ===== */

.vx-view-toggle { display:flex; align-items:center; gap:6px; margin-left: 6px; }
.vx-view-toggle .btn { padding: 8px 10px; border-radius: 12px; }


/* Scroll container for Vault file list/grid */
.vault-main{ min-height: 0; }
#vaultFilesCard{ min-height: 0; }
.vx-files-scroll{
  margin-top: 10px;
  border-radius: 14px;
  overflow: auto;
  height: clamp(260px, calc(100vh - 410px), 760px);
  padding-right: 6px;
  padding-bottom: 14px;
}
@media (max-width: 980px){
  .vx-files-scroll{ height: clamp(220px, calc(100vh - 360px), 640px); }
}

.vx-file-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 14px 14px;
  margin-top: 10px;
  align-content: flex-start;
  justify-content: flex-start;
  padding: 4px 2px;
}

.vx-file-grid-item {
  position: relative;
  width: 156px;
  /* Give the icon + 2-line name enough vertical room (prevents text clipping) */
  height: 136px;
  border: 1px solid transparent;
  background: transparent;
  border-radius: 14px;
  padding: 10px 10px 12px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 8px;
  user-select: none;
}

.vx-file-grid-item:hover { 
  background: rgba(255,255,255,0.04); 
  border-color: rgba(255,255,255,0.14);
}

.vx-file-select {
  position: absolute;
  top: 8px;
  left: 8px;
  opacity: 0;
  transition: opacity 120ms ease;
}
.vx-file-grid-item:hover .vx-file-select,
.vx-file-grid-item:focus-within .vx-file-select,
.vx-file-grid-item[data-selected="1"] .vx-file-select { opacity: 1; }
.vx-file-cb { width: 16px; height: 16px; }

.vx-file-thumb {
  width: 56px;
  height: 46px;
  display:flex;
  align-items:center;
  justify-content:center;
  opacity: 0.92;
  color: rgba(148, 163, 184, 0.95);
}
.vx-row-icon{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;}
.vx-row-icon svg{width:18px;height:18px;display:block;}


/* Grid view: folders are yellow + filled (Windows-like) */

.vx-folder-grid-item .vx-file-select{ display:none; }

/* Folder tiles: yellow icon */
.vx-folder-grid-item .vx-file-thumb { color: rgba(250, 204, 21, 0.98); }
.vx-folder-grid-item:hover .vx-file-thumb,
.vx-folder-grid-item:focus-within .vx-file-thumb { color: rgba(253, 224, 71, 1); }

/* Fill folder body (first path) */
.vx-folder-grid-item .vx-file-thumb svg path:first-child {
  fill: currentColor;
  fill-opacity: 0.78;
}

/* Keep strokes readable on dark background */
.vx-folder-grid-item .vx-file-thumb svg path:first-child,
.vx-folder-grid-item .vx-file-thumb svg path:nth-child(2) {
  stroke: rgba(0,0,0,0.45);
  stroke-opacity: 0.40;
}

.vx-file-title {
  width: 100%;
  text-align: center;
  font-size: 0.95rem;
  /* Slightly taller line-height + bottom padding avoids clipped descenders */
  line-height: 1.2rem;
  color: rgba(226,232,240,0.96);
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  word-break: break-word;
  padding: 0 6px 2px;
}

.vx-file-hover-actions {
  position:absolute;
  left:8px;
  right:8px;
  bottom:8px;
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:6px;
  opacity:0;
  pointer-events:none;
  transition: opacity 120ms ease;
  padding-top: 6px;
  background: linear-gradient(to top, rgba(15,23,42,0.78), rgba(15,23,42,0.0));
  border-bottom-left-radius: 12px;
  border-bottom-right-radius: 12px;
}
.vx-file-grid-item:hover .vx-file-hover-actions,
.vx-file-grid-item:focus-within .vx-file-hover-actions {
  opacity:1;
  pointer-events:auto;
}

.vx-mini-btn { 
  padding: 5px 7px; 
  border-radius: 12px; 
  font-size: 0.80rem; 
  opacity: 0.95;
}


/* ===== Windows-style icon tiles: hover menu ===== */
.vx-tile-more{
  position:absolute;
  top:8px;
  right:8px;
  width:28px;
  height:28px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(15,23,42,0.35);
  color: rgba(226,232,240,0.95);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 18px;
  line-height: 1;
  opacity:0;
  pointer-events:none;
  transition: opacity 120ms ease, background 120ms ease, border-color 120ms ease;
}
.vx-file-grid-item:hover .vx-tile-more,
.vx-file-grid-item:focus-within .vx-tile-more,
.vx-file-grid-item[data-menu="1"] .vx-tile-more{
  opacity:1;
  pointer-events:auto;
}
.vx-tile-more:hover{
  background: rgba(255,255,255,0.08);
  border-color: rgba(255,255,255,0.20);
}

.vx-tile-menu{
  position:absolute;
  top:40px;
  right:8px;
  min-width: 160px;
  padding: 8px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(10,15,30,0.92);
  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
  opacity:0;
  transform: translateY(-6px);
  pointer-events:none;
  transition: opacity 120ms ease, transform 120ms ease;
  z-index: 50;
}
.vx-file-grid-item[data-menu="1"] .vx-tile-menu{
  opacity:1;
  transform: translateY(0);
  pointer-events:auto;
}
.vx-menu-item{
  width:100%;
  text-align:left;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid transparent;
  background: transparent;
  color: rgba(226,232,240,0.95);
  font-size: 0.92rem;
  display:flex;
  align-items:center;
  justify-content:space-between;
}
.vx-menu-item:hover{
  background: rgba(255,255,255,0.07);
  border-color: rgba(255,255,255,0.10);
}
.vx-menu-sep{
  height:1px;
  background: rgba(255,255,255,0.10);
  margin: 6px 2px;
}


/* ===== List view: compact actions (Windows-like) ===== */
.vx-row-actions{ position: relative; width: 72px; }
.vx-row-more{
  width: 28px;
  height: 28px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(15,23,42,0.35);
  color: rgba(226,232,240,0.95);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 18px;
  line-height:1;
  opacity: 0;
  pointer-events: none;
  transition: opacity 120ms ease, background 120ms ease, border-color 120ms ease;
}
.vault-file-list tr:hover .vx-row-more,
.vx-row-actions[data-menu="1"] .vx-row-more{
  opacity: 1;
  pointer-events: auto;
}
.vx-row-more:hover{
  background: rgba(255,255,255,0.08);
  border-color: rgba(255,255,255,0.20);
}
.vx-row-menu{
  position:absolute;
  top: 34px;
  right: 0;
  min-width: 170px;
  padding: 8px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(10,15,30,0.92);
  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
  opacity:0;
  transform: translateY(-6px);
  pointer-events:none;
  transition: opacity 120ms ease, transform 120ms ease;
  z-index: 60;
}
.vx-row-actions[data-menu="1"] .vx-row-menu{
  opacity:1;
  transform: translateY(0);
  pointer-events:auto;
}
.vx-drop-active { outline: 2px dashed rgba(255,255,255,0.22); outline-offset: -8px; }

      .vault-badge-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }

      .vault-badge {
        border-radius: 999px;
        padding: 4px 10px;
        border: 1px solid rgba(148, 163, 184, 0.8);
        font-size: 0.82rem;
        color: var(--muted);
        background: rgba(15, 23, 42, 0.9);
      }

      .vault-badge-strong { border-color: rgba(96, 165, 250, 0.9); color: var(--text); }

      .vault-hint { margin-top: 10px; color: var(--muted); font-size: 0.85rem; }

      .vault-split2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
        min-width: 0;
      }

      @media (max-width: 980px) {
        .vault-grid { grid-template-columns: 1fr; }
        .vault-split2 { grid-template-columns: 1fr; }
      }

      /* ===== Chat UI ===== */
      .chat-shell {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 14px;
        min-height: 520px;
      }

      .chat-list {
        border: 1px solid var(--line);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.96);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 520px;
      }

      .chat-list-head {
        padding: 12px 12px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(255,255,255,.04);
      }

      .chat-room {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.22);
        cursor: pointer;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .chat-room:hover { background: rgba(255,255,255,.04); color: var(--text); }

      .chat-room .t { font-weight: 800; color: var(--text); }
      .chat-room .s { font-size: 0.88rem; color: var(--muted); }

      .chat-room.chat-room-active {
        background: rgba(96, 165, 250, 0.10);
        box-shadow: inset 0 0 0 1px rgba(96, 165, 250, 0.22);
      }

      .chat-pane {
        border: 1px solid var(--line);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.96);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 520px;
      }

      .chat-pane-head {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(255,255,255,.04);
      }

      .chat-messages {
        padding: 14px;
        overflow: auto;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .chat-bubble {
        max-width: 78%;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.22);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
      }

      .chat-bubble.me {
        margin-left: auto;
        border-color: rgba(45, 212, 191, 0.35);
        background: rgba(45, 212, 191, 0.10);
      }

      .chat-bubble .meta { font-size: 0.82rem; color: var(--muted); margin-bottom: 4px; }

      .chat-compose {
        border-top: 1px solid var(--line);
        padding: 12px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        background: rgba(0,0,0,.10);
      }

      .chat-compose textarea { min-height: 46px; resize: none; }

      @media (max-width: 980px) {
        .chat-shell { grid-template-columns: 1fr; }
        .chat-list, .chat-pane { min-height: 420px; }
      }

      /* ===== Video UI ===== */
      .video-shell { display: grid; grid-template-columns: 1fr 320px; gap: 14px; }

      .video-stage {
        border: 1px solid var(--line);
        border-radius: 16px;
        overflow: hidden;
        background: rgba(15, 23, 42, 0.96);
        min-height: 520px;
        display: flex;
        flex-direction: column;
      }

      .video-stage-head {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(255,255,255,.04);
      }

      .video-grid {
        flex: 1;
        padding: 14px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }

      .video-tile {
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 16px;
        background: rgba(255,255,255,.03);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .video-tile .cap {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        color: var(--muted);
        font-size: 0.9rem;
        background: rgba(0,0,0,.10);
      }

      .video-placeholder {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        padding: 16px;
        text-align: center;
      }

      .video-side {
        border: 1px solid var(--line);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.96);
        overflow: hidden;
        min-height: 520px;
        display: flex;
        flex-direction: column;
      }

      .video-side-head {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(255,255,255,.04);
      }

      .video-side-body {
        padding: 12px 14px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow: auto;
      }

      .participant {
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(255,255,255,.03);
        color: var(--muted);
      }

      @media (max-width: 980px) {
        .video-shell { grid-template-columns: 1fr; }
        .video-grid { grid-template-columns: 1fr; }
        .video-stage, .video-side { min-height: 420px; }
      }

      /* ===== Secure Send UI ===== */
      .send-shell { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
      @media (max-width: 980px) { .send-shell { grid-template-columns: 1fr; } }

      .send-callout {
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(96, 165, 250, 0.10);
        border-radius: 16px;
        padding: 12px 14px;
        color: var(--text);
      }

      .send-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
      @media (max-width: 980px) { .send-row { grid-template-columns: 1fr; } }

      /* ===== ACTION BUTTONS IN TABLE ===== */
      .vault-actions {
        display: inline-flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .btn-mini {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 0.86rem;
        font-weight: 700;
      }
      .vault-status {
        margin-top: 10px;
        color: var(--muted);
        font-size: 0.92rem;
      }
      .vault-status strong { color: var(--text); }
      .vault-busy { opacity: 0.85; }
      .vault-inline {
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        flex-wrap: wrap;
      }
      .vault-inline .left {
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap: wrap;
      }
      .vault-inline .right {
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap: wrap;
      }
      .vault-pill {
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 6px 10px;
        background: rgba(255,255,255,.03);
        color: var(--muted);
        font-size: 0.88rem;
      }

      .vault-modal {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.55);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 18px;
        z-index: 200;
      }
      .vault-modal.open { display: flex; }
      .vault-modal .modal-card {
        width: 100%;
        max-width: 520px;
        border: 1px solid var(--line);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.98);
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .vault-modal .modal-head {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(255,255,255,.04);
      }
      .vault-modal .modal-body { padding: 14px; }
      .vault-modal .modal-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      @media (max-width: 640px) {
        .vault-modal .modal-row { grid-template-columns: 1fr; }
      }
    
      /* ===== Status dots (ensures Account dot works even if styles.css changes) ===== */
      .dot { display:inline-block; width:10px; height:10px; border-radius:999px; background: rgba(255,255,255,0.25); }
      .dot.ok { background: #22c55e; }
      .dot.warn { background: #f59e0b; }
      .dot.bad { background: #ef4444; }

      /* ===== Windows-like folder tree (Vault) ===== */
      .vault-tree { list-style:none; margin:0; padding:0; }
      .vault-tree-node { margin:0; padding:0; }
      .vault-tree-row { display:flex; align-items:center; gap:6px; padding: 4px 6px; border-radius: 10px; }
      .vault-tree-row:hover { background: rgba(255,255,255,0.06); }
      .vault-tree-toggle { width:22px; height:22px; border: 1px solid var(--line); background: rgba(255,255,255,0.04); color: var(--text); border-radius: 6px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; font-size: 12px; }
      .vault-tree-toggle[aria-expanded="false"]::before { content: "▸"; }
      .vault-tree-toggle[aria-expanded="true"]::before { content: "▾"; }
      .vault-tree-toggle.is-leaf { opacity: 0.35; cursor: default; }
      .vault-tree-toggle.is-leaf::before { content: ""; }
      .vault-tree-btn { border: 0; background: transparent; color: var(--text); cursor: pointer; text-align:left; padding: 0; font-size: 0.95rem; display:flex; align-items:center; gap:8px; min-width:0; }
      .vault-tree-btn .label { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 220px; }
      .vault-tree-btn.active .label { font-weight: 800; }
      .vault-tree-indent { padding-left: 18px; }
      #folderSearch, #fileSearch, #fileSort {
        border: 1px solid var(--line);
        background: rgba(255,255,255,0.04);
        color: var(--text);
        border-radius: 10px;
        padding: 7px 10px;
        font-size: 0.95rem;
        outline: none;
      }
      #folderSearch:focus, #fileSearch:focus, #fileSort:focus { border-color: rgba(255,255,255,0.25); }
      #fileSort { padding-right: 28px; }
      .vault-breadcrumb a { color: var(--text); text-decoration: none; border-bottom: 1px dotted rgba(255,255,255,0.25); }
      .vault-breadcrumb a:hover { border-bottom-color: rgba(255,255,255,0.6); }

      /* ---- Footer: keep at bottom (avoid cutting through content) ---- */
      body { min-height: 100vh; display: flex; flex-direction: column; }
      main.wrap { flex: 1 0 auto; }
      footer.footer { flex: 0 0 auto; position: static !important; margin-top: 16px; }
    

/* Hide Trash UI (we still soft-delete behind the scenes) */
#emptyTrashBtn, #bulkRestoreBtn, #bulkDeleteBtnTrash, .trash-section, [data-folder="_Trash"] { display:none !important; }

</style>
  </head>

  <body style="overflow-y:auto;">
    <!-- HEADER (MATCH pricing.html) -->
    <header class="topbar">
      <div class="topbar-inner">
        <!-- LEFT: Brand + Secure tabs -->
        <div class="brand-left">
          <div class="brand">
            <div class="logo"></div>
            <div class="brand-text">PDFRealm</div>
          </div>

          <div class="brand-divider"></div>

          <nav class="left-secure-nav" aria-label="Secure">
                        <a href="/?ai=1" class="nav-chip" data-ai-nav="1">
              AI Operator
              <span class="nav-chip-pill">BETA</span>
            </a>
<a href="/vault.html" class="nav-chip nav-chip-active">
              Secure Vault
              <span class="nav-chip-pill">AES-256</span>
            </a>
            <a href="/office.html" class="nav-chip">
              Office
              <span class="nav-chip-pill">DOCX/XLSX/PPTX</span>
            </a>
            <a href="/" class="nav-chip">Quick Tools</a>
          </nav>
        </div>

        <!-- RIGHT: Tools + Industry Packs + Pricing + Account -->
        <div class="right-nav-cluster">
          <nav class="top-nav" aria-label="Primary">
<div class="workspace-menu" id="industryMenuWrap">
              <button class="nav-link workspace-toggle" type="button" id="industryToggle">
                Industry Packs
                <span class="workspace-caret">▾</span>
              </button>
              <div class="workspace-dropdown" id="industryDropdown" role="menu" aria-label="Industry Packs">
                <a class="workspace-item" role="menuitem" href="/broker.html">Broker TMS Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/carrier.html">Carrier Dashboard</a>
                <div style="height:1px; background: rgba(255,255,255,0.10); margin: 8px 10px;"></div>
                <a class="workspace-item" role="menuitem" href="/legal.html">Legal Workspace</a>
                <a class="workspace-item" role="menuitem" href="/real-estate.html">Real Estate Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/accounting.html">Accounting Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/hr.html">HR Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/marketing.html">Marketing Dashboard</a>
                <a class="workspace-item" role="menuitem" href="/csuite.html">C-Suite Dashboard</a>
              </div>
            </div>

            <a href="/pricing.html" class="nav-link">Pricing</a>
          </nav>

          <div class="top-actions">
            <button
              id="accountLoginBtn"
              class="btn"
              type="button"
              aria-haspopup="dialog"
              aria-controls="accountModal"
            >
              <span id="accountDot" class="dot"></span>
              Account
            </button>
          </div>
        </div>
      </div>
    </header>

    <!-- MAIN: Secure Vault -->
    <main class="wrap">
      <section class="panel vault-panel">
        <div class="tool-header">
          <div style="min-width:0;">
            <h2>Secure Vault</h2>
            <p>
              A <strong>secure, encrypted workspace</strong> for PDFs, documents, and sensitive data.
              This Vault hosts <strong>Secure Send</strong>, <strong>Secure Chat</strong>, <strong>Secure Video Chat</strong>, and
              <strong>Encrypted Containers</strong> for local/offline protection.
            </p>

            

            <div class="vault-tabs" style="margin-top:14px;">
              <button class="vault-tab vault-tab-active" type="button" data-vault-tab="files">Vault Files</button>
              <button class="vault-tab" type="button" data-vault-tab="send">Secure Send</button>
              <button class="vault-tab" type="button" data-vault-tab="containers">Encrypted Containers</button>
              <button class="vault-tab" type="button" data-vault-tab="chat">Secure Chat</button>
              <button class="vault-tab" type="button" data-vault-tab="video">Secure Video Chat</button>
            </div>
          </div>
        </div>

        <div class="tool-body">
          <div class="vault-grid">
            <!-- LEFT: folder tree (Windows-style) -->
            <aside class="card vault-sidebar">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <h3 class="h3" style="margin:0;">Folders</h3>
                <button id="newFolderBtn" class="btn btn-secondary" type="button" disabled>
                  + New
                </button>
              </div>

              <p style="margin:8px 0 10px; color:var(--muted); font-size:0.9rem;">
                Navigate your vault like a folder tree.
              </p>

              
              <div class="vault-tree-controls" style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                <input id="folderSearch" type="text" placeholder="Search folders…" style="flex:1; min-width:0;" disabled />
                <button id="expandAllBtn" class="btn btn-secondary" type="button" title="Expand all" disabled>Expand</button>
                <button id="collapseAllBtn" class="btn btn-secondary" type="button" title="Collapse all" disabled>Collapse</button>
              </div>

              <ul class="vault-tree" id="vaultTree"></ul>


              <div class="row" style="gap:8px; margin-top:10px;">
              <button class="btn btn-secondary" id="folderRenameBtn" disabled>Rename</button>
              <button class="btn btn-secondary" id="folderMoveBtn" disabled>Move</button>
              <button class="btn btn-secondary" id="folderDeleteBtn" disabled>Delete</button>
            </div>


              <div class="vault-hint">
                Selected folder: <b id="selectedFolderLabel">My Vault Folder</b>
              </div>
            </aside>

            <!-- RIGHT: content sections -->
            <div class="vault-main">
              <!-- ===== SECTION: FILES ===== -->
              <div class="vault-section vault-section-active" data-vault-section="files">
                <div class="card">
                  <div class="vault-inline">
                    <div class="left">
                      <h3 class="h3" style="margin:0;">Upload to current folder</h3>
                      <span class="vault-pill" id="currentFolderPill">Folder: My Vault Folder</span>
                    </div>
                    <div class="right">
                      <button id="vaultRefreshBtn" class="btn btn-secondary" type="button" disabled>Refresh</button>
                    </div>
                  </div>

                  <p style="margin:8px 0 12px; color:var(--muted); font-size:0.9rem;">
                    Choose a file and upload it into the currently selected folder.
                    Files will be encrypted at rest on the backend.
                  </p>

                  <div class="vault-upload-row">
                    <label for="vaultFile">Select file</label>
                    <div class="vault-upload-controls">
                      <input id="vaultFile" type="file" />
                      <button id="vaultUploadBtn" class="btn btn-primary" type="button" disabled>
                        Upload
                      </button>
                    </div>
                    <div class="vault-status" id="vaultUploadStatus"></div>
                  </div>

                  <div class="vault-hint">
                    Upload requires login. This page stores a token in <code>localStorage</code> after login.
                  </div>
                </div>

                <div class="card" id="vaultFilesCard">
                  <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                    <h3 class="h3" style="margin-bottom:0;">Files in folder</h3>
                    <div class="tool-actions" style="margin-top:0;">
                      <button id="bulkDownloadBtn" class="btn btn-secondary" type="button" disabled>Download</button>
                      <button id="bulkMoveBtn" class="btn btn-secondary" type="button" disabled>Move</button>
                      <button id="bulkRestoreBtn" class="btn btn-secondary" type="button" disabled style="display:none;">Restore</button>
                      <button id="emptyTrashBtn" class="btn btn-secondary" type="button" disabled style="display:none;">Empty Trash</button>
                      <button id="bulkDeleteBtn" class="btn btn-secondary" type="button" disabled>Delete</button>
                    </div>
                  </div>
                  <div class="vault-file-controls" style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin:10px 0 6px;">
                    <div id="vaultBreadcrumb" class="vault-breadcrumb" style="min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:var(--muted); font-size:0.92rem;">
                      Path: <span id="vaultBreadcrumbPath">/</span>
                    </div>
                    <div style="display:flex; align-items:center; gap:8px;">
                      <input id="fileSearch" type="text" placeholder="Search files…" style="width:220px;" disabled />
                      <select id="fileSort" disabled>
                        <option value="newest">Sort: Newest</option>
                        <option value="oldest">Sort: Oldest</option>
                        <option value="az">Sort: A → Z</option>
                        <option value="za">Sort: Z → A</option>
                        <option value="sizeDesc">Sort: Size (desc)</option>
                        <option value="sizeAsc">Sort: Size (asc)</option>
                      </select>
                      <div class="vx-view-toggle">
                        <button id="fileViewListBtn" class="btn btn-secondary" type="button" disabled aria-pressed="true">List</button>
                        <button id="fileViewGridBtn" class="btn btn-secondary" type="button" disabled aria-pressed="false">Grid</button>
                      </div>
                    </div>
                  </div>
<div id="vaultFilesScroll" class="vx-files-scroll">
<table id="vaultFilesTable" class="vault-file-list">
                    <thead>
                      <tr>
                        <th style="width:44px;"><input id="selectAllCb" type="checkbox" disabled /></th>
                        <th>Name</th>
                        <th style="width:140px;">Type</th>
                        <th style="width:90px;">Size</th>
                        <th style="width:160px;">Last modified</th>
                        <th style="width:72px;">Actions</th>
                      </tr>
                    </thead>
                    <tbody id="vaultFilesTbody">
                      <tr>
                        <td colspan="6" style="color:var(--muted); font-size:0.9rem;">
                          Login to load your vault files.
                        </td>
                      </tr>
                    </tbody>
                  </table>

                  <div id="vaultFilesGrid" class="vx-file-grid" style="display:none;"></div>
</div>



                  <div class="vault-status" id="vaultListStatus"></div>
                </div>
              </div>

              <!-- ===== SECTION: SECURE SEND ===== -->
              <div class="vault-section" data-vault-section="send">
                <div class="card">
                  <h3 class="h3">Secure Send</h3>
                  <div class="send-shell" style="margin-top:14px;">
                    <div class="card" style="padding:14px;">
                      <h3 class="h3">Choose file(s)</h3>

                      <label for="sendFromVault">From Vault (current folder)</label>
                      <select id="sendFromVault" disabled>
                        <option>Login to load files…</option>
                      </select>

                      <label for="sendLocal">Or upload a local file</label>
                      <input id="sendLocal" type="file" multiple />

                      <div class="tool-actions">
                        <button id="sendAddBtn" class="btn btn-secondary" type="button" disabled>Add to send</button>
                        <button id="sendClearBtn" class="btn btn-secondary" type="button" disabled>Clear</button>
                      </div>

                      <div class="vault-hint">Tip: select files in the Vault table (checkboxes) or pick from the dropdown, then click “Add to send”.</div>

                      <div id="sendQueueWrap" style="margin-top:12px; border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.03); border-radius: 14px; padding: 10px 12px;">
                        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
                          <div style="font-weight:800;">Queued files (<span id="sendQueueCount">0</span>)</div>
                          <button id="sendQueueUseSelectionBtn" class="btn btn-secondary btn-mini" type="button" disabled>Use table selection</button>
                        </div>
                        <div id="sendQueueList" style="margin-top:8px; display:flex; flex-direction:column; gap:6px;"></div>
                      </div>
                    </div>

                    <div class="card" style="padding:14px;">
                      <h3 class="h3">Delivery settings</h3>

                      <div class="send-row">
                        <div>
                          <label for="sendTo">Recipient (email)</label>
                          <input id="sendTo" type="email" placeholder="name@company.com" />
                        </div>
                        <div>
                          <label for="sendExpire">Link expires</label>
                          <select id="sendExpire">
                            <option>15 minutes</option>
                            <option>1 hour</option>
                            <option>24 hours</option>
                            <option>7 days</option>
                          </select>
                        </div>
                      </div>

                      <div class="send-row">
                        <div>
                          <label for="sendPasscode">Passcode (optional)</label>
                          <input id="sendPasscode" type="text" placeholder="Auto-generate or custom" />
                        </div>
                        <div>
                          <label for="sendPerms">Permissions</label>
                          <select id="sendPerms">
                            <option>View only</option>
                            <option>Download allowed</option>
                            <option>View + Download + Print</option>
                          </select>
                        </div>
                      </div>

                      <label for="sendNote">Message (optional)</label>
                      <textarea id="sendNote" placeholder="Add a note for the recipient..."></textarea>

                      <div class="tool-actions">
                        <button id="sendCreateBtn" class="btn btn-primary" type="button" disabled>Create secure link</button>
                        <button id="sendRevokeBtn" class="btn btn-secondary" type="button" disabled>Revoke</button>
                      </div>

                      <div class="vault-status" id="sendStatus" style="margin-top:10px;"></div>

                      <div id="sendLinkWrap" style="display:none; margin-top:12px;">
                        <div class="send-callout" style="margin-bottom:10px;">
                          <div style="font-weight:800; margin-bottom:6px;">Secure link</div>
                          <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            <input id="sendLinkOut" type="text" readonly />
                            <button id="sendCopyLinkBtn" class="btn btn-secondary" type="button">Copy</button>
                          </div>
                          <div id="sendPasscodeOutWrap" style="display:none; margin-top:10px;">
                            <div style="font-weight:800; margin-bottom:6px;">Passcode</div>
                            <div style="display:flex; gap:8px; flex-wrap:wrap;">
                              <input id="sendPasscodeOut" type="text" readonly />
                              <button id="sendCopyPassBtn" class="btn btn-secondary" type="button">Copy</button>
                            </div>
                            <div class="vault-hint" style="margin-top:8px;">Passcode is shown once at creation. Save it.</div>
                          </div>
                        </div>
                      </div>

                      <div class="vault-hint">Links are manual: copy the link and send it however you want (email, DM, etc). No Twilio required.</div>
                    </div>
                  </div>

                  <hr class="hr" />

                  <h3 class="h3">Access log (preview)</h3>
                  <table class="vault-file-list">
                    <thead>
                      <tr>
                        <th>Event</th>
                        <th>Recipient</th>
                        <th>Time</th>
                        <th>Status</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Link created</td>
                        <td>name@company.com</td>
                        <td>Dec 22, 2025</td>
                        <td>Active</td>
                      </tr>
                      <tr>
                        <td>Viewed</td>
                        <td>name@company.com</td>
                        <td>Dec 22, 2025</td>
                        <td>OK</td>
                      </tr>
                      <tr>
                        <td colspan="4" style="color:var(--muted); font-size:0.9rem;">
                          Static demo content. Once wired, this becomes your audit trail.
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>

              <!-- ===== SECTION: ENCRYPTED CONTAINERS ===== -->
              <div class="vault-section" data-vault-section="containers">
                <div class="card">
                  <h3 class="h3">Encrypted Containers</h3>
                  <p style="margin:4px 0 12px; color:var(--muted); font-size:0.9rem;">
                    Create a downloadable <strong>encrypted container</strong> for offline storage.
                    Import files into the container, download locally, and re-import later.
                  </p>

                  

                  <div class="vault-split2" style="margin-top:14px;">
                    <div class="card" style="padding:14px;">
                      <h3 class="h3">Create new container</h3>

                      <label for="containerName">Container name</label>
                      <input id="containerName" type="text" placeholder="e.g., 2025_Taxes_Vault" />

                      <label for="containerPassword">Container password</label>
                      <input id="containerPassword" type="password" placeholder="Strong password required" />

                      <label for="containerTtl">Auto-lock policy (preview)</label>
                      <select id="containerTtl">
                        <option value="30m">30 minutes</option>
                        <option value="1h">1 hour</option>
                        <option value="4h">4 hours</option>
                        <option value="8h">8 hours</option>
                      </select>

                      <label for="containerFiles">Add files into container</label>
                      <input id="containerFiles" type="file" multiple />

                      <label style="display:flex; align-items:center; gap:10px; margin-top:10px; color:var(--muted); font-size:0.95rem;">
                        <input id="containerAlsoUpload" type="checkbox" style="width:auto; margin:0;" />
                        Also upload the encrypted container into the Vault after creation
                      </label>


                      <div class="tool-actions">
                        <button id="containerCreateBtn" class="btn btn-primary" type="button" disabled>Create container</button>
                        <button id="containerDownloadBtn" class="btn btn-secondary" type="button" disabled>Download container</button>
                      
                        <button id="offlineUnlockerBtn" class="btn btn-secondary" type="button">Offline unlocker</button>
</div>

                      <div class="vault-hint">
                        Creates a single encrypted container file you can download (and optionally store in your Vault).<div id="containerStatus" style="margin-top:8px;"></div>
                      </div>
                    </div>

                    <div class="card" style="padding:14px;">
                      <h3 class="h3">Import existing container</h3>

                      <div class="container-import-row">
                        <div class="field">
                          <label for="containerImportFile">Select container file</label>
                          <input id="containerImportFile" type="file" />
                        </div>
                        <div class="field">
                          <label for="containerImportPassword">Password</label>
                          <input id="containerImportPassword" type="password" placeholder="Enter container password" />
                        </div>
                      </div>

                      <div class="tool-actions">
                        <button id="containerUnlockBtn" class="btn btn-primary" type="button" disabled>Unlock container</button>
                        <button id="containerExtractBtn" class="btn btn-secondary" type="button" disabled>Extract files to Vault</button>
                      </div>

                      <div class="vault-hint">
                        Unlock the container, preview its contents, then extract decrypted files into the currently selected Vault folder.<div id="containerImportStatus" style="margin-top:8px;"></div>
                      </div>

                      <hr class="hr" />

                      <h3 class="h3">Container contents (preview)</h3>
                      <table class="vault-file-list">
                        <thead>
                          <tr>
                            <th>File</th>
                            <th style="width:140px;">Type</th>
                            <th style="width:90px;">Size</th>
                            <th>Action</th>
                          </tr>
                        </thead>
                        <tbody id="containerPreviewTbody">
                          <tr>
                            <td colspan="4" style="color:var(--muted); font-size:0.9rem;">
                              Unlock a container to preview its file manifest.
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>
              </div>

              
<!-- ===== SECTION: SECURE CHAT ===== -->
<div class="vault-section" data-vault-section="chat">
  <div class="card">
    <h3 class="h3">Secure Chat</h3>
    <p style="margin:4px 0 12px; color:var(--muted); font-size:0.9rem;">
      End-to-end encrypted rooms for members and guests. AI Notes PDF export (if enabled) is server-processed (not end-to-end encrypted). Create a room, then generate an invite link you can share manually.
    </p>

    

    <div class="vault-split2" style="margin-top:12px;">
      <div class="card" style="padding:14px;">
        <h3 class="h3">Join via Invite</h3>
        <label for="chatJoinInvite">Invite link or token</label>
        <input id="chatJoinInvite" type="text" placeholder="Paste invite link (or token)" />

        <div class="vault-split2" style="margin-top:10px;">
          <div class="field">
            <label for="chatJoinRoomKey">Room key (optional)</label>
            <input id="chatJoinRoomKey" type="text" placeholder="If link includes #k=..., paste it here" />
          </div>
          <div class="field">
            <label for="chatJoinPassword">Room password (optional)</label>
            <input id="chatJoinPassword" type="password" placeholder="If room is password protected" />
          </div>
        </div>

        <div class="tool-actions" style="margin-top:10px;">
          <button id="chatJoinBtn" class="btn btn-primary" type="button">Join</button>
          <button id="chatJoinClearBtn" class="btn btn-secondary" type="button">Clear</button>
        </div>
        <div class="vault-status" id="chatJoinStatus"></div>
      </div>

      <div class="card" style="padding:14px;">
        <h3 class="h3">Invite / Keys</h3>

        <div class="vault-split2">
          <div class="field">
            <label for="chatInviteOut">Invite link</label>
            <input id="chatInviteOut" type="text" placeholder="Select a room, then click Invite Link" readonly />
          </div>
          <div class="field">
            <label for="chatRoomKeyOut">Room key</label>
            <input id="chatRoomKeyOut" type="text" placeholder="Select a room, then click Room Key" readonly />
          </div>
        </div>

        <div class="tool-actions" style="margin-top:10px;">
          <button id="chatInviteBtn" class="btn btn-primary" type="button" disabled>Invite Link</button>
          <button id="chatRoomKeyBtn" class="btn btn-secondary" type="button" disabled>Room Key</button>
          <button id="chatPasswordBtn" class="btn btn-secondary" type="button" disabled>Password</button>
          <button id="chatRemoveBtn" class="btn btn-secondary" type="button" disabled>Remove</button>
          <button id="chatCopyInviteBtn" class="btn btn-secondary" type="button" disabled>Copy Link</button>
          <button id="chatCopyKeyBtn" class="btn btn-secondary" type="button" disabled>Copy Key</button>
        </div>

        <div class="vault-status" id="chatInviteStatus"></div>
      </div>
    </div>

    <div class="chat-shell" style="margin-top:14px;">
      <div class="chat-list">
        <div class="chat-list-head">
          <div style="font-weight:900;">Threads</div>
          <button id="chatNewThreadBtn" class="btn btn-secondary" type="button" disabled>+ New</button>
        </div>

        <div id="chatThreads" style="overflow:auto; flex:1;">
          <div style="padding:12px; color:var(--muted); font-size:0.9rem;">
            Log in to load threads.
          </div>
        </div>
      </div>

      <div class="chat-pane">
        <div class="chat-pane-head">
          <div style="display:flex; flex-direction:column; gap:2px;">
            <div id="chatActiveTitle" style="font-weight:900;">Select a thread</div>
            <div id="chatActiveMeta" style="color:var(--muted); font-size:0.88rem;">Create or join a room to begin.</div>
            <div id="chatParticipants" style="margin-top:2px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <div style="color:var(--muted); font-weight:900; font-size:0.78rem; text-transform:uppercase; letter-spacing:0.04em;">Who’s online</div>
                <div id="chatParticipantsCount" style="min-width:22px; text-align:center; padding:2px 8px; border-radius:999px; font-size:0.78rem; font-weight:800; background:rgba(255,255,255,0.08); color:var(--text);">0</div>
              </div>
              <div id="chatParticipantsList" style="margin-top:4px; display:flex; flex-wrap:wrap; gap:6px; align-items:center; color:var(--muted); font-size:0.82rem;">—</div>
            </div>
          </div>
          <div class="tool-actions" style="margin-top:0;">
            <input id="chatAttachFile" type="file" style="display:none" />
            <button id="chatAttachBtn" class="btn btn-secondary" type="button" disabled>Attach</button>
            <button id="chatRefreshBtn" class="btn btn-secondary" type="button" disabled>Refresh</button>
          </div>
        </div>

        <div id="chatMessages" class="chat-messages">
          <div style="color:var(--muted); font-size:0.92rem;">No thread selected.</div>
        </div>

        <div class="chat-compose">
          <textarea id="chatCompose" placeholder="Type a secure message…"></textarea>
          <button id="chatSendBtn" class="btn btn-primary" type="button" disabled>Send</button>
        </div>
      </div>
    </div>
  </div>
</div>

              <!-- ===== SECTION: SECURE VIDEO CHAT ===== -->
              <div class="vault-section" data-vault-section="video">
  <div class="card">
    <h3 class="h3">Secure Video Chat</h3>
    <p style="margin:4px 0 12px; color:var(--muted); font-size:0.9rem;">
      Peer-to-peer WebRTC rooms with server-backed signaling and optional guest invite links. Media stays end-to-end encrypted by WebRTC (DTLS-SRTP).
    </p>

    

    <div class="video-shell" style="margin-top:14px;">
      <div class="video-stage">
        <div class="video-stage-head">
          <div style="display:flex; flex-direction:column; gap:4px;">
            <div class="h4" style="margin:0;">Room</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <select id="videoRoomsSelect" class="input" style="min-width:260px;"></select>
              <button id="videoNewRoomBtn" class="btn btn-primary" type="button">New</button>
              <button id="videoDeleteRoomBtn" class="btn btn-secondary" type="button">Remove</button>
            </div>
          </div>

          <div class="tool-actions" style="margin-top:0; display:flex; gap:8px; flex-wrap:wrap;">
            <button id="videoStartBtn" class="btn btn-primary" type="button">Start</button>
            <button id="videoHangupBtn" class="btn btn-secondary" type="button">Hang up</button>
            <button id="videoMuteBtn" class="btn btn-secondary" type="button">Mute</button>
            <button id="videoShareBtn" class="btn btn-secondary" type="button">Share screen</button>
          </div>
        </div>

        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <button id="videoInviteBtn" class="btn btn-secondary" type="button">Create invite link</button>
          <input id="videoInvitePassword" class="input" type="password" placeholder="Optional invite password" style="max-width:220px;" />
          <input id="videoInviteLink" class="input" type="text" placeholder="Invite link…" readonly style="min-width:320px; flex:1;" />
          <button id="videoCopyInviteBtn" class="btn btn-secondary" type="button">Copy</button>
        </div>

        <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
          <div id="videoOnlineRow" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <span class="pill">Who’s online</span>
            <span id="videoOnlineCount" class="pill pill-strong">0</span>
            <span id="videoOnlineChips" style="display:flex; gap:6px; flex-wrap:wrap;"></span>
          </div>
          <div id="videoStatus" style="color:var(--muted); font-size:0.9rem;">Idle</div>
        </div>

        <div style="margin-top:12px; display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
          <div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
              <div class="h4" style="margin:0;">You</div>
              <div style="color:var(--muted); font-size:0.85rem;" id="videoYouLabel">—</div>
            </div>
            <video id="videoLocal" autoplay playsinline muted style="width:100%; border-radius:14px; background:#000; min-height:220px;"></video>
          </div>
          <div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
              <div class="h4" style="margin:0;">Others</div>
              <div style="color:var(--muted); font-size:0.85rem;" id="videoOthersLabel">—</div>
            </div>
            <div id="videoRemoteGrid" style="display:grid; grid-template-columns:1fr; gap:10px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

</div><!-- /vault-main -->
          </div><!-- /vault-grid -->
        </div><!-- /tool-body -->
      </section>
    </main>

    <footer class="footer">
      <div>© <span id="year"></span> PDFRealm. All rights reserved.</div>
    </footer>

    <!-- Account Modal (kept consistent with your site pattern) -->
    <div id="accountModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="mh">Account</div>
          <button id="accountModalClose" class="btn btn-secondary" type="button">Close</button>
        </div>
        <div class="modal-body">
          <div class="card">
            <label for="loginEmail">Email</label>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
            <label for="loginPassword">Password</label>
            <input id="loginPassword" type="password" placeholder="••••••••" />
            <div class="modal-row">
              <button id="loginSubmitBtn" class="btn btn-primary" type="button">Login</button>
              <button id="logoutBtn" class="btn btn-secondary" type="button">Logout</button>
              <button id="subscribeMonthlyBtn" class="btn btn-secondary" type="button">Subscribe (stub)</button>
              <button id="subscribeYearlyBtn" class="btn btn-secondary" type="button">Subscribe (stub)</button>
            </div>
            <div id="loginStatus" style="margin-top:10px; color: var(--muted); font-size: 0.95rem;"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Move Modal -->
    <div id="moveModal" class="vault-modal" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="mh" id="moveModalTitle">Move</div>
          <button id="moveModalClose" class="btn btn-secondary" type="button">Close</button>
        </div>
        <div class="modal-body">
          <div class="card" style="padding:14px;">
            <div style="color:var(--muted); font-size:0.92rem; margin-bottom:10px;">
              This uses a safe fallback: <strong>download blob → upload to target folder → delete original</strong>.
            </div>

            <div class="vault-modal-row">
              <label id="moveItemLabel">Item</label>
              <input id="moveFileName" type="text" disabled />
            </div>

            <label for="moveTargetFolder">Target folder</label>
            <select id="moveTargetFolder">
              <option value="">My Vault Folder</option>
            </select>

            <div class="vault-modal-row" id="moveNewNameRow">
              <label for="moveNewName">New name (optional)</label>
              <input id="moveNewName" type="text" placeholder="Leave blank to keep name" />
            </div>

            <div class="tool-actions" style="margin-top:12px;">
              <button id="moveConfirmBtn" class="btn btn-primary" type="button">Move</button>
              <button id="moveCancelBtn" class="btn btn-secondary" type="button">Cancel</button>
            </div>

            <div class="vault-status" id="moveStatus"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        var y = document.getElementById("year");
        if (y) y.textContent = new Date().getFullYear();
      })();
    </script>

    <!-- Industry Packs dropdown behavior (pricing.html style) -->
    <script>
      (function () {
        var wrap = document.getElementById("industryMenuWrap");
        var toggle = document.getElementById("industryToggle");
        if (!wrap || !toggle) return;

        toggle.addEventListener("click", function (e) {
          e.stopPropagation();
          wrap.classList.toggle("workspace-open");
        });

        document.addEventListener("click", function () {
          wrap.classList.remove("workspace-open");
        });
      })();
    </script>

    <!-- Vault tabs behavior + optional hash navigation -->
    <script>
      (function () {
        var tabBtns = Array.prototype.slice.call(document.querySelectorAll("[data-vault-tab]"));
        var sections = Array.prototype.slice.call(document.querySelectorAll("[data-vault-section]"));
        if (!tabBtns.length || !sections.length) return;

        function setTab(name) {
          tabBtns.forEach(function (b) {
            b.classList.toggle("vault-tab-active", b.getAttribute("data-vault-tab") === name);
          });
          sections.forEach(function (s) {
            s.classList.toggle("vault-section-active", s.getAttribute("data-vault-section") === name);
          });
        }

        tabBtns.forEach(function (btn) {
          btn.addEventListener("click", function () {
            var name = btn.getAttribute("data-vault-tab");
            setTab(name);
            try { history.replaceState(null, "", "#" + name); } catch (e) {}
          });
        });

        var hash = (location.hash || "").replace("#", "").trim();
        if (hash) {
          var exists = tabBtns.some(function (b) { return b.getAttribute("data-vault-tab") === hash; });
          if (exists) setTab(hash);
        }
      })();
    </script>

    <!-- Vault wiring (KEEP DESIGN; WIRE FEATURES) -->
    
<script>
(function () {
  "use strict";

  // ============================
  // Vault Explorer++ (Windows-style)
  // - Drag & drop move (files + folders)
  // - Right-click context menu
  // - Command palette (Ctrl+K)
  // - Favorites + Recents + Trash
  // - Inline preview
  // - Tags (localStorage first)
  // - Activity log + Undo for move/trash
  // ============================

  // ---- DOM helpers
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

  // ---- Elements (existing layout)
  const elAccountBtn = $("#accountLoginBtn");
  const elAccountDot = $("#accountDot");
  const elAccountModal = $("#accountModal");
  const elAccountModalClose = $("#accountModalClose");
  const elLoginEmail = $("#loginEmail");
  const elLoginPass = $("#loginPassword");
  const elLoginSubmit = $("#loginSubmitBtn");
  const elLoginStatus = $("#loginStatus");

  const elLogoutBtn = $("#logoutBtn");
  const elVaultConnStatus = $("#vaultConnStatus");
  const elVaultRefreshBtn = $("#vaultRefreshBtn");
  const elVaultListStatus = $("#vaultListStatus");
  const elSelectedFolderLabel = $("#selectedFolderLabel");
  const elCurrentFolderPill = $("#currentFolderPill");
  const elBreadcrumbPath = $("#vaultBreadcrumbPath");


  const elNewFolderBtn = $("#newFolderBtn");
  const elTree = $("#vaultTree");

  const elVaultFile = $("#vaultFile");
  const elUploadBtn = $("#vaultUploadBtn");
  const elUploadStatus = $("#vaultUploadStatus");

  const elSelectAll = $("#selectAllCb");
  const elFilesTbody = $("#vaultFilesTbody");
  const elFilesTable = $("#vaultFilesTable");
  const elFilesGrid = $("#vaultFilesGrid");
  const elFilesCard = $("#vaultFilesCard");
  const elViewListBtn = $("#fileViewListBtn");
  const elViewGridBtn = $("#fileViewGridBtn");

  const elBulkDownload = $("#bulkDownloadBtn");
  const elBulkMove = $("#bulkMoveBtn");
  const elBulkRestore = $("#bulkRestoreBtn");
  const elEmptyTrash = $("#emptyTrashBtn");
  const elBulkDelete = $("#bulkDeleteBtn");

  // Move modal (existing)
  const elMoveModal = $("#moveModal");
  const elMoveModalClose = $("#moveModalClose");
  const elMoveFileName = $("#moveFileName");
  const elMoveTargetFolder = $("#moveTargetFolder");
  const elMoveConfirmBtn = $("#moveConfirmBtn");
  
  // Encrypted Containers (client-side container) controls
  const elContainerPassword = $("#containerPassword");
  const elContainerFiles = $("#containerFiles");
  const elContainerAlsoUpload = $("#containerAlsoUpload");
  const elContainerCreateBtn = $("#containerCreateBtn");
  const elContainerDownloadBtn = $("#containerDownloadBtn");
  const elOfflineUnlockerBtn = $("#offlineUnlockerBtn");
  const elContainerStatus = $("#containerStatus");

  const elContainerImportFile = $("#containerImportFile");
  const elContainerImportPassword = $("#containerImportPassword");
  const elContainerUnlockBtn = $("#containerUnlockBtn");
  const elContainerExtractBtn = $("#containerExtractBtn");
  const elContainerImportStatus = $("#containerImportStatus");
  const elContainerPreviewTbody = $("#containerPreviewTbody");


  // Secure Send controls
  const elSendFromVault = $("#sendFromVault");
  const elSendLocal = $("#sendLocal");
  const elSendAddBtn = $("#sendAddBtn");
  const elSendClearBtn = $("#sendClearBtn");
  const elSendTo = $("#sendTo");
  const elSendNote = $("#sendNote");
  const elSendExpire = $("#sendExpire");
  const elSendPerms = $("#sendPerms");
  const elSendPasscode = $("#sendPasscode");
  const elSendCreateBtn = $("#sendCreateBtn");
  const elSendRevokeBtn = $("#sendRevokeBtn");

  const elSendStatus = $("#sendStatus");
  const elSendQueueWrap = $("#sendQueueWrap");
  const elSendQueueCount = $("#sendQueueCount");
  const elSendQueueList = $("#sendQueueList");
  const elSendQueueUseSelectionBtn = $("#sendQueueUseSelectionBtn");

  const elSendLinkWrap = $("#sendLinkWrap");
  const elSendLinkOut = $("#sendLinkOut");
  const elSendCopyLinkBtn = $("#sendCopyLinkBtn");
  const elSendPasscodeOutWrap = $("#sendPasscodeOutWrap");
  const elSendPasscodeOut = $("#sendPasscodeOut");
  const elSendCopyPassBtn = $("#sendCopyPassBtn");

  // ---- API
  const API = {
    LOGIN: "/api/login",
    ME: "/api/me",
    VAULT_LIST: "/api/vault/list",
    VAULT_UPLOAD: "/api/vault/upload",
    VAULT_CREATE_FOLDER: "/api/vault/folder",
    VAULT_FILE: (id) => `/api/vault/file/${encodeURIComponent(id)}`,
    VAULT_FILE_DELETE: (id) => `/api/vault/file/${encodeURIComponent(id)}`,
    VAULT_FILE_MOVE: "/api/vault/file/move",
    VAULT_FOLDER_MOVE: "/api/vault/folder/move",
    VAULT_FOLDER_DELETE: "/api/vault/folder",
    VAULT_FOLDERS: "/api/vault/folders",
    VAULT_TRASH_EMPTY: "/api/vault/trash/empty",

    // Secure Send
    SECURE_SHARES: "/api/secure-shares",
    SECURE_SHARE_REVOKE: (id) => `/api/secure-shares/${encodeURIComponent(id)}/revoke`,
    SECURE_SHARE_AUDITS: (id) => `/api/secure-shares/${encodeURIComponent(id)}/audits`,
  };

  // ---- Local storage keys
  const LS = {
    TOKEN: "pdfrealm_token",
    FAVS: "pdfrealm_vault_favs",
    RECENTS: "pdfrealm_vault_recents",
    TAGS: "pdfrealm_vault_tags",
    ACTIVITY: "pdfrealm_vault_activity",
    TRASHMAP: "pdfrealm_vault_trash_map",
    UI: "pdfrealm_vault_ui",
  };

  const TRASH_ENABLED = false;
  const TRASH_FOLDER = "_Trash";
  const MAX_RECENTS = 25;
  const MAX_ACTIVITY = 200;

  const state = {
    token: null,
    user: null,

    // data from server
    folders: [],  // ["a/b", ...]
    items: [],    // [{id,key,filename,size,lastModified,contentType,storage,folderPath?}, ...]
    folderSet: new Set(),

    // UI state
    selectedFolder: "", // "" = root
    expanded: new Set(),
    folderFilter: "",
    fileFilter: "",
    fileSort: "newest",
    fileView: "list",
    selectedFiles: new Set(), // item.id or item.key
    lastToastUndo: null,

    // Encrypted container state
    containerBuilt: null, // { blob, filename, header }
    containerUnlocked: null, // { header, files: [{ name, type, size, mtime, blob }] }

    // Secure Send state
    sendQueue: [],
    lastSecureShareId: null,
    lastSecureShareUrl: null,
    lastSecureSharePasscode: null,
  };

  // ============================
  // CSS injection (no layout changes)
  // ============================
  (function injectCss() {
    const css = `
      /* Status dot states */
      #accountDot.dot { display:inline-block; width:10px; height:10px; border-radius:999px; background: #8a8f98; margin-right:8px; vertical-align:middle; }
      #accountDot.dot.ok { background: #1fbf75; }
      #accountDot.dot.warn { background: #f5a524; }
      #accountDot.dot.bad { background: #e5484d; }

      /* Explorer addons */
      .vault-sidebar .vx-row { display:flex; gap:8px; align-items:center; margin-top:10px; }
      .vx-input { width:100%; padding:10px 10px; border-radius:12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); color: var(--text); outline:none; }
      .vx-mini { font-size: 0.9rem; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); color: var(--text); cursor:pointer; }
      .vx-mini[disabled] { opacity:0.5; cursor:not-allowed; }
      .vx-muted { color: var(--muted); font-size:0.9rem; }

      /* Tree rows */
      .vx-node { display:flex; gap:8px; align-items:center; padding:7px 10px; border-radius:12px; cursor:pointer; user-select:none; }
      .vx-node:hover { background: rgba(255,255,255,0.06); }
      .vx-node.vx-selected { background: rgba(255,255,255,0.10); }
      .vx-exp { width:18px; text-align:center; opacity:0.85; }
      .vx-ico { width:18px; text-align:center; }
      .vx-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .vx-star { opacity:0.9; }
      .vx-badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; margin-left:8px; background: rgba(255,255,255,0.08); color: var(--muted); }
      .vx-tags { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
      .vx-tag { font-size:12px; padding:2px 8px; border-radius:999px; background: rgba(255,255,255,0.08); color: var(--muted); }

      /* Context menu */
      .vx-menu { position: fixed; z-index: 99999; min-width: 220px; padding: 8px; border-radius: 14px;
                 background: rgba(20,20,22,0.95); border:1px solid rgba(255,255,255,0.12); box-shadow: 0 16px 50px rgba(0,0,0,0.55); display:none; }
      .vx-menu .vx-mi { display:flex; align-items:center; justify-content:space-between; padding:10px 10px; border-radius:12px; cursor:pointer; }
      .vx-menu .vx-mi:hover { background: rgba(255,255,255,0.08); }
      .vx-menu .vx-sep { height:1px; background: rgba(255,255,255,0.10); margin:6px 0; }
      .vx-kbd { font-size:12px; color: var(--muted); margin-left:10px; }

      /* Command palette */
      .vx-palette-backdrop { position: fixed; inset:0; z-index: 99998; background: rgba(0,0,0,0.45); display:none; align-items:flex-start; justify-content:center; padding-top: 9vh; }
      .vx-palette { width: min(760px, 92vw); border-radius: 18px; background: rgba(20,20,22,0.98); border:1px solid rgba(255,255,255,0.14);
                    box-shadow: 0 18px 70px rgba(0,0,0,0.65); overflow:hidden; }
      .vx-palette-head { padding: 14px; border-bottom:1px solid rgba(255,255,255,0.10); }
      .vx-palette-input { width:100%; padding: 12px 12px; border-radius: 14px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05); color: var(--text); outline:none; }
      .vx-palette-list { max-height: 52vh; overflow:auto; }
      .vx-palette-item { padding: 12px 14px; cursor:pointer; display:flex; justify-content:space-between; gap:12px; }
      .vx-palette-item:hover { background: rgba(255,255,255,0.06); }
      .vx-palette-sub { color: var(--muted); font-size: 0.9rem; }

      /* Toasts */
      .vx-toasts { position: fixed; right: 18px; bottom: 18px; z-index: 99997; display:flex; flex-direction:column; gap:10px; }
      .vx-toast { min-width: 320px; max-width: 520px; padding: 12px 14px; border-radius: 16px; background: rgba(20,20,22,0.95); border:1px solid rgba(255,255,255,0.12);
                  box-shadow: 0 14px 45px rgba(0,0,0,0.55); }
      .vx-toast-row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
      .vx-toast-msg { color: var(--text); font-size: 0.95rem; }
      .vx-toast-actions { display:flex; gap:8px; }
      .vx-toast-actions button { padding: 8px 10px; border-radius: 12px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: var(--text); cursor:pointer; }
      .vx-toast-actions button:hover { background: rgba(255,255,255,0.10); }
    

      /* Ensure Vault tab strip is clickable (avoid accidental overlay capture) */
      .vault-tabs, .vault-tab { position: relative; z-index: 5; }

      /* Left folder tree should scroll independently */
      .vault-sidebar { max-height: calc(100vh - 240px); overflow: hidden; }
      #vaultTree { overflow-y: auto; flex: 1 1 auto; min-height: 220px; padding-right: 6px; }
`;
    const style = document.createElement("style");
    style.textContent = css;
    document.head.appendChild(style);
    if (elAccountDot && !elAccountDot.classList.contains("dot")) elAccountDot.classList.add("dot");
  })();

  // ============================
  // UI augmentations (no layout changes)
  // ============================
  const ui = {
    folderSearch: null,
    expandAllBtn: null,
    collapseAllBtn: null,
    folderActions: null,
    fileSearch: null,
    sortSelect: null,
    breadcrumb: null,
    activityBtn: null,
    viewListBtn: null,
    viewGridBtn: null,
  };

    function bindExistingControls() {
    // NOTE: This Vault page already contains the folder/file controls in HTML.
    // We bind to those controls and DO NOT inject duplicates.

    // Folder controls (left panel)
    const folderSearch = $("#folderSearch");
    const expandAll = $("#expandAllBtn");
    const collapseAll = $("#collapseAllBtn");
    const renameBtn = $("#folderRenameBtn");
    const moveBtn = $("#folderMoveBtn");
    const delBtn = $("#folderDeleteBtn");

    ui.folderSearch = folderSearch || ui.folderSearch;
    ui.expandAllBtn = expandAll || ui.expandAllBtn;
    ui.collapseAllBtn = collapseAll || ui.collapseAllBtn;

    if (renameBtn && moveBtn && delBtn) {
      ui.folderActions = { renameBtn, moveBtn, delBtn };
    }

    if (folderSearch && !folderSearch.dataset.vxBound) {
      folderSearch.dataset.vxBound = "1";
      folderSearch.addEventListener("input", () => {
        state.folderFilter = folderSearch.value.trim().toLowerCase();
        renderFolderTree();
      });
    }

    if (expandAll && !expandAll.dataset.vxBound) {
      expandAll.dataset.vxBound = "1";
      expandAll.addEventListener("click", () => {
        state.folderSet.forEach((p) => state.expanded.add(p));
        persistUI();
        renderFolderTree();
      });
    }

    if (collapseAll && !collapseAll.dataset.vxBound) {
      collapseAll.dataset.vxBound = "1";
      collapseAll.addEventListener("click", () => {
        state.expanded.clear();
        persistUI();
        renderFolderTree();
      });
    }

    if (renameBtn && !renameBtn.dataset.vxBound) {
      renameBtn.dataset.vxBound = "1";
      renameBtn.addEventListener("click", () => doRenameFolder());
    }
    if (moveBtn && !moveBtn.dataset.vxBound) {
      moveBtn.dataset.vxBound = "1";
      moveBtn.addEventListener("click", () => doMoveFolder());
    }
    if (delBtn && !delBtn.dataset.vxBound) {
      delBtn.dataset.vxBound = "1";
      delBtn.addEventListener("click", () => doDeleteFolderSoft());
    }

    // File controls (right panel)
    const fileSearch = $("#fileSearch");
    const sortSel = $("#fileSort");
    ui.fileSearch = fileSearch || ui.fileSearch;
    ui.sortSelect = sortSel || ui.sortSelect;

    ui.viewListBtn = elViewListBtn || ui.viewListBtn;
    ui.viewGridBtn = elViewGridBtn || ui.viewGridBtn;

    if (elViewListBtn && !elViewListBtn.dataset.vxBound) {
      elViewListBtn.dataset.vxBound = "1";
      elViewListBtn.addEventListener("click", () => setFileView("list"));
    }
    if (elViewGridBtn && !elViewGridBtn.dataset.vxBound) {
      elViewGridBtn.dataset.vxBound = "1";
      elViewGridBtn.addEventListener("click", () => setFileView("grid"));
    }


    if (fileSearch && !fileSearch.dataset.vxBound) {
      fileSearch.dataset.vxBound = "1";
      fileSearch.addEventListener("input", () => {
        state.fileFilter = fileSearch.value.trim().toLowerCase();
        renderFileTable();
      });
    }

    if (sortSel && !sortSel.dataset.vxBound) {
      sortSel.dataset.vxBound = "1";
      sortSel.addEventListener("change", () => {
        state.fileSort = sortSel.value;
        persistUI();
        renderFileTable();
      });
    }
  }

  // ============================
  // Auth + fetch
  // ============================
  function getStoredToken() {
    const ls = localStorage.getItem(LS.TOKEN);
    if (ls) return ls;
    const m = document.cookie.match(/(?:^|;\s*)pdfrealm_token=([^;]+)/);
    if (m && m[1]) return decodeURIComponent(m[1]);
    return null;
  }

  function setStoredToken(token) {
    state.token = token || null;
    if (token) {
      localStorage.setItem(LS.TOKEN, token);
      document.cookie = `pdfrealm_token=${encodeURIComponent(token)}; path=/; SameSite=Lax`;
    } else {
      localStorage.removeItem(LS.TOKEN);
      document.cookie = `pdfrealm_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
    }
  }

  async function apiFetch(url, opts={}) {
    const headers = new Headers(opts.headers || {});
    if (state.token) headers.set("Authorization", `Bearer ${state.token}`);
    if (!headers.has("Content-Type") && opts.body && !(opts.body instanceof FormData)) {
      headers.set("Content-Type", "application/json");
    }
    const fetchOpts = { ...opts, headers };
    if (!("cache" in fetchOpts)) fetchOpts.cache = "no-store";
    const resp = await fetch(url, fetchOpts);
    const text = await resp.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch { data = { raw: text }; }
    if (!resp.ok) {
      const errMsg = (data && (data.error || data.message)) ? (data.error || data.message) : `HTTP ${resp.status}`;
      const e = new Error(errMsg);
      e.status = resp.status;
      e.data = data;
      throw e;
    }
    return data;
  }

  function setAuthDot(status) {
    if (!elAccountDot) return;
    elAccountDot.classList.remove("ok","warn","bad");
    if (status) elAccountDot.classList.add(status);
  }

  function setAuthedUI(authed) {
    // Enable/disable relevant controls without changing layout
    const enable = !!authed;

    if (elNewFolderBtn) elNewFolderBtn.disabled = !enable;
    if (elUploadBtn) elUploadBtn.disabled = !enable;
    if (elVaultRefreshBtn) elVaultRefreshBtn.disabled = !enable;

    // Encrypted container controls
    if (elContainerCreateBtn) elContainerCreateBtn.disabled = !enable;
    if (elContainerUnlockBtn) elContainerUnlockBtn.disabled = !enable;
    if (elContainerDownloadBtn) elContainerDownloadBtn.disabled = !enable || !state.containerBuilt;
    if (elContainerExtractBtn) elContainerExtractBtn.disabled = !enable || !state.containerUnlocked;

    // Secure Send controls
    if (elSendFromVault) elSendFromVault.disabled = !enable;
    if (elSendLocal) elSendLocal.disabled = !enable;
    if (elSendAddBtn) elSendAddBtn.disabled = !enable;
    if (elSendClearBtn) elSendClearBtn.disabled = !enable;
    if (elSendTo) elSendTo.disabled = !enable;
    if (elSendNote) elSendNote.disabled = !enable;
    if (elSendExpire) elSendExpire.disabled = !enable;
    if (elSendPerms) elSendPerms.disabled = !enable;
    if (elSendPasscode) elSendPasscode.disabled = !enable;
    if (elSendCreateBtn) elSendCreateBtn.disabled = !enable;
    if (elSendQueueUseSelectionBtn) elSendQueueUseSelectionBtn.disabled = !enable;
    if (elSendRevokeBtn) elSendRevokeBtn.disabled = !enable || !state.lastSecureShareId;

    if (ui.folderSearch) ui.folderSearch.disabled = !enable;
    if (ui.expandAllBtn) ui.expandAllBtn.disabled = !enable;
    if (ui.collapseAllBtn) ui.collapseAllBtn.disabled = !enable;

    if (ui.fileSearch) ui.fileSearch.disabled = !enable;
    if (ui.sortSelect) ui.sortSelect.disabled = !enable;

    if (ui.viewListBtn) ui.viewListBtn.disabled = !enable;
    if (ui.viewGridBtn) ui.viewGridBtn.disabled = !enable;
    updateViewButtons();


    // File selection checkbox is enabled only when files exist; we keep it disabled when logged out.
    if (elSelectAll) elSelectAll.disabled = !enable;

    const isTrashRoot = TRASH_ENABLED && normalizePath(state.selectedFolder) === TRASH_FOLDER;
    const canFolderOps = enable && !!state.selectedFolder && !isTrashRoot;

    if (ui.folderActions) {
      ui.folderActions.renameBtn.disabled = !canFolderOps;
      ui.folderActions.moveBtn.disabled = !canFolderOps;
      ui.folderActions.delBtn.disabled = !canFolderOps;
    }

    // Connection indicator in the left panel
    if (elVaultConnStatus) {
      if (enable) {
        const who = (state.user && state.user.email) ? ` as ${state.user.email}` : "";
        elVaultConnStatus.innerHTML = `Status: <strong>Connected${who}</strong>`;
      } else {
        elVaultConnStatus.innerHTML = `Status: <strong>Not logged in</strong>`;
      }
    }

    if (enable) {
      setAuthDot("ok");
      if (elAccountBtn) elAccountBtn.setAttribute("aria-pressed", "true");
    } else {
      setAuthDot("warn");
      if (elAccountBtn) elAccountBtn.removeAttribute("aria-pressed");
    }
  }

  async function bootstrapAuth() {
    setStoredToken(getStoredToken());

    if (!state.token) {
      setAuthedUI(false);
      if (elLoginStatus) elLoginStatus.textContent = "Not logged in.";
      return;
    }

    try {
      const me = await apiFetch(API.ME, { method: "GET" });
      state.user = me.user || me;
      setAuthedUI(true);
      if (elLoginStatus) elLoginStatus.textContent = `Signed in as ${state.user.email || "user"}`;
    } catch (e) {
      setStoredToken(null);
      state.user = null;
      setAuthedUI(false);
      if (elLoginStatus) elLoginStatus.textContent = "Session expired. Please sign in.";
    }
  }

  // ============================
  // Modal controls (account + move)
  // ============================
  function openModal(el) {
    if (!el) return;
    el.setAttribute("aria-hidden", "false");
    el.classList.add("open");
    // Some pages rely on CSS for visibility; force a safe display to guarantee the modal opens.
    el.style.display = "flex";
    document.body.classList.add("modal-open");
  }
  function closeModal(el) {
    if (!el) return;
    el.setAttribute("aria-hidden", "true");
    el.classList.remove("open");
    el.style.display = "";
    document.body.classList.remove("modal-open");
  }

  // ============================
  // Persistence (UI)
  // ============================
  function loadUI() {
    try {
      const raw = localStorage.getItem(LS.UI);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && obj.expanded && Array.isArray(obj.expanded)) state.expanded = new Set(obj.expanded);
      if (obj && typeof obj.selectedFolder === "string") state.selectedFolder = obj.selectedFolder;
      if (obj && typeof obj.fileSort === "string") state.fileSort = obj.fileSort;
      if (obj && typeof obj.fileView === "string") state.fileView = (obj.fileView === "grid" ? "grid" : "list");
    } catch {}
  }
  function persistUI() {
    try {
      localStorage.setItem(LS.UI, JSON.stringify({
        expanded: Array.from(state.expanded),
        selectedFolder: state.selectedFolder,
        fileSort: state.fileSort,
        fileView: state.fileView,
      }));
    } catch {}
  }

  // ============================
  // Favorites / Recents / Tags / Activity
  // ============================
  function loadFavs() {
    try { return JSON.parse(localStorage.getItem(LS.FAVS) || "[]") || []; } catch { return []; }
  }
  function saveFavs(arr) {
    localStorage.setItem(LS.FAVS, JSON.stringify(arr || []));
  }
  function isFav(path) {
    const favs = loadFavs();
    return favs.includes(path);
  }
  function toggleFav(path) {
    const favs = loadFavs();
    const idx = favs.indexOf(path);
    if (idx >= 0) favs.splice(idx, 1); else favs.unshift(path);
    saveFavs(Array.from(new Set(favs)).slice(0, 50));
    renderFolderTree();
  }

  function pushRecent(path) {
    if (path == null) return;
    const p = String(path);
    try {
      const arr = JSON.parse(localStorage.getItem(LS.RECENTS) || "[]") || [];
      const next = [p, ...arr.filter(x => x !== p)].slice(0, MAX_RECENTS);
      localStorage.setItem(LS.RECENTS, JSON.stringify(next));
    } catch {}
  }

  function getRecents() {
    try { return JSON.parse(localStorage.getItem(LS.RECENTS) || "[]") || []; } catch { return []; }
  }

  function getTagsMap() {
    try { return JSON.parse(localStorage.getItem(LS.TAGS) || "{}") || {}; } catch { return {}; }
  }
  function setTagsFor(keyOrId, tags) {
    const map = getTagsMap();
    map[keyOrId] = tags;
    localStorage.setItem(LS.TAGS, JSON.stringify(map));
  }
  function getTagsFor(keyOrId) {
    const map = getTagsMap();
    const t = map[keyOrId];
    return Array.isArray(t) ? t : [];
  }

  function logActivity(action, detail) {
    try {
      const arr = JSON.parse(localStorage.getItem(LS.ACTIVITY) || "[]") || [];
      arr.unshift({ ts: Date.now(), action, detail });
      localStorage.setItem(LS.ACTIVITY, JSON.stringify(arr.slice(0, MAX_ACTIVITY)));
    } catch {}
  }
  function getActivity() {
    try { return JSON.parse(localStorage.getItem(LS.ACTIVITY) || "[]") || []; } catch { return []; }
  }

  // ============================
  // Toast with optional Undo
  // ============================
  const elToasts = (() => {
    const t = document.createElement("div");
    t.className = "vx-toasts";
    document.body.appendChild(t);
    return t;
  })();

  function toast(message, opts={}) {
    const el = document.createElement("div");
    el.className = "vx-toast";
    const row = document.createElement("div");
    row.className = "vx-toast-row";
    const msg = document.createElement("div");
    msg.className = "vx-toast-msg";
    msg.textContent = message;

    row.appendChild(msg);

    const actions = document.createElement("div");
    actions.className = "vx-toast-actions";
    if (opts.undoLabel && typeof opts.onUndo === "function") {
      const undoBtn = document.createElement("button");
      undoBtn.textContent = opts.undoLabel;
      undoBtn.addEventListener("click", async () => {
        try { await opts.onUndo(); } catch (e) { console.error(e); toast(`Undo failed: ${e.message || e}`, { ttl: 5000 }); }
        el.remove();
      });
      actions.appendChild(undoBtn);
    }
    const closeBtn = document.createElement("button");
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => el.remove());
    actions.appendChild(closeBtn);

    row.appendChild(actions);
    el.appendChild(row);
    elToasts.appendChild(el);

    const ttl = opts.ttl || 6000;
    if (ttl > 0) setTimeout(() => { try { el.remove(); } catch {} }, ttl);
  }

  // ============================
  // Folder tree building/rendering
  // ============================
  function normalizePath(p) {
    if (!p) return "";
    const s = String(p).replace(/^\/+/, "").replace(/\/+$/, "");
    return s;
  }

  function displayFolderPath(path) {
    const p = normalizePath(path);
    return p ? p : "My Vault Folder";
  }

  function updateFolderLabels() {
    const label = displayFolderPath(state.selectedFolder);
    if (elSelectedFolderLabel) elSelectedFolderLabel.textContent = label;
    if (elCurrentFolderPill) elCurrentFolderPill.textContent = `Folder: ${label}`;
    if (elBreadcrumbPath) elBreadcrumbPath.textContent = "/" + (normalizePath(state.selectedFolder) || "");
  }

  function setSelectedFolder(path) {
    state.selectedFolder = normalizePath(path);
    persistUI();
    pushRecent(state.selectedFolder);
    updateFolderLabels();
    renderFolderTree();
    renderFileTable();
    bindFileDropzones();
    try { secureSendRefreshFromVault(); } catch (e) {}
    setAuthedUI(!!state.user); // update folder action buttons

    // Fetch fresh items for this folder (so Vault stays in sync with Office/PDFStudio)
    refreshFilesOnly().catch(() => {});
  }

  function buildFolderSet() {
    const set = new Set();
    // server folders
    (state.folders || []).forEach((p) => {
      const n = normalizePath(p);
      if (n) set.add(n);
    });
    // derive from items keys/filenames if possible
    (state.items || []).forEach((it) => {
      const fp = inferFolderPathFromItem(it);
      if (fp) set.add(fp);
      // add parents
      let cur = fp;
      while (cur && cur.includes("/")) {
        cur = cur.split("/").slice(0, -1).join("/");
        if (cur) set.add(cur);
      }
    });

    // always include trash if any trashed items exist
    if (TRASH_ENABLED) set.add(TRASH_FOLDER);

    state.folderSet = set;
  }

  function inferFolderPathFromItem(it) {
    // Primary: if server supplies folder_path or folderPath
    const fp = it.folder_path || it.folderPath;
    if (fp != null) return normalizePath(fp);

    // Secondary: infer from filename if it contains slashes (DB may store original name)
    const name = it.filename || "";
    if (name.includes("/")) return normalizePath(name.split("/").slice(0, -1).join("/"));

    // Fallback: infer from S3 key with prefix users/<id>/vault/
    const key = it.key || "";
    const marker = "/vault/";
    const idx = key.indexOf(marker);
    if (idx >= 0) {
      const rel = key.slice(idx + marker.length);
      if (rel.includes("/")) return normalizePath(rel.split("/").slice(0, -1).join("/"));
    }
    return "";
  }

  function buildTreeObject() {
    const root = { name: "My Vault Folder", path: "", children: new Map() };

    function ensureNode(path) {
      const parts = path ? path.split("/") : [];
      let node = root;
      let acc = "";
      for (const part of parts) {
        acc = acc ? `${acc}/${part}` : part;
        if (!node.children.has(part)) node.children.set(part, { name: part, path: acc, children: new Map() });
        node = node.children.get(part);
      }
      return node;
    }

    // insert all folder paths
    state.folderSet.forEach((p) => {
      const n = normalizePath(p);
      if (!n) return;
      ensureNode(n);
    });

    // Ensure parents exist
    (state.folders || []).forEach((p) => ensureNode(normalizePath(p)));

    return root;
  }

  function nodeMatchesFilter(node, filter) {
    if (!filter) return true;
    const name = (node.name || "").toLowerCase();
    const path = (node.path || "").toLowerCase();
    return name.includes(filter) || path.includes(filter);
  }

  function renderFolderTree() {
    if (!elTree) return;

    const filter = state.folderFilter;
    const root = buildTreeObject();

    // Build virtual sections: Favorites, Recent, Trash (without changing layout)
    const favs = loadFavs().filter(Boolean);
    const recents = getRecents().filter(Boolean);

    // Clear
    elTree.innerHTML = "";

    // Helpers
    function makeSection(title, items, icon) {
      const li = document.createElement("li");
      const row = document.createElement("div");
      row.className = "vx-node";
      row.style.fontWeight = "600";
      row.innerHTML = `<span class="vx-exp">▸</span><span class="vx-ico">${icon}</span><span class="vx-name">${title}</span>`;
      li.appendChild(row);
      const ul = document.createElement("ul");
      ul.className = "vault-tree-children";
      ul.style.marginLeft = "18px";
      ul.style.display = "none";
      li.appendChild(ul);

      let open = false;
      row.addEventListener("click", () => {
        open = !open;
        row.querySelector(".vx-exp").textContent = open ? "▾" : "▸";
        ul.style.display = open ? "block" : "none";
      });

      items.forEach((p) => {
        const pli = document.createElement("li");
        const prow = document.createElement("div");
        prow.className = "vx-node";
        prow.dataset.path = p;
        prow.innerHTML = `<span class="vx-exp"></span><span class="vx-ico">📁</span><span class="vx-name">${p}</span>`;
        prow.addEventListener("click", (e) => { e.stopPropagation(); setSelectedFolder(p); });
        prow.addEventListener("contextmenu", (e) => { e.preventDefault(); openContextMenu(e.clientX, e.clientY, { kind:"folder", path:p }); });
        ul.appendChild(pli);
        pli.appendChild(prow);
      });

      return li;
    }

    // Favorites hidden (single-root tree)
    // if (favs.length) elTree.appendChild(makeSection("Favorites", favs, "⭐"));
    // Recent
    // Recent shortcuts removed from tree to avoid confusion (use Activity modal instead)
    // if (recents.length) elTree.appendChild(makeSection("Recent", recents, "🕘"));

    // Root node (My Vault Folder)
    const rootLi = document.createElement("li");
    const rootRow = document.createElement("div");
    rootRow.className = "vx-node" + (state.selectedFolder === "" ? " vx-selected" : "");
    rootRow.dataset.path = "";
    rootRow.innerHTML = `<span class="vx-exp">${state.expanded.has("") ? "▾" : "▸"}</span><span class="vx-ico">🗂️</span><span class="vx-name">My Vault Folder</span>`;
    rootLi.appendChild(rootRow);
    const rootUl = document.createElement("ul");
    rootUl.className = "vault-tree-children";
    rootUl.style.marginLeft = "18px";
    rootUl.style.display = state.expanded.has("") ? "block" : "none";
    rootLi.appendChild(rootUl);
    elTree.appendChild(rootLi);

    rootRow.addEventListener("click", () => {
      // toggle expand on exp click; select on name click
      state.expanded.has("") ? state.expanded.delete("") : state.expanded.add("");
      persistUI();
      renderFolderTree();
      setSelectedFolder("");
    });

    rootRow.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      openContextMenu(e.clientX, e.clientY, { kind:"folder", path:"" });
    });

    // Drag/drop onto root (My Vault Folder): move files/folders to root and allow OS file upload into root
    rootRow.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      rootRow.style.background = "rgba(255,255,255,0.10)";
    });
    rootRow.addEventListener("dragleave", () => { rootRow.style.background = ""; });
    rootRow.addEventListener("drop", async (e) => {
      e.preventDefault();
      rootRow.style.background = "";
      try {
        const localFiles = (e.dataTransfer && e.dataTransfer.files) ? Array.from(e.dataTransfer.files) : [];
        if (localFiles && localFiles.length) {
          await uploadFilesToFolder(localFiles, "");
          return;
        }
        const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
        if (data.kind === "file") {
          await moveFilesToFolder([data.id], "");
        } else if (data.kind === "folder") {
          if (!data.path) return;
          await moveFolderInto(data.path, "");
        }
        await refreshVault();
      } catch (err) {
        console.error(err);
        toast(`Drop failed: ${err.message || err}`, { ttl: 6000 });
      }
    });

    // Render children recursively with filter context
    function renderNode(node, ul) {
      const children = Array.from(node.children.values()).sort((a,b)=>a.name.localeCompare(b.name));
      for (const child of children) {
        // Skip virtual trash section in main tree duplication
        if (child.path === TRASH_FOLDER) continue;

        // Filter logic: show node if it matches OR any descendant matches
        const matchesSelf = nodeMatchesFilter(child, filter);
        let descendantMatch = false;
        if (filter) {
          descendantMatch = Array.from(child.children.values()).some((d) => nodeMatchesFilter(d, filter) || hasDescMatch(d, filter));
        }
        if (filter && !matchesSelf && !descendantMatch) continue;

        const li = document.createElement("li");
        const row = document.createElement("div");
        const hasKids = child.children.size > 0;
        const expanded = state.expanded.has(child.path);

        row.className = "vx-node" + (state.selectedFolder === child.path ? " vx-selected" : "");
        row.draggable = true;
        row.dataset.path = child.path;

        const star = isFav(child.path) ? "⭐" : "";
        row.innerHTML = `
          <span class="vx-exp">${hasKids ? (expanded ? "▾" : "▸") : ""}</span>
          <span class="vx-ico">📁</span>
          <span class="vx-name">${escapeHtml(child.name)} ${star ? `<span class="vx-star">${star}</span>` : ""}</span>
        `;

        // Click: select
        row.addEventListener("click", (e) => {
          e.stopPropagation();
          // If click on expander area, toggle
          const isExp = (e.target && e.target.classList && e.target.classList.contains("vx-exp"));
          if (isExp && hasKids) {
            expanded ? state.expanded.delete(child.path) : state.expanded.add(child.path);
            persistUI();
            renderFolderTree();
            return;
          }
          setSelectedFolder(child.path);
        });

        // Context menu
        row.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          openContextMenu(e.clientX, e.clientY, { kind:"folder", path: child.path });
        });

        // Drag/drop folder move and file drop
        row.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("text/plain", JSON.stringify({ kind:"folder", path: child.path }));
          e.dataTransfer.effectAllowed = "move";
        });
        row.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          row.style.background = "rgba(255,255,255,0.10)";
        });
        row.addEventListener("dragleave", () => { row.style.background = ""; });
        row.addEventListener("drop", async (e) => {
          e.preventDefault();
          row.style.background = "";
          try {
            // Local file drop from OS → upload into this folder
            const localFiles = (e.dataTransfer && e.dataTransfer.files) ? Array.from(e.dataTransfer.files) : [];
            if (localFiles && localFiles.length) {
              await uploadFilesToFolder(localFiles, child.path);
              return;
            }

            const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
            if (data.kind === "file") {
              await moveFilesToFolder([data.id], child.path);
            } else if (data.kind === "folder") {
              if (data.path === child.path) return;
              await moveFolderInto(data.path, child.path);
            }
            await refreshVault();
          } catch (err) {
            console.error(err);
            toast(`Drop failed: ${err.message || err}`, { ttl: 6000 });
          }
        });

        li.appendChild(row);

        if (hasKids) {
          const cul = document.createElement("ul");
          cul.className = "vault-tree-children";
          cul.style.marginLeft = "18px";
          cul.style.display = expanded ? "block" : "none";
          li.appendChild(cul);
          if (expanded) renderNode(child, cul);
        }
        ul.appendChild(li);
      }
    }

    function hasDescMatch(n, f) {
      for (const c of n.children.values()) {
        if (nodeMatchesFilter(c,f)) return true;
        if (hasDescMatch(c,f)) return true;
      }
      return false;
    }

    // Ensure expanded nodes render children
    state.expanded.forEach((p) => {
      // nothing needed; renderNode handles on-demand
    });

    renderNode(root, rootUl);

    // Update breadcrumb
    if (ui.breadcrumb) ui.breadcrumb.textContent = `Path: /${state.selectedFolder || ""}`;
  }

  function escapeHtml(str) {
    return String(str || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // ============================
  // File list rendering
  // ============================
  function filteredItemsForFolder() {
    const folder = normalizePath(state.selectedFolder);
    const all = (state.items || []);
    const out = [];

    for (const it of all) {
      const fp = normalizePath(inferFolderPathFromItem(it));
      if ((folder === "" && fp === "") || (folder !== "" && fp === folder)) out.push(it);
    }
    return out;
  }

  function applyFileFilter(items) {
    const q = state.fileFilter || "";
    if (!q) return items;

    // tag:xxx support
    const tagMatch = q.match(/tag:([a-z0-9_\-]+)/i);
    const tag = tagMatch ? tagMatch[1].toLowerCase() : null;
    const plain = q.replace(/tag:[^\s]+/i, "").trim();

    return items.filter((it) => {
      const id = it.id || it.key;
      const name = (it.filename || it.key || "").toLowerCase();
      const okName = plain ? name.includes(plain) : true;
      const okTag = tag ? getTagsFor(id).some(t => String(t).toLowerCase() === tag) : true;
      return okName && okTag;
    });
  }


  function applyFolderFilter(paths) {
    const q = state.fileFilter || "";
    if (!q) return paths;
    const tagMatch = q.match(/tag:([a-z0-9_\-]+)/i);
    const plain = q.replace(/tag:[^\s]+/i, "").trim().toLowerCase();
    if (!plain) return paths;
    return paths.filter((p) => {
      const name = basenamePath(p).toLowerCase();
      return name.includes(plain) || String(p||"").toLowerCase().includes(plain);
    });
  }

  function getDirectSubfolders(parentPath) {
    const parent = normalizePath(parentPath);
    const prefix = parent ? parent + "/" : "";
    const out = [];

    (state.folderSet || new Set()).forEach((p) => {
      const n = normalizePath(p);
      if (!n) return;
      const lower = String(n).toLowerCase();
      if (lower === "_trash" || lower.startsWith("_trash/")) return;
      if (prefix) {
        if (!n.startsWith(prefix)) return;
        const rest = n.slice(prefix.length);
        if (!rest) return;
        if (rest.includes("/")) return; // only direct children
        out.push(n);
      } else {
        // root: only top-level (no slash)
        if (n.includes("/")) return;
        out.push(n);
      }
    });

    out.sort((a,b)=>basenamePath(a).localeCompare(basenamePath(b)));
    return out;
  }

  function sortItems(items) {
    const s = state.fileSort;
    const copy = items.slice();

    const getTs = (it) => {
      const lm = it.lastModified || it.last_modified || it.updatedAt || it.updated_at || it.createdAt || it.created_at;
      const t = lm ? Date.parse(lm) : NaN;
      return Number.isFinite(t) ? t : 0;
    };

    if (s === "newest") copy.sort((a,b)=>getTs(b)-getTs(a));
    else if (s === "oldest") copy.sort((a,b)=>getTs(a)-getTs(b));
    else if (s === "az") copy.sort((a,b)=>(a.filename||"").localeCompare(b.filename||""));
    else if (s === "za") copy.sort((a,b)=>(b.filename||"").localeCompare(a.filename||""));
    else if (s === "sizeDesc") copy.sort((a,b)=>(b.size||0)-(a.size||0));
    else if (s === "sizeAsc") copy.sort((a,b)=>(a.size||0)-(b.size||0));
    return copy;
  }

  function fmtBytes(n) {
    const x = Number(n || 0);
    if (x < 1024) return `${x} B`;
    const units = ["KB","MB","GB","TB"];
    let v = x; let u = -1;
    while (v >= 1024 && u < units.length-1) { v/=1024; u++; }
    return `${v.toFixed(v>=10?1:2)} ${units[u]}`;
  }

  function fmtDate(v) {
    if (!v) return "";
    const t = Date.parse(v);
    if (!Number.isFinite(t)) return String(v);
    const d = new Date(t);
    return d.toLocaleString();
  }

  function fileTypeFrom(it) {
    const ct = (it.contentType || it.content_type || "").toLowerCase();
    const name = (it.filename || it.key || "").toLowerCase();
    if (ct.includes("pdf") || name.endsWith(".pdf")) return "PDF";
    if (ct.startsWith("image/") || /\.(png|jpg|jpeg|webp|gif)$/.test(name)) return "Image";
    if (ct.startsWith("text/") || /\.(txt|md|csv|json|log)$/.test(name)) return "Text";
    return (ct || "File").split(";")[0].slice(0, 24) || "File";
  }


  function updateTrashActionButtons(totalVisible){
    const isTrash = normalizePath(state.selectedFolder) === TRASH_FOLDER;

    if (elBulkRestore){
      elBulkRestore.style.display = isTrash ? "" : "none";
      elBulkRestore.disabled = !isTrash || state.selectedFiles.size === 0;
    }
    if (elEmptyTrash){
      elEmptyTrash.style.display = isTrash ? "" : "none";
      elEmptyTrash.disabled = !isTrash || !totalVisible;
    }
    // Bulk Move stays available (lets you pick a destination), but disable when nothing selected
    if (elBulkMove) elBulkMove.disabled = state.selectedFiles.size === 0;
  }

  async function restoreSelectedFromTrash(){
    const ids = Array.from(state.selectedFiles);
    if (!ids.length) return;
    const dest = "Working Folder";
    if (!confirm(`Restore ${ids.length} file(s) from Trash to "${dest}"?`)) return;
    await moveFilesToFolder(ids, dest);
    state.selectedFiles.clear();
    await refreshVault();
    toast(`Restored ${ids.length} file(s)`, { ttl: 3000 });
  }

  
async function emptyTrash() {
  // Trash disabled: no-op for compatibility.
  toast("Trash is disabled.", { ttl: 3500 });
}

  
// ============================
// File view (List / Grid)
// ============================
function updateViewButtons() {
  const isGrid = state.fileView === "grid";
  if (ui.viewListBtn) {
    ui.viewListBtn.classList.toggle("btn-primary", !isGrid);
    ui.viewListBtn.classList.toggle("btn-secondary", isGrid);
    ui.viewListBtn.setAttribute("aria-pressed", (!isGrid).toString());
  }
  if (ui.viewGridBtn) {
    ui.viewGridBtn.classList.toggle("btn-primary", isGrid);
    ui.viewGridBtn.classList.toggle("btn-secondary", !isGrid);
    ui.viewGridBtn.setAttribute("aria-pressed", (isGrid).toString());
  }
}

function setFileView(view) {
  state.fileView = (view === "grid") ? "grid" : "list";
  persistUI();
  updateViewButtons();
  renderFileTable();
}

function bindFileDropzones() {
  if (!elFilesCard || elFilesCard.dataset.vxDropBound) return;
  elFilesCard.dataset.vxDropBound = "1";

  const onDragOver = (e) => {
    // Only show drop styling when files are being dragged from OS
    const hasFiles = !!(e.dataTransfer && e.dataTransfer.types && Array.from(e.dataTransfer.types).includes("Files"));
    if (!hasFiles) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
    elFilesCard.classList.add("vx-drop-active");
  };
  const onDragLeave = () => elFilesCard.classList.remove("vx-drop-active");
  const onDrop = async (e) => {
    const files = (e.dataTransfer && e.dataTransfer.files) ? Array.from(e.dataTransfer.files) : [];
    if (!files.length) return;
    e.preventDefault();
    elFilesCard.classList.remove("vx-drop-active");
    await uploadFilesToFolder(files, state.selectedFolder || "");
  };

  elFilesCard.addEventListener("dragover", onDragOver);
  elFilesCard.addEventListener("dragleave", onDragLeave);
  elFilesCard.addEventListener("drop", onDrop);
}

// ===== File action menus (grid + list) =====
let vxMenuCloserBound = false;
function closeAllFileMenus(){
  document.querySelectorAll('.vx-file-grid-item[data-menu="1"]').forEach(el => el.removeAttribute('data-menu'));
  document.querySelectorAll('.vx-row-actions[data-menu="1"]').forEach(el => el.removeAttribute('data-menu'));
}
function bindGlobalMenuCloser(){
  if (vxMenuCloserBound) return;
  vxMenuCloserBound = true;
  document.addEventListener('click', () => closeAllFileMenus());
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeAllFileMenus(); });
}



async function uploadFilesToFolder(files, folderPath) {
  if (!state.user) {
    toast("Login required to upload.", { ttl: 4500 });
    return;
  }
  const arr = Array.isArray(files) ? files : Array.from(files || []);
  if (!arr.length) return;

  // Best-effort status
  if (elVaultListStatus) elVaultListStatus.textContent = `Uploading ${arr.length} file(s)…`;

  let ok = 0, fail = 0;
  for (const f of arr) {
    try {
      const form = new FormData();
      form.append("file", f);
      form.append("folderPath", folderPath || "");
      await apiFetch(API.VAULT_UPLOAD, { method: "POST", body: form, headers: {} });
      ok++;
    } catch (e) {
      console.error(e);
      fail++;
    }
  }

  if (elVaultListStatus) elVaultListStatus.textContent = "";
  if (ok) toast(`Uploaded ${ok} file(s).`, { ttl: 3500 });
  if (fail) toast(`${fail} upload(s) failed.`, { ttl: 6000 });

  await refreshVault();
}


// ===== Icon SVGs (inline, no external assets) =====
const ICON_FOLDER_TILE = `
  <svg viewBox="0 0 64 48" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <path d="M6 12c0-2.2 1.8-4 4-4h14l6 6h24c2.2 0 4 1.8 4 4v18c0 2.2-1.8 4-4 4H10c-2.2 0-4-1.8-4-4V12z" fill="#FACC15" stroke="#FACC15" stroke-width="2" opacity="0.98"/>
    <path d="M6 14h52" stroke="#B45309" stroke-width="2" opacity="0.30"/>
  </svg>
`;

const ICON_DOC_TILE = `
  <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <path d="M18 6h20l8 8v44a6 6 0 0 1-6 6H18a6 6 0 0 1-6-6V12a6 6 0 0 1 6-6z" fill="rgba(255,255,255,0.06)" stroke="rgba(255,255,255,0.55)" stroke-width="2"/>
    <path d="M38 6v10a6 6 0 0 0 6 6h10" fill="rgba(255,255,255,0.06)" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
    <path d="M20 30h24M20 38h24M20 46h18" stroke="rgba(255,255,255,0.35)" stroke-width="2" stroke-linecap="round"/>
  </svg>
`;

const ICON_PDF_TILE = `
  <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <path d="M18 6h20l8 8v44a6 6 0 0 1-6 6H18a6 6 0 0 1-6-6V12a6 6 0 0 1 6-6z" fill="#FFFFFF" stroke="#DC2626" stroke-width="3"/>
    <path d="M38 6v10a6 6 0 0 0 6 6h10" fill="#F3F4F6" stroke="#DC2626" stroke-width="3" stroke-linejoin="round"/>
    <rect x="18" y="40" width="28" height="14" rx="2" fill="#DC2626"/>
    <text x="32" y="51" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" font-weight="800" fill="#FFFFFF">PDF</text>
  </svg>
`;

const ICON_FOLDER_ROW = ICON_FOLDER_TILE;
const ICON_DOC_ROW = ICON_DOC_TILE;
const ICON_PDF_ROW = ICON_PDF_TILE;

function renderFileGrid(subfolders, sorted, visibleIds) {
  if (!elFilesGrid) return;
  const folders = Array.isArray(subfolders) ? subfolders : [];
  const files = Array.isArray(sorted) ? sorted : [];

  if (!folders.length && !files.length) {
    elFilesGrid.innerHTML = `<div style="color:var(--muted); font-size:0.9rem;">No files or folders in this folder.</div>`;
    return;
  }

  const cards = [];

  // --- Folder tiles (direct children) ---
  for (const fp of folders) {
    const name = basenamePath(fp) || fp;
    cards.push(`
      <div class="vx-file-grid-item vx-folder-grid-item" data-folder-path="${escapeHtml(fp)}" draggable="true" tabindex="0" title="Folder: ${escapeHtml(fp)}">
        <div class="vx-file-thumb" aria-hidden="true">
          ${ICON_FOLDER_TILE}
        </div>

        <div class="vx-file-title">${escapeHtml(name)}</div>

        <button class="vx-tile-more" type="button" aria-label="More actions">⋯</button>
        <div class="vx-tile-menu" role="menu" aria-label="Folder actions">
          <button class="vx-folder-action vx-menu-item" data-act="open" role="menuitem">Open</button>
          <div class="vx-menu-sep"></div>
          <button class="vx-folder-action vx-menu-item" data-act="rename" role="menuitem">Rename…</button>
          <button class="vx-folder-action vx-menu-item" data-act="move" role="menuitem">Move…</button>
          <button class="vx-folder-action vx-menu-item" data-act="delete" role="menuitem">Delete</button>
        </div>
      </div>
    `);
  }

  // --- File tiles ---
  for (const it of files) {
    const id = it.id || it.key;
    const name = it.filename || it.key || "file";
    const type = fileTypeFrom(it);
    const size = fmtBytes(it.size || it.size_bytes || 0);
    const lm = fmtDate(it.lastModified || it.last_modified || it.updated_at || it.created_at);
    const isPdf = String(type || '').toLowerCase().includes('pdf') || String(name || '').toLowerCase().endsWith('.pdf');
    const checked = state.selectedFiles.has(id) ? "checked" : "";

    cards.push(`
      <div class="vx-file-grid-item" data-file-id="${escapeHtml(id)}" data-selected="${checked ? "1" : "0"}" draggable="true" tabindex="0" title="${escapeHtml(name)}&#10;${escapeHtml(type)} • ${escapeHtml(size)} • ${escapeHtml(lm)}">
        <div class="vx-file-select">
          <input class="vx-file-cb" type="checkbox" ${checked} />
        </div>

        <div class="vx-file-thumb" aria-hidden="true">
          ${isPdf ? ICON_PDF_TILE : ICON_DOC_TILE}
        </div>

        <div class="vx-file-title">${escapeHtml(name)}</div>

        <button class="vx-tile-more" type="button" aria-label="More actions">⋯</button>
        <div class="vx-tile-menu" role="menu" aria-label="File actions">
          <button class="vx-action vx-menu-item" data-act="preview" role="menuitem">Open</button>
          <button class="vx-action vx-menu-item" data-act="download" role="menuitem">Download</button>
          <div class="vx-menu-sep"></div>
          <button class="vx-action vx-menu-item" data-act="move" role="menuitem">Move…</button>
          <button class="vx-action vx-menu-item" data-act="rename" role="menuitem">Rename…</button>
          <button class="vx-action vx-menu-item" data-act="delete" role="menuitem">Delete</button>
        </div>
      </div>
    `);
  }

  elFilesGrid.innerHTML = cards.join("");

  // Menu toggles
  bindGlobalMenuCloser();
  $$(".vx-tile-more", elFilesGrid).forEach((moreBtn) => {
    moreBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const card = moreBtn.closest(".vx-file-grid-item");
      if (!card) return;
      const wasOpen = card.getAttribute("data-menu") === "1";
      closeAllFileMenus();
      if (!wasOpen) card.setAttribute("data-menu", "1");
    });
  });
  $$(".vx-tile-menu", elFilesGrid).forEach((menu) => {
    menu.addEventListener("click", (e) => e.stopPropagation());
  });

  // Folder tile interactions (open + DnD)
  const getDraggedFileIds = (draggedId) => {
    if (!draggedId) return [];
    return state.selectedFiles && state.selectedFiles.has(draggedId)
      ? Array.from(state.selectedFiles)
      : [draggedId];
  };

  $$(".vx-folder-grid-item", elFilesGrid).forEach((tile) => {
    const folderPath = tile.getAttribute("data-folder-path") || "";

    tile.addEventListener("click", (e) => {
      // Clicking the tile opens the folder (unless clicking the menu button)
      if (e.target && (e.target.classList && e.target.classList.contains("vx-tile-more"))) return;
      setSelectedFolder(folderPath);
    });

    tile.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      openContextMenu(e.clientX, e.clientY, { kind:"folder", path: folderPath });
    });

    tile.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", JSON.stringify({ kind:"folder", path: folderPath }));
      e.dataTransfer.effectAllowed = "move";
    });

    tile.addEventListener("dragover", (e) => {
      e.preventDefault();
      const hasFiles = !!(e.dataTransfer && e.dataTransfer.types && Array.from(e.dataTransfer.types).includes("Files"));
      e.dataTransfer.dropEffect = hasFiles ? "copy" : "move";
      tile.style.background = "rgba(255,255,255,0.06)";
      tile.style.borderColor = "rgba(255,255,255,0.20)";
    });

    tile.addEventListener("dragleave", () => {
      tile.style.background = "";
      tile.style.borderColor = "";
    });

    tile.addEventListener("drop", async (e) => {
      e.preventDefault();
      tile.style.background = "";
      tile.style.borderColor = "";
      try {
        const localFiles = (e.dataTransfer && e.dataTransfer.files) ? Array.from(e.dataTransfer.files) : [];
        if (localFiles && localFiles.length) {
          await uploadFilesToFolder(localFiles, folderPath);
          return;
        }

        const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
        if (data.kind === "file") {
          const ids = getDraggedFileIds(data.id);
          await moveFilesToFolder(ids, folderPath);
        } else if (data.kind === "folder") {
          if (!data.path) return;
          if (data.path === folderPath) return;
          await moveFolderInto(data.path, folderPath);
        }

        await refreshVault();
      } catch (err) {
        console.error(err);
        toast(`Drop failed: ${err.message || err}`, { ttl: 6000 });
      }
    });
  });

  // Folder menu actions
  $$(".vx-folder-action", elFilesGrid).forEach((btn) => {
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();
      closeAllFileMenus();
      const act = btn.getAttribute("data-act");
      const tile = btn.closest(".vx-folder-grid-item");
      const p = tile?.getAttribute("data-folder-path");
      if (!p) return;
      try {
        if (act === "open") {
          setSelectedFolder(p);
        } else if (act === "rename") {
          setSelectedFolder(p);
          await doRenameFolder();
        } else if (act === "move") {
          setSelectedFolder(p);
          await doMoveFolder();
        } else if (act === "delete") {
          setSelectedFolder(p);
          await doDeleteFolderSoft();
        }
      } catch (e2) {
        console.error(e2);
        toast(`${act} failed: ${e2.message || e2}`, { ttl: 7000 });
      }
    });
  });

  // Bind checkboxes (files only)
  $$(".vx-file-cb", elFilesGrid).forEach((cb) => {
    cb.addEventListener("change", () => {
      const card = cb.closest(".vx-file-grid-item");
      const id = card?.getAttribute("data-file-id");
      if (!id) return;
      if (cb.checked) state.selectedFiles.add(id); else state.selectedFiles.delete(id);
      if (elBulkDownload) elBulkDownload.disabled = state.selectedFiles.size === 0;
      if (elBulkDelete) elBulkDelete.disabled = state.selectedFiles.size === 0;
      updateTrashActionButtons(visibleIds.size);
    });
  });

  // Bind file action buttons
  $$(".vx-action", elFilesGrid).forEach((btn) => {
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();
      closeAllFileMenus();
      const act = btn.getAttribute("data-act");
      const card = btn.closest(".vx-file-grid-item");
      const id = card?.getAttribute("data-file-id");
      if (!id) return;
      try {
        if (act === "download") await downloadFile(id);
        else if (act === "preview") await previewFile(id);
        else if (act === "move") await openMoveModalForFile(id);
        else if (act === "rename") await renameFile(id);
        else if (act === "delete") await deleteFileSoft(id);
      } catch (e2) {
        console.error(e2);
        toast(`${act} failed: ${e2.message || e2}`, { ttl: 7000 });
      }
    });
  });

  // Drag support for files
  $$(".vx-file-grid-item", elFilesGrid).forEach((card) => {
    if (card.classList.contains('vx-folder-grid-item')) return;
    card.addEventListener("dragstart", (e) => {
      const id = card.getAttribute("data-file-id");
      e.dataTransfer.setData("text/plain", JSON.stringify({ kind:"file", id }));
      e.dataTransfer.effectAllowed = "move";
    });
    card.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      const id = card.getAttribute("data-file-id");
      openContextMenu(e.clientX, e.clientY, { kind:"file", id });
    });
  });
}

function renderFileTable() {
    if (!elFilesTbody) return;

    if (!state.user) {
      elFilesTbody.innerHTML = `<tr><td colspan="6" style="color:var(--muted); font-size:0.9rem;">Login to load your vault files.</td></tr>`;
      if (elBulkDownload) elBulkDownload.disabled = true;
      if (elBulkDelete) elBulkDelete.disabled = true;
      updateTrashActionButtons(0);
      if (elSelectAll) elSelectAll.checked = false;
      return;
    }

    const inFolder = filteredItemsForFolder();
    const filtered = applyFileFilter(inFolder);
    const sorted = sortItems(filtered);

    const subfoldersRaw = getDirectSubfolders(state.selectedFolder);
    const subfolders = applyFolderFilter(subfoldersRaw);

    // update selection if items changed
    const visibleIds = new Set(sorted.map(it => it.id || it.key));
    state.selectedFiles = new Set(Array.from(state.selectedFiles).filter(id => visibleIds.has(id)));

    const isGridView = state.fileView === "grid";
    if (elFilesTable) elFilesTable.style.display = isGridView ? "none" : "";
    if (elFilesGrid) elFilesGrid.style.display = isGridView ? "" : "none";
    updateViewButtons();



    if (isGridView) {
      // Grid render (cards)
      renderFileGrid(subfolders, sorted, visibleIds);
      // Bulk controls
      if (elSelectAll) elSelectAll.disabled = true; // hidden in grid header; keep safe
      if (elBulkDownload) elBulkDownload.disabled = state.selectedFiles.size === 0;
      if (elBulkDelete) elBulkDelete.disabled = state.selectedFiles.size === 0;
      updateTrashActionButtons(sorted.length);
      return;
    }

    // Render
    if (!sorted.length && !subfolders.length) {
      elFilesTbody.innerHTML = `<tr><td colspan="6" style="color:var(--muted); font-size:0.9rem;">No files or folders in this folder.</td></tr>`;
    } else {
      const rows = [];

      // Direct subfolders first (so you can drag/drop in the list/grid)
      for (const fp of subfolders) {
        const fname = basenamePath(fp) || fp;
        rows.push(`
          <tr class="vx-folder-row" data-folder-path="${escapeHtml(fp)}">
            <td style="width:44px;"></td>
            <td>
              <div style="font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center; gap:8px;">
                <span class="vx-row-icon" aria-hidden="true">${ICON_FOLDER_ROW}</span>
                <span>${escapeHtml(fname)}</span>
              </div>
            </td>
            <td>Folder</td>
            <td></td>
            <td></td>
            <td class="vx-row-actions">
              <button class="vx-row-more" type="button" aria-label="More actions">⋯</button>
              <div class="vx-row-menu" role="menu" aria-label="Folder actions">
                <button class="vx-folder-row-action vx-menu-item" data-act="open" role="menuitem">Open</button>
                <div class="vx-menu-sep"></div>
                <button class="vx-folder-row-action vx-menu-item" data-act="rename" role="menuitem">Rename…</button>
                <button class="vx-folder-row-action vx-menu-item" data-act="move" role="menuitem">Move…</button>
                <button class="vx-folder-row-action vx-menu-item" data-act="delete" role="menuitem">Delete</button>
              </div>
            </td>
          </tr>
        `);
      }

      for (const it of sorted) {
        const id = it.id || it.key;
        const name = it.filename || it.key || "file";
        const type = fileTypeFrom(it);
        const size = fmtBytes(it.size || it.size_bytes || 0);
        const lm = fmtDate(it.lastModified || it.last_modified || it.updated_at || it.created_at);
        const checked = state.selectedFiles.has(id) ? "checked" : "";
        const tags = getTagsFor(id);
        const tagsHtml = tags.length ? `<div class="vx-tags">${tags.map(t=>`<span class="vx-tag">${escapeHtml(t)}</span>`).join("")}</div>` : "";

        
        const lowerName = String(name || "").toLowerCase();
        const lowerType = String(type || "").toLowerCase();
        const isPdf = lowerName.endsWith(".pdf") || lowerType.includes("pdf");
rows.push(`
          <tr data-file-id="${escapeHtml(id)}">
            <td style="width:44px;"><input class="vx-file-cb" type="checkbox" ${checked} /></td>
            <td>
              <div style="font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center; gap:8px;">
                <span class="vx-row-icon" aria-hidden="true">${isPdf ? ICON_PDF_ROW : ICON_DOC_ROW}</span>
                <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(name)}</span>
              </div>
              ${tagsHtml}
            </td>
            <td>${escapeHtml(type)}</td>
            <td>${escapeHtml(size)}</td>
            <td>${escapeHtml(lm)}</td>
            <td class="vx-row-actions">
              <button class="vx-row-more" type="button" aria-label="More actions">⋯</button>
              <div class="vx-row-menu" role="menu" aria-label="File actions">
                <button class="vx-action vx-menu-item" data-act="preview" role="menuitem">Open</button>
                <button class="vx-action vx-menu-item" data-act="download" role="menuitem">Download</button>
                <div class="vx-menu-sep"></div>
                <button class="vx-action vx-menu-item" data-act="move" role="menuitem">Move…</button>
                <button class="vx-action vx-menu-item" data-act="rename" role="menuitem">Rename…</button>
                <button class="vx-action vx-menu-item" data-act="delete" role="menuitem">Delete</button>
              </div>
            </td>
          </tr>
        `);
      }
      elFilesTbody.innerHTML = rows.join("");
    }

    if (elFilesGrid) elFilesGrid.innerHTML = "";

    // Enable bulk controls
    if (elSelectAll) elSelectAll.disabled = !sorted.length;
    if (elBulkDownload) elBulkDownload.disabled = state.selectedFiles.size === 0;
    if (elBulkDelete) elBulkDelete.disabled = state.selectedFiles.size === 0;
    updateTrashActionButtons(sorted.length);

    // Bind row handlers
    $$(".vx-file-cb", elFilesTbody).forEach((cb) => {
      cb.addEventListener("change", () => {
        const tr = cb.closest("tr");
        const id = tr?.getAttribute("data-file-id");
        if (!id) return;
        if (cb.checked) state.selectedFiles.add(id); else state.selectedFiles.delete(id);
        if (elBulkDownload) elBulkDownload.disabled = state.selectedFiles.size === 0;
        if (elBulkDelete) elBulkDelete.disabled = state.selectedFiles.size === 0;
        updateTrashActionButtons(visibleIds.size);
      });
    });

    // Row action buttons
    $$(".vx-action", elFilesTbody).forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        e.stopPropagation();
        closeAllFileMenus();
        const act = btn.getAttribute("data-act");
        const tr = btn.closest("tr");
        const id = tr?.getAttribute("data-file-id");
        if (!id) return;
        try {
          if (act === "download") await downloadFile(id);
          else if (act === "preview") await previewFile(id);
          else if (act === "move") await openMoveModalForFile(id);
          else if (act === "rename") await renameFile(id);
          else if (act === "delete") await deleteFileSoft(id);
        } catch (e) {
          console.error(e);
          toast(`${act} failed: ${e.message || e}`, { ttl: 7000 });
        }
      });
    });


    // Folder row action buttons
    $$(".vx-folder-row-action", elFilesTbody).forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        e.stopPropagation();
        closeAllFileMenus();
        const act = btn.getAttribute("data-act");
        const tr = btn.closest("tr");
        const p = tr?.getAttribute("data-folder-path");
        if (!p) return;
        try {
          if (act === "open") {
            setSelectedFolder(p);
          } else if (act === "rename") {
            setSelectedFolder(p);
            await doRenameFolder();
          } else if (act === "move") {
            setSelectedFolder(p);
            await doMoveFolder();
          } else if (act === "delete") {
            setSelectedFolder(p);
            await doDeleteFolderSoft();
          }
        } catch (e2) {
          console.error(e2);
          toast(`${act} failed: ${e2.message || e2}`, { ttl: 7000 });
        }
      });
    });


    // Row menu toggles (⋯)
    bindGlobalMenuCloser();
    $$(".vx-row-more", elFilesTbody).forEach((moreBtn) => {
      moreBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const cell = moreBtn.closest(".vx-row-actions");
        if (!cell) return;
        const wasOpen = cell.getAttribute("data-menu") === "1";
        closeAllFileMenus();
        if (!wasOpen) cell.setAttribute("data-menu", "1");
      });
    });
    $$(".vx-row-menu", elFilesTbody).forEach((menu) => {
      menu.addEventListener("click", (e) => e.stopPropagation());
    });

    // Row context menu + drag/drop
    $$("#vaultFilesTbody tr").forEach((tr) => {
      const folderPath = tr.getAttribute("data-folder-path");

      // Context menu
      tr.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        if (folderPath) {
          openContextMenu(e.clientX, e.clientY, { kind:"folder", path: folderPath });
        } else {
          const id = tr.getAttribute("data-file-id");
          openContextMenu(e.clientX, e.clientY, { kind:"file", id });
        }
      });

      // Click to open folders
      if (folderPath) {
        tr.addEventListener("click", (e) => {
          // Don't trigger when clicking menu button
          if (e.target && (e.target.classList && e.target.classList.contains("vx-row-more"))) return;
          setSelectedFolder(folderPath);
        });
      }

      // Drag support
      tr.setAttribute("draggable", "true");
      tr.addEventListener("dragstart", (e) => {
        if (folderPath) {
          e.dataTransfer.setData("text/plain", JSON.stringify({ kind:"folder", path: folderPath }));
        } else {
          const id = tr.getAttribute("data-file-id");
          e.dataTransfer.setData("text/plain", JSON.stringify({ kind:"file", id }));
        }
        e.dataTransfer.effectAllowed = "move";
      });

      // Folder rows are drop targets (files/folders/OS uploads)
      if (folderPath) {
        tr.addEventListener("dragover", (e) => {
          e.preventDefault();
          const hasFiles = !!(e.dataTransfer && e.dataTransfer.types && Array.from(e.dataTransfer.types).includes("Files"));
          e.dataTransfer.dropEffect = hasFiles ? "copy" : "move";
          tr.style.outline = "1px solid rgba(255,255,255,0.18)";
          tr.style.background = "rgba(255,255,255,0.04)";
        });
        tr.addEventListener("dragleave", () => {
          tr.style.outline = "";
          tr.style.background = "";
        });
        tr.addEventListener("drop", async (e) => {
          e.preventDefault();
          tr.style.outline = "";
          tr.style.background = "";
          try {
            const localFiles = (e.dataTransfer && e.dataTransfer.files) ? Array.from(e.dataTransfer.files) : [];
            if (localFiles && localFiles.length) {
              await uploadFilesToFolder(localFiles, folderPath);
              return;
            }
            const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
            if (data.kind === "file") {
              const draggedId = data.id;
              const ids = (state.selectedFiles && state.selectedFiles.has(draggedId)) ? Array.from(state.selectedFiles) : [draggedId];
              await moveFilesToFolder(ids, folderPath);
            } else if (data.kind === "folder") {
              if (!data.path) return;
              if (data.path === folderPath) return;
              await moveFolderInto(data.path, folderPath);
            }
            await refreshVault();
          } catch (err) {
            console.error(err);
            toast(`Drop failed: ${err.message || err}`, { ttl: 6000 });
          }
        });
      }
    });
  }

  // Select all
  if (elSelectAll) {
    elSelectAll.addEventListener("change", () => {
      const cbs = $$(".vx-file-cb", elFilesTbody);
      cbs.forEach((cb) => {
        cb.checked = elSelectAll.checked;
        const tr = cb.closest("tr");
        const id = tr?.getAttribute("data-file-id");
        if (!id) return;
        if (cb.checked) state.selectedFiles.add(id); else state.selectedFiles.delete(id);
      });
      if (elBulkDownload) elBulkDownload.disabled = state.selectedFiles.size === 0;
      if (elBulkDelete) elBulkDelete.disabled = state.selectedFiles.size === 0;
    });
  }

  // ============================
  // Vault operations
  // ============================
  async function refreshVault() {
    if (!state.user) return;

    // 1) Folders
    let folderData = null;
    try {
      folderData = await apiFetch(API.VAULT_FOLDERS + "?ts=" + Date.now(), { method: "GET" });
    } catch (e) {
      // fallback: some servers return folders inside /api/vault/list
      folderData = null;
    }

    const foldersRaw =
      (folderData && (folderData.folders || folderData.items || folderData)) ||
      [];

    state.folders = (Array.isArray(foldersRaw) ? foldersRaw : [])
      .map((x) => normalizePath(x.path || x.folderPath || x.folder_path || x.name || x))
      .filter((p) => p !== "__root__" && String(p||"").toLowerCase() !== "_trash" && !String(p||"").toLowerCase().startsWith("_trash/"));

    // Do not inject synthetic folders; rely on server.


    // 2) Files for selected folder
    const folderQ = encodeURIComponent(state.selectedFolder || "");
    const listUrl = `${API.VAULT_LIST}?folder=${folderQ}&ts=${Date.now()}`;
    const data = await apiFetch(listUrl, { method: "GET" });

    state.items = (data.items || []).map((x) => ({
      id: x.id || x.key,
      key: x.key || x.id,
      filename: x.filename || x.name || x.path || x.key,
      size: x.size || x.sizeBytes || x.size_bytes || 0,
      lastModified: x.lastModified || x.last_modified || x.updatedAt || x.updated_at || x.createdAt || x.created_at || null,
      contentType: x.contentType || x.content_type || x.mimeType || x.mime_type || "",
      storage: x.storage || "",
      folderPath: normalizePath(x.folderPath || x.folder_path || x.folder || ""),
      trashedAt: x.trashedAt || x.trashed_at || null,
    }));

    buildFolderSet();
    bindExistingControls();
    updateFolderLabels();
    // Keep selected folder valid
    if (state.selectedFolder && !state.folderSet.has(state.selectedFolder)) state.selectedFolder = "";
    renderFolderTree();
    renderFileTable();
    try { secureSendRefreshFromVault(); } catch (e) {}
  }


  async function refreshFilesOnly() {
    if (!state.user) return;
    const folderQ = encodeURIComponent(state.selectedFolder || "");
    const listUrl = `${API.VAULT_LIST}?folder=${folderQ}&ts=${Date.now()}`;
    const data = await apiFetch(listUrl, { method: "GET" });

    state.items = (data.items || []).map((x) => ({
      id: x.id || x.key,
      key: x.key || x.id,
      filename: x.filename || x.name || x.path || x.key,
      size: x.size || x.sizeBytes || x.size_bytes || 0,
      lastModified: x.lastModified || x.last_modified || x.updatedAt || x.updated_at || x.createdAt || x.created_at || null,
      contentType: x.contentType || x.content_type || x.mimeType || x.mime_type || "",
      storage: x.storage || "",
      folderPath: normalizePath(x.folderPath || x.folder_path || x.folder || ""),
      trashedAt: x.trashedAt || x.trashed_at || null,
    }));

    renderFileTable();
  }


  async function createFolder(fullPath) {
    const folderPath = normalizePath(fullPath);
    if (!folderPath) throw new Error("Folder name required.");
    await apiFetch(API.VAULT_CREATE_FOLDER, {
      method: "POST",
      body: JSON.stringify({ folderPath }),
    });
    logActivity("folder:create", folderPath);
  }

  async function doNewFolder() {
    if (!state.user) return;
    const base = state.selectedFolder ? `${state.selectedFolder}/` : "";
    const name = prompt("New folder name:", "");
    if (!name) return;

    const clean = name.replace(/[\\]/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
    const full = normalizePath(base + clean);
    await createFolder(full);
    toast(`Folder created: ${full}`, { ttl: 4500 });
    await refreshVault();
    setSelectedFolder(full);
    // Expand parents
    let p = full;
    while (p && p.includes("/")) {
      p = p.split("/").slice(0, -1).join("/");
      state.expanded.add(p);
    }
    state.expanded.add("");
    persistUI();
    renderFolderTree();
  }

  async function doRenameFolder() {
    const from = normalizePath(state.selectedFolder);
    if (!from) return;
    const parts = from.split("/");
    const curName = parts[parts.length-1];
    const parent = parts.slice(0,-1).join("/");
    const nextName = prompt("Rename folder to:", curName);
    if (!nextName) return;
    const to = normalizePath((parent ? parent + "/" : "") + nextName);
    await moveFolder(from, to);
    toast(`Renamed: ${from} → ${to}`, { ttl: 5000 });
    await refreshVault();
    setSelectedFolder(to);
    logActivity("folder:rename", `${from} → ${to}`);
  }

  async function doMoveFolder() {
    const from = normalizePath(state.selectedFolder);
    if (!from) return;
    // Destination picker: choose existing folder as parent
    const all = Array.from(state.folderSet).filter(p => p && p !== TRASH_FOLDER).sort();
    const dest = prompt("Move folder to (destination parent path, blank for root):", "");
    if (dest == null) return;
    const parent = normalizePath(dest);
    const name = from.split("/").slice(-1)[0];
    const to = normalizePath((parent ? parent + "/" : "") + name);
    if (to === from) return;
    await moveFolder(from, to);
    toast(`Moved: ${from} → ${to}`, { ttl: 5000 });
    await refreshVault();
    setSelectedFolder(to);
    logActivity("folder:move", `${from} → ${to}`);
  }

  
async function doDeleteFolderSoft() {
  // Trash disabled: treat delete as permanent hard delete.
  const p = normalizePath(state.selectedFolder);
  if (!p) return;
  return await deleteFolderPermanent(p);
}

async function deleteFolderPermanent(path) {
    const p = normalizePath(path);
    if (!p) return;
    if (!confirm(`Permanently delete folder "${p}" and all contents? This cannot be undone.`)) return;
    await apiFetch(API.VAULT_FOLDER_DELETE, { method:"DELETE", body: JSON.stringify({ folderPath: p, force: true, hard: true }) });
    logActivity("folder:delete", p);
    toast(`Folder deleted: ${p}`, { ttl: 5000 });
    await refreshVault();
    setSelectedFolder("");
  }

  function basenamePath(p) {
    const n = normalizePath(p);
    if (!n) return "";
    const parts = n.split("/").filter(Boolean);
    return parts[parts.length - 1] || "";
  }

  function joinPath(parent, name) {
    const p = normalizePath(parent);
    const n = String(name || "").trim();
    if (!n) return p;
    return p ? (p + "/" + n) : n;
  }

  function rewritePathsAfterMove(from, to) {
    // Update selected folder if it was the moved folder or inside it
    const sel = normalizePath(state.selectedFolder);
    if (sel === from) state.selectedFolder = to;
    else if (sel && sel.startsWith(from + "/")) state.selectedFolder = to + sel.slice(from.length);

    // Rewrite expanded paths to keep tree state stable
    const next = new Set();
    for (const p of state.expanded) {
      const np = normalizePath(p);
      if (np === from) next.add(to);
      else if (np && np.startsWith(from + "/")) next.add(to + np.slice(from.length));
      else next.add(np);
    }
    state.expanded = next;
    persistUI();
  }

  async function moveFolderInto(fromPath, destFolderPath) {
    const from = normalizePath(fromPath);
    const destParent = normalizePath(destFolderPath);
    if (!from) throw new Error("No source folder.");

    // Prevent moving into itself (or its descendants)
    if (destParent === from) return;
    if (destParent && destParent.startsWith(from + "/")) {
      throw new Error("Cannot move a folder into itself.");
    }

    const base = basenamePath(from);
    if (!base) throw new Error("Invalid source folder.");

    // Windows behavior: drop folder A onto folder B => B/A
    let attempt = 0;
    while (attempt < 50) {
      const name = attempt == 0 ? base : `${base} (${attempt + 1})`;
      const toFull = joinPath(destParent, name);
      if (toFull === from) return;
      try {
        await moveFolder(from, toFull);
        rewritePathsAfterMove(from, toFull);
        return;
      } catch (e) {
        if (e && e.status === 409) {
          attempt += 1;
          continue;
        }
        throw e;
      }
    }
    throw new Error("Too many name collisions in the destination folder.");
  }

  async function moveFolder(fromPath, toPath) {
    const from = normalizePath(fromPath);
    const to = normalizePath(toPath);
    if (!from) throw new Error("No source folder.");
    if (to === from) return;

    // Prefer server endpoint; fallback to client-side move (files only) if 404
    try {
      await apiFetch(API.VAULT_FOLDER_MOVE, { method:"POST", body: JSON.stringify({ fromPath: from, toPath: to }) });
      return;
    } catch (e) {
      if (e.status !== 404 && e.status !== 501) throw e;
    }

    // Fallback: move each file under from to to (non-recursive; best effort)
    const moved = [];
    for (const it of state.items) {
      const fp = normalizePath(inferFolderPathFromItem(it));
      if (fp === from) moved.push(it.id || it.key);
    }
    await moveFilesToFolder(moved, to);
  }

  async function uploadSelectedFile() {
    if (!state.user) return;
    if (!elVaultFile || !elVaultFile.files || !elVaultFile.files[0]) {
      toast("Select a file first.", { ttl: 4000 });
      return;
    }
    const f = elVaultFile.files[0];
    if (elUploadStatus) elUploadStatus.textContent = "Uploading…";

    const form = new FormData();
    form.append("file", f);
    form.append("folderPath", state.selectedFolder || "");

    try {
      const data = await apiFetch(API.VAULT_UPLOAD, { method: "POST", body: form, headers: {} });
      logActivity("file:upload", f.name);
      if (elUploadStatus) elUploadStatus.textContent = "Uploaded.";
      toast(`Uploaded: ${f.name}`, { ttl: 4500 });
      elVaultFile.value = "";
      await refreshVault();
    } catch (e) {
      if (elUploadStatus) elUploadStatus.textContent = `Upload failed: ${e.message || e}`;
      throw e;
    }
  }

  // ============================
  // Encrypted Containers (client-side, downloadable artifact)
  // - Create a single encrypted container file from local uploads (and optionally selected Vault files)
  // - Unlock + decrypt container, preview manifest
  // - Extract decrypted files into currently selected Vault folder
  // ============================

  const te = new TextEncoder();
  const td = new TextDecoder();

  function u8ToB64(u8) {
    let s = "";
    for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
    return btoa(s);
  }
  function b64ToU8(b64) {
    const bin = atob(b64);
    const u8 = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
    return u8;
  }

  function setStatus(el, msg, isErr=false) {
    if (!el) return;
    el.textContent = msg || "";
    el.style.color = isErr ? "#e5484d" : "var(--muted)";
  }

  function triggerDownload(blob, filename) {
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename || "pdfrealm-container.pvr";
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 1000);
  }

  function updateContainerButtons() {
    const authed = !!state.user;
    if (elContainerCreateBtn) elContainerCreateBtn.disabled = !authed;
    if (elContainerUnlockBtn) elContainerUnlockBtn.disabled = !authed;
    if (elContainerDownloadBtn) elContainerDownloadBtn.disabled = !authed || !state.containerBuilt;
    if (elContainerExtractBtn) elContainerExtractBtn.disabled = !authed || !state.containerUnlocked;
  }

  async function deriveAesKeyFromPassword(password, saltU8, iterations) {
    if (!crypto?.subtle) throw new Error("WebCrypto not available in this browser.");
    const baseKey = await crypto.subtle.importKey(
      "raw",
      te.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return await crypto.subtle.deriveKey(
      { name: "PBKDF2", salt: saltU8, iterations, hash: "SHA-256" },
      baseKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  }

  async function uploadBlobToVault(blob, filename, folderPath="") {
    const form = new FormData();
    const file = new File([blob], filename, { type: blob.type || "application/octet-stream" });
    form.append("file", file);
    form.append("folderPath", folderPath || "");
    await apiFetch(API.VAULT_UPLOAD, { method: "POST", body: form, headers: {} });
  }

  async function fetchSelectedVaultFilesAsFiles() {
    const ids = Array.from(state.selectedFiles || []);
    if (!ids.length) return [];
    const out = [];
    for (const id of ids) {
      const item = state.items.find(it => (it.id || it.key) === id) || null;
      // Some systems store key instead of id
      const reqId = item?.id || item?.key || id;
      const meta = await apiFetch(API.VAULT_FILE(reqId), { method: "GET" });
      const url = meta.url || meta.signedUrl || meta.href;
      if (!url) throw new Error("No download URL returned for selected Vault file.");
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`Failed to fetch Vault file (${resp.status})`);
      const blob = await resp.blob();
      const name = item?.filename || meta.filename || meta.name || "vault-file";
      const type = item?.contentType || blob.type || "application/octet-stream";
      out.push(new File([blob], name, { type, lastModified: item?.lastModified ? Date.parse(item.lastModified) : Date.now() }));
    }
    return out;
  }

  async function createEncryptedContainer() {
    if (!state.user) return;

    const password = (elContainerPassword?.value || "").trim();
    if (!password) {
      toast("Enter a container password first.", { ttl: 4500 });
      return;
    }

    const localFiles = Array.from(elContainerFiles?.files || []);
    const selectedVaultCount = (state.selectedFiles?.size || 0);

    if (!localFiles.length && !selectedVaultCount) {
      toast("Select local files (or select Vault files) to add to the container.", { ttl: 5000 });
      return;
    }

    setStatus(elContainerStatus, "Preparing container…");
    updateContainerButtons();

    try {
      const vaultFiles = selectedVaultCount ? await fetchSelectedVaultFilesAsFiles() : [];
      const allFiles = [...localFiles, ...vaultFiles];

      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iterations = 250000;
      const key = await deriveAesKeyFromPassword(password, salt, iterations);

      const filesMeta = [];
      const chunks = [];
      let offset = 0;

      for (let i = 0; i < allFiles.length; i++) {
        const f = allFiles[i];
        setStatus(elContainerStatus, `Encrypting (${i+1}/${allFiles.length}): ${f.name}`);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const mtime = f.lastModified || Date.now();
        const aadObj = { name: f.name, type: f.type || "", size: f.size || 0, mtime };
        const aadStr = JSON.stringify(aadObj);
        const aadBytes = te.encode(aadStr);

        const plain = await f.arrayBuffer();
        const cipherBuf = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv, additionalData: aadBytes },
          key,
          plain
        );
        const cipherU8 = new Uint8Array(cipherBuf);

        filesMeta.push({
          name: f.name,
          type: f.type || "",
          size: f.size || 0,
          mtime,
          iv: u8ToB64(iv),
          aad: aadStr,
          offset,
          length: cipherU8.byteLength
        });
        chunks.push(cipherU8);
        offset += cipherU8.byteLength;
      }

      const header = {
        v: 1,
        kdf: { name: "PBKDF2", hash: "SHA-256", iterations, salt: u8ToB64(salt) },
        enc: { name: "AES-GCM" },
        createdAt: new Date().toISOString(),
        files: filesMeta
      };

      const headerBytes = te.encode(JSON.stringify(header));
      const lenBuf = new ArrayBuffer(4);
      new DataView(lenBuf).setUint32(0, headerBytes.byteLength, true);
      const magic = te.encode("PVR1");

      const blob = new Blob([magic, lenBuf, headerBytes, ...chunks], { type: "application/octet-stream" });
      const filename = `pdfrealm-container-${new Date().toISOString().replace(/[:.]/g,"-")}.pvr`;

      state.containerBuilt = { blob, filename, header };
      setStatus(elContainerStatus, `Container ready (${allFiles.length} file${allFiles.length===1?"":"s"}).`, false);
      toast("Encrypted container created.", { ttl: 4000 });
      updateContainerButtons();

      // Optional: also upload container into Vault
      if (elContainerAlsoUpload?.checked) {
        setStatus(elContainerStatus, "Uploading container to Vault…");
        await uploadBlobToVault(blob, filename, state.selectedFolder || "");
        setStatus(elContainerStatus, "Container uploaded to Vault.", false);
        toast("Container uploaded to Vault.", { ttl: 4000 });
        await refreshVault();
      }
    } catch (e) {
      state.containerBuilt = null;
      setStatus(elContainerStatus, `Failed: ${e.message || e}`, true);
      toast(`Container failed: ${e.message || e}`, { ttl: 6000 });
    } finally {
      updateContainerButtons();
    }
  }

  function renderContainerPreview(unlocked) {
    if (!elContainerPreviewTbody) return;
    if (!unlocked || !unlocked.files || !unlocked.files.length) {
      elContainerPreviewTbody.innerHTML = `<tr><td colspan="4" style="color:var(--muted); font-size:0.9rem;">No files in container.</td></tr>`;
      return;
    }
    elContainerPreviewTbody.innerHTML = unlocked.files.map((f, idx) => {
      const size = typeof f.size === "number" ? fmtBytes(f.size) : "";
      const type = f.type || "";
      return `
        <tr data-cidx="${idx}">
          <td>${escapeHtml(f.name)}</td>
          <td>${escapeHtml(type)}</td>
          <td>${size}</td>
          <td><button class="btn btn-secondary" type="button" data-act="cdownload">Download</button></td>
        </tr>
      `;
    }).join("");
  }

  async function unlockEncryptedContainer() {
    if (!state.user) return;

    const file = elContainerImportFile?.files?.[0];
    const password = (elContainerImportPassword?.value || "").trim();

    if (!file) {
      toast("Select a container file first.", { ttl: 4500 });
      return;
    }
    if (!password) {
      toast("Enter the container password.", { ttl: 4500 });
      return;
    }

    setStatus(elContainerImportStatus, "Unlocking container…");
    state.containerUnlocked = null;
    updateContainerButtons();
    renderContainerPreview(null);

    try {
      const buf = await file.arrayBuffer();
      const u8 = new Uint8Array(buf);
      const magic = td.decode(u8.slice(0, 4));
      if (magic !== "PVR1") throw new Error("Invalid container format (missing PVR1 header).");

      const headerLen = new DataView(buf, 4, 4).getUint32(0, true);
      if (headerLen <= 0 || headerLen > (buf.byteLength - 8)) throw new Error("Invalid header length.");
      const headerBytes = u8.slice(8, 8 + headerLen);
      const header = JSON.parse(td.decode(headerBytes));

      const salt = b64ToU8(header?.kdf?.salt || "");
      const iterations = header?.kdf?.iterations || 0;
      if (!salt.length || !iterations) throw new Error("Container KDF parameters missing.");

      const key = await deriveAesKeyFromPassword(password, salt, iterations);

      const dataStart = 8 + headerLen;
      const files = [];

      const list = Array.isArray(header.files) ? header.files : [];
      for (let i = 0; i < list.length; i++) {
        const meta = list[i];
        setStatus(elContainerImportStatus, `Decrypting (${i+1}/${list.length}): ${meta.name || "file"}`);
        const iv = b64ToU8(meta.iv || "");
        const aadStr = meta.aad || JSON.stringify({ name: meta.name, type: meta.type || "", size: meta.size || 0, mtime: meta.mtime || 0 });
        const aadBytes = te.encode(aadStr);

        const start = dataStart + (meta.offset || 0);
        const end = start + (meta.length || 0);
        if (start < dataStart || end > buf.byteLength || end <= start) throw new Error("Container data range invalid.");

        const cipherSlice = buf.slice(start, end);
        const plainBuf = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv, additionalData: aadBytes },
          key,
          cipherSlice
        );

        const blob = new Blob([plainBuf], { type: meta.type || "application/octet-stream" });
        files.push({ name: meta.name || `file-${i+1}`, type: meta.type || "", size: meta.size || blob.size, mtime: meta.mtime || 0, blob });
      }

      state.containerUnlocked = { header, files };
      renderContainerPreview(state.containerUnlocked);
      setStatus(elContainerImportStatus, `Unlocked. ${files.length} file${files.length===1?"":"s"} ready to extract.`, false);
      toast("Container unlocked.", { ttl: 3500 });
    } catch (e) {
      state.containerUnlocked = null;
      renderContainerPreview(null);
      setStatus(elContainerImportStatus, `Failed: ${e.message || e}`, true);
      toast(`Unlock failed: ${e.message || e}`, { ttl: 6000 });
    } finally {
      updateContainerButtons();
    }
  }

  async function extractUnlockedContainerToVault() {
    if (!state.user) return;
    if (!state.containerUnlocked || !state.containerUnlocked.files?.length) {
      toast("Unlock a container first.", { ttl: 4500 });
      return;
    }

    const folderPath = state.selectedFolder || "";
    const files = state.containerUnlocked.files;

    setStatus(elContainerImportStatus, `Extracting to Vault${folderPath ? " / " + folderPath : ""}…`);
    updateContainerButtons();

    try {
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        setStatus(elContainerImportStatus, `Uploading (${i+1}/${files.length}): ${f.name}`);
        await uploadBlobToVault(f.blob, f.name, folderPath);
      }
      setStatus(elContainerImportStatus, "Extract complete. Files uploaded to Vault.", false);
      toast("Extracted to Vault.", { ttl: 4000 });
      await refreshVault();
    } catch (e) {
      setStatus(elContainerImportStatus, `Extract failed: ${e.message || e}`, true);
      toast(`Extract failed: ${e.message || e}`, { ttl: 6000 });
    } finally {
      updateContainerButtons();
    }
  }


  async function downloadFile(id) {
    const data = await apiFetch(API.VAULT_FILE(id), { method: "GET" });
    const url = data.url || data.signedUrl || data.href;
    if (!url) throw new Error("No download URL returned.");
    window.open(url, "_blank", "noopener");
    logActivity("file:download", id);
  }

  async function previewFile(id) {
    const data = await apiFetch(API.VAULT_FILE(id), { method: "GET" });
    const url = data.url || data.signedUrl || data.href;
    if (!url) throw new Error("No preview URL returned.");
    openPreviewModal(url, id);
    logActivity("file:preview", id);
  }

  function openInPDFStudio(id) {
    if (!id) return;
    // Navigate to PDFStudio editor (full-page)
    const url = `/pdfstudio.html?fileId=${encodeURIComponent(id)}&folder=${encodeURIComponent((state.currentFolder ?? ""))}`;
    window.open(url, "_blank", "noopener");
    logActivity("file:pdfstudio", id);
  }


  async function openMoveModalForFile(id) {
    if (!elMoveModal) {
      // fallback prompt
      const dest = prompt("Move to folder (path, blank for root):", state.selectedFolder || "");
      if (dest == null) return;
      await moveFilesToFolder([id], normalizePath(dest));
      await refreshVault();
      return;
    }

    const all = Array.from(state.folderSet).sort();
    elMoveTargetFolder.innerHTML = "";
    const optRoot = document.createElement("option");
    optRoot.value = "";
    optRoot.textContent = "/ (root)";
    elMoveTargetFolder.appendChild(optRoot);
    all.forEach((p) => {
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = `/${p}`;
      elMoveTargetFolder.appendChild(opt);
    });
    elMoveTargetFolder.value = state.selectedFolder || "";

    const item = state.items.find(x => (x.id||x.key) === id);
    elMoveFileName.textContent = item ? (item.filename || item.key || id) : id;

    openModal(elMoveModal);

    // bind once per open
    const handler = async () => {
      try {
        const dest = normalizePath(elMoveTargetFolder.value || "");
        await moveFilesToFolder([id], dest);
        closeModal(elMoveModal);
        toast("Moved.", { ttl: 3000 });
        logActivity("file:move", `${id} → ${dest}`);
        await refreshVault();
      } catch (e) {
        console.error(e);
        toast(`Move failed: ${e.message || e}`, { ttl: 7000 });
      } finally {
        elMoveConfirmBtn.removeEventListener("click", handler);
      }
    };
    elMoveConfirmBtn.addEventListener("click", handler);
  }

  async function renameFile(id) {
    const item = state.items.find(x => (x.id||x.key) === id);
    const cur = item ? (item.filename || "file") : "file";
    const next = prompt("Rename file to:", cur.split("/").slice(-1)[0]);
    if (!next) return;

    // Prefer server move endpoint with newName; fallback to download/upload/delete if not available
    try {
      await apiFetch(API.VAULT_FILE_MOVE, { method:"POST", body: JSON.stringify({ ids:[id], toFolderPath: state.selectedFolder || "", newName: next }) });
      logActivity("file:rename", `${cur} → ${next}`);
      toast("Renamed.", { ttl: 3500 });
      await refreshVault();
      return;
    } catch (e) {
      if (e.status !== 404 && e.status !== 501) throw e;
    }

    // Fallback: move within folder with new name by blob transfer
    await moveFilesToFolder([id], state.selectedFolder || "", next);
    await refreshVault();
  }

  async function deleteFileSoft(id) {
    if (!TRASH_ENABLED) { return await deleteFilePermanent(id); }

    const folder = normalizePath(inferFolderPathFromItem(state.items.find(x => (x.id||x.key) === id) || {})) || state.selectedFolder || "";
    const item = state.items.find(x => (x.id||x.key) === id);
    const name = item ? (item.filename || item.key || "file") : "file";
    if (!confirm(`Move file to Trash?\n\n${name}`)) return;

    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const baseName = name.split("/").slice(-1)[0];
    const destFolder = `${TRASH_FOLDER}`;
    const undoFromFolder = folder;

    // Move file to trash
    await moveFilesToFolder([id], destFolder, `${baseName}__${ts}`);
    logActivity("file:trash", `${name} → ${destFolder}`);

    toast(`Moved to Trash: ${baseName}`, {
      ttl: 9000,
      undoLabel: "Undo",
      onUndo: async () => { await moveFilesToFolder([id], undoFromFolder, baseName); logActivity("file:undoTrash", baseName); await refreshVault(); }
    });

    await refreshVault();
  }



  async function deleteFileSoftNoPrompt(id) {
    // Bulk delete helper: no per-file confirmation. Caller confirms once.
    if (!TRASH_ENABLED) {
      await apiFetch(API.VAULT_FILE_DELETE(id), { method: "DELETE" });
      logActivity("file:delete", id);
      return;
    }

    const item = state.items.find(x => (x.id||x.key) === id);
    const name = item ? (item.filename || item.key || "file") : "file";
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const baseName = name.split("/").slice(-1)[0];

    // Move into Trash with a unique suffix, no prompt
    await moveFilesToFolder([id], TRASH_FOLDER, baseName + "__" + ts);
    logActivity("file:trash", name + " → " + TRASH_FOLDER);
  }

  async function deleteFilePermanent(id) {
    if (!confirm("Permanently delete this file? This cannot be undone.")) return;
    await apiFetch(API.VAULT_FILE_DELETE(id), { method: "DELETE" });
    logActivity("file:delete", id);
    toast("Deleted.", { ttl: 3500 });
    await refreshVault();
  }

  async function moveFilesToFolder(ids, destFolder, newName=null) {
    const toFolderPath = normalizePath(destFolder || "");

    // Prefer server move endpoint
    try {
      await apiFetch(API.VAULT_FILE_MOVE, { method:"POST", body: JSON.stringify({ ids, toFolderPath, newName }) });
      return;
    } catch (e) {
      if (e.status !== 404 && e.status !== 501) throw e;
    }

    // Fallback: for each file id -> download signed URL -> fetch blob -> upload -> delete
    for (const id of ids) {
      const info = await apiFetch(API.VAULT_FILE(id), { method:"GET" });
      const url = info.url;
      if (!url) throw new Error("Missing signed url for move fallback.");
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`Failed to fetch blob for move (HTTP ${resp.status})`);
      const blob = await resp.blob();

      // upload with folderPath
      const form = new FormData();
      const item = state.items.find(x => (x.id||x.key) === id);
      const origName = item ? (item.filename || "file") : "file";
      const finalName = newName || origName.split("/").slice(-1)[0];
      const file = new File([blob], finalName, { type: blob.type || "application/octet-stream" });
      form.append("file", file);
      form.append("folderPath", toFolderPath);

      await apiFetch(API.VAULT_UPLOAD, { method:"POST", body: form, headers:{} });

      // delete original
      await apiFetch(API.VAULT_FILE_DELETE(id), { method:"DELETE" });
      logActivity("file:move(fallback)", `${id} → ${toFolderPath}`);
    }
  }

  // Bulk actions
  async function bulkDownload() {
    const ids = Array.from(state.selectedFiles);
    for (const id of ids) await downloadFile(id);
  }

  async function bulkDelete() {
    const ids = Array.from(state.selectedFiles);
    if (!ids.length) return;

    const msg = TRASH_ENABLED
      ? `Are you sure you want to move ${ids.length} file(s) to Trash?`
      : `Are you sure you want to permanently delete ${ids.length} file(s)?`;

    if (!confirm(msg)) return;

    for (const id of ids) {
      await deleteFileSoftNoPrompt(id);
    }

    state.selectedFiles.clear();

    toast(
      TRASH_ENABLED ? `Moved ${ids.length} file(s) to Trash.` : `Deleted ${ids.length} file(s).`,
      { ttl: 4000 }
    );

    await refreshVault();
  }


  // ============================
  // Context menu
  // ============================
  const elMenu = (() => {
    const m = document.createElement("div");
    m.className = "vx-menu";
    document.body.appendChild(m);
    return m;
  })();

  function closeContextMenu() {
    elMenu.style.display = "none";
    elMenu.innerHTML = "";
  }

  function openContextMenu(x, y, ctx) {
    closeContextMenu();
    const items = [];

    if (ctx.kind === "folder") {
      const path = normalizePath(ctx.path);
      items.push({ label:"New folder here…", kbd:"N", onClick: async () => { setSelectedFolder(path); await doNewFolder(); } });
      if (path) items.push({ label: isFav(path) ? "Unfavorite" : "Favorite", kbd:"F", onClick: () => toggleFav(path) });
      if (path) items.push({ label:"Rename…", kbd:"R", onClick: async () => { setSelectedFolder(path); await doRenameFolder(); } });
      if (path) items.push({ label:"Move…", kbd:"M", onClick: async () => { setSelectedFolder(path); await doMoveFolder(); } });

      items.push({ sep:true });

      if (path) items.push({ label:"Copy path", kbd:"C", onClick: async () => { await navigator.clipboard.writeText(`Vault:/${path}`); toast("Path copied.", { ttl: 2500 }); } });
      items.push({ label:"Search in this folder", kbd:"/", onClick: () => { if (ui.fileSearch) ui.fileSearch.focus(); } });

      items.push({ sep:true });

      if (path) items.push({ label:"Delete (move to Trash)", kbd:"Del", onClick: async () => { setSelectedFolder(path); await doDeleteFolderSoft(); } });
      if (path) items.push({ label:"Delete permanently", kbd:"Shift+Del", onClick: async () => { await deleteFolderPermanent(path); } });
    } else if (ctx.kind === "file") {
      const id = ctx.id;
      items.push({ label:"Preview", kbd:"P", onClick: async () => previewFile(id) });
      items.push({ label:"Download", kbd:"D", onClick: async () => downloadFile(id) });
      items.push({ label:"Move…", kbd:"M", onClick: async () => openMoveModalForFile(id) });
      items.push({ label:"Rename…", kbd:"R", onClick: async () => renameFile(id) });

      items.push({ sep:true });

      items.push({ label:"Copy path", kbd:"C", onClick: async () => {
        const it = state.items.find(x => (x.id||x.key)===id);
        const fp = normalizePath(inferFolderPathFromItem(it || {}));
        const nm = (it?.filename || it?.key || id).split("/").slice(-1)[0];
        await navigator.clipboard.writeText(`Vault:/${fp ? fp + "/" : ""}${nm}`);
        toast("Path copied.", { ttl: 2500 });
      }});
      items.push({ label:"Copy share link", kbd:"S", onClick: async () => {
        const info = await apiFetch(API.VAULT_FILE(id), { method:"GET" });
        const url = info.url;
        if (!url) throw new Error("No signed url.");
        await navigator.clipboard.writeText(url);
        toast("Share link copied.", { ttl: 2500 });
      }});
      items.push({ label:"Edit tags…", kbd:"T", onClick: async () => openTagsModal(id) });

      items.push({ sep:true });

      items.push({ label:"Delete (move to Trash)", kbd:"Del", onClick: async () => deleteFileSoft(id) });
      items.push({ label:"Delete permanently", kbd:"Shift+Del", onClick: async () => deleteFilePermanent(id) });
    }

    // Render menu
    for (const it of items) {
      if (it.sep) {
        const sep = document.createElement("div");
        sep.className = "vx-sep";
        elMenu.appendChild(sep);
        continue;
      }
      const div = document.createElement("div");
      div.className = "vx-mi";
      div.innerHTML = `<div>${escapeHtml(it.label)}</div>${it.kbd ? `<div class="vx-kbd">${escapeHtml(it.kbd)}</div>` : ""}`;
      div.addEventListener("click", async () => {
        closeContextMenu();
        try { await it.onClick(); } catch (e) { console.error(e); toast(e.message || String(e), { ttl: 7000 }); }
      });
      elMenu.appendChild(div);
    }

    const pad = 10;
    elMenu.style.left = Math.min(x, window.innerWidth - 260 - pad) + "px";
    elMenu.style.top = Math.min(y, window.innerHeight - 260 - pad) + "px";
    elMenu.style.display = "block";
  }

  document.addEventListener("click", () => closeContextMenu());
  window.addEventListener("resize", () => closeContextMenu());
  document.addEventListener("scroll", () => closeContextMenu(), true);

  // ============================
  // Command palette (Ctrl+K)
  // ============================
  const elPaletteBackdrop = (() => {
    const b = document.createElement("div");
    b.className = "vx-palette-backdrop";
    b.innerHTML = `
      <div class="vx-palette" role="dialog" aria-modal="true">
        <div class="vx-palette-head">
          <input class="vx-palette-input" id="vxPaletteInput" placeholder="Type a command… (new folder, upload, move, tag, trash)" />
        </div>
        <div class="vx-palette-list" id="vxPaletteList"></div>
      </div>
    `;
    document.body.appendChild(b);
    return b;
  })();

  const elPaletteInput = $("#vxPaletteInput", elPaletteBackdrop);
  const elPaletteList = $("#vxPaletteList", elPaletteBackdrop);

  function openPalette() {
    elPaletteBackdrop.style.display = "flex";
    elPaletteInput.value = "";
    renderPalette("");
    setTimeout(() => elPaletteInput.focus(), 50);
  }
  function closePalette() {
    elPaletteBackdrop.style.display = "none";
  }

  function paletteCommands() {
    const folder = state.selectedFolder;
    const hasSel = state.selectedFiles.size > 0;

    const cmds = [
      { title: "New folder", sub: `Create a folder in /${folder || ""}`, run: async () => doNewFolder() },
      { title: "Upload file", sub: `Upload into /${folder || ""}`, run: async () => { if (elVaultFile) elVaultFile.click(); } },
      { title: "Refresh", sub: "Reload folders and files", run: async () => refreshVault() },
      { title: "Toggle favorite folder", sub: folder ? `Favorite /${folder}` : "Select a folder first", run: async () => { if (folder) toggleFav(folder); } },
      { title: "Search files", sub: "Focus file search", run: async () => { if (ui.fileSearch) ui.fileSearch.focus(); } },
      { title: "Activity", sub: "Open activity log", run: async () => openActivityModal() },
    ];

    if (folder) {
      cmds.push({ title: "Rename folder", sub: `Rename /${folder}`, run: async () => doRenameFolder() });
      cmds.push({ title: "Move folder", sub: `Move /${folder}`, run: async () => doMoveFolder() });
      cmds.push({ title: "Delete folder (Trash)", sub: `Move /${folder} to Trash`, run: async () => doDeleteFolderSoft() });
    }
    if (hasSel) {
      cmds.push({ title: "Move selected files…", sub: `Move ${state.selectedFiles.size} file(s)`, run: async () => {
        const dest = prompt("Move selected files to folder (blank for root):", state.selectedFolder || "");
        if (dest == null) return;
        await moveFilesToFolder(Array.from(state.selectedFiles), normalizePath(dest));
        await refreshVault();
      }});
      cmds.push({ title: "Delete selected files (Trash)", sub: `Move ${state.selectedFiles.size} file(s) to Trash`, run: async () => bulkDelete() });
    }
    return cmds;
  }

  function renderPalette(query) {
    const q = (query || "").trim().toLowerCase();
    const cmds = paletteCommands().filter(c => !q || c.title.toLowerCase().includes(q) || c.sub.toLowerCase().includes(q));
    elPaletteList.innerHTML = cmds.map((c, idx) => `
      <div class="vx-palette-item" data-idx="${idx}">
        <div>
          <div style="font-weight:600;">${escapeHtml(c.title)}</div>
          <div class="vx-palette-sub">${escapeHtml(c.sub)}</div>
        </div>
        <div class="vx-kbd">↵</div>
      </div>
    `).join("");

    $$(".vx-palette-item", elPaletteList).forEach((el) => {
      el.addEventListener("click", async () => {
        const idx = Number(el.getAttribute("data-idx"));
        const cmd = cmds[idx];
        closePalette();
        try { await cmd.run(); } catch (e) { console.error(e); toast(e.message || String(e), { ttl: 7000 }); }
      });
    });
  }

  elPaletteBackdrop.addEventListener("click", (e) => {
    if (e.target === elPaletteBackdrop) closePalette();
  });

  elPaletteInput.addEventListener("input", () => renderPalette(elPaletteInput.value));
  elPaletteInput.addEventListener("keydown", async (e) => {
    if (e.key === "Escape") { e.preventDefault(); closePalette(); return; }
    if (e.key === "Enter") {
      e.preventDefault();
      const first = $(".vx-palette-item", elPaletteList);
      if (first) first.click();
    }
  });

  document.addEventListener("keydown", (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
      e.preventDefault();
      openPalette();
    }
    if (e.key === "Escape") {
      closeContextMenu();
      closePalette();
      // Close modals
      closeModal(elAccountModal);
      closeModal(elMoveModal);
      closePreviewModal();
      closeTagsModal();
      closeActivityModal();
    }
  });

  // ============================
  // Preview modal
  // ============================
  const elPreview = (() => {
    const wrap = document.createElement("div");
    wrap.id = "vxPreviewModal";
    wrap.className = "vault-modal";
    wrap.setAttribute("aria-hidden", "true");
    wrap.innerHTML = `
      <div class="modal-card" style="max-width: min(1100px, 94vw);">
        <div class="modal-head">
          <div class="mh">Preview</div>
          <button class="btn btn-secondary" id="vxPreviewClose" type="button">Close</button>
        </div>
        <div class="modal-body">
          <div class="card" style="padding:12px;">
            <iframe id="vxPreviewFrame" style="width:100%; height:70vh; border:0; border-radius:12px; background: rgba(255,255,255,0.03);"></iframe>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(wrap);
    return wrap;
  })();

  const elPreviewClose = $("#vxPreviewClose", elPreview);
  const elPreviewFrame = $("#vxPreviewFrame", elPreview);

  function openPreviewModal(url) {
    elPreviewFrame.src = url;
    openModal(elPreview);
  }
  function closePreviewModal() {
    if (!elPreview) return;
    elPreviewFrame.src = "about:blank";
    closeModal(elPreview);
  }
  if (elPreviewClose) elPreviewClose.addEventListener("click", closePreviewModal);

  // ============================
  // Tags modal
  // ============================
  const elTags = (() => {
    const wrap = document.createElement("div");
    wrap.id = "vxTagsModal";
    wrap.className = "vault-modal";
    wrap.setAttribute("aria-hidden", "true");
    wrap.innerHTML = `
      <div class="modal-card" style="max-width: min(720px, 92vw);">
        <div class="modal-head">
          <div class="mh">Tags</div>
          <button class="btn btn-secondary" id="vxTagsClose" type="button">Close</button>
        </div>
        <div class="modal-body">
          <div class="card" style="padding:14px;">
            <div class="vx-muted" style="margin-bottom:10px;">Comma-separated tags. Stored locally for now.</div>
            <input id="vxTagsInput" class="vx-input" type="text" placeholder="tax, carrier-packet, legal, ...">
            <div style="display:flex; gap:10px; margin-top:12px; justify-content:flex-end;">
              <button class="btn btn-secondary" id="vxTagsCancel" type="button">Cancel</button>
              <button class="btn btn-primary" id="vxTagsSave" type="button">Save</button>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(wrap);
    return wrap;
  })();

  const elTagsClose = $("#vxTagsClose", elTags);
  const elTagsCancel = $("#vxTagsCancel", elTags);
  const elTagsSave = $("#vxTagsSave", elTags);
  const elTagsInput = $("#vxTagsInput", elTags);
  let tagsTargetId = null;

  function openTagsModal(id) {
    tagsTargetId = id;
    elTagsInput.value = getTagsFor(id).join(", ");
    openModal(elTags);
    setTimeout(()=>elTagsInput.focus(), 50);
  }
  function closeTagsModal() {
    tagsTargetId = null;
    closeModal(elTags);
  }
  async function saveTagsModal() {
    if (!tagsTargetId) return;
    const raw = elTagsInput.value || "";
    const tags = raw.split(",").map(t=>t.trim()).filter(Boolean).slice(0, 30);
    setTagsFor(tagsTargetId, tags);
    logActivity("file:tags", `${tagsTargetId} -> ${tags.join(",")}`);
    closeTagsModal();
    renderFileTable();
    toast("Tags saved.", { ttl: 2500 });
  }

  elTagsClose.addEventListener("click", closeTagsModal);
  elTagsCancel.addEventListener("click", closeTagsModal);
  elTagsSave.addEventListener("click", saveTagsModal);

  // ============================
  // Activity modal
  // ============================
  const elActivity = (() => {
    const wrap = document.createElement("div");
    wrap.id = "vxActivityModal";
    wrap.className = "vault-modal";
    wrap.setAttribute("aria-hidden", "true");
    wrap.innerHTML = `
      <div class="modal-card" style="max-width: min(980px, 94vw);">
        <div class="modal-head">
          <div class="mh">Activity</div>
          <button class="btn btn-secondary" id="vxActivityClose" type="button">Close</button>
        </div>
        <div class="modal-body">
          <div class="card" style="padding:14px;">
            <div class="vx-muted" style="margin-bottom:10px;">Recent Vault actions (local for now).</div>
            <div id="vxActivityList" style="max-height:62vh; overflow:auto;"></div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(wrap);
    return wrap;
  })();

  const elActivityClose = $("#vxActivityClose", elActivity);
  const elActivityList = $("#vxActivityList", elActivity);

  function openActivityModal() {
    const a = getActivity();
    const rows = a.map((x) => {
      const dt = new Date(x.ts).toLocaleString();
      return `<div style="padding:10px 0; border-bottom:1px solid rgba(255,255,255,0.08);">
        <div style="display:flex; justify-content:space-between; gap:10px;">
          <div style="font-weight:600;">${escapeHtml(x.action)}</div>
          <div class="vx-muted">${escapeHtml(dt)}</div>
        </div>
        <div class="vx-muted" style="margin-top:4px;">${escapeHtml(x.detail || "")}</div>
      </div>`;
    }).join("") || `<div class="vx-muted">No activity yet.</div>`;
    elActivityList.innerHTML = rows;
    openModal(elActivity);
  }
  function closeActivityModal() {
    closeModal(elActivity);
  }
  elActivityClose.addEventListener("click", closeActivityModal);

  // ============================
  // Wire existing buttons
  // ============================
  if (elAccountBtn) elAccountBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (elLoginStatus) { elLoginStatus.textContent = state.user && state.user.email ? `Signed in as ${state.user.email}` : "Not logged in."; } openModal(elAccountModal); });
  if (elAccountModalClose) elAccountModalClose.addEventListener("click", () => closeModal(elAccountModal));

  if (elLoginSubmit) {
    elLoginSubmit.addEventListener("click", async () => {
      const email = (elLoginEmail?.value || "").trim();
      const password = (elLoginPass?.value || "").trim();
      if (!email || !password) {
        elLoginStatus.textContent = "Email and password required.";
        return;
      }
      elLoginStatus.textContent = "Signing in…";
      try {
        const data = await apiFetch(API.LOGIN, { method:"POST", body: JSON.stringify({ email, password }) });
        const token = data.token || (data.user && data.user.token);
        if (!token) throw new Error("Login succeeded but token missing.");
        setStoredToken(token);
        closeModal(elAccountModal);
        await bootstrapAuth();
    updateContainerButtons();
        await refreshVault();
        toast("Signed in.", { ttl: 2500 });
      } catch (e) {
        console.error(e);
        elLoginStatus.textContent = `Login failed: ${e.message || e}`;
        setAuthDot("bad");
      }
    });
  }


  if (elLogoutBtn) {
    elLogoutBtn.addEventListener("click", async () => {
      setStoredToken(null);
      state.user = null;
      // clear client-side selections (server data will be reloaded on next login)
      state.folders = [];
      state.items = [];
      state.selectedFiles.clear();
      buildFolderSet();
      setSelectedFolder("");
      setAuthedUI(false);
      if (elLoginStatus) elLoginStatus.textContent = "Logged out.";
      toast("Logged out.", { ttl: 2500 });
      // Keep the modal open so the user can login again immediately.
    });
  }


  if (elNewFolderBtn) elNewFolderBtn.addEventListener("click", () => doNewFolder());

  if (elUploadBtn) elUploadBtn.addEventListener("click", () => uploadSelectedFile().catch(()=>{}));

  if (elVaultRefreshBtn) elVaultRefreshBtn.addEventListener("click", () => refreshVault().catch(()=>{}));

  if (elMoveModalClose) elMoveModalClose.addEventListener("click", () => closeModal(elMoveModal));

  if (elBulkDownload) elBulkDownload.addEventListener("click", () => bulkDownload().catch(()=>{}));
  if (elBulkMove) elBulkMove.addEventListener("click", () => {
    const ids = Array.from(state.selectedFiles);
    if (!ids.length) return;
    // Reuse move modal: show "(multiple)" and allow choose destination
    elMoveFileName.textContent = ids.length === 1 ? (state.items.find(x => (x.id||x.key)===ids[0])?.filename || ids[0]) : `${ids.length} files`;
    elMoveModal.style.display = "flex";
    elMoveModal.setAttribute("aria-hidden","false");
    elMoveConfirmBtn.onclick = async () => {
      const dest = elMoveTargetFolder.value || "";
      try { await moveFilesToFolder(ids, dest); state.selectedFiles.clear(); await refreshVault(); }
      finally { elMoveModal.style.display = "none"; elMoveModal.setAttribute("aria-hidden","true"); }
    };
  });
  if (elBulkDelete) elBulkDelete.addEventListener("click", () => bulkDelete().catch(()=>{}));
  if (elBulkRestore) elBulkRestore.addEventListener("click", () => restoreSelectedFromTrash().catch(()=>{}));
  if (elEmptyTrash) elEmptyTrash.addEventListener("click", () => emptyTrash().catch(()=>{}));

  // Encrypted Containers
  if (elContainerCreateBtn) elContainerCreateBtn.addEventListener("click", () => createEncryptedContainer().catch(()=>{}));

  if (elContainerDownloadBtn) elContainerDownloadBtn.addEventListener("click", () => {
    if (!state.containerBuilt) { toast("Create a container first.", { ttl: 3500 }); return; }
    triggerDownload(state.containerBuilt.blob, state.containerBuilt.filename);
  });

  // Offline unlocker download (ZIP) — local-only tool for decrypting .pvr containers without PDFRealm
  if (elOfflineUnlockerBtn) elOfflineUnlockerBtn.addEventListener("click", () => {
    const a = document.createElement("a");
    a.href = "/offline-unlocker.zip";
    a.download = "pdfrealm-offline-unlocker.zip";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  if (elContainerUnlockBtn) elContainerUnlockBtn.addEventListener("click", () => unlockEncryptedContainer().catch(()=>{}));

  if (elContainerExtractBtn) elContainerExtractBtn.addEventListener("click", () => extractUnlockedContainerToVault().catch(()=>{}));

  if (elContainerPreviewTbody) elContainerPreviewTbody.addEventListener("click", (ev) => {
    const btn = ev.target?.closest?.("button[data-act='cdownload']");
    if (!btn) return;
    const tr = btn.closest("tr");
    const idx = tr?.getAttribute("data-cidx");
    if (idx == null) return;
    const i = parseInt(idx, 10);
    const f = state.containerUnlocked?.files?.[i];
    if (!f) return;
    triggerDownload(f.blob, f.name);
  });

  // ============================
  // Secure Send — create real share links (manual copy/paste)
  // ============================

  function secureSendSetStatus(msg, kind) {
    if (!elSendStatus) return;
    const k = kind || "info";
    const color = (k === "error") ? "var(--danger, #ef4444)" : (k === "ok" ? "var(--text)" : "var(--muted)");
    elSendStatus.style.color = color;
    elSendStatus.textContent = msg || "";
  }

  function secureSendClearOutputs() {
    state.lastSecureShareId = null;
    state.lastSecureShareUrl = null;
    state.lastSecureSharePasscode = null;
    if (elSendLinkWrap) elSendLinkWrap.style.display = "none";
    if (elSendPasscodeOutWrap) elSendPasscodeOutWrap.style.display = "none";
    if (elSendLinkOut) elSendLinkOut.value = "";
    if (elSendPasscodeOut) elSendPasscodeOut.value = "";
    if (elSendRevokeBtn) elSendRevokeBtn.disabled = true;
  }

  function secureSendRenderQueue() {
    if (elSendQueueCount) elSendQueueCount.textContent = String((state.sendQueue || []).length);
    if (!elSendQueueList) return;

    const q = (state.sendQueue || []);
    if (!q.length) {
      elSendQueueList.innerHTML = `<div style="color:var(--muted); font-size:0.92rem;">No files queued yet.</div>`;
      return;
    }

    elSendQueueList.innerHTML = q.map((x) => {
      const name = escapeHtml(x.name || x.filename || x.id || "file");
      const id = escapeHtml(x.id || "");
      return `
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.03); border-radius: 12px; padding: 8px 10px;">
          <div style="min-width:0;">
            <div style="font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${name}</div>
            <div style="color:var(--muted); font-size:0.82rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${id}</div>
          </div>
          <button class="btn btn-secondary btn-mini" type="button" data-send-remove="${id}">Remove</button>
        </div>
      `;
    }).join("");

    // bind remove
    Array.from(elSendQueueList.querySelectorAll("button[data-send-remove]")).forEach((btn) => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-send-remove");
        state.sendQueue = (state.sendQueue || []).filter((x) => String(x.id) !== String(id));
        secureSendRenderQueue();
        secureSendSyncButtons();
      });
    });
  }

  function secureSendSyncButtons() {
    const authed = !!state.user;
    const qLen = (state.sendQueue || []).length;
    if (elSendCreateBtn) elSendCreateBtn.disabled = !authed;
    if (elSendClearBtn) elSendClearBtn.disabled = !authed || qLen === 0;
    if (elSendRevokeBtn) elSendRevokeBtn.disabled = !authed || !state.lastSecureShareId;
    if (elSendQueueUseSelectionBtn) elSendQueueUseSelectionBtn.disabled = !authed;
  }

  function secureSendAddIdsToQueue(ids) {
    const uniq = new Set((state.sendQueue || []).map((x) => String(x.id)));
    const folder = normalizePath(state.selectedFolder);
    const idList = (ids || []).map(String).filter(Boolean);

    for (const id of idList) {
      if (uniq.has(id)) continue;
      const it = (state.items || []).find((x) => String(x.id) === id || String(x.key) === id);
      const name = it?.filename || it?.key || id;
      const fp = normalizePath(it?.folderPath || "");
      // keep folder scoped when possible
      if (it && fp !== folder) {
        // still allow, but it means selection came from table view elsewhere; accept it.
      }
      state.sendQueue.push({ id, name });
      uniq.add(id);
    }

    secureSendRenderQueue();
    secureSendSyncButtons();
  }

  function secureSendCurrentFolderOptions() {
    const folder = normalizePath(state.selectedFolder);
    const items = (state.items || []).filter((x) => normalizePath(x.folderPath || "") === folder);
    items.sort((a,b) => String(a.filename||"").localeCompare(String(b.filename||"")));
    return items;
  }

  function secureSendRefreshFromVault() {
    if (!elSendFromVault) return;
    if (!state.user) {
      elSendFromVault.innerHTML = `<option value="">Login to load files…</option>`;
      return;
    }
    const opts = secureSendCurrentFolderOptions();
    const current = elSendFromVault.value || "";
    const html = [`<option value="">Select a file…</option>`].concat(
      opts.map((it) => `<option value="${escapeHtml(String(it.id||it.key))}">${escapeHtml(String(it.filename||it.key||"file"))}</option>`)
    ).join("");
    elSendFromVault.innerHTML = html;

    // restore selection if still present
    if (current && opts.some((it) => String(it.id||it.key) === current)) elSendFromVault.value = current;
  }

  function secureSendExpireToSeconds(val) {
    const v = String(val || "").trim();
    if (v === "15m") return 15 * 60;
    if (v === "1h") return 60 * 60;
    if (v === "24h") return 24 * 60 * 60;
    if (v === "7d") return 7 * 24 * 60 * 60;
    // default 24h
    return 24 * 60 * 60;
  }

  function secureSendPermsToFlags(val) {
    const v = String(val || "view").trim();
    if (v === "full") return { permissions: "full", allowDownload: true, allowPrint: true };
    if (v === "download") return { permissions: "view_only", allowDownload: true, allowPrint: false };
    if (v === "print") return { permissions: "view_only", allowDownload: false, allowPrint: true };
    return { permissions: "view_only", allowDownload: false, allowPrint: false };
  }

  async function secureSendUploadLocalFiles(files) {
    const list = Array.from(files || []);
    if (!list.length) return [];
    secureSendSetStatus(`Uploading ${list.length} file(s) to Vault…`, "info");

    const uploadedIds = [];
    for (const f of list) {
      const fd = new FormData();
      fd.append("file", f);
      fd.append("folderPath", normalizePath(state.selectedFolder) || "");
      const r = await apiFetch(API.VAULT_UPLOAD, { method: "POST", body: fd });
      const id = r?.id || r?.key || null;
      if (id) uploadedIds.push(String(id));
    }

    await refreshVault().catch(()=>{});
    return uploadedIds;
  }

  async function secureSendCreateLink() {
    if (!state.user) return;

    secureSendSetStatus("", "info");
    secureSendClearOutputs();

    // If nothing queued, try to use current table selection as a convenience
    if (!(state.sendQueue || []).length && state.selectedFiles && state.selectedFiles.size) {
      secureSendAddIdsToQueue(Array.from(state.selectedFiles));
    }

    const ids = (state.sendQueue || []).map((x) => x.id).filter(Boolean);
    if (!ids.length) {
      secureSendSetStatus("Must have at least one file queued (select files in the Vault table and click “Add to send”).", "error");
      return;
    }

    const expiresInSec = secureSendExpireToSeconds(elSendExpire?.value);
    const flags = secureSendPermsToFlags(elSendPerms?.value);

    const payload = {
      objectIds: ids,
      recipientEmail: String(elSendTo?.value || "").trim() || null,
      note: String(elSendNote?.value || "").trim() || null,
      expiresIn: expiresInSec,
      permissions: flags.permissions,
      allowDownload: !!flags.allowDownload,
      allowPrint: !!flags.allowPrint,
      requirePasscode: true,
      passcode: String(elSendPasscode?.value || "").trim() || null,
      oneTime: false,
      maxViews: null,
    };

    secureSendSetStatus("Creating secure link…", "info");

    const r = await apiFetch(API.SECURE_SHARES, { method: "POST", body: JSON.stringify(payload) });

    const url = r?.url || r?.shareUrl || r?.share_url || "";
    const pass = r?.passcode || r?.sharePasscode || r?.share_passcode || "";

    state.lastSecureShareId = r?.id || r?.shareId || r?.share_id || null;
    state.lastSecureShareUrl = url || null;
    state.lastSecureSharePasscode = pass || null;

    if (elSendLinkOut) elSendLinkOut.value = url || "";
    if (elSendLinkWrap) elSendLinkWrap.style.display = url ? "block" : "none";

    if (pass && elSendPasscodeOut && elSendPasscodeOutWrap) {
      elSendPasscodeOut.value = pass;
      elSendPasscodeOutWrap.style.display = "block";
    } else if (elSendPasscodeOutWrap) {
      elSendPasscodeOutWrap.style.display = "none";
    }

    if (elSendRevokeBtn) elSendRevokeBtn.disabled = !state.lastSecureShareId;

    secureSendSetStatus("Secure link created.", "ok");
    secureSendSyncButtons();
  }

  async function secureSendRevoke() {
    if (!state.user) return;
    if (!state.lastSecureShareId) {
      secureSendSetStatus("No active link to revoke yet.", "error");
      return;
    }
    if (!confirm("Revoke this secure link? It will stop working immediately.")) return;
    secureSendSetStatus("Revoking…", "info");
    await apiFetch(API.SECURE_SHARE_REVOKE(state.lastSecureShareId), { method: "POST" });
    secureSendSetStatus("Link revoked.", "ok");
    secureSendClearOutputs();
    secureSendSyncButtons();
  }

  async function secureSendAddAction() {
    if (!state.user) return;

    // Add dropdown selection
    const chosen = String(elSendFromVault?.value || "").trim();
    if (chosen) secureSendAddIdsToQueue([chosen]);

    // Add table selection
    if (state.selectedFiles && state.selectedFiles.size) {
      secureSendAddIdsToQueue(Array.from(state.selectedFiles));
    }

    // Upload local files and add their IDs
    const files = elSendLocal?.files;
    if (files && files.length) {
      const upIds = await secureSendUploadLocalFiles(files);
      if (upIds.length) secureSendAddIdsToQueue(upIds);
      if (elSendLocal) elSendLocal.value = ""; // clear chooser
    }

    if (!(state.sendQueue || []).length) {
      secureSendSetStatus("No files added. Select files in the Vault table, pick one from the dropdown, or choose local files.", "error");
    } else {
      secureSendSetStatus(`Queued ${(state.sendQueue || []).length} file(s).`, "ok");
    }
  }

  function secureSendClearQueue() {
    state.sendQueue = [];
    secureSendRenderQueue();
    secureSendClearOutputs();
    secureSendSetStatus("Queue cleared.", "info");
    secureSendSyncButtons();
  }

  async function secureSendUseTableSelection() {
    if (!state.user) return;
    if (state.selectedFiles && state.selectedFiles.size) {
      secureSendAddIdsToQueue(Array.from(state.selectedFiles));
      secureSendSetStatus(`Queued ${(state.sendQueue || []).length} file(s) from table selection.`, "ok");
    } else {
      secureSendSetStatus("No files selected in the Vault table.", "error");
    }
  }

  async function secureSendCopy(text) {
    const t = String(text || "");
    if (!t) return;
    try {
      await navigator.clipboard.writeText(t);
      toast("Copied.", { ttl: 1800 });
    } catch (e) {
      // fallback
      const ta = document.createElement("textarea");
      ta.value = t;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Copied.", { ttl: 1800 });
    }
  }

  // Secure Send bindings
  if (elSendAddBtn) elSendAddBtn.addEventListener("click", () => secureSendAddAction().catch((e)=>{ console.error(e); secureSendSetStatus(e.message||String(e), "error"); }));
  if (elSendClearBtn) elSendClearBtn.addEventListener("click", () => secureSendClearQueue());
  if (elSendCreateBtn) elSendCreateBtn.addEventListener("click", () => secureSendCreateLink().catch((e)=>{ console.error(e); secureSendSetStatus(e.message||String(e), "error"); }));
  if (elSendRevokeBtn) elSendRevokeBtn.addEventListener("click", () => secureSendRevoke().catch((e)=>{ console.error(e); secureSendSetStatus(e.message||String(e), "error"); }));

  if (elSendQueueUseSelectionBtn) elSendQueueUseSelectionBtn.addEventListener("click", () => secureSendUseTableSelection().catch(()=>{}));

  if (elSendCopyLinkBtn) elSendCopyLinkBtn.addEventListener("click", () => secureSendCopy(state.lastSecureShareUrl || elSendLinkOut?.value || ""));
  if (elSendCopyPassBtn) elSendCopyPassBtn.addEventListener("click", () => secureSendCopy(state.lastSecureSharePasscode || elSendPasscodeOut?.value || ""));

  // Update Send buttons on tab changes / auth changes
  secureSendRenderQueue();
  secureSendSyncButtons();

  // Initialize
  (async function init() {
    loadUI();
    bindExistingControls();
    updateFolderLabels();
    await bootstrapAuth();
    if (state.user) {
      await refreshVault();
      bindFileDropzones();
    } else {
      // render placeholder tree
      buildFolderSet();
      bindExistingControls();
    updateFolderLabels();
      renderFolderTree();
      renderFileTable();
    }
    // Ensure folder action buttons reflect selection
    setSelectedFolder(state.selectedFolder || "");

    // Auto-refresh when tab/window regains focus (keeps Vault synced with Office/PDFStudio)
    window.addEventListener("focus", () => { if (state.user) refreshVault().catch(()=>{}); });
    // Cross-tab sync: PDFStudio/Office can broadcast a 'vault changed' ping
    try {
      const bc = new BroadcastChannel("pdfrealm_vault");
      bc.onmessage = () => { if (state.user) refreshVault().catch(()=>{}); };
    } catch (e) {}
    window.addEventListener("storage", (e) => {
      if (e && e.key === "pdfrealm_vault_changed" && state.user) refreshVault().catch(()=>{});
    });
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && state.user) refreshVault().catch(()=>{});
    });
  })();

})();
</script>



<script src="/chat_vault.js"></script>
    <script src="/video_vault.js"></script>


</body>
</html>
