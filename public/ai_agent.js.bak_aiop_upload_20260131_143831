(() => {
  "use strict";

  // PDFRealm AI Operator (public QuickTools)
  // Requested behavior:
  //   - Remove the separate "Plan" tab.
  //   - When user clicks Run: plan first, then execute.

  const state = {
    open: false,
    running: false,
    lastPlan: null,
  };

  function qs(sel, root = document) { return root.querySelector(sel); }

  function el(tag, attrs = {}, children = []) {
    const n = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs || {})) {
      if (k === "class") n.className = v;
      else if (k === "style") n.setAttribute("style", v);
      else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
      else if (v === false || v === null || typeof v === "undefined") {
        // skip
      } else {
        n.setAttribute(k, String(v));
      }
    }
    for (const c of (children || [])) {
      n.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    }
    return n;
  }

  function resolveModalEl(modalOrId) {
  if (!modalOrId) return null;
  if (typeof modalOrId === "string") return document.getElementById(modalOrId);
  return modalOrId;
}

function resolveModalId(modalOrId) {
  if (!modalOrId) return null;
  if (typeof modalOrId === "string") return modalOrId;
  return modalOrId.id || null;
}

function openModalCompat(modalOrId) {
  const id = resolveModalId(modalOrId);
  const modal = resolveModalEl(modalOrId);
  if (!modal) return;
  if (id && typeof window.openModal === "function") {
    try { window.openModal(id); state.open = true; return; } catch (_) {}
  }
  // Fallback: mimic the site's modal behavior as best as possible.
  modal.classList.add("open");
  modal.setAttribute("aria-hidden", "false");
  modal.style.display = modal.style.display || "flex";
  state.open = true;
}

  function closeModalCompat(modalOrId) {
  const id = resolveModalId(modalOrId);
  const modal = resolveModalEl(modalOrId);
  if (!modal) return;
  if (id && typeof window.closeModal === "function") {
    try { window.closeModal(id); state.open = false; return; } catch (_) {}
  }
  modal.classList.remove("open");
  modal.setAttribute("aria-hidden", "true");
  // let CSS decide; but ensure it's not stuck visible
  modal.style.display = "none";
  state.open = false;
}

  function setStatus(txt) {
    const n = qs("#aiOpStatus");
    if (n) n.textContent = txt || "";
  }

  function logLine(msg, kind = "info") {
    const box = qs("#aiOpLog");
    if (!box) return;
    const line = el("div", {
      class: "aiop-line aiop-" + kind,
      style: "padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.06); white-space:pre-wrap; word-break:break-word;"
    }, [String(msg ?? "")]);
    box.prepend(line);
  }

  async function readTextSafe(r) {
    try { return await r.text(); } catch (_) { return ""; }
  }

  async function postJSON(url, payload) {
    const r = await fetch(url, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(payload || {})
    });

    // Try JSON first; fall back to text.
    const ct = (r.headers.get("content-type") || "").toLowerCase();
    let data = null;
    if (ct.includes("application/json")) {
      try { data = await r.json(); } catch (_) { data = null; }
    }
    if (data === null) {
      const t = await readTextSafe(r);
      data = t ? { text: t } : {};
    }
    return { ok: r.ok, status: r.status, data };
  }

  function normalizePlan(resp) {
    if (!resp) return null;
    if (typeof resp === "string") return resp;
    if (resp.plan) return typeof resp.plan === "string" ? resp.plan : JSON.stringify(resp.plan, null, 2);
    if (resp.steps) return Array.isArray(resp.steps) ? resp.steps.map((s, i) => `${i + 1}. ${s}`).join("\n") : JSON.stringify(resp.steps, null, 2);
    if (resp.text) return String(resp.text);
    if (resp.message) return String(resp.message);
    return null;
  }

  function normalizeResult(resp) {
    if (!resp) return null;
    if (typeof resp === "string") return resp;
    for (const k of ["result", "output", "text", "message"]) {
      if (resp[k]) {
        if (typeof resp[k] === "string") return resp[k];
        return JSON.stringify(resp[k], null, 2);
      }
    }
    return JSON.stringify(resp, null, 2);
  }

  async function planThenExecute(userText) {
    const prompt = String(userText || "").trim();
    if (!prompt) {
      alert("Type a command first.");
      return;
    }

    const runBtn = qs("#aiOpRun");
    state.running = true;
    if (runBtn) runBtn.disabled = true;

    try {
      setStatus("Planning...");
      logLine("Planning...", "info");

      // PLAN
      const planResp = await postJSON("/api/ai/plan", {
        input: prompt,
        prompt,
        task: prompt,
        command: prompt
      });

      if (!planResp.ok) {
        const err = planResp.data?.error || planResp.data?.message || planResp.data?.text || ("Plan failed (HTTP " + planResp.status + ")");
        logLine(err, "error");
        setStatus("Plan failed");
        return;
      }

      const planText = normalizePlan(planResp.data) || "(No plan returned)";
      state.lastPlan = planText;
      logLine("PLAN:\n" + planText, "plan");

      // EXECUTE
      setStatus("Running...");
      logLine("Running...", "info");

      // Try the most likely execute endpoints in order.
      const executeEndpoints = [
        "/api/ai/execute",
        "/api/ai/run",
        "/api/ai/act",
        "/api/ai/command"
      ];

      let execOut = null;
      let lastErr = null;

      for (const ep of executeEndpoints) {
        const execResp = await postJSON(ep, {
          input: prompt,
          prompt,
          task: prompt,
          command: prompt,
          plan: planText,
          steps: planText
        });

        if (execResp.status === 404) {
          lastErr = `Endpoint not found: ${ep}`;
          continue;
        }

        if (!execResp.ok) {
          lastErr = execResp.data?.error || execResp.data?.message || execResp.data?.text || ("Run failed (HTTP " + execResp.status + ")");
          // if it wasn't a 404, don't keep tryingâ€”likely real failure
          break;
        }

        // Support either immediate result OR job-style responses.
        const d = execResp.data || {};
        if (d.status_url || d.statusUrl) {
          const statusUrl = d.status_url || d.statusUrl;
          execOut = await pollJob(statusUrl);
        } else if (d.job_id || d.jobId || d.id) {
          const jobId = d.job_id || d.jobId || d.id;
          // common patterns
          execOut = await pollJob(`/api/ai/jobs/${encodeURIComponent(jobId)}`);
        } else {
          execOut = normalizeResult(d);
        }

        if (execOut) break;
      }

      if (!execOut) {
        logLine(lastErr || "Run failed.", "error");
        setStatus("Run failed");
        return;
      }

      logLine("RESULT:\n" + execOut, "result");
      setStatus("Done");
    } catch (e) {
      logLine(String(e?.message || e || "Unknown error"), "error");
      setStatus("Error");
    } finally {
      state.running = false;
      if (runBtn) runBtn.disabled = false;
    }
  }

  async function pollJob(url) {
    // Simple polling loop for job-based backends.
    const maxMs = 45_000;
    const start = Date.now();

    while (Date.now() - start < maxMs) {
      let r;
      try {
        r = await fetch(url, { method: "GET" });
      } catch (e) {
        return "Job poll failed: " + (e?.message || String(e));
      }

      const ct = (r.headers.get("content-type") || "").toLowerCase();
      let data = null;
      if (ct.includes("application/json")) {
        try { data = await r.json(); } catch (_) { data = null; }
      }
      if (data === null) {
        const t = await readTextSafe(r);
        return t || ("Job status HTTP " + r.status);
      }

      const status = String(data.status || data.state || "").toUpperCase();
      if (["DONE", "COMPLETED", "SUCCESS", "SUCCEEDED"].includes(status)) {
        return normalizeResult(data.result || data.output || data) || "(completed)";
      }
      if (["ERROR", "FAILED", "FAILURE"].includes(status)) {
        return "Job failed: " + (data.error || data.message || JSON.stringify(data, null, 2));
      }

      // log occasional heartbeat
      if (Math.random() < 0.25) {
        logLine("Job status: " + (status || "RUNNING") + "...", "info");
      }

      await new Promise(res => setTimeout(res, 900));
    }

    return "Job poll timed out.";
  }

  function ensureUI() {
    if (qs("#aiOperatorModal")) return;

    const modal = el("div", { id: "aiOperatorModal", class: "modal", "aria-hidden": "true", role: "dialog", "aria-modal": "true" }, [
      el("div", { class: "modal-card" }, [
        el("div", { class: "modal-head" }, [
          el("div", { class: "mh" }, ["AI Operator"]),
          el("button", { id: "aiOpClose", class: "btn btn-secondary", type: "button" }, ["Close"])
        ]),
        el("div", { class: "modal-body" }, [
          el("div", { style: "color:var(--muted); font-size:0.95rem; margin-bottom:10px;" }, [
            "Type what you want to do. When you press Run, it will plan and then execute."
          ]),
          el("textarea", {
            id: "aiOpInput",
            rows: "5",
            placeholder: "Example: Extract pages 2-4 and 9 from this PDF, then merge into a new file.",
            style: "width:100%; resize:vertical;"
          }),
          el("div", { class: "modal-row", style: "margin-top:12px; gap:10px; display:flex; align-items:center;" }, [
            el("button", { id: "aiOpRun", class: "btn btn-primary", type: "button" }, ["Run"]),
            el("div", { id: "aiOpStatus", style: "color:var(--muted); font-size:0.9rem;" }, [""])
          ]),
          el("div", { class: "card", style: "margin-top:12px;" }, [
            el("div", { style: "font-weight:600; margin-bottom:8px;" }, ["Output"]),
            el("div", { id: "aiOpLog", style: "max-height:260px; overflow:auto; padding-right:6px;" }, [])
          ])
        ])
      ])
    ]);

    document.body.appendChild(modal);

    // Wire up
    qs("#aiOpClose").addEventListener("click", () => closeModalCompat("aiOperatorModal"));
    modal.addEventListener("click", (e) => {
      if (e.target === modal) closeModalCompat("aiOperatorModal");
    });

    qs("#aiOpRun").addEventListener("click", () => {
      const t = qs("#aiOpInput").value;
      planThenExecute(t);
    });

    // ENTER to run (Ctrl/Cmd+Enter)
    qs("#aiOpInput").addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        qs("#aiOpRun").click();
      }
    });

    // Hide any existing "Plan" tab UI if the older script/markup exists.
    // This is a best-effort cleanup for installs where an old AI Operator UI is already present.
    for (const n of document.querySelectorAll("[data-aiop-tab='plan'], #aiopPlanTab, #aiPlanTab, .aiop-tab-plan")) {
      try { n.remove(); } catch (_) { n.style.display = "none"; }
    }
  }

  function bindNav() {
    // Prefer an explicit header chip.
    // NOTE: index.html historically had #aiOperatorNav, but newer builds use data-ai-nav="1".
    const nav = qs("#aiOperatorNav") || qs("[data-ai-nav='1']");
    if (nav) {
      // Use capture to beat any other click handlers that might navigate.
      nav.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        ensureUI();
        openModalCompat("aiOperatorModal");
      }, true);
      return;
    }

    // Fallback: intercept any link to /?ai=1 (capture phase so navigation can't win)
    document.addEventListener("click", (e) => {
      const a = e.target && e.target.closest ? e.target.closest("a[href*='ai=1'], a[href*='aiOperator']") : null;
      if (!a) return;
      e.preventDefault();
      e.stopPropagation();
      ensureUI();
      openModalCompat("aiOperatorModal");
    }, true);
  }

  function init() {
    bindNav();

    // If user lands directly on /?ai=1, open automatically.
    try {
      const u = new URL(location.href);
      if (u.searchParams.get("ai") === "1") {
        ensureUI();
        openModalCompat("aiOperatorModal");
      }
    } catch (_) {}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
