
// [pdfrealm] GLOBAL_CALL_HELPERS_SHIM
(function(){
  function getTokenSafe(){
    try { if (typeof getAuthToken === "function") return (getAuthToken()||"").trim(); } catch {}
    try {
      const m = document.cookie.match(/(?:^|;\s*)pdfrealm_token=([^;]+)/);
      if (m) return decodeURIComponent(m[1]).trim();
    } catch {}
    try { return (localStorage.getItem("pdfrealm_token")||localStorage.getItem("token")||"").trim(); } catch {}
    return "";
  }

  if (typeof globalThis.callJson !== "function") {
    globalThis.callJson = async function callJson(url, body, opts = {}) {
      const method = opts.method || "POST";
      const headers = new Headers(opts.headers || {});
      const token = getTokenSafe();
      if (token && !headers.has("Authorization")) headers.set("Authorization","Bearer "+token);

      const isForm = (typeof FormData !== "undefined") && body instanceof FormData;
      if (!isForm && body != null && !headers.has("Content-Type")) headers.set("Content-Type","application/json");

      const res = await fetch(url, {
        method,
        headers,
        credentials: "same-origin",
        body: body == null ? undefined : (isForm ? body : (typeof body === "string" ? body : JSON.stringify(body)))
      });
      if (!res.ok) {
        let msg = "HTTP "+res.status;
        try { const t = await res.text(); if (t) msg += ": " + t.slice(0,400); } catch {}
        throw new Error(msg);
      }
      const ct = (res.headers.get("content-type")||"").toLowerCase();
      if (ct.includes("application/json")) return await res.json();
      const text = await res.text();
      try { return JSON.parse(text); } catch { return { ok:true, text }; }
    };
  }

  if (typeof globalThis.callBlob !== "function") {
    globalThis.callBlob = async function callBlob(url, body, opts = {}) {
      const method = opts.method || "POST";
      const headers = new Headers(opts.headers || {});
      const token = getTokenSafe();
      if (token && !headers.has("Authorization")) headers.set("Authorization","Bearer "+token);

      const res = await fetch(url, {
        method,
        headers,
        credentials: "same-origin",
        body: body == null ? undefined : body
      });
      if (!res.ok) {
        let msg = "HTTP "+res.status;
        try { const t = await res.text(); if (t) msg += ": " + t.slice(0,400); } catch {}
        throw new Error(msg);
      }
      return await res.blob();
    };
  }
})();

// public/app.js â€” PDFRealm frontend wiring
// - Preview PDFs locally using object URLs
// - PDF Studio overlay placement via click-layer (not iframe)
// - Pay-per-export ($1.49) when export is blocked (402 PAYWALL)
// - Optional account login/subscription support
// - Secure Vault UI (S3-backed): list/upload/folder/download/delete

const ENDPOINTS = {
  // Auth
  ME: "/api/me",
  LOGIN: "/api/login",

  // Stripe
  PAYWALL_CHECKOUT: "/api/paywall/create-checkout-session",
  BILLING_CHECKOUT: "/api/billing/create-checkout-session",
  PPE_CHECKOUT: "/api/pay-per-export/create-checkout-session",

  // Tools
  PDF_STUDIO: "/api/pdf-studio",
  QUICK_SIGN: "/api/quick-sign",
  ENCRYPT: "/api/encrypt",
  DECRYPT: "/api/decrypt",
  IS_ENCRYPTED: "/api/is-encrypted",
  QPDF_NORMALIZE: "/api/qpdf/normalize",

  INVOICE: "/api/invoice",
  RECEIPT: "/api/receipt",
  PAYSTUB: "/api/paystub",

  // Legacy preview endpoints (kept for compatibility)
  INVOICE_PREVIEW: "/api/invoice/preview",
  RECEIPT_PREVIEW: "/api/receipt/preview",
  PAYSTUB_PREVIEW: "/api/paystub/preview",

  MERGE: "/api/merge",
  DELETE_PAGE: "/api/delete-page",
  DELETE_PAGES: "/api/delete-pages",
  SPLIT: "/api/split",

  COMPRESS: "/api/compress",
  ROTATE: "/api/rotate",
  REORDER: "/api/reorder",
  WATERMARK: "/api/watermark",

  META_REMOVE: "/api/meta/remove",
  META_APPLY: "/api/meta/apply",
  FLATTEN: "/api/flatten",
  REMOVE_BLANK: "/api/remove-blank-pages",

  PAGE_NUMBERS: "/api/page-numbers",
  STAMP: "/api/stamp",
  REDACT: "/api/redact",

  JPG_TO_PDF: "/api/jpg-to-pdf",
  PNG_TO_PDF: "/api/png-to-pdf",
  PDF_TO_JPG: "/api/pdf-to-jpg",
  PDF_TO_PNG: "/api/pdf-to-png",
  WORD_TO_PDF: "/api/word-to-pdf",
  WORD_TO_PDF_PREVIEW: "/api/word-to-pdf/preview",
  WORD_TO_PDF_INPUT_PREVIEW: "/api/word-to-pdf/input-preview",
  PDF_TO_WORD: "/api/pdf-to-word",

  // Extended conversions
  JPG_TO_PNG: "/api/jpg-to-png",
  PNG_TO_JPG: "/api/png-to-jpg",
  PDF_TO_TIFF: "/api/pdf-to-tiff",
  TIFF_TO_PDF: "/api/tiff-to-pdf",
  MULTI_IMAGE_TO_PDF: "/api/multi-image-to-pdf",
  DOCX_TO_PNG: "/api/docx-to-png",
  PDF_TO_SVG: "/api/pdf-to-svg",
  SVG_TO_PDF: "/api/svg-to-pdf",

  OCR: "/api/ocr",
TEMPLATES: "/api/templates",
  TEMPLATE_PREVIEW: "/api/templates/preview",
  TEMPLATE_DOWNLOAD: "/api/templates/download",

  // Secure Vault
  VAULT_S3_TEST: "/api/vault/s3-test",
  VAULT_WHOAMI: "/api/vault/whoami", // optional server route (if present)
  VAULT_LIST: "/api/vault/list",
  VAULT_UPLOAD: "/api/vault/upload",
  VAULT_FOLDER: "/api/vault/folder",
  VAULT_FILE: "/api/vault/file", // GET/DELETE with /:id
};

const STORAGE = {
  token: "pdfrealm_token",
  ppe: "pdfrealm_ppe_sessions_by_tool", // JSON map tool -> session_id
};

// -------------------- Helpers --------------------
function $(id) {
  return document.getElementById(id);
}

function setYear() {
  const y = $("year");
  if (y) y.textContent = String(new Date().getFullYear());
}

function getToken() {
  return localStorage.getItem(STORAGE.token) || "";
}

function setToken(t) {
  if (!t) {
    localStorage.removeItem(STORAGE.token);
    try { document.cookie = "pdfrealm_token=; Max-Age=0; path=/; samesite=lax" + (location.protocol === "https:" ? "; secure" : ""); } catch (_) {}
  } else {
    localStorage.setItem(STORAGE.token, t);
    try { document.cookie = "pdfrealm_token=" + encodeURIComponent(t) + "; path=/; samesite=lax" + (location.protocol === "https:" ? "; secure" : ""); } catch (_) {}
  }
  updateAccountDot();
}

function getPpeMap() {
  try {
    return JSON.parse(localStorage.getItem(STORAGE.ppe) || "{}");
  } catch {
    return {};
  }
}

function setPpeForTool(tool, sessionId) {
  const m = getPpeMap();
  m[tool] = sessionId;
  localStorage.setItem(STORAGE.ppe, JSON.stringify(m));
}

function getPpeForTool(tool) {
  const m = getPpeMap();
  return m[tool] || "";
}

function updateAccountDot() {
  const btn = $("accountLoginBtn");
  if (!btn) return;
  const dot = btn.querySelector(".dot");
  if (!dot) return;
  if (getToken()) dot.classList.add("dot-logged-in");
  else dot.classList.remove("dot-logged-in");
}

function openModal(id) {
  const el = $(id);
  if (!el) return;

  // Many PDFRealm pages (e.g., broker.html) style modals using `.modal.open`.
  // Some newer pages used `.modal.modal-open`. Support BOTH so the UI never appears "dead".
  el.classList.add("open");
  el.classList.add("modal-open");
  el.setAttribute("aria-hidden", "false");
}

function closeModal(id) {
  const el = $(id);
  if (!el) return;
  el.classList.remove("open");
  el.classList.remove("modal-open");
  el.setAttribute("aria-hidden", "true");
}

function setStatus(el, text) {
  if (!el) return;
  el.innerHTML = `<span class="pill">${text}</span>`;
}

function showPlaceholder(placeholderId, show) {
  const el = $(placeholderId);
  if (!el) return;
  el.style.display = show ? "flex" : "none";
}

function setIframeSrc(frameId, src) {
  const fr = $(frameId);
  if (!fr) return;
  let out = src || "";
  // For Merge + Split previews, try to suppress built-in PDF viewer toolbars.
  // (Some browsers may still show minimal UI; this is the best we can do without PDF.js.)
  if (out && (frameId === "mergePreviewFrame" || frameId === "splitPreviewFrame" || frameId === "reorderPreviewFrame" || frameId === "compressPreviewFrame" || frameId === "watermarkPreviewFrame" || frameId === "pageNumsPreviewFrame")) {
    if (!out.includes("#")) out += "#toolbar=0&navpanes=0&scrollbar=0";
  }
  fr.setAttribute("src", out);
}

function makeObjectUrlFromFile(file) {
  return URL.createObjectURL(file);
}


// Detect whether a PDF is likely encrypted (client-side heuristic).
// IMPORTANT: Do not rely on the embedded PDF viewer's password prompt.
// We block preview/export for encrypted PDFs until the user unlocks via our UI.
async function detectEncryptedPdf(file) {
  try {
    if (!file) return false;

    // Fast, reliable scan for the literal /Encrypt token.
    // Some PDFs (incremental updates) may place the trailer far from the end,
    // so we scan a larger tail section and (if needed) chunk-scan the rest.

    const TOKEN_RE = /\/Encrypt\b/i;

    // Prefer ISO-8859-1/Latin1 decoding so we don't lose bytes.
    let dec;
    try {
      dec = new TextDecoder("iso-8859-1");
    } catch {
      try { dec = new TextDecoder("latin1"); } catch { dec = new TextDecoder(); }
    }

    const MB = 1024 * 1024;
    const HEAD = Math.min(1 * MB, file.size);
    const TAIL = Math.min(8 * MB, file.size);

    // Head scan
    {
      const buf = await file.slice(0, HEAD).arrayBuffer();
      const txt = dec.decode(new Uint8Array(buf));
      if (TOKEN_RE.test(txt)) return true;
    }

    // Tail scan (larger than head because trailers + incremental updates usually live near the end)
    {
      const start = Math.max(0, file.size - TAIL);
      const buf = await file.slice(start, file.size).arrayBuffer();
      const txt = dec.decode(new Uint8Array(buf));
      if (TOKEN_RE.test(txt)) return true;
    }

    // Chunk scan the middle only if necessary.
    // This keeps things responsive while still catching odd layouts.
    const middleStart = HEAD;
    const middleEnd = Math.max(middleStart, file.size - TAIL);
    if (middleEnd <= middleStart) return false;

    const CHUNK = 2 * MB;
    const OVERLAP = 128; // bytes

    for (let off = middleStart; off < middleEnd; off += CHUNK) {
      const a = Math.max(0, off - OVERLAP);
      const b = Math.min(file.size, off + CHUNK);
      const buf = await file.slice(a, b).arrayBuffer();
      const txt = dec.decode(new Uint8Array(buf));
      if (TOKEN_RE.test(txt)) return true;
    }

    return false;
  } catch {
    return false;
  }
}

// Reliable encryption detection for previews:
// 1) Fast client-side scan for /Encrypt
// 2) If not found, ask the server (qpdf) for a definitive answer
async function detectEncryptedPdfReliable(file) {
  if (!file) return false;

  const local = await detectEncryptedPdf(file);
  if (local) return true;

  try {
    const fd = new FormData();
    fd.append("file", file);

    const headers = {};
    const token = getToken();
    if (token) headers.Authorization = `Bearer ${token}`;

    const res = await fetch(ENDPOINTS.IS_ENCRYPTED || "/api/is-encrypted", {
      method: "POST",
      body: fd,
      headers,
    });

    if (!res.ok) return false;
    const j = await res.json().catch(() => ({}));
    return !!j.encrypted;
  } catch {
    return false;
  }
}


// Server-side decrypt using /api/decrypt (qpdf). Returns a new File instance.
async function decryptPdfToFile(file, password) {
  if (!file) throw new Error("No file provided.");
  const pw = String(password || "").trim();
  if (!pw) throw new Error("Password required.");

  const fd = new FormData();
  fd.append("file", file);
  fd.append("password", pw);

  const headers = {};
  const token = getToken();
  if (token) headers.Authorization = `Bearer ${token}`;

  const res = await fetch(ENDPOINTS.DECRYPT, { method: "POST", body: fd, headers });
  if (!res.ok) {
    let msg = `Decrypt failed (HTTP ${res.status}).`;
    try {
      const j = await res.json();
      msg = j?.error || msg;
      if (j?.details) msg += `

${j.details}`;
    } catch {}
    throw new Error(msg);
  }

  const blob = await res.blob();
  const origName = file.name || "document.pdf";
  const base = origName.replace(/\.pdf$/i, "");
  const outName = base ? `${base}-decrypted.pdf` : "decrypted.pdf";
  return new File([blob], outName, { type: "application/pdf" });
}

function authHeaders(extra = {}) {
  const h = { ...(extra || {}) };
  const token = getToken();
  if (token) h["Authorization"] = `Bearer ${token}`;
  return h;
}

async function fetchJson(url, opts = {}) {
  const res = await fetch(url, {
    ...opts,
    headers: {
      "Content-Type": "application/json",
      ...(opts.headers || {}),
    },
  });
  const data = await res.json().catch(() => null);
  if (!res.ok) {
    const msg = data?.error || data?.message || `Request failed (${res.status})`;
    const err = new Error(msg);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  return data;
}

async function fetchBlob(url, opts = {}) {
  const res = await fetch(url, opts);
  if (!res.ok) {
    const data = await res.json().catch(() => null);
    const msg = data?.error || data?.message || `Export failed (${res.status})`;
    const err = new Error(msg);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  const blob = await res.blob();
  return blob;
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename || "output.pdf";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 10_000);
  return url;
}

// -------------------- Pay-Per-Export flow --------------------
async function beginPayPerExport(tool) {
  const out = await fetchJson(ENDPOINTS.PPE_CHECKOUT, {
    method: "POST",
    body: JSON.stringify({ tool }),
  });
  if (out?.url) window.location.href = out.url;
  else alert("Could not start checkout.");
}

function capturePpeSuccessFromUrl() {
  const u = new URL(window.location.href);
  const ok = u.searchParams.get("ppe_success") === "1";
  const sessionId = u.searchParams.get("session_id");
  const tool = u.searchParams.get("tool");

  if (ok && sessionId && tool) {
    setPpeForTool(tool, sessionId);

    u.searchParams.delete("ppe_success");
    u.searchParams.delete("session_id");
    u.searchParams.delete("tool");
    u.searchParams.delete("ppe_cancel");
    window.history.replaceState({}, "", u.toString());

    return { tool, sessionId };
  }
  return null;
}

// -------------------- Paid export wrapper --------------------
async function runPaidPdfExport({
  tool,
  endpoint,
  formData,
  filename,
  setPreviewFrameId,
  placeholderId,
}) {
  const token = getToken();
  const ppeSession = getPpeForTool(tool);

  const headers = {};
  if (token) headers["Authorization"] = `Bearer ${token}`;
  if (ppeSession) headers["x-ppe-session"] = ppeSession;

  try {
    const res = await fetch(endpoint, { method: "POST", headers, body: formData });

    if (!res.ok) {
      let data = null;
      try {
        data = await res.json();
      } catch {}
      const err = new Error(
        data?.error || data?.message || `Export failed (${res.status})`
      );
      err.status = res.status;
      err.data = data;
      throw err;
    }

    const blob = await res.blob();

    // If filename is provided, download; otherwise this is a preview-only run (no download).
    const objectUrl = filename ? downloadBlob(blob, filename) : URL.createObjectURL(blob);

    if (setPreviewFrameId) setIframeSrc(setPreviewFrameId, objectUrl);
    if (placeholderId) showPlaceholder(placeholderId, false);

    return { ok: true, blob, objectUrl };
  } catch (e) {
    if (e.status === 402) {
      const payData = e.data || {};
      const wantsPpe = confirm(
        "Payment required to export.\n\nOK = Pay $1.49 for this export (no account)\nCancel = Open Account modal (subscribe/login)"
      );

      if (wantsPpe) {
        if (payData.checkoutUrl) {
          window.location.href = payData.checkoutUrl;
        } else {
          alert("Payment required, but no checkout URL was provided by the server.");
        }
        return { ok: false, blocked: true };
      } else {
        openModal("accountModal");
        return { ok: false, blocked: true };
      }
    }

    if (e.status === 401) {
      openModal("accountModal");
      return { ok: false, blocked: true };
    }

    alert(e.message || "Export failed");
    return { ok: false, blocked: false };
  }
}

// -------------------- Tabs --------------------

function initTabs() {
  const tabs = Array.from(document.querySelectorAll(".tool-tab"));
  const views = Array.from(document.querySelectorAll(".tool-view"));

  function activate(tool) {
    tabs.forEach((t) => {
      const is = t.getAttribute("data-tool") === tool;
      t.classList.toggle("tool-tab-active", is);
      t.setAttribute("aria-selected", is ? "true" : "false");
    });
    views.forEach((v) => {
      const is = v.getAttribute("data-tool-view") === tool;
      v.classList.toggle("tool-view-active", is);
      v.style.display = is ? "block" : "none";
    });
  }

  // Expose for capability gating (used after we fetch /api/capabilities)
  window.__pdfrealmActivateTool = activate;

  tabs.forEach((t) => {
    t.addEventListener("click", () => {
      if (t.disabled || t.getAttribute("aria-disabled") === "true") return;
      activate(t.getAttribute("data-tool"));
    });
  });

  let initial = document.querySelector(".tool-tab.tool-tab-active");
  if (!initial || initial.disabled || initial.getAttribute("aria-disabled") === "true") {
    initial = tabs.find((x) => !x.disabled && x.getAttribute("aria-disabled") !== "true") || null;
  }
  if (initial) activate(initial.getAttribute("data-tool"));
}

// -------------------- Account modal --------------------

function initAccount() {
  const openBtn = $("accountLoginBtn");
  const closeBtn = $("accountModalClose");

  if (openBtn) openBtn.addEventListener("click", () => openModal("accountModal"));
  if (closeBtn) closeBtn.addEventListener("click", () => closeModal("accountModal"));

  const loginBtn = $("loginSubmitBtn");
  const status = $("loginStatus");

  if (loginBtn) {
    loginBtn.addEventListener("click", async () => {
      try {
        if (status) status.textContent = "Logging in...";
        const email = $("loginEmail")?.value || "";
        const password = $("loginPassword")?.value || "";
        const out = await fetchJson(ENDPOINTS.LOGIN, {
          method: "POST",
          body: JSON.stringify({ email, password }),
        });
        setToken(out.token || "");
        if (status) status.textContent = out.token ? "Logged in." : "Login returned no token.";
        // If Vault tab exists, refresh it after login
        try { await refreshVaultList(); } catch {}
      } catch (e) {
        if (status) status.textContent = e.message || "Login failed.";
      }
    });
  }

  const subM = $("subscribeMonthlyBtn");
  const subY = $("subscribeYearlyBtn");

  async function goCheckout(kind) {
    try {
      const out = await fetchJson(ENDPOINTS.PAYWALL_CHECKOUT, {
        method: "POST",
        body: JSON.stringify({ plan: kind }),
      });
      if (out?.url) window.location.href = out.url;
      else alert("Checkout not configured on server.");
    } catch (e) {
      alert(e.message || "Checkout failed.");
    }
  }

  if (subM) subM.addEventListener("click", () => goCheckout("monthly"));
  if (subY) subY.addEventListener("click", () => goCheckout("yearly"));
}

// -------------------- Preview wiring (PDF inputs) --------------------
function wireLocalPdfPreview(fileInputId, iframeId, placeholderId) {
  const inp = $(fileInputId);
  if (!inp) return;
  inp.addEventListener("change", () => {
    const f = inp.files && inp.files[0];
    if (!f) return;
    const url = makeObjectUrlFromFile(f);
    setIframeSrc(iframeId, url);
    showPlaceholder(placeholderId, false);
  });
}

function wireLocalImagePreview(fileInputId, imgId, placeholderId) {
  const inp = $(fileInputId);
  const img = $(imgId);
  if (!inp || !img) return;

  inp.addEventListener("change", () => {
    const f = inp.files && inp.files[0];
    if (!f) return;
    const url = makeObjectUrlFromFile(f);
    img.src = url;
    img.style.display = "block";
    if (placeholderId) showPlaceholder(placeholderId, false);
  });
}

// -------------------- PDF Studio overlays --------------------
function initStudio() {
  const fileInput = $("studioFile");
  // If the legacy overlay studio UI is not present (we embed full PDF Studio), skip.
  if (!fileInput) return;
  const frameId = "studioFrame";
  const placeholderId = "studioPlaceholder";
  const wrapper = $("studioViewerWrapper");
  const clickLayer = $("studioClickLayer");

  const sigOverlay = $("studioSignatureOverlay");
  const noteOverlay = $("studioNoteOverlay");
  const sigTextEl = $("studioSignatureText");
  const noteTextEl = $("studioNoteText");

  const sigName = $("studioSignatureName");
  const noteText = $("studioNoteText");

  let placing = null;

  if (fileInput) {
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      const url = makeObjectUrlFromFile(f);
      setIframeSrc(frameId, url);
      showPlaceholder(placeholderId, false);
    });
  }

  function enableClickLayer(on) {
    if (!clickLayer) return;
    clickLayer.classList.toggle("inactive", !on);
  }

  function setOverlayPosition(overlay, x, y) {
    if (!overlay) return;
    overlay.style.left = `${x}px`;
    overlay.style.top = `${y}px`;
    overlay.style.display = "inline-flex";
  }

  if (wrapper && clickLayer) {
    clickLayer.addEventListener("click", (e) => {
      if (!placing) return;
      const rect = wrapper.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (placing === "sig") setOverlayPosition(sigOverlay, x, y);
      if (placing === "note") setOverlayPosition(noteOverlay, x, y);

      placing = null;
      enableClickLayer(false);
    });
  }

  function getOverlayNormalized(overlay) {
    if (!overlay || overlay.style.display === "none") return null;
    const rect = wrapper.getBoundingClientRect();
    const left = parseFloat(overlay.style.left || "0");
    const top = parseFloat(overlay.style.top || "0");
    const nx = left / rect.width;
    const ny = top / rect.height;
    return { x: clamp01(nx), y: clamp01(ny) };
  }

  function makeDraggable(overlay) {
    if (!overlay || !wrapper) return;
    let dragging = false;

    overlay.addEventListener("pointerdown", (e) => {
      dragging = true;
      overlay.setPointerCapture(e.pointerId);
      overlay.style.cursor = "grabbing";
      e.preventDefault();
    });

    overlay.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const rect = wrapper.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      setOverlayPosition(overlay, x, y);
    });

    overlay.addEventListener("pointerup", () => {
      dragging = false;
      overlay.style.cursor = "grab";
    });

    overlay.addEventListener("pointercancel", () => {
      dragging = false;
      overlay.style.cursor = "grab";
    });
  }

  makeDraggable(sigOverlay);
  makeDraggable(noteOverlay);

  const placeSigBtn = $("studioAddSignatureBtn");
  const placeNoteBtn = $("studioAddTextBtn");
  const exportBtn = $("studioExportBtn");

  if (placeSigBtn) {
    placeSigBtn.addEventListener("click", () => {
      placing = "sig";
      enableClickLayer(true);
    });
  }
  if (placeNoteBtn) {
    placeNoteBtn.addEventListener("click", () => {
      placing = "note";
      enableClickLayer(true);
    });
  }

  if (exportBtn) {
    exportBtn.addEventListener("click", async () => {
      const f = fileInput?.files?.[0];
      if (!f) return alert("Upload a PDF first.");

      const sigVal = (sigName?.value || "").trim();
      const noteVal = (noteText?.value || "").trim();
      if (sigTextEl) sigTextEl.textContent = sigVal || "Signature";
      if (noteTextEl) noteTextEl.textContent = noteVal || "Note";

      const sigPos = getOverlayNormalized(sigOverlay) || { x: 0.08, y: 0.12 };
      const notePos = getOverlayNormalized(noteOverlay) || { x: 0.08, y: 0.22 };

      const fd = new FormData();
      fd.append("file", f);
      fd.append("signatureText", sigVal);
      fd.append("noteText", noteVal);
      fd.append("sigX", String(sigPos.x));
      fd.append("sigY", String(sigPos.y));
      fd.append("noteX", String(notePos.x));
      fd.append("noteY", String(notePos.y));

      await runPaidPdfExport({
        tool: "pdf-studio",
        endpoint: ENDPOINTS.PDF_STUDIO,
        formData: fd,
        filename: "pdfrealm-studio.pdf",
        setPreviewFrameId: frameId,
        placeholderId,
      });
    });
  }
}

// -------------------- Quick Sign --------------------
// -------------------- Quick Sign --------------------

// -------------------- Quick Sign --------------------
// -------------------- Quick Sign --------------------
function initQuickSign() {
  const fileInput = $("qsFile");
  const passInput = $("qsPassword");
  const unlockBtn = $("qsUnlockBtn");
  const status = $("qsStatus");

  const placeholder = $("qsQuickPlaceholder");
  const wrapper = $("qsViewerWrapper");
  const shell = $("qsCanvasShell");
  const pdfCanvas = $("qsPdfCanvas");
  const overlayCanvas = $("qsSigCanvas");
  const hint = $("qsPreviewHint");

  // Signature source controls
  const modeDrawBtn = $("qsSigModeDraw");
  const modeUploadBtn = $("qsSigModeUpload");
  const modeGenerateBtn = $("qsSigModeGenerate");
  const drawPanel = $("qsSigDrawPanel");
  const uploadPanel = $("qsSigUploadPanel");
  const genPanel = $("qsSigGeneratePanel");

  const sigPad = $("qsSigPad");
  const sigClearBtn = $("qsSigClearBtn");
  const sigPenSize = $("qsSigPenSize");

  const sigUpload = $("qsSigUpload");
  const sigGenName = $("qsSigGenName");
  const sigGenBtn = $("qsSigGenerateBtn");

  const sigScaleRange = $("qsSigScale");

  // Initials
  const initEnable = $("qsInitEnable");
  const initText = $("qsInitText");
  const initCreateBtn = $("qsInitCreateBtn");
  const initScaleRange = $("qsInitScale");

  // Active item + locking
  const activeSigBtn = $("qsActiveSigBtn");
  const activeInitBtn = $("qsActiveInitBtn");
  const lockSigBtn = $("qsLockSigBtn");
  const lockInitBtn = $("qsLockInitBtn");
  const lockNextBtn = $("qsLockNextBtn");
  const addSigBtn = $("qsAddSigBtn");
  const addInitBtn = $("qsAddInitBtn");

  // Page nav + actions
  const prevPageBtn = $("qsPrevPageBtn");
  const nextPageBtn = $("qsNextPageBtn");
  const pageLabel = $("qsPageLabel");
  const exportBtn = $("qsApplyBtn");

  if (!fileInput || !pdfCanvas || !overlayCanvas || !exportBtn) return;

  // --- PDF.js bootstrap (dynamic import; avoids CDN 404/mime issues) ---
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // ---- State ----
  let pdfJs = null;
  let pdfDoc = null;
  let pageNum = 1;
  let pageCount = 1;
  let viewportCss = { w: 0, h: 0, scale: 1 };

  let srcFile = null;        // original file
  let unlockedFile = null;   // decrypted file (if needed)
  let enc = null;            // null=pending, true/false

  let sigDataUrl = null;
  const sigImg = new Image();
  let sigReady = false;

  let initDataUrl = null;
  const initImg = new Image();
  let initReady = false;

  // placements per page (normalized coords + scale pct)
  // { '1': [ {id,x,y,scale,locked}, ... ] }
  const sigByPage = {};
  const initByPage = {};

  let activeItem = 'sig';
  let selected = { type: 'sig', id: null };

  // interaction
  let isDrag = false;
  let isResize = false;
  let dragOff = { x: 0, y: 0 };
  let start = { x: 0, y: 0, w: 0, scale: 0 };
  let dragTarget = { type: 'sig', id: null };

  // draw cache
  let sigBoxes = []; // [{id, rect:{x,y,w,h}, locked, pl}]
  let initBoxes = [];

  // Auto-placement: drop newly created/uploaded items ~2 inches from top so users see them immediately.
  const AUTO_TOP_INCHES = 2;
  const CSS_PX_PER_INCH = 96;
  let pendingAutoPlaceSig = false;
  let pendingAutoPlaceInit = false;

  let uidSeq = 0;
  const uid = (p) => `${p}_${Date.now().toString(36)}_${(++uidSeq).toString(36)}`;

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function pageKey(pn) { return String(parseInt(String(pn || 1), 10) || 1); }

  function setHint(msg, show = true) {
    if (!hint) return;
    hint.textContent = msg || '';
    hint.style.display = show && msg ? 'block' : 'none';
  }

  function showEmpty(msg) {
    if (shell) shell.style.display = 'none';
    if (placeholder) {
      placeholder.textContent = msg || 'Upload a PDF to preview it here.';
      placeholder.style.display = 'flex';
    }
  }

  function showCanvas() {
    if (placeholder) placeholder.style.display = 'none';
    if (shell) shell.style.display = 'block';
  }

  function setActiveItem(item) {
    activeItem = item === 'init' ? 'init' : 'sig';
    selected.type = activeItem;

    [activeSigBtn, activeInitBtn].forEach((b) => b && b.classList.remove('active'));
    if (activeItem === 'sig') activeSigBtn && activeSigBtn.classList.add('active');
    if (activeItem === 'init') activeInitBtn && activeInitBtn.classList.add('active');

    drawOverlay();
    updateLockButtons();
  }

  function initEnabled() {
    return !!(initEnable && initEnable.checked);
  }

  function getSigScalePct() {
    const v = parseFloat(sigScaleRange?.value || '20');
    return isFinite(v) ? v : 20;
  }

  function getInitScalePct() {
    const v = parseFloat(initScaleRange?.value || '10');
    return isFinite(v) ? v : 10;
  }

  function autoTopYNorm() {
    const yPx = AUTO_TOP_INCHES * CSS_PX_PER_INCH;
    if (viewportCss && viewportCss.h) return clamp(yPx / viewportCss.h, 0.01, 0.90);
    return 0.15;
  }

  function scrollPreviewToYNorm(yNorm) {
    if (!wrapper || !viewportCss || !viewportCss.h) return;
    const y = yNorm * viewportCss.h;
    const target = Math.max(0, y - 80);
    try { wrapper.scrollTop = target; } catch (_) {}
  }

  function listFor(type, pn, create = false) {
    const key = pageKey(pn);
    const store = type === 'init' ? initByPage : sigByPage;
    let v = store[key];
    if (!v && create) {
      store[key] = [];
      v = store[key];
    }
    if (!v) return [];
    if (Array.isArray(v)) return v;
    // defensive: if something ever wrote a single object here, normalize to array
    store[key] = [v];
    return store[key];
  }

  function getSelectedPlacement(type, pn) {
    const list = listFor(type, pn, false);
    const id = type === 'sig' ? (selected.type === 'sig' ? selected.id : null) : (selected.type === 'init' ? selected.id : null);
    if (id) {
      const found = list.find((p) => p && p.id === id);
      if (found) return found;
    }
    // fallback: last
    if (list.length) return list[list.length - 1];
    return null;
  }

  function selectPlacement(type, id) {
    selected = { type, id };
    setActiveItem(type);
  }

  function createPlacement(type, pn, xNorm, yNorm, scalePct) {
    const list = listFor(type, pn, true);
    const pl = {
      id: uid(type),
      x: clamp(xNorm, 0, 1),
      y: clamp(yNorm, 0, 1),
      scale: clamp(scalePct, type === 'sig' ? 8 : 0.5, type === 'sig' ? 50 : 25),
      locked: false,
    };
    list.push(pl);
    selectPlacement(type, pl.id);
    return pl;
  }

  function ensureAtLeastOnePlacement(type) {
    const list = listFor(type, pageNum, true);
    if (list.length) {
      if (!selected.id || !getSelectedPlacement(type, pageNum)) {
        selectPlacement(type, list[list.length - 1].id);
      }
      return list[list.length - 1];
    }
    // create default
    const y = autoTopYNorm();
    const x = type === 'init' ? 0.72 : 0.12;
    const scale = type === 'init' ? getInitScalePct() : getSigScalePct();
    return createPlacement(type, pageNum, x, y, scale);
  }

  function setMode(mode) {
    [modeDrawBtn, modeUploadBtn, modeGenerateBtn].forEach((b) => b && b.classList.remove('active'));
    if (mode === 'draw') modeDrawBtn && modeDrawBtn.classList.add('active');
    if (mode === 'upload') modeUploadBtn && modeUploadBtn.classList.add('active');
    if (mode === 'generate') modeGenerateBtn && modeGenerateBtn.classList.add('active');

    if (drawPanel) drawPanel.style.display = mode === 'draw' ? 'block' : 'none';
    if (uploadPanel) uploadPanel.style.display = mode === 'upload' ? 'block' : 'none';
    if (genPanel) genPanel.style.display = mode === 'generate' ? 'block' : 'none';
  }

  async function loadPdfFromFile(file) {
    pdfJs = pdfJs || await getPdfJsAsync();
    if (!pdfJs) throw new Error('PDF renderer failed to load.');

    const ab = await file.arrayBuffer();
    const task = pdfJs.getDocument({ data: ab });
    const doc = await task.promise;
    return doc;
  }

  function updatePageLabel() {
    if (!pageLabel) return;
    pageLabel.textContent = `Page ${pageNum} / ${pageCount}`;
  }

  async function renderPage() {
    if (!pdfDoc || !shell) return;
    const page = await pdfDoc.getPage(pageNum);

    const pad = 24;
    const availableW = Math.max(300, (wrapper?.clientWidth || shell.clientWidth || 800) - pad);
    const v0 = page.getViewport({ scale: 1 });
    const scale = availableW / v0.width;
    const viewport = page.getViewport({ scale });
    viewportCss = { w: viewport.width, h: viewport.height, scale };

    const dpr = window.devicePixelRatio || 1;

    pdfCanvas.width = Math.floor(viewport.width * dpr);
    pdfCanvas.height = Math.floor(viewport.height * dpr);
    pdfCanvas.style.width = viewport.width + 'px';
    pdfCanvas.style.height = viewport.height + 'px';

    const ctx = pdfCanvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, viewport.width, viewport.height);

    await page.render({ canvasContext: ctx, viewport }).promise;

    overlayCanvas.width = pdfCanvas.width;
    overlayCanvas.height = pdfCanvas.height;
    overlayCanvas.style.width = pdfCanvas.style.width;
    overlayCanvas.style.height = pdfCanvas.style.height;

    showCanvas();
    updatePageLabel();

    // If assets were created/uploaded before the page was ready, drop them now.
    if (pendingAutoPlaceSig && sigReady) {
      pendingAutoPlaceSig = false;
      ensureAtLeastOnePlacement('sig');
      const pl = getSelectedPlacement('sig', pageNum);
      if (pl) scrollPreviewToYNorm(pl.y);
    }
    if (pendingAutoPlaceInit && initReady && initEnabled()) {
      pendingAutoPlaceInit = false;
      ensureAtLeastOnePlacement('init');
      const pl = getSelectedPlacement('init', pageNum);
      if (pl) scrollPreviewToYNorm(pl.y);
    }

    drawOverlay();
    updateLockButtons();
  }

  function rectHitTest(pt, rect) {
    const x = pt.x, y = pt.y;
    const inside = x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
    const handleBase = 16;
    const hs = Math.max(8, Math.min(handleBase, Math.min(rect.w, rect.h) * 0.25));
    const hx = rect.x + rect.w - hs;
    const hy = rect.y + rect.h - hs;
    const onHandle = x >= hx && x <= hx + hs && y >= hy && y <= hy + hs;
    return { inside, onHandle, hs };
  }

  function cssPointFromEvent(ev) {
    const r = overlayCanvas.getBoundingClientRect();
    return { x: ev.clientX - r.left, y: ev.clientY - r.top, r };
  }

  function drawOne(ctx, img, pl, type, active) {
    const w = viewportCss.w;
    const h = viewportCss.h;
    const scalePct = type === 'sig' ? pl.scale : pl.scale;

    const boxW = w * (scalePct / 100);
    const aspect = img.naturalHeight / img.naturalWidth;
    const boxH = boxW * aspect;

    let x = pl.x * w;
    let y = pl.y * h;

    x = clamp(x, 0, Math.max(0, w - boxW));
    y = clamp(y, 0, Math.max(0, h - boxH));

    pl.x = w ? x / w : 0;
    pl.y = h ? y / h : 0;

    ctx.drawImage(img, x, y, boxW, boxH);

    // Outline + handle
    ctx.save();
    ctx.lineWidth = active ? 2.5 : 2;
    ctx.strokeStyle = active ? 'rgba(255,255,255,0.90)' : 'rgba(255,255,255,0.55)';
    if (!pl.locked) ctx.setLineDash([6, 4]);
    ctx.strokeRect(x, y, boxW, boxH);
    ctx.setLineDash([]);

    if (!pl.locked) {
      const hs = Math.max(8, Math.min(16, Math.min(boxW, boxH) * 0.25));
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.fillRect(x + boxW - hs, y + boxH - hs, hs, hs);
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText('Locked', x + 6, y + 14);
    }

    ctx.restore();

    return { x, y, w: boxW, h: boxH };
  }

  function drawOverlay() {
    const dpr = window.devicePixelRatio || 1;
    const w = viewportCss.w;
    const h = viewportCss.h;

    const ctx = overlayCanvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, w, h);

    sigBoxes = [];
    initBoxes = [];

    if (!pdfDoc) {
      setHint('Upload a PDF to preview and sign.', true);
      return;
    }

    const sigVisible = sigReady && sigImg.naturalWidth;
    const initVisible = initEnabled() && initReady && initImg.naturalWidth;

    if (!sigVisible && !initVisible) {
      if (!sigReady) setHint('Tip: Generate, draw, or upload a signature, then place it on the PDF.', true);
      else if (initEnabled() && !initReady) setHint('Tip: Create initials (optional), then place them on the PDF.', true);
      else setHint('', false);
      return;
    }

    // Ensure selection is sensible per page
    if (sigVisible && !getSelectedPlacement('sig', pageNum) && !listFor('sig', pageNum, false).length) {
      // no placement yet; don't auto-create unless user just created/uploaded
    }

    // Draw signatures first
    if (sigVisible) {
      const list = listFor('sig', pageNum, false);
      for (const pl of list) {
        if (!pl) continue;
        const isActive = (selected.type === 'sig' && selected.id === pl.id);
        const rect = drawOne(ctx, sigImg, pl, 'sig', isActive);
        sigBoxes.push({ id: pl.id, rect, locked: !!pl.locked, pl });
      }
    }

    // Draw initials on top
    if (initVisible) {
      const list = listFor('init', pageNum, false);
      for (const pl of list) {
        if (!pl) continue;
        const isActive = (selected.type === 'init' && selected.id === pl.id);
        const rect = drawOne(ctx, initImg, pl, 'init', isActive);
        initBoxes.push({ id: pl.id, rect, locked: !!pl.locked, pl });
      }
    }

    // hint
    const selPl = getSelectedPlacement(selected.type, pageNum);
    if (selPl && selPl.locked) {
      setHint('This item is locked. Click Unlock to move it, or click elsewhere to place another.', true);
    } else {
      setHint('Drag to move. Drag the corner handle to resize. Click elsewhere to place another when locked.', true);
    }
  }

  function hitTestAll(pt) {
    // check handles first, top layer first (initials drawn on top)
    const scan = (boxes) => {
      for (let i = boxes.length - 1; i >= 0; i--) {
        const b = boxes[i];
        const hit = rectHitTest(pt, b.rect);
        if (hit.onHandle) return { box: b, hit, onHandle: true, inside: true };
      }
      for (let i = boxes.length - 1; i >= 0; i--) {
        const b = boxes[i];
        const hit = rectHitTest(pt, b.rect);
        if (hit.inside) return { box: b, hit, onHandle: false, inside: true };
      }
      return null;
    };

    return scan(initBoxes) || scan(sigBoxes);
  }

  function movePlacementCentered(pl, type, pt) {
    const w = viewportCss.w;
    const h = viewportCss.h;
    const img = type === 'sig' ? sigImg : initImg;
    const scalePct = pl.scale;

    const boxW = w * (scalePct / 100);
    const aspect = img.naturalHeight / img.naturalWidth;
    const boxH = boxW * aspect;

    const nx = clamp((pt.x - boxW * 0.5) / w, 0, 1);
    const ny = clamp((pt.y - boxH * 0.5) / h, 0, 1);

    pl.x = nx;
    pl.y = ny;
  }

  // --- Overlay interaction (drag/resize + multi-placement) ---
  overlayCanvas.addEventListener('pointerdown', (ev) => {
    if (!pdfDoc) return;

    const pt = cssPointFromEvent(ev);

    // empty click: move selected if unlocked; if locked/no selection -> create a new placement at click
    const hitAny = hitTestAll(pt);
    if (!hitAny) {
      let type = activeItem;
      if (type === 'init' && !(initEnabled() && initReady)) type = 'sig';

      const ready = type === 'sig' ? sigReady : (initEnabled() && initReady);
      if (!ready) return;

      let sel = getSelectedPlacement(type, pageNum);
      if (!sel) {
        // create new
        const scale = type === 'sig' ? getSigScalePct() : getInitScalePct();
        sel = createPlacement(type, pageNum, 0.12, autoTopYNorm(), scale);
      }

      if (sel.locked) {
        // create another placement centered at click
        const scale = type === 'sig' ? getSigScalePct() : getInitScalePct();
        sel = createPlacement(type, pageNum, 0.12, autoTopYNorm(), scale);
        movePlacementCentered(sel, type, pt);
      } else {
        movePlacementCentered(sel, type, pt);
      }

      selectPlacement(type, sel.id);
      scrollPreviewToYNorm(sel.y);
      drawOverlay();
      updateLockButtons();
      return;
    }

    const { box, hit, onHandle } = hitAny;
    const type = initBoxes.some((b) => b.id === box.id) ? 'init' : 'sig';

    selectPlacement(type, box.id);

    const pl = box.pl;
    if (!pl || pl.locked) return;

    ev.preventDefault();
    overlayCanvas.setPointerCapture(ev.pointerId);

    dragTarget = { type, id: box.id };

    if (onHandle) {
      isResize = true;
      start = { x: pt.x, y: pt.y, w: box.rect.w, scale: pl.scale };
    } else {
      isDrag = true;
      dragOff = { x: pt.x - box.rect.x, y: pt.y - box.rect.y };
    }
  });

  overlayCanvas.addEventListener('pointermove', (ev) => {
    if (!isDrag && !isResize) return;
    if (!pdfDoc) return;

    ev.preventDefault();
    const pt = cssPointFromEvent(ev);

    const type = dragTarget.type;
    const sel = getSelectedPlacement(type, pageNum);
    if (!sel || sel.id !== dragTarget.id) return;
    if (sel.locked) return;

    const w = viewportCss.w;
    const h = viewportCss.h;

    // find current rect
    const boxes = type === 'sig' ? sigBoxes : initBoxes;
    const box = boxes.find((b) => b.id === sel.id);
    if (!box) return;

    if (isDrag) {
      const boxW = box.rect.w;
      const boxH = box.rect.h;
      const x = clamp(pt.x - dragOff.x, 0, Math.max(0, w - boxW));
      const y = clamp(pt.y - dragOff.y, 0, Math.max(0, h - boxH));
      sel.x = w ? x / w : 0;
      sel.y = h ? y / h : 0;
      drawOverlay();
      return;
    }

    if (isResize) {
      const dx = pt.x - start.x;
      const minPct = type === 'sig' ? 8 : 0.5;
      const maxPct = type === 'sig' ? 50 : 25;
      const minW = w * (minPct / 100);
      const maxW = w * (maxPct / 100);
      const newW = clamp(start.w + dx, minW, maxW);
      const newScale = clamp((newW / w) * 100, minPct, maxPct);
      sel.scale = newScale;
      if (type === 'sig' && sigScaleRange) sigScaleRange.value = String(Math.round(newScale));
      if (type === 'init' && initScaleRange) initScaleRange.value = String(newScale.toFixed(1));
      drawOverlay();
    }
  });

  function endPointer() {
    isDrag = false;
    isResize = false;
    dragTarget = { type: activeItem, id: null };
  }

  overlayCanvas.addEventListener('pointerup', (ev) => { ev.preventDefault(); endPointer(); });
  overlayCanvas.addEventListener('pointercancel', (ev) => { ev.preventDefault(); endPointer(); });

  function updateLockButtons() {
    const initOn = initEnabled();

    // signature lock
    const s = getSelectedPlacement('sig', pageNum);
    if (lockSigBtn) {
      lockSigBtn.disabled = !sigReady;
      lockSigBtn.textContent = (s && s.locked) ? 'Unlock Signature' : 'Lock Signature';
    }

    // initials lock
    const i = getSelectedPlacement('init', pageNum);
    if (lockInitBtn) {
      lockInitBtn.disabled = !(initOn && initReady);
      lockInitBtn.textContent = (i && i.locked) ? 'Unlock Initials' : 'Lock Initials';
    }

    if (activeInitBtn) activeInitBtn.disabled = !(initOn && initReady);

    // add buttons
    if (addSigBtn) addSigBtn.disabled = !sigReady;
    if (addInitBtn) addInitBtn.disabled = !(initOn && initReady);
  }

  // --- Asset helpers ---
  function trimCanvasToDataUrl(canvas) {
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    const img = ctx.getImageData(0, 0, width, height);
    const data = img.data;

    let minX = width, minY = height, maxX = 0, maxY = 0;
    let found = false;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const a = data[(y * width + x) * 4 + 3];
        if (a > 12) {
          found = true;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (!found) return null;

    const pad = 10;
    minX = clamp(minX - pad, 0, width - 1);
    minY = clamp(minY - pad, 0, height - 1);
    maxX = clamp(maxX + pad, 0, width - 1);
    maxY = clamp(maxY + pad, 0, height - 1);

    const tw = maxX - minX + 1;
    const th = maxY - minY + 1;

    const out = document.createElement('canvas');
    out.width = tw;
    out.height = th;
    const octx = out.getContext('2d');
    octx.putImageData(ctx.getImageData(minX, minY, tw, th), 0, 0);
    return out.toDataURL('image/png');
  }

  async function loadImageAsDataUrl(file) {
    return await new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(String(r.result || ''));
      r.onerror = () => reject(new Error('Failed to read image.'));
      r.readAsDataURL(file);
    });
  }

  async function normalizeImageDataUrl(dataUrl) {
    return await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const c = document.createElement('canvas');
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        const ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const trimmed = trimCanvasToDataUrl(c);
        resolve(trimmed || dataUrl);
      };
      img.onerror = () => resolve(dataUrl);
      img.src = dataUrl;
    });
  }

  function generateSignatureFromName(name) {
    const n = (name || '').trim() || 'Signature';
    const c = document.createElement('canvas');
    c.width = 1200;
    c.height = 360;
    const ctx = c.getContext('2d');

    ctx.clearRect(0, 0, c.width, c.height);

    ctx.fillStyle = '#111';
    ctx.textBaseline = 'middle';
    ctx.font = '120px "Brush Script MT", "Segoe Script", "Lucida Handwriting", cursive';

    ctx.save();
    ctx.translate(40, 190);
    ctx.transform(1, 0, -0.12, 1, 0, 0);
    ctx.fillText(n, 0, 0);
    ctx.restore();

    return trimCanvasToDataUrl(c);
  }

  function generateInitialsFromText(txt) {
    const t = (txt || "").trim() || "XX";
    const c = document.createElement("canvas");
    c.width = 1000;
    c.height = 420;
    const ctx = c.getContext("2d");

    ctx.clearRect(0, 0, c.width, c.height);
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    ctx.font = '900 260px "Segoe UI", system-ui, -apple-system, Arial, sans-serif';
    const x = c.width / 2;
    const y = c.height / 2;

    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.lineWidth = 26;
    ctx.strokeText(t, x, y);

    ctx.fillStyle = "#111";
    ctx.fillText(t, x, y);

    ctx.strokeStyle = "rgba(0,0,0,0.9)";
    ctx.lineWidth = 8;
    ctx.strokeText(t, x, y);

    return trimCanvasToDataUrl(c);
  }

  function setSignatureDataUrl(url) {
    sigDataUrl = url || null;
    sigReady = false;

    if (!sigDataUrl) {
      drawOverlay();
      updateLockButtons();
      return;
    }

    sigImg.onload = () => {
      sigReady = true;
      // place new signature near top so user sees it
      if (pdfDoc && viewportCss && viewportCss.h) {
        const pl = ensureAtLeastOnePlacement('sig');
        if (pl) scrollPreviewToYNorm(pl.y);
      } else {
        pendingAutoPlaceSig = true;
      }
      drawOverlay();
      updateLockButtons();
    };
    sigImg.onerror = () => {
      sigReady = false;
      drawOverlay();
      updateLockButtons();
    };
    sigImg.src = sigDataUrl;
  }

  function setInitialsDataUrl(url) {
    initDataUrl = url || null;
    initReady = false;

    if (!initDataUrl) {
      drawOverlay();
      updateLockButtons();
      return;
    }

    initImg.onload = () => {
      initReady = true;
      if (pdfDoc && viewportCss && viewportCss.h && initEnabled()) {
        const pl = ensureAtLeastOnePlacement('init');
        if (pl) scrollPreviewToYNorm(pl.y);
      } else {
        pendingAutoPlaceInit = true;
      }
      drawOverlay();
      updateLockButtons();
    };
    initImg.onerror = () => {
      initReady = false;
      drawOverlay();
      updateLockButtons();
    };
    initImg.src = initDataUrl;
  }

  // --- Signature pad (draw) ---
  function initSignaturePad() {
    if (!sigPad) return;
    const ctx = sigPad.getContext('2d');
    ctx.clearRect(0, 0, sigPad.width, sigPad.height);

    let drawing = false;
    let last = null;

    function getPt(ev) {
      const r = sigPad.getBoundingClientRect();
      const x = (ev.clientX - r.left) * (sigPad.width / r.width);
      const y = (ev.clientY - r.top) * (sigPad.height / r.height);
      return { x, y };
    }

    function strokeWidth() {
      const v = parseFloat(sigPenSize?.value || '4');
      return isFinite(v) ? v : 4;
    }

    function drawSegment(p0, p1) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#111';
      ctx.lineWidth = strokeWidth();

      ctx.beginPath();
      if (!last) {
        ctx.moveTo(p0.x, p0.y);
      } else {
        const mx = (last.x + p1.x) / 2;
        const my = (last.y + p1.y) / 2;
        ctx.moveTo(last.x, last.y);
        ctx.quadraticCurveTo(last.x, last.y, mx, my);
      }
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    }

    sigPad.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      drawing = true;
      last = getPt(ev);
      sigPad.setPointerCapture(ev.pointerId);
    });

    sigPad.addEventListener('pointermove', (ev) => {
      if (!drawing) return;
      ev.preventDefault();
      const pt = getPt(ev);
      drawSegment(last, pt);
      last = pt;
    });

    function endStroke() {
      if (!drawing) return;
      drawing = false;
      last = null;
      const url = trimCanvasToDataUrl(sigPad);
      if (url) {
        setSignatureDataUrl(url);
        // create a new placement for this signature (supports multiple on same page)
        if (pdfDoc) {
          const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
          scrollPreviewToYNorm(pl.y);
          drawOverlay();
        } else {
          pendingAutoPlaceSig = true;
        }
      }
    }

    sigPad.addEventListener('pointerup', (ev) => { ev.preventDefault(); endStroke(); });
    sigPad.addEventListener('pointercancel', (ev) => { ev.preventDefault(); endStroke(); });

    sigClearBtn?.addEventListener('click', () => {
      ctx.clearRect(0, 0, sigPad.width, sigPad.height);
      setSignatureDataUrl(null);
    });
  }

  // --- Encryption-aware PDF load ---
  async function loadCurrentPdf() {
    if (!srcFile) {
      pdfDoc = null;
      showEmpty('Upload a PDF to preview it here.');
      return;
    }

    // Block rendering until encryption status known
    enc = null;
    pdfDoc = null;
    showEmpty('Checking PDFâ€¦');

    let encrypted = true; // fail-closed
    try {
      encrypted = await detectEncryptedPdfReliable(srcFile);
      if (!encrypted) encrypted = await serverSaysEncrypted(srcFile);
    } catch {
      encrypted = true;
    }

    enc = !!encrypted;

    if (enc && !unlockedFile) {
      showEmpty('Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.');
      updateLockButtons();
      return;
    }

    try {
      const loadFile = unlockedFile || srcFile;
      pdfDoc = await loadPdfFromFile(loadFile);
      pageCount = pdfDoc.numPages || 1;
      pageNum = clamp(pageNum, 1, pageCount);
      await renderPage();
      updateLockButtons();
    } catch (e) {
      console.error(e);
      showEmpty('Preview failed. Try unlocking the PDF if it is encrypted.');
    }
  }

  // --- File input ---
  async function onFileChange() {
    const files = Array.from(fileInput.files || []).filter((f) => f && /pdf/i.test(f.type || 'application/pdf'));
    if (!files.length) {
      srcFile = null;
      unlockedFile = null;
      pdfDoc = null;
      pageNum = 1;
      pageCount = 1;
      showEmpty('Upload a PDF to preview it here.');
      return;
    }

    // use the first PDF (prev/next pdf controls removed by design)
    srcFile = files[0];
    unlockedFile = null;
    enc = null;
    pageNum = 1;

    // reset placements for new PDF
    
    // reset placements for new PDF
    for (const k of Object.keys(sigByPage)) delete sigByPage[k];
    for (const k of Object.keys(initByPage)) delete initByPage[k];
    selected = { type: 'sig', id: null };
    activeItem = 'sig';

    if (initEnable) initEnable.checked = false;
    if (initText) initText.value = '';
    initDataUrl = null;
    initReady = false;

    // keep signature asset as-is (user might be signing multiple docs), but clear selection

    showEmpty('Checking PDFâ€¦');
    await loadCurrentPdf();


  }

  

  // Capture prevents any legacy wiring from loading before encryption guard
  fileInput.addEventListener('change', (e) => {
    try { e.stopImmediatePropagation(); } catch {}
    onFileChange();
  }, true);

  // --- Unlock (decrypt) ---
  unlockBtn?.addEventListener('click', async () => {
    if (!srcFile) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '');
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decryptingâ€¦';
    }

    try {
      unlockedFile = await decryptPdfToFile(srcFile, pw);
      enc = false;
      await loadCurrentPdf();
    } catch (err) {
      alert(String(err?.message || err));
      showEmpty('Unlock failed. Check the password and try again.');
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  // --- Signature source wiring ---
  modeGenerateBtn?.addEventListener('click', () => setMode('generate'));
  modeDrawBtn?.addEventListener('click', () => setMode('draw'));
  modeUploadBtn?.addEventListener('click', () => setMode('upload'));
  setMode('generate');

  sigGenBtn?.addEventListener('click', async () => {
    const url = generateSignatureFromName(String(sigGenName?.value || ''));
    if (!url) return alert('Enter a name to generate a signature.');
    setSignatureDataUrl(await normalizeImageDataUrl(url));
    // always create a new placement near top when a signature is created
    if (pdfDoc) {
      const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
      scrollPreviewToYNorm(pl.y);
      drawOverlay();
    } else {
      pendingAutoPlaceSig = true;
    }
  });

  sigUpload?.addEventListener('change', async () => {
    const f = (sigUpload.files && sigUpload.files[0]) || null;
    if (!f) return;
    const url = await normalizeImageDataUrl(await loadImageAsDataUrl(f));
    setSignatureDataUrl(url);
    // create a new placement near top
    if (pdfDoc) {
      const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
      scrollPreviewToYNorm(pl.y);
      drawOverlay();
    } else {
      pendingAutoPlaceSig = true;
    }
  });

  // Initials create
  initCreateBtn?.addEventListener('click', async () => {
    if (!initEnable) return;
    if (!initEnable.checked) initEnable.checked = true;

    const url = generateInitialsFromText(String(initText?.value || ''));
    if (!url) return alert('Enter initials (e.g., JS).');

    setInitialsDataUrl(await normalizeImageDataUrl(url));

    // Create a new placement near top each time initials are created
    if (pdfDoc) {
      const pl = createPlacement('init', pageNum, 0.72, autoTopYNorm(), getInitScalePct());
      scrollPreviewToYNorm(pl.y);
      drawOverlay();
    } else {
      pendingAutoPlaceInit = true;
    }
  });

  initEnable?.addEventListener('change', () => {
    if (!initEnable.checked) {
      // keep existing placements but hide initials
      setActiveItem('sig');
    }
    drawOverlay();
    updateLockButtons();
  });

  // Scale changes update selected placement
  sigScaleRange?.addEventListener('input', () => {
    const pl = getSelectedPlacement('sig', pageNum);
    if (pl && !pl.locked) pl.scale = getSigScalePct();
    drawOverlay();
  });

  initScaleRange?.addEventListener('input', () => {
    const pl = getSelectedPlacement('init', pageNum);
    if (pl && !pl.locked) pl.scale = getInitScalePct();
    drawOverlay();
  });

  activeSigBtn?.addEventListener('click', () => setActiveItem('sig'));
  activeInitBtn?.addEventListener('click', () => setActiveItem('init'));

  // Add another placement (makes multi-signing obvious)
  addSigBtn?.addEventListener('click', () => {
    if (!pdfDoc || !sigReady) return;
    const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
    scrollPreviewToYNorm(pl.y);
    drawOverlay();
    updateLockButtons();
  });

  addInitBtn?.addEventListener('click', () => {
    if (!pdfDoc) return;
    if (!initEnable) return;
    if (!initEnable.checked) initEnable.checked = true;
    if (!(initEnabled() && initReady)) return;
    const pl = createPlacement('init', pageNum, 0.72, autoTopYNorm(), getInitScalePct());
    scrollPreviewToYNorm(pl.y);
    drawOverlay();
    updateLockButtons();
  });

  // Lock toggles (selected placement)
  lockSigBtn?.addEventListener('click', () => {
    if (!sigReady) return;
    const pl = getSelectedPlacement('sig', pageNum) || ensureAtLeastOnePlacement('sig');
    if (!pl) return;
    pl.locked = !pl.locked;
    selectPlacement('sig', pl.id);
    drawOverlay();
    updateLockButtons();
  });

  lockInitBtn?.addEventListener('click', () => {
    if (!(initEnabled() && initReady)) return;
    const pl = getSelectedPlacement('init', pageNum) || ensureAtLeastOnePlacement('init');
    if (!pl) return;
    pl.locked = !pl.locked;
    selectPlacement('init', pl.id);
    drawOverlay();
    updateLockButtons();
  });

  // Lock & Next Page
  lockNextBtn?.addEventListener('click', async () => {
    if (!pdfDoc) return;
    // lock selected sig/init (if any)
    const sp = getSelectedPlacement('sig', pageNum);
    if (sp) sp.locked = true;
    const ip = getSelectedPlacement('init', pageNum);
    if (ip) ip.locked = true;

    if (pageNum < pageCount) {
      pageNum = Math.min(pageCount, pageNum + 1);
      await renderPage();
    }
    drawOverlay();
    updateLockButtons();
  });

  prevPageBtn?.addEventListener('click', async () => {
    if (!pdfDoc) return;
    pageNum = Math.max(1, pageNum - 1);
    // clear selection for new page (will re-select last on draw)
    selected.id = null;
    await renderPage();
  });

  nextPageBtn?.addEventListener('click', async () => {
    if (!pdfDoc) return;
    pageNum = Math.min(pageCount, pageNum + 1);
    selected.id = null;
    await renderPage();
  });

  async function getPageWH(pn) {
    try {
      const pg = await pdfDoc.getPage(pn);
      const v = pg.getViewport({ scale: 1 });
      return { w: v.width || 1, h: v.height || 1 };
    } catch {
      return { w: viewportCss.w || 1, h: viewportCss.h || 1 };
    }
  }

  exportBtn.addEventListener('click', async () => {
    if (!srcFile) return alert('Upload a PDF first.');
    if (enc === null) return alert('Checking encryptionâ€¦ please try again in a moment.');
    if (enc && !unlockedFile) return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    if (!sigDataUrl) return alert('Add a signature first (generate, draw, or upload).');

    if (status) setStatus(status, 'Status: Exporting...');

    const sigAspect = sigImg.naturalHeight / sigImg.naturalWidth;
    const sigPlacements = [];
    for (const [k, list] of Object.entries(sigByPage)) {
      const pn = parseInt(k, 10);
      if (!(pn >= 1) || !Array.isArray(list)) continue;
      for (const pl of list) {
        if (!pl) continue;
        const { w: pw, h: ph } = await getPageWH(pn);
        const wNorm = (parseFloat(pl.scale) || 20) / 100;
        const hNorm = wNorm * ((pw / ph) * sigAspect);
        sigPlacements.push({ page: pn, x: pl.x, y: pl.y, w: wNorm, h: hNorm });
      }
    }

    // If user never placed anything, export one default placement
    if (!sigPlacements.length) {
      const pl = ensureAtLeastOnePlacement('sig');
      const { w: pw, h: ph } = await getPageWH(pageNum);
      const wNorm = (parseFloat(pl.scale) || 20) / 100;
      const hNorm = wNorm * ((pw / ph) * sigAspect);
      sigPlacements.push({ page: pageNum, x: pl.x, y: pl.y, w: wNorm, h: hNorm });
    }

    const initPlacements = [];
    if (initEnabled() && initDataUrl && initReady) {
      const initAspect = initImg.naturalHeight / initImg.naturalWidth;
      for (const [k, list] of Object.entries(initByPage)) {
        const pn = parseInt(k, 10);
        if (!(pn >= 1) || !Array.isArray(list)) continue;
        for (const pl of list) {
          if (!pl) continue;
          const { w: pw, h: ph } = await getPageWH(pn);
          const wNorm = (parseFloat(pl.scale) || 10) / 100;
          const hNorm = wNorm * ((pw / ph) * initAspect);
          initPlacements.push({ page: pn, x: pl.x, y: pl.y, w: wNorm, h: hNorm });
        }
      }
    }

    const fd = new FormData();
    fd.append('file', unlockedFile || srcFile);
    fd.append('signerName', (sigGenName?.value || '').trim());
    fd.append('signatureDataUrl', sigDataUrl);

    fd.append('sigPlacements', JSON.stringify(sigPlacements));
    if (sigPlacements.length) {
      const s0 = sigPlacements[0];
      fd.append('sigPage', String(s0.page));
      fd.append('sigX', String(s0.x));
      fd.append('sigY', String(s0.y));
      fd.append('sigW', String(s0.w));
      fd.append('sigH', String(s0.h));
    }

    if (initPlacements.length) {
      fd.append('initialsDataUrl', initDataUrl);
      fd.append('initialsText', String(initText?.value || '').trim());
      fd.append('initPlacements', JSON.stringify(initPlacements));
      const i0 = initPlacements[0];
      fd.append('initPage', String(i0.page));
      fd.append('initX', String(i0.x));
      fd.append('initY', String(i0.y));
      fd.append('initW', String(i0.w));
      fd.append('initH', String(i0.h));
    }

    const out = await runPaidPdfExport({
      tool: 'quick-sign',
      endpoint: ENDPOINTS.QUICK_SIGN,
      formData: fd,
      filename: 'pdfrealm-quick-sign.pdf',
      setPreviewFrameId: null,
      placeholderId: null,
    });

    if (status) setStatus(status, out.ok ? 'Status: Done' : 'Status: Ready');
  });

  // Init
  initSignaturePad();
  updateLockButtons();
  setActiveItem('sig');
  showEmpty('Upload a PDF to preview it here. If it is encrypted, unlock it first.');
}

// -------------------- Password Protect --------------------
// -------------------- Password Protect --------------------
function initPassword() {
  const fileInput = $("passwordPdfFile");
  const currentPwInput = $("passwordCurrentInput");
  const unlockBtn = $("passwordUnlockBtn");
  const newPwInput = $("passwordInput");
  const encryptBtn = $("passwordEncryptBtn");

  const frameId = "passwordPreviewFrame";
  const placeholderId = "passwordPreviewPlaceholder";

  if (!fileInput || !encryptBtn) return;

  let unlocked = null;
  let enc = null; // null=pending, true=encrypted, false=not encrypted
  let previewUrl = null;
  let seq = 0;

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmpty(msg) {
    revokePreviewUrl();
    setIframeSrc(frameId, "");
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    // Clip the built-in PDF toolbar/tools (Edge draw, etc.)
    try {
      const fr = $(frameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmpty('Upload a PDF to preview it here.');
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(frameId, previewUrl + '#toolbar=0&navpanes=0&scrollbar=0');
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmpty('Upload a PDF to preview it here.');

    // Block iframe load until we know encryption status (prevents browser password popups)
    enc = null;
    setIframeSrc(frameId, "");
    const ph = $(placeholderId);
    if (ph) ph.textContent = 'Checking PDFâ€¦';
    showPlaceholder(placeholderId, true);

    const mySeq = ++seq;
    let encrypted = true; // fail-closed
    try {
      encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        encrypted = await serverSaysEncrypted(f);
      }
    } catch {
      encrypted = true;
    }

    if (mySeq != seq) return;

    enc = !!encrypted;
    if (enc) {
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the current password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    if (ph) ph.textContent = 'Upload a PDF to preview it here.';
    setPreviewFile(f);
  }

  // Capture prevents any legacy wiring from loading the file before encryption guard
  fileInput.addEventListener('change', (e) => {
    try { e.stopImmediatePropagation(); } catch {}
    onFileChange();
  }, true);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(currentPwInput?.value || '');
    if (!pw) return alert('Enter the current PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decryptingâ€¦';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Upload a PDF to preview it here.';
      setPreviewFile(unlocked);
    } catch (err) {
      alert(String(err?.message || err));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  encryptBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    const newPw = String(newPwInput?.value || '');
    if (!newPw) return alert('Enter a new password.');

    if (enc === null) {
      return alert('Checking encryptionâ€¦ please try again in a moment.');
    }

    const fd = new FormData();

    // If the input is encrypted and the user did NOT unlock it,
    // send the raw file + the current password so qpdf can open it.
    if (enc && !unlocked) {
      const cur = String(currentPwInput?.value || '');
      if (!cur) {
        return alert('This PDF is already encrypted. Enter the current password (or decrypt/unlock it) before changing the password.');
      }
      fd.append('file', f);
      fd.append('inputPassword', cur);
    } else {
      fd.append('file', unlocked || f);
    }

    fd.append('password', newPw);

    // IMPORTANT: Do NOT set preview to the encrypted output (would trigger the browser password UI).
    await runPaidPdfExport({
      tool: 'encrypt',
      endpoint: ENDPOINTS.ENCRYPT,
      formData: fd,
      filename: 'pdfrealm-protected.pdf',
      setPreviewFrameId: null,
      placeholderId: null,
    });
  });

  // Initial state
  setEmpty('Upload a PDF to preview it here. If it\'s encrypted, unlock first.');
}


// -------------------- Merge / Delete / Split --------------------
function initMerge() {
  const inp1 = $("mergeFile1");
  const inp2 = $("mergeFile2");

  const pw1 = $("mergePassword1");
  const pw2 = $("mergePassword2");
  const unlock1Btn = $("mergeUnlock1Btn");
  const unlock2Btn = $("mergeUnlock2Btn");

  const frameId = "mergePreviewFrame";
  const placeholderId = "mergePreviewPlaceholder";

  if (!inp1 && !inp2) return;

  let unlocked1 = null;
  let unlocked2 = null;

  // encX tri-state:
  //   null  => pending/unknown (block preview to avoid the browser PDF password UI)
  //   true  => encrypted (block preview until unlocked)
  //   false => not encrypted (safe to preview)
  let enc1 = null;
  let enc2 = null;

  // Sequence guards to avoid out-of-order async checks overriding the latest selection
  let encSeq1 = 0;
  let encSeq2 = 0;

  let previewDocUrl = null;
  let innerPdfUrls = [];

  function revokePreviewUrls() {
    try {
      if (previewDocUrl) URL.revokeObjectURL(previewDocUrl);
    } catch {}
    previewDocUrl = null;

    for (const u of innerPdfUrls) {
      try { URL.revokeObjectURL(u); } catch {}
    }
    innerPdfUrls = [];
  }

  function setEmptyPreview() {
    revokePreviewUrls();
    setIframeSrc(frameId, "");
    showPlaceholder(placeholderId, true);
    try { if (previewHint) previewHint.style.display = 'none'; } catch {}
  }

  function updatePreview() {
    const f1 = inp1?.files?.[0] || null;
    const f2 = inp2?.files?.[0] || null;

    if (!f1 && !f2) return setEmptyPreview();

    const d1 = unlocked1 || (enc1 === false ? f1 : null);
    const d2 = unlocked2 || (enc2 === false ? f2 : null);

    const msg1 = !f1
      ? "No file selected"
      : enc1 === null && !unlocked1
      ? "Checking encryptionâ€¦"
      : enc1 === true && !unlocked1
      ? "Encrypted â€” enter password and click Decrypt / Unlock"
      : "";

    const msg2 = !f2
      ? "No file selected"
      : enc2 === null && !unlocked2
      ? "Checking encryptionâ€¦"
      : enc2 === true && !unlocked2
      ? "Encrypted â€” enter password and click Decrypt / Unlock"
      : "";

    const doc = document.implementation.createHTMLDocument("Merge Preview");
    try {
      doc.documentElement.setAttribute("lang", "en");
      const metaCharset = doc.createElement("meta");
      metaCharset.setAttribute("charset", "utf-8");
      doc.head.appendChild(metaCharset);
      const metaViewport = doc.createElement("meta");
      metaViewport.setAttribute("name", "viewport");
      metaViewport.setAttribute("content", "width=device-width, initial-scale=1");
      doc.head.appendChild(metaViewport);
    } catch {}

    doc.body.style.margin = "0";
    doc.body.style.background = "#050814";

    const container = doc.createElement("div");
    container.style.display = "grid";
    container.style.gridTemplateColumns = "1fr 1fr";
    container.style.gap = "1px";
    container.style.height = "100vh";

    function addPanel(file, label, emptyText) {
      const wrap = doc.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.background = "#0b0f17";

      const head = doc.createElement("div");
      head.textContent = label;
      head.style.padding = "8px 10px";
      head.style.fontFamily = "system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
      head.style.fontSize = "12px";
      head.style.color = "#9ca3af";
      head.style.borderBottom = "1px solid #111827";
      wrap.appendChild(head);

      const iframe = doc.createElement("iframe");
      iframe.style.border = "0";
      iframe.style.width = "100%";
      // Hide browser PDF viewer toolbars (Edge draw, etc.) by shifting the iframe up inside a clipped container.
      iframe.style.height = "calc(100% + 64px)";
      iframe.style.marginTop = "-64px";
      iframe.src = "about:blank";

      const clip = doc.createElement("div");
      clip.style.flex = "1";
      clip.style.overflow = "hidden";
      clip.appendChild(iframe);

      if (file) {
        const url = URL.createObjectURL(file);
        innerPdfUrls.push(url);
        iframe.src = url + "#toolbar=0&navpanes=0&scrollbar=0";
      } else {
        const msg = doc.createElement("div");
        msg.textContent = emptyText || "No file selected";
        msg.style.display = "flex";
        msg.style.alignItems = "center";
        msg.style.justifyContent = "center";
        msg.style.padding = "16px";
        msg.style.textAlign = "center";
        msg.style.color = "#6b7280";
        msg.style.fontFamily = "system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
        msg.style.fontSize = "13px";
        iframe.onload = () => {
          try {
            iframe.contentDocument.body.style.margin = "0";
            iframe.contentDocument.body.style.background = "#0b0f17";
            iframe.contentDocument.body.appendChild(msg);
          } catch {}
        };
      }

      wrap.appendChild(clip);
      container.appendChild(wrap);
    }

    // Reset URLs each rebuild so we don't leak blob URLs.
    revokePreviewUrls();

    addPanel(d1, "Top PDF", msg1);
    addPanel(d2, "Bottom PDF", msg2);

    doc.body.appendChild(container);

    const html = "<!DOCTYPE html>\n" + doc.documentElement.outerHTML;
    const blob = new Blob([html], { type: "text/html;charset=utf-8" });
    previewDocUrl = URL.createObjectURL(blob);
    setIframeSrc(frameId, previewDocUrl);
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange(which) {
    if (which === 1) {
      unlocked1 = null;
      const f = inp1?.files?.[0] || null;

      // Block preview immediately until we definitively know encryption status.
      enc1 = null;
      updatePreview();

      if (!f) return;

      const seq = ++encSeq1;
      let encrypted = true; // fail-closed: never allow the browser PDF password UI
      try {
        encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        // Extra safety: some encrypted PDFs may evade token scan.
        encrypted = await serverSaysEncrypted(f);
      }
      } catch {
        encrypted = true;
      }
      if (seq !== encSeq1) return; // stale result (user picked another file)

      enc1 = !!encrypted;
      updatePreview();
      return;
    }

    // which === 2
    unlocked2 = null;
    const f = inp2?.files?.[0] || null;

    enc2 = null;
    updatePreview();

    if (!f) return;

    const seq = ++encSeq2;
    let encrypted = true;
    try {
      encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        // Extra safety: some encrypted PDFs may evade token scan.
        encrypted = await serverSaysEncrypted(f);
      }
    } catch {
      encrypted = true;
    }
    if (seq !== encSeq2) return;

    enc2 = !!encrypted;
    updatePreview();
  }

  // Capture + stopImmediatePropagation prevents any legacy preview wiring from loading the PDF before our encryption guard runs.
  inp1?.addEventListener(
    "change",
    (e) => {
      try { e.stopImmediatePropagation(); } catch {}
      onFileChange(1);
    },
    true
  );

  inp2?.addEventListener(
    "change",
    (e) => {
      try { e.stopImmediatePropagation(); } catch {}
      onFileChange(2);
    },
    true
  );

  async function unlock(which) {
    const file = which === 1 ? inp1?.files?.[0] : inp2?.files?.[0];
    const pwEl = which === 1 ? pw1 : pw2;
    const btnEl = which === 1 ? unlock1Btn : unlock2Btn;

    if (!file) return alert(which === 1 ? "Select PDF 1 first." : "Select PDF 2 first.");
    const password = String(pwEl?.value || "").trim();
    if (!password) return alert("Enter the PDF password.");

    if (btnEl) {
      btnEl.disabled = true;
      btnEl.textContent = "Decrypting...";
    }

    try {
      const decFile = await decryptPdfToFile(file, password);
      if (which === 1) {
        unlocked1 = decFile;
        enc1 = false;
      } else {
        unlocked2 = decFile;
        enc2 = false;
      }
      updatePreview();
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (btnEl) {
        btnEl.disabled = false;
        btnEl.textContent = "Decrypt / Unlock";
      }
    }
  }

  unlock1Btn?.addEventListener("click", () => unlock(1));
  unlock2Btn?.addEventListener("click", () => unlock(2));

  const btn = $("mergePdfBtn");
  if (!btn) return;

  btn.addEventListener("click", async () => {
    const f1 = inp1?.files?.[0] || null;
    const f2 = inp2?.files?.[0] || null;
    if (!f1 && !f2) return alert("Select at least one PDF.");

    if (f1 && enc1 !== false && !unlocked1) {
      return alert('PDF 1 is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }
    if (f2 && enc2 !== false && !unlocked2) {
      return alert('PDF 2 is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    if (f1) fd.append("files", unlocked1 || f1);
    if (f2) fd.append("files", unlocked2 || f2);

    await runPaidPdfExport({
      tool: "merge",
      endpoint: ENDPOINTS.MERGE,
      formData: fd,
      filename: "pdfrealm-merged.pdf",
      setPreviewFrameId: frameId,
      placeholderId,
    });
  });

  // Initial state
  setEmptyPreview();
}



function initDeletePages() {
  const fileInput = $("deletePdfFile");
  const passInput = $("deletePdfPassword");
  const unlockBtn = $("deleteUnlockBtn");
  const pagesInput = $("deletePagesSpec");
  const exportBtn = $("deletePagesBtn");

  const ph = $("deletePreviewPlaceholder");
  const stage = $("deletePreviewStage");
  const inner = $("deletePreviewInner");
  const img = $("deletePreviewImg");

  const prevBtn = $("deletePrevPageBtn");
  const nextBtn = $("deleteNextPageBtn");
  const pageInput = $("deletePreviewPage");
  const pageCountEl = $("deletePageCount");
  const zoomInput = $("deleteZoom");
  const zoomLabel = $("deleteZoomLabel");

  if (!fileInput || !exportBtn || !ph || !stage || !inner || !img) return;

  let currentFile = null;
  let isEncrypted = false;
  let password = "";
  let currentPage = 1;
  let pageCount = null;

  // Zoom slider
  let zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
  const previewCache = new Map(); // page -> objectURL
  if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

  function clamp(n, a, b) {
    return Math.max(a, Math.min(b, n));
  }

  async function isProbablyEncryptedPdf(file) {
    try {
      const headSlice = file.slice(0, Math.min(65536, file.size));
      const tailSlice = file.slice(Math.max(0, file.size - 65536), file.size);
      const [headBuf, tailBuf] = await Promise.all([headSlice.arrayBuffer(), tailSlice.arrayBuffer()]);
      const dec = new TextDecoder("latin1");
      const head = dec.decode(new Uint8Array(headBuf));
      const tail = dec.decode(new Uint8Array(tailBuf));
      return /\/Encrypt/i.test(head) || /\/Encrypt/i.test(tail);
    } catch {
      return false;
    }
  }

  function showPlaceholder(msg) {
    ph.textContent = msg;
    ph.style.display = "";
    stage.style.display = "none";
  }

  function showStage() {
    ph.style.display = "none";
    stage.style.display = "block";
  }

  function clearCache() {
    for (const url of previewCache.values()) {
      try { URL.revokeObjectURL(url); } catch {}
    }
    previewCache.clear();
  }

  function computeFitScale() {
    const wrapper = stage.parentElement;
    if (!wrapper) return 1;

    const availW = Math.max(100, wrapper.clientWidth - 24);
    const availH = Math.max(100, wrapper.clientHeight - 24);

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return 1;

    const scale = Math.min(availW / w, availH / h, 1.25);
    if (!Number.isFinite(scale) || scale <= 0) return 1;
    return scale;
  }

  function applyZoom() {
    zoomPct = clamp(parseInt(zoomPct, 10) || 100, 50, 200);
    if (zoomInput) zoomInput.value = String(zoomPct);
    if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return;

    const fit = computeFitScale();
    const scale = fit * (zoomPct / 100);

    inner.style.width = `${Math.max(1, Math.round(w * scale))}px`;
    inner.style.height = `${Math.max(1, Math.round(h * scale))}px`;

    img.style.transform = `translate(-50%, -50%) scale(${scale})`;
  }

  async function loadPreview(page) {
    if (!currentFile) return;
    const p = clamp(page, 1, pageCount || 999999);
    currentPage = p;
    if (pageInput) pageInput.value = String(currentPage);

    if (previewCache.has(currentPage)) {
      img.src = previewCache.get(currentPage);
      showStage();
      return;
    }

    showPlaceholder("Rendering previewâ€¦");

    try {
      const fd = new FormData();
      fd.append("file", currentFile);
      fd.append("page", String(currentPage));
      fd.append("dpi", "200");
      if (password) fd.append("password", password);

      const res = await fetch("/api/render/page", { method: "POST", body: fd });
      if (!res.ok) {
        const data = await res.json().catch(() => null);
        const msg = (data?.error || `Preview failed (${res.status})`).toString();
        if (/password|encrypt/i.test(msg)) {
          isEncrypted = true;
          showPlaceholder('Encrypted PDF â€” enter the password and click Decrypt / Unlock.');
          return;
        }
        throw new Error(msg);
      }

      const pc = res.headers.get("x-pdf-page-count") || res.headers.get("X-PDF-Page-Count");
      const maybeCount = pc ? parseInt(pc, 10) : NaN;
      if (Number.isFinite(maybeCount) && maybeCount > 0) {
        pageCount = maybeCount;
        if (pageCountEl) pageCountEl.textContent = String(pageCount);
      }

      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      previewCache.set(currentPage, url);
      img.src = url;
      showStage();
    } catch (e) {
      console.error(e);
      showPlaceholder(e?.message || "Preview not available");
    }
  }

  img.addEventListener("load", () => {
    applyZoom();
  });

  function resetStateForFile(file) {
    currentFile = file;
    password = "";
    if (passInput) passInput.value = "";
    isEncrypted = false;
    currentPage = 1;
    pageCount = null;
    if (pageCountEl) pageCountEl.textContent = "?";
    if (pageInput) pageInput.value = "1";
    clearCache();
    zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
    if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;
  }

  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      resetStateForFile(null);
      showPlaceholder("Upload a PDF to preview. If it's encrypted, enter the password then click Decrypt / Unlock.");
      return;
    }

    resetStateForFile(f);
    showPlaceholder("Analyzing PDFâ€¦");

    isEncrypted = await detectEncryptedPdfReliable(f);
    if (isEncrypted) {
      showPlaceholder("Encrypted PDF â€” enter the password and click Decrypt / Unlock.");
      return;
    }

    await loadPreview(1);
  });

  unlockBtn?.addEventListener("click", async () => {
    if (!currentFile) return alert("Upload a PDF first.");
    const pw = String(passInput?.value || "");
    if (!pw) return alert("Enter the PDF password.");
    password = pw;
    await loadPreview(currentPage || 1);
  });

  zoomInput?.addEventListener("input", () => {
    zoomPct = clamp(parseInt(zoomInput.value || "100", 10) || 100, 50, 200);
    applyZoom();
  });

  prevBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) - 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  nextBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) + 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  pageInput?.addEventListener("change", () => {
    const p = parseInt(pageInput.value || "1", 10) || 1;
    loadPreview(p);
  });

  exportBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");

    const pages = String(pagesInput?.value || "").trim();
    if (!pages) return alert("Enter pages to delete (e.g., 2,4-6). ");
    let pw = password;
    if (isEncrypted && !pw) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    fd.append("file", f);
    fd.append("pages", pages);

    // Keep encrypted output by default when encrypted input.
    if (isEncrypted && pw) {
      fd.append("password", pw);
      fd.append("outputPassword", pw);
    }

    await runPaidPdfExport({
      tool: "delete-pages",
      endpoint: ENDPOINTS.DELETE_PAGES,
      formData: fd,
      filename: "pdfrealm-pages-deleted.pdf",
    });
  });
}

function initSplit() {
  const fileInput = $("splitPdfFile");
  const passInput = $("splitPdfPassword");
  const unlockBtn = $("splitUnlockBtn");

  const frameId = "splitPreviewFrame";
  const placeholderId = "splitPreviewPlaceholder";

  const btn = $("splitPdfBtn");
  if (!btn || !fileInput) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmptyPreview() {
    revokePreviewUrl();
    setIframeSrc(frameId, "");
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    try {
      const fr = $(frameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmptyPreview();
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(frameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }
    try { if (previewHint) previewHint.style.display = 'none'; } catch {}
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmptyPreview();

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      // Show placeholder message and require decrypt to preview/export.
      setIframeSrc(frameId, "");
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    // Normal preview
    const ph = $(placeholderId);
    if (ph) ph.textContent = 'Upload a PDF to preview it here.';
    setPreviewFile(f);
  }

  fileInput.addEventListener("change", onFileChange);

  unlockBtn?.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const password = String(passInput?.value || "").trim();
    if (!password) return alert("Enter the PDF password.");

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = "Decrypting...";
    }

    try {
      unlocked = await decryptPdfToFile(f, password);
      enc = false;
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Upload a PDF to preview it here.';
      setPreviewFile(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = "Decrypt / Unlock";
      }
    }
  });

  btn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const ranges = ($("splitPageRanges")?.value || "").trim();
    if (!ranges) return alert("Enter ranges like 1-3,5");

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append("file", unlocked || f);
    fd.append("ranges", ranges);

    await runPaidPdfExport({
      tool: "split",
      endpoint: ENDPOINTS.SPLIT,
      formData: fd,
      filename: "pdfrealm-split.pdf",
      setPreviewFrameId: frameId,
      placeholderId,
    });
  });

  // Initial state
  setEmptyPreview();
}




function initReorderSecure() {
  const fileInput = $("reorderPdfFile");
  const passInput = $("reorderPdfPassword");
  const unlockBtn = $("reorderUnlockBtn");
  const orderInput = $("reorderPages");
  const exportBtn = $("reorderPdfBtn");
  const listEl = $("reorderPageList");
  const resetBtn = $("reorderResetBtn");

  const refreshBtn = $("reorderRefreshBtn");
  const statusEl = $("reorderPreviewStatus");

  const frameId = "reorderPreviewFrame";
  const placeholderId = "reorderPreviewPlaceholder";

  if (!fileInput || !exportBtn) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }
  let previewOutUrl = null;
  let lastPreviewOrder = null;

  // Drag/list state (reorder tool only)
  let pageCount = 0;
  let pageOrder = [];
  let currentThumbFile = null;
  let thumbObserver = null;
  let dragEl = null;
  let buildToken = 0;
  let dragHandlersBound = false;

  const thumbUrls = new Map(); // page -> objectURL
  const thumbState = new Map(); // page -> 'loading'|'loaded'

  // Simple concurrency limiter for thumbnail rendering.
  let inFlight = 0;
  const pending = [];
  const MAX_THUMB_INFLIGHT = 3;

  function enqueue(task) {
    return new Promise((resolve, reject) => {
      pending.push({ task, resolve, reject });
      drain();
    });
  }

  async function drain() {
    if (inFlight >= MAX_THUMB_INFLIGHT) return;
    const next = pending.shift();
    if (!next) return;
    inFlight++;
    try {
      const out = await next.task();
      next.resolve(out);
    } catch (e) {
      next.reject(e);
    } finally {
      inFlight--;
      drain();
    }
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function revokeOutUrl() {
    try { if (previewOutUrl) URL.revokeObjectURL(previewOutUrl); } catch {}
    previewOutUrl = null;
  }

  function clearThumbs() {
    try {
      if (thumbObserver) thumbObserver.disconnect();
    } catch {}
    thumbObserver = null;

    for (const u of thumbUrls.values()) {
      try { URL.revokeObjectURL(u); } catch {}
    }
    thumbUrls.clear();
    thumbState.clear();
    pageCount = 0;
    pageOrder = [];
    currentThumbFile = null;
    dragEl = null;
  }

  function setListEmpty(message) {
    if (!listEl) return;
    listEl.innerHTML = `<div class="reorder-list-empty">${escapeHtml(message || "Upload a PDF to generate draggable pages.")}</div>`;
  }

  function syncOrderFromDom() {
    if (!listEl) return;
    const items = Array.from(listEl.querySelectorAll(".reorder-page-item"));
    const nums = items
      .map((el) => parseInt(el.dataset.page || "", 10))
      .filter((n) => Number.isFinite(n) && n > 0);
    pageOrder = nums;
    if (orderInput && nums.length) {
      orderInput.value = nums.join(",");
    }
    updatePreviewSyncUI();
  }

  function resetToOriginalOrder() {
    if (!listEl || !pageCount) return;
    const map = new Map();
    for (const el of Array.from(listEl.querySelectorAll(".reorder-page-item"))) {
      const p = parseInt(el.dataset.page || "", 10);
      if (Number.isFinite(p)) map.set(p, el);
    }
    listEl.innerHTML = "";
    for (let p = 1; p <= pageCount; p++) {
      const el = map.get(p);
      if (el) listEl.appendChild(el);
    }
    syncOrderFromDom();
  }

  function parseOrderInput(value) {
    const raw = String(value || "")
      .split(/[,\s]+/)
      .map((s) => s.trim())
      .filter(Boolean);
    const nums = raw
      .map((s) => parseInt(s, 10))
      .filter((n) => Number.isFinite(n));
    // De-dupe while preserving order
    const seen = new Set();
    const unique = [];
    for (const n of nums) {
      if (!seen.has(n)) {
        seen.add(n);
        unique.push(n);
      }
    }
    return unique;
  }

  function currentOrderString() {
    if (pageOrder && pageOrder.length) return pageOrder.join(',');
    const nums = parseOrderInput(orderInput?.value || '');
    return nums.length ? nums.join(',') : '';
  }

  function setStatus(text) {
    if (!statusEl) return;
    if (!text) {
      statusEl.style.display = 'none';
      statusEl.textContent = '';
      return;
    }
    statusEl.textContent = text;
    statusEl.style.display = 'block';
  }

  function updatePreviewSyncUI() {
    const cur = currentOrderString();
    const stale = Boolean(lastPreviewOrder && cur && cur !== lastPreviewOrder);
    if (refreshBtn) refreshBtn.disabled = !stale;
    setStatus(stale ? 'Order changed â€” click Refresh Preview to update the preview.' : '');
  }

  function syncListFromInput() {
    if (!listEl || !pageCount || !orderInput) return;
    const nums = parseOrderInput(orderInput.value);
    if (nums.length !== pageCount) return; // ignore partial/invalid
    if (nums.some((n) => n < 1 || n > pageCount)) return;

    const map = new Map();
    for (const el of Array.from(listEl.querySelectorAll(".reorder-page-item"))) {
      const p = parseInt(el.dataset.page || "", 10);
      if (Number.isFinite(p)) map.set(p, el);
    }
    // Ensure all pages exist
    for (let p = 1; p <= pageCount; p++) {
      if (!map.has(p)) return;
    }

    listEl.innerHTML = "";
    for (const p of nums) {
      listEl.appendChild(map.get(p));
    }
    syncOrderFromDom();
  }

  function setEmptyPreview(msg) {
    revokeOutUrl();
    revokePreviewUrl();
    setIframeSrc(frameId, "");
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    revokeOutUrl();
    revokePreviewUrl();
    if (!file) {
      return setEmptyPreview('Upload a PDF to preview it here.');
    }
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(frameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function probePageCount(file) {
    // Use render/page because it returns X-PDF-Page-Count when possible.
    const fd = new FormData();
    fd.append("file", file);
    fd.append("page", "1");
    fd.append("dpi", "60");
    const res = await fetch("/api/render/page", { method: "POST", body: fd });
    if (!res.ok) {
      const data = await res.json().catch(() => null);
      const msg = String((data?.error || data?.message || `Preview failed (${res.status})`).toString());
      throw new Error(msg);
    }
    const pc = res.headers.get("x-pdf-page-count") || res.headers.get("X-PDF-Page-Count");
    const count = pc ? parseInt(pc, 10) : NaN;
    const blob = await res.blob();
    return { count: Number.isFinite(count) && count > 0 ? count : 0, firstBlob: blob };
  }

  async function fetchThumb(file, page, dpi = 96) {
    const fd = new FormData();
    fd.append("file", file);
    fd.append("page", String(page));
    fd.append("dpi", String(dpi));
    const res = await fetch("/api/render/page", { method: "POST", body: fd });
    if (!res.ok) {
      const data = await res.json().catch(() => null);
      const msg = String((data?.error || data?.message || `Preview failed (${res.status})`).toString());
      throw new Error(msg);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    thumbUrls.set(page, url);
    return url;
  }

  function buildListDom(count) {
    if (!listEl) return;
    listEl.innerHTML = "";

    const frag = document.createDocumentFragment();
    for (let p = 1; p <= count; p++) {
      const item = document.createElement("div");
      item.className = "reorder-page-item";
      item.draggable = true;
      item.dataset.page = String(p);

      const handle = document.createElement("div");
      handle.className = "reorder-drag-handle";
      handle.textContent = "â‹®â‹®";

      const thumb = document.createElement("div");
      thumb.className = "reorder-thumb";
      const img = document.createElement("img");
      img.alt = `Page ${p}`;
      img.loading = "lazy";
      thumb.appendChild(img);

      const meta = document.createElement("div");
      meta.className = "reorder-meta";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = `Page ${p}`;
      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = "Drag to move";
      meta.appendChild(title);
      meta.appendChild(sub);

      item.appendChild(handle);
      item.appendChild(thumb);
      item.appendChild(meta);
      frag.appendChild(item);
    }
    listEl.appendChild(frag);
  }

  function attachDragHandlers() {
    if (!listEl) return;
    if (dragHandlersBound) return;
    dragHandlersBound = true;

    function clearDropTargets() {
      listEl.querySelectorAll(".reorder-page-item.drop-target").forEach((el) => el.classList.remove("drop-target"));
    }

    listEl.addEventListener("dragstart", (e) => {
      const item = e.target?.closest?.(".reorder-page-item");
      if (!item) return;
      dragEl = item;
      item.classList.add("dragging");
      try {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", item.dataset.page || "");
      } catch {}
    });

    listEl.addEventListener("dragover", (e) => {
      if (!dragEl) return;
      e.preventDefault();
      const target = e.target?.closest?.(".reorder-page-item");
      if (!target || target === dragEl) return;

      clearDropTargets();
      target.classList.add("drop-target");

      const rect = target.getBoundingClientRect();
      const after = (e.clientY - rect.top) > rect.height / 2;
      if (after) target.after(dragEl);
      else target.before(dragEl);
    });

    listEl.addEventListener("drop", (e) => {
      if (!dragEl) return;
      e.preventDefault();
      clearDropTargets();
      syncOrderFromDom();
    });

    listEl.addEventListener("dragend", () => {
      clearDropTargets();
      if (dragEl) dragEl.classList.remove("dragging");
      dragEl = null;
      syncOrderFromDom();
    });
  }

  async function buildPageList(file) {
    if (!listEl) return;
    const myToken = ++buildToken;
    clearThumbs();
    currentThumbFile = file;
    setListEmpty("Generating pagesâ€¦");

    try {
      const { count, firstBlob } = await probePageCount(file);
      if (myToken !== buildToken) return;
      if (!count || count < 1) {
        setListEmpty("Couldn't detect page count for this PDF.");
        return;
      }

      pageCount = count;
      pageOrder = Array.from({ length: pageCount }, (_, i) => i + 1);
      if (orderInput) orderInput.value = pageOrder.join(",");

      // Input preview matches the default order on load.
      lastPreviewOrder = pageOrder.join(',');
      updatePreviewSyncUI();

      buildListDom(pageCount);
      attachDragHandlers();

      // Seed page 1 thumbnail from the probe.
      try {
        const url1 = URL.createObjectURL(firstBlob);
        thumbUrls.set(1, url1);
        const item1 = listEl.querySelector('.reorder-page-item[data-page="1"]');
        const img1 = item1?.querySelector('img');
        if (img1) {
          img1.src = url1;
          thumbState.set(1, "loaded");
        }
      } catch {}

      // Lazy-load thumbnails as items scroll into view.
      thumbObserver = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (!entry.isIntersecting) continue;
            const item = entry.target;
            const p = parseInt(item.dataset.page || "", 10);
            if (!Number.isFinite(p) || p < 1) continue;
            if (thumbState.get(p) === "loaded" || thumbState.get(p) === "loading") continue;
            const img = item.querySelector("img");
            if (!img) continue;

            thumbState.set(p, "loading");
            enqueue(async () => {
              // If user changed files mid-load, drop it.
              if (myToken !== buildToken) return null;
              if (!currentThumbFile) return null;
              const url = await fetchThumb(currentThumbFile, p, 96);
              return url;
            })
              .then((url) => {
                if (!url) return;
                if (myToken !== buildToken) return;
                img.src = url;
                thumbState.set(p, "loaded");
              })
              .catch(() => {
                // Keep placeholder; user can still drag/order.
                thumbState.delete(p);
              });
          }
        },
        { root: listEl, threshold: 0.12 }
      );

      for (const item of Array.from(listEl.querySelectorAll(".reorder-page-item"))) {
        thumbObserver.observe(item);
      }
    } catch (e) {
      if (myToken !== buildToken) return;
      setListEmpty(e?.message || "Failed to generate pages.");
    }
  }

  async function serverSaysEncrypted(file) {
    try {
      const fd = new FormData();
      fd.append('file', file);
      fd.append('page', '1');
      fd.append('dpi', '50');
      const res = await fetch('/api/render/page', { method: 'POST', body: fd });
      if (res.ok) {
        // We don't need the image; just a signal.
        try {
          const b = await res.blob();
          // revoke quickly
          const u = URL.createObjectURL(b);
          setTimeout(() => { try { URL.revokeObjectURL(u); } catch {} }, 1000);
        } catch {}
        return false;
      }
      const data = await res.json().catch(() => null);
      const msg = String((data?.error || data?.message || '').toString());
      return /password|encrypt/i.test(msg);
    } catch {
      return false;
    }
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      enc = false;
      clearThumbs();
      lastPreviewOrder = null;
      updatePreviewSyncUI();
      setListEmpty("Upload a PDF to generate draggable pages.");
      return setEmptyPreview('Upload a PDF to preview it here.');
    }

    // Fail-closed: block iframe until encryption status is known.
    enc = true;
    setEmptyPreview('Checking encryptionâ€¦');
    clearThumbs();
    setListEmpty("Checking encryptionâ€¦");

    let encrypted = true
    try {
      encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        // Extra safety: some encrypted PDFs may evade token scan.
        encrypted = await serverSaysEncrypted(f);
      }
    } catch {
      encrypted = true
    }

    enc = encrypted
    if (enc) {
      lastPreviewOrder = null;
      updatePreviewSyncUI();
      setListEmpty('Encrypted PDF â€” enter the password and click "Decrypt / Unlock" to build draggable pages.');
      return setEmptyPreview('Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.');
    }

    setPreviewFile(f);
    buildPageList(f);
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting...';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      resetPrepared();
      if (previewHint) {
        try { previewHint.style.display = 'none'; } catch {}
      }
      try { if (previewHint) previewHint.style.display = 'none'; } catch {}
      setPreviewFile(unlocked);
      buildPageList(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  exportBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    let order = String(orderInput?.value || '').trim();
    if (!order && pageOrder && pageOrder.length) {
      order = pageOrder.join(',');
      if (orderInput) orderInput.value = order;
    }
    if (!order) return alert('Enter a page order (e.g., 3,1,2) || drag pages to set the order.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);
    fd.append('order', order);

    const out = await runPaidPdfExport({
      tool: 'reorder',
      endpoint: ENDPOINTS.REORDER,
      formData: fd,
      filename: 'pdfrealm-reordered.pdf',
      setPreviewFrameId: frameId,
      placeholderId,
    });

    if (out?.ok) {
      lastPreviewOrder = order;
      updatePreviewSyncUI();
    }
  });

  async function refreshReorderPreview() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    // Prefer the drag-derived order; fall back to the input box.
    let order = currentOrderString();
    if (!order) order = String(orderInput?.value || '').trim();
    if (!order) return alert('Set a page order first (drag pages || type an order).');

    const nums = parseOrderInput(order);
    if (pageCount && nums.length && nums.length != pageCount) {
      return alert('Order must include exactly ' + pageCount + ' pages.');
    }
    if (nums.length) order = nums.join(',');

    if (refreshBtn) {
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'Refreshing...';
    }

    try {
      const fd = new FormData();
      fd.append('file', unlocked || f);
      fd.append('order', order);

      // Preview-only run (no download).
      revokeOutUrl();
      revokePreviewUrl();
      const out = await runPaidPdfExport({
        tool: 'reorder',
        endpoint: ENDPOINTS.REORDER,
        formData: fd,
        filename: null,
        setPreviewFrameId: frameId,
        placeholderId,
      });

      if (out?.ok && out.objectUrl) {
        previewOutUrl = out.objectUrl;
        lastPreviewOrder = order;
        updatePreviewSyncUI();
      }
    } finally {
      if (refreshBtn) refreshBtn.textContent = 'Refresh Preview';
      updatePreviewSyncUI();
    }
  }

  refreshBtn?.addEventListener('click', () => {
    refreshReorderPreview();
  });

  // Initial
  setEmptyPreview('Upload a PDF to preview it here.');
  setListEmpty("Upload a PDF to generate draggable pages.");

  updatePreviewSyncUI();

  resetBtn?.addEventListener("click", () => {
    resetToOriginalOrder();
  });

  orderInput?.addEventListener("change", () => {
    syncListFromInput();
  });
}
// -------------------- Docs (invoice / receipt / paystub) --------------------
function initDocs() {
  function getDocModel(kind) {
    if (kind === "invoice") {
      return {
        kind: "invoice",
        senderName: $("invSenderName")?.value || "",
        senderCompany: $("invSenderCompany")?.value || "",
        senderAddress: $("invSenderAddress")?.value || "",
        senderPhone: $("invSenderPhone")?.value || "",
        senderEmail: $("invSenderEmail")?.value || "",
        senderWebsite: $("invSenderWebsite")?.value || "",
        to: $("invTo")?.value || "",
        invoice_number: $("invNumber")?.value || "",
        amount: $("invAmount")?.value || "",
        notes: $("invNotes")?.value || "",
      };
    }

    if (kind === "receipt") {
      return {
        kind: "receipt",
        senderName: $("recSenderName")?.value || "",
        senderCompany: $("recSenderCompany")?.value || "",
        senderAddress: $("recSenderAddress")?.value || "",
        senderPhone: $("recSenderPhone")?.value || "",
        senderEmail: $("recSenderEmail")?.value || "",
        senderWebsite: $("recSenderWebsite")?.value || "",
        to: $("recTo")?.value || "",
        amount: $("recAmount")?.value || "",
        reason: $("recReason")?.value || "",
        method: $("recMethod")?.value || "",
      };
    }

    return {
      kind: "paystub",
      employee: $("psEmployee")?.value || "",
      employer: $("psEmployer")?.value || "",
      gross: $("psGross")?.value || "",
      deductions: $("psDeductions")?.value || "",
      period: $("psPeriod")?.value || "",
      payPeriodStart: $("psPeriodStart")?.value || "",
      payPeriodEnd: $("psPeriodEnd")?.value || "",
    };
  }

  function buildDocsPreviewHtml(model) {
    const kind = model.kind;
    const title = kind === "invoice" ? "INVOICE" : kind === "receipt" ? "RECEIPT" : "PAYSTUB";
    const today = new Date().toLocaleDateString();

    const senderBlock =
      kind === "paystub"
        ? `
      <div class="row">
        <div class="block">
          <div class="label">Employer</div>
          <div class="value">${escapeHtml(model.employer || "")}</div>
        </div>
      </div>
    `
        : `
      <div class="row">
        <div class="block">
          <div class="label">From</div>
          <div class="value">
            ${escapeHtml(model.senderName || "")}<br/>
            ${escapeHtml(model.senderCompany || "")}<br/>
            ${escapeHtml(model.senderAddress || "")}<br/>
            ${escapeHtml(model.senderPhone || "")}<br/>
            ${escapeHtml(model.senderEmail || "")}<br/>
            ${escapeHtml(model.senderWebsite || "")}
          </div>
        </div>
      </div>
    `;

    let bodySpecific = "";

    if (kind === "invoice") {
      bodySpecific = `
        <div class="row">
          <div class="block">
            <div class="label">Bill To</div>
            <div class="value">${escapeHtml(model.to || "")}</div>
          </div>
          <div class="block">
            <div class="label">Invoice #</div>
            <div class="value">${escapeHtml(model.invoice_number || "")}</div>
          </div>
          <div class="block">
            <div class="label">Amount</div>
            <div class="value big">${escapeHtml(model.amount || "")}</div>
          </div>
        </div>
        <div class="row">
          <div class="block full">
            <div class="label">Notes</div>
            <div class="value">${escapeHtml(model.notes || "")}</div>
          </div>
        </div>
      `;
    } else if (kind === "receipt") {
      bodySpecific = `
        <div class="row">
          <div class="block">
            <div class="label">Receipt For</div>
            <div class="value">${escapeHtml(model.to || "")}</div>
          </div>
          <div class="block">
            <div class="label">Amount</div>
            <div class="value big">${escapeHtml(model.amount || "")}</div>
          </div>
          <div class="block">
            <div class="label">Method</div>
            <div class="value">${escapeHtml(model.method || "")}</div>
          </div>
        </div>
        <div class="row">
          <div class="block full">
            <div class="label">Reason</div>
            <div class="value">${escapeHtml(model.reason || "")}</div>
          </div>
        </div>
      `;
    } else {
      const payPeriodText =
        model.payPeriodStart || model.payPeriodEnd
          ? `${model.payPeriodStart || ""} â€“ ${model.payPeriodEnd || ""}`
          : model.period || "";

      bodySpecific = `
        <div class="row">
          <div class="block">
            <div class="label">Employee</div>
            <div class="value">${escapeHtml(model.employee || "")}</div>
          </div>
          <div class="block">
            <div class="label">Employer</div>
            <div class="value">${escapeHtml(model.employer || "")}</div>
          </div>
          <div class="block">
            <div class="label">Pay Period</div>
            <div class="value">${escapeHtml(payPeriodText || "")}</div>
          </div>
        </div>
        <div class="row">
          <div class="block">
            <div class="label">Gross Pay</div>
            <div class="value big">${escapeHtml(model.gross || "")}</div>
          </div>
          <div class="block">
            <div class="label">Deductions</div>
            <div class="value">${escapeHtml(model.deductions || "")}</div>
          </div>
          <div class="block">
            <div class="label">Net Pay</div>
            <div class="value big">
              ${escapeHtml(model.gross || "")}
            </div>
          </div>
        </div>
      `;
    }

    return `
<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>${escapeHtml(title)} Preview</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    html,body{margin:0;padding:0;background:#f3f4f6;color:#111827;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif;}
    .page{max-width:900px;margin:24px auto;background:#ffffff;border-radius:12px;border:1px solid #e5e7eb;box-shadow:0 10px 30px rgba(15,23,42,.18);padding:24px 24px 28px;}
    .top-row{display:flex;justify-content:space-between;gap:24px;align-items:flex-start;border-bottom:1px solid #e5e7eb;padding-bottom:16px;margin-bottom:18px;}
    .logo-box{width:150px;height:90px;border-radius:10px;border:1px dashed #d1d5db;display:flex;align-items:center;justify-content:center;font-size:0.8rem;color:#6b7280;text-align:center;padding:6px;box-sizing:border-box;overflow:hidden;position:relative;}
    .logo-placeholder{width:100%;height:100%;display:flex;align-items:center;justify-content:center;text-align:center;font-size:0.75rem;color:#9ca3af;padding:4px;box-sizing:border-box;}
    .logo-box img{max-width:100%;max-height:80px;object-fit:contain;border-radius:10px;position:relative;left:0;top:0;display:none;cursor:grab;}
    .doc-meta{text-align:right;}
    .doc-title{font-size:1.4rem;font-weight:800;letter-spacing:.12em;}
    .doc-date{margin-top:6px;font-size:.9rem;color:#6b7280;}
    .row{display:flex;flex-wrap:wrap;gap:16px;margin-bottom:12px;}
    .block{flex:1 1 180px;padding:12px 12px;border-radius:10px;background:#f9fafb;border:1px solid #e5e7eb;}
    .block.full{flex-basis:100%;}
    .label{font-size:.78rem;text-transform:uppercase;letter-spacing:.12em;color:#6b7280;margin-bottom:6px;}
    .value{font-size:.95rem;white-space:pre-line;}
    .big{font-size:1.05rem;font-weight:750;}
  </style>
</head>
<body>
  <div class="page">
    <div class="top-row">
      <div class="logo-box" id="logoBox">
        <div class="logo-placeholder" id="logoPlaceholder">
          Logo can be added here in the pop-out window (optional).
        </div>
        <img id="logoImg" alt="Logo"/>
      </div>
      <div class="doc-meta">
        <div class="doc-title">${escapeHtml(title)}</div>
        <div class="doc-date">Preview â€¢ ${escapeHtml(today)}</div>
      </div>
    </div>

    ${senderBlock}
    ${bodySpecific}
  </div>

  <script>
    (function(){
      var isPopup = !!window.opener;
      var box = document.getElementById("logoBox");
      var placeholder = document.getElementById("logoPlaceholder");
      var img = document.getElementById("logoImg");
      if (!box || !img || !placeholder) return;

      if (!isPopup) return;

      var input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.style.display = "none";
      document.body.appendChild(input);

      box.style.cursor = "pointer";
      box.title = "Click to upload a logo, then drag to position it";

      box.addEventListener("click", function(){ input.click(); });

      input.addEventListener("change", function(){
        var f = input.files && input.files[0];
        if (!f) return;
        var url = URL.createObjectURL(f);
        img.src = url;
        img.style.display = "block";
        placeholder.style.display = "none";
      });

      var dragging = false;
      var startX = 0, startY = 0;
      var origX = 0, origY = 0;

      img.addEventListener("pointerdown", function(e){
        if (!img.src) return;
        dragging = true;
        img.setPointerCapture(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        origX = parseFloat(img.style.left || "0");
        origY = parseFloat(img.style.top || "0");
        img.style.cursor = "grabbing";
        e.preventDefault();
      });

      img.addEventListener("pointermove", function(e){
        if (!dragging) return;
        var dx = e.clientX - startX;
        var dy = e.clientY - startY;
        img.style.left = (origX + dx) + "px";
        img.style.top  = (origY + dy) + "px";
      });

      img.addEventListener("pointerup", function(){
        dragging = false;
        img.style.cursor = "grab";
      });

      img.addEventListener("pointercancel", function(){
        dragging = false;
        img.style.cursor = "grab";
      });
    })();
  </script>
</body>
</html>
    `;
  }

  function setPreviewFromModel(kind) {
    try {
      const model = getDocModel(kind);
      const html = buildDocsPreviewHtml(model);
      const blob = new Blob([html], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      setIframeSrc("invoicePreviewFrame", url);
      showPlaceholder("invoicePreviewPlaceholder", false);
      const frame = $("invoicePreviewFrame");
      if (frame) frame.classList.add("active");
    } catch (e) {
      console.error("Docs preview error:", e);
      alert("Preview failed: " + (e.message || "Unknown error"));
    }
  }

  async function exportDoc(kind, endpoint, filename) {
    const fd = new FormData();
    const model = getDocModel(kind);
    for (const [k, v] of Object.entries(model)) fd.append(k, v);

    await runPaidPdfExport({
      tool: kind,
      endpoint,
      formData: fd,
      filename,
      setPreviewFrameId: "invoicePreviewFrame",
      placeholderId: "invoicePreviewPlaceholder",
    });
  }

  $("invoicePreviewBtn")?.addEventListener("click", () => setPreviewFromModel("invoice"));
  $("receiptPreviewBtn")?.addEventListener("click", () => setPreviewFromModel("receipt"));
  $("paystubPreviewBtn")?.addEventListener("click", () => setPreviewFromModel("paystub"));

  $("invoiceExportBtn")?.addEventListener("click", () => exportDoc("invoice", ENDPOINTS.INVOICE, "pdfrealm-invoice.pdf"));
  $("receiptExportBtn")?.addEventListener("click", () => exportDoc("receipt", ENDPOINTS.RECEIPT, "pdfrealm-receipt.pdf"));
  $("paystubExportBtn")?.addEventListener("click", () => exportDoc("paystub", ENDPOINTS.PAYSTUB, "pdfrealm-paystub.pdf"));
}

// -------------- Convert (documents + images) --------------
function initConvert() {
  function wirePdfPreview(inputId, frameId, placeholderId) {
    const inp = $(inputId);
    if (!inp) return;
    inp.addEventListener("change", () => {
      const f = inp.files && inp.files[0];
      if (!f) return;
      const url = makeObjectUrlFromFile(f);
      if (frameId) setIframeSrc(frameId, url);
      if (placeholderId) showPlaceholder(placeholderId, false);
    });
  }

  // Image input previews (use the same iframe previewer for consistency)
  wirePdfPreview("jpgToPngFile", "jpg2pngPreviewFrame", "jpg2pngPreviewPlaceholder");
  wirePdfPreview("pngToJpgFile", "png2jpgPreviewFrame", "png2jpgPreviewPlaceholder");
  

  // ---- Word â†’ PDF (split preview: input left, output right) ----
  function initWordToPdfSplit() {
    const fileInput = $("w2pFile");
    const pwInput = $("w2pPassword");
    const previewInputBtn = $("w2pPreviewBtn");
    const convertPreviewBtn = $("wordToPdfPreviewBtn");
    const exportBtn = $("wordToPdfExportBtn");
    const statusEl = $("w2pStatus");

    const inputHost = $("w2pInputPreviewHost");
    const outputHost = $("w2pOutputPreviewHost");

    if (!fileInput || !previewInputBtn || !convertPreviewBtn || !exportBtn || !inputHost || !outputHost) return;

    // Keep output preview clean (no browser PDF tools, no context menu)
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    // PDF.js bootstrap (dynamic import; matches our OCR/QuickSign pattern)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    function renderInputHtml(html) {
      inputHost.innerHTML = "";
      const iframe = document.createElement("iframe");
      // No scripts; same-origin so CSS applies; srcdoc is isolated.
      iframe.setAttribute("sandbox", "allow-same-origin");
      iframe.style.width = "100%";
      iframe.style.height = "100%";
      iframe.style.border = "0";
      iframe.style.background = "white";

      // Wrap in a minimal document so the preview is readable.
      const doc = `<!doctype html><html><head><meta charset="utf-8" />
        <style>
          body{margin:0;padding:18px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#111;background:#fff;}
          img{max-width:100%;height:auto;}
          table{max-width:100%;}
        </style></head><body>${html || "<div>No preview available.</div>"}</body></html>`;
      iframe.srcdoc = doc;
      inputHost.appendChild(iframe);
      showPlaceholder("w2pInputPlaceholder", false);
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      // Render up to 10 pages for preview (scrollable).
      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("w2pOutputPlaceholder", false);
    }

    async function callJson(endpoint, fd) {
      const token = getToken();
      const headers = {};
      if (token) headers["Authorization"] = `Bearer ${token}`;
      const res = await fetch(endpoint, { method: "POST", headers, body: fd });
      let data = null;
      try { data = await res.json(); } catch {}
      if (!res.ok) {
        const msg = data?.error || data?.message || `Request failed (${res.status})`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
      }
      return data;
    }

    async function callBlob(endpoint, fd) {
      const token = getToken();
      const headers = {};
      if (token) headers["Authorization"] = `Bearer ${token}`;
      const res = await fetch(endpoint, { method: "POST", headers, body: fd });
      if (!res.ok) {
        let data = null;
        try { data = await res.json(); } catch {}
        const msg = data?.error || data?.message || `Request failed (${res.status})`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
      }
      return await res.blob();
    }

    function buildFormData() {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return null;
      const fd = new FormData();
      fd.append("file", f);
      const pw = pwInput ? String(pwInput.value || "") : "";
      if (pw) fd.append("password", pw);
      return fd;
    }

    async function previewInput() {
      const fd = buildFormData();
      if (!fd) return alert("Upload a Word document first.");
      setStatus("Generating input preview...");
      try {
        const out = await callJson(ENDPOINTS.WORD_TO_PDF_INPUT_PREVIEW, fd);
        renderInputHtml(out.html || "");
        setStatus("");
      } catch (e) {
        setStatus(e.message || "Input preview failed.");
      }
    }

    async function convertPreview() {
      const fd = buildFormData();
      if (!fd) return alert("Upload a Word document first.");
      setStatus("Converting to PDF (preview)...");
      exportBtn.disabled = true;
      try {
        const blob = await callBlob(ENDPOINTS.WORD_TO_PDF_PREVIEW, fd);
        lastOutputBlob = blob;
        await renderPdfBlobToHost(blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch (e) {
        setStatus(e.message || "Convert preview failed.");
      }
    }

    async function exportPdf() {
      const fd = buildFormData();
      if (!fd) return alert("Upload a Word document first.");
      // Use original filename if available
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-word");
      const filename = `${base}.pdf`;

      setStatus("Exporting PDF...");
      const out = await runPaidPdfExport({
        tool: "word-to-pdf",
        endpoint: ENDPOINTS.WORD_TO_PDF,
        formData: fd,
        filename,
        setPreviewFrameId: null,
        placeholderId: null,
      });

      if (out && out.ok && out.blob) {
        lastOutputBlob = out.blob;
        try { await renderPdfBlobToHost(out.blob, outputHost); } catch {}
        exportBtn.disabled = false;
        setStatus("Exported.");
      }
    }

    // Auto-preview input on file select
    fileInput.addEventListener("change", () => {
      exportBtn.disabled = true;
      showPlaceholder("w2pOutputPlaceholder", true);
      showPlaceholder("w2pInputPlaceholder", true);
      // clear hosts
      inputHost.innerHTML = "";
      outputHost.innerHTML = "";
      setStatus("");
      previewInput();
    });

    previewInputBtn.addEventListener("click", previewInput);
    convertPreviewBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportPdf);
  }

  function wireConversionButton({ buttonId, fileInputId, endpoint, tool, filename, multiple = false, previewFrameId = null, placeholderId = null }) {
    const btn = $(buttonId);
    if (!btn) return;

    btn.addEventListener("click", async () => {
      const inp = $(fileInputId);
      if (!inp) return alert("Missing input for " + tool);

      const files = multiple ? Array.from(inp.files || []) : (inp.files && [inp.files[0]]) || [];
      if (!files.length) return alert("Upload a file first.");

      const fd = new FormData();
      if (multiple) files.forEach((f) => fd.append("files", f));
      else fd.append("file", files[0]);

      await runPaidPdfExport({
        tool,
        endpoint,
        formData: fd,
        filename,
        setPreviewFrameId: previewFrameId,
        placeholderId: placeholderId,
      });
    });
  }
  // Word â†’ PDF (split preview)
  initWordToPdfSplit();
  // SVG â†’ PDF (split preview)
  if (typeof initSvgToPdfSplit === "function") initSvgToPdfSplit();
// PDF â†’ Images (mostly stubbed server-side)
  wireConversionButton({ buttonId: "pdfToJpgBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_JPG, tool: "pdf-to-jpg", filename: "pdfrealm-pdf-to-jpg.zip" });
  wireConversionButton({ buttonId: "pdfToPngBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_PNG, tool: "pdf-to-png", filename: "pdfrealm-pdf-to-png.zip" });
  wireConversionButton({ buttonId: "pdfToTiffBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_TIFF, tool: "pdf-to-tiff", filename: "pdfrealm-pdf-to-tiff.zip" });
  wireConversionButton({ buttonId: "pdfToSvgBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_SVG, tool: "pdf-to-svg", filename: "pdfrealm-pdf-to-svg.zip" });
  wireConversionButton({ buttonId: "tiffToPdfBtn", fileInputId: "tiffToPdfFile", endpoint: ENDPOINTS.TIFF_TO_PDF, tool: "tiff-to-pdf", filename: "pdfrealm-tiff.pdf", previewFrameId: "tiff2pdfPreviewFrame", placeholderId: "tiff2pdfPreviewPlaceholder" });

  // Image â†” Image (stubbed)
  wireConversionButton({ buttonId: "jpgToPngBtn", fileInputId: "jpgToPngFile", endpoint: ENDPOINTS.JPG_TO_PNG, tool: "jpg-to-png", filename: "pdfrealm-jpg-to-png.png" });
  wireConversionButton({ buttonId: "pngToJpgBtn", fileInputId: "pngToJpgFile", endpoint: ENDPOINTS.PNG_TO_JPG, tool: "png-to-jpg", filename: "pdfrealm-png-to-jpg.jpg" });

  // SVG / DOCX preview conversions (stubbed)
  wireConversionButton({ buttonId: "svgToPdfBtn", fileInputId: "svgToPdfFile", endpoint: ENDPOINTS.SVG_TO_PDF, tool: "svg-to-pdf", filename: "pdfrealm-svg.pdf", previewFrameId: "svg2pdfPreviewFrame", placeholderId: "svg2pdfPreviewPlaceholder" });
  wireConversionButton({ buttonId: "docxToPngBtn", fileInputId: "docxToPngFile", endpoint: ENDPOINTS.DOCX_TO_PNG, tool: "docx-to-png", filename: "pdfrealm-docx-preview.zip" });



  // ---- JPG â†’ PNG (split preview: input left, output right) ----
  function initJpgToPngSplit() {
    const fileInput = $("jpgToPngFile");
    const convertBtn = $("jpgToPngPreviewBtn");
    const exportBtn = $("jpgToPngExportBtn");
    const statusEl = $("jpg2pngStatus");
    const inputHost = $("jpg2pngInputPreviewHost");
    const outputHost = $("jpg2pngOutputPreviewHost");
    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastBlob = null;

    function setStatus(msg){ if (statusEl) statusEl.textContent = msg || ""; }

    function resetOutput(){
      lastBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("jpg2pngOutputPlaceholder", true);
    }
    function resetInput(){
      if (inputUrl) { try { URL.revokeObjectURL(inputUrl); } catch {} }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("jpg2pngInputPlaceholder", true);
    }

    fileInput.addEventListener("change", () => {
      resetOutput(); resetInput();
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      inputUrl = URL.createObjectURL(f);
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "JPG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);
      showPlaceholder("jpg2pngInputPlaceholder", false);
      setStatus("");
    });

    async function convertPreview(){
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a JPG first.");
      convertBtn.disabled = true;
      resetOutput();
      setStatus("Converting to PNG...");
      try{
        const bitmap = await createImageBitmap(f);
        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(bitmap, 0, 0);
        const blob = await new Promise((resolve)=>canvas.toBlob(resolve, "image/png", 1.0));
        if (!blob) throw new Error("Failed to encode PNG.");
        lastBlob = blob;

        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        img.alt = "PNG output preview";
        img.draggable = false;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.borderRadius = "12px";
        img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        img.style.background = "white";
        outputHost.innerHTML = "";
        outputHost.appendChild(img);
        showPlaceholder("jpg2pngOutputPlaceholder", false);

        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch(e){
        console.error(e);
        alert(String(e?.message || e || "Conversion failed."));
        setStatus("");
      } finally{
        convertBtn.disabled = false;
      }
    }

    function exportPng(){
      if (!lastBlob) return alert("Convert (preview) first.");
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-jpg");
      downloadBlob(lastBlob, `${base}.png`);
    }

    convertBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportPng);
  }

  // ---- PNG â†’ JPG (split preview: input left, output right) ----
  function initPngToJpgSplit() {
    const fileInput = $("pngToJpgFile");
    const convertBtn = $("pngToJpgPreviewBtn");
    const exportBtn = $("pngToJpgExportBtn");
    const statusEl = $("png2jpgStatus");
    const inputHost = $("png2jpgInputPreviewHost");
    const outputHost = $("png2jpgOutputPreviewHost");
    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastBlob = null;

    function setStatus(msg){ if (statusEl) statusEl.textContent = msg || ""; }

    function resetOutput(){
      lastBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("png2jpgOutputPlaceholder", true);
    }
    function resetInput(){
      if (inputUrl) { try { URL.revokeObjectURL(inputUrl); } catch {} }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("png2jpgInputPlaceholder", true);
    }

    fileInput.addEventListener("change", () => {
      resetOutput(); resetInput();
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      inputUrl = URL.createObjectURL(f);
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "PNG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);
      showPlaceholder("png2jpgInputPlaceholder", false);
      setStatus("");
    });

    async function convertPreview(){
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a PNG first.");
      convertBtn.disabled = true;
      resetOutput();
      setStatus("Converting to JPG...");
      try{
        const bitmap = await createImageBitmap(f);
        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext("2d");
        // Fill white background (PNG may have alpha)
        ctx.fillStyle = "white";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(bitmap, 0, 0);
        const blob = await new Promise((resolve)=>canvas.toBlob(resolve, "image/jpeg", 0.95));
        if (!blob) throw new Error("Failed to encode JPG.");
        lastBlob = blob;

        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        img.alt = "JPG output preview";
        img.draggable = false;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.borderRadius = "12px";
        img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        img.style.background = "white";
        outputHost.innerHTML = "";
        outputHost.appendChild(img);
        showPlaceholder("png2jpgOutputPlaceholder", false);

        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch(e){
        console.error(e);
        alert(String(e?.message || e || "Conversion failed."));
        setStatus("");
      } finally{
        convertBtn.disabled = false;
      }
    }

    function exportJpg(){
      if (!lastBlob) return alert("Convert (preview) first.");
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-png");
      downloadBlob(lastBlob, `${base}.jpg`);
    }

    convertBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportJpg);
  }

  // ---- DOCX â†’ PNG (split preview: input left, output right; export ZIP) ----
  function initDocxToPngSplit() {
    const fileInput = $("docxToPngFile");
    const pwInput = $("docxToPngPassword");
    const previewInputBtn = $("d2pPreviewBtn");
    const convertBtn = $("docxToPngPreviewBtn");
    const exportBtn = $("docxToPngExportBtn");
    const statusEl = $("docx2pngStatus");

    const inputHost = $("docx2pngInputPreviewHost");
    const outputHost = $("docx2pngOutputPreviewHost");

    if (!fileInput || !previewInputBtn || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let lastZipBlob = null;
    let previewUrls = [];

    function setStatus(msg){ if (statusEl) statusEl.textContent = msg || ""; }

    function cleanupPreviewUrls(){
      for (const u of previewUrls) { try { URL.revokeObjectURL(u); } catch {} }
      previewUrls = [];
    }

    function resetOutput(){
      cleanupPreviewUrls();
      lastZipBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("docx2pngOutputPlaceholder", true);
    }

    function resetInput(){
      inputHost.innerHTML = "";
      showPlaceholder("docx2pngInputPlaceholder", true);
    }

    function buildFormData(){
      const f = fileInput.files && fileInput.files[0];
      if (!f) return null;
      const fd = new FormData();
      fd.append("file", f);
      const pw = (pwInput?.value || "").trim();
      if (pw) fd.append("password", pw);
      return fd;
    }

    function renderInputHtml(html){
      inputHost.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.background = "white";
      wrap.style.borderRadius = "12px";
      wrap.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      wrap.style.padding = "16px";
      wrap.style.maxWidth = "980px";
      wrap.style.margin = "0 auto";
      wrap.innerHTML = html || "<div class='muted'>No preview.</div>";
      inputHost.appendChild(wrap);
      showPlaceholder("docx2pngInputPlaceholder", false);
    }

    // PDF.js bootstrap
    let _pdfJsPromise = null;
    async function getPdfJsAsync(){
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async ()=>{
        try{
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch(e1){
          try{
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch(e2){
            console.error("PDF.js failed to load.", e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    // JSZip bootstrap
    let _jsZipPromise = null;
    async function getJsZipAsync(){
      if (_jsZipPromise) return _jsZipPromise;
      _jsZipPromise = (async ()=>{
        try{
          const mod = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm');
          return mod?.default || mod;
        } catch(e1){
          try{
            await import('https://unpkg.com/jszip@3.10.1/dist/jszip.min.js');
            return window.JSZip || null;
          } catch(e2){
            console.error("JSZip failed to load.", e1, e2);
            return window.JSZip || null;
          }
        }
      })();
      return _jsZipPromise;
    }

    async function previewInput(){
      const fd = buildFormData();
      if (!fd) return alert("Upload a DOCX first.");
      setStatus("Generating input preview...");
      try{
        const out = await callJson(ENDPOINTS.WORD_TO_PDF_INPUT_PREVIEW, fd);
        renderInputHtml(out.html || "");
        setStatus("");
      } catch(e){
        setStatus(e.message || "Input preview failed.");
      }
    }

    async function convertPreview(){
      const fd = buildFormData();
      if (!fd) return alert("Upload a DOCX first.");
      convertBtn.disabled = true;
      resetOutput();
      setStatus("Converting DOCX â†’ PDF...");
      try{
        const pdfBlob = await callBlob(ENDPOINTS.WORD_TO_PDF_PREVIEW, fd);
        const pdfBytes = new Uint8Array(await pdfBlob.arrayBuffer());
        setStatus("Rendering pages...");
        const pdfjs = await getPdfJsAsync();
        if (!pdfjs) throw new Error("PDF.js failed to load.");
        const JSZip = await getJsZipAsync();
        if (!JSZip) throw new Error("JSZip failed to load.");

        const pw = (pwInput?.value || "").trim();
        const task = pdfjs.getDocument({ data: pdfBytes, password: pw || undefined });
        if (pw) task.onPassword = (updatePassword)=>updatePassword(pw);
        const doc = await task.promise;

        const zip = new JSZip();
        outputHost.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.flexDirection = "column";
        wrap.style.gap = "12px";
        wrap.style.alignItems = "center";
        outputHost.appendChild(wrap);

        const previewPages = Math.min(doc.numPages, 6);
        const scaleFull = 3.0; // full quality

        for (let i=1;i<=doc.numPages;i++){
          setStatus(`Rendering page ${i}/${doc.numPages}...`);
          const page = await doc.getPage(i);
          const viewport = page.getViewport({ scale: scaleFull });

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);

          await page.render({ canvasContext: ctx, viewport }).promise;

          const blob = await new Promise((resolve)=>canvas.toBlob(resolve, "image/png", 1.0));
          if (!blob) throw new Error("Failed to encode PNG.");
          zip.file(`page-${String(i).padStart(3,"0")}.png`, blob);

          if (i<=previewPages){
            const url = URL.createObjectURL(blob);
            previewUrls.push(url);
            const img = document.createElement("img");
            img.src = url;
            img.alt = `Page ${i}`;
            img.draggable = false;
            img.style.maxWidth = "100%";
            img.style.height = "auto";
            img.style.borderRadius = "12px";
            img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
            img.style.background = "white";
            wrap.appendChild(img);
          }

          canvas.width = 0; canvas.height = 0;
        }

        showPlaceholder("docx2pngOutputPlaceholder", false);
        setStatus("Building ZIP...");
        lastZipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch(e){
        console.error(e);
        alert(String(e?.message || e || "Conversion failed."));
        setStatus("");
      } finally{
        convertBtn.disabled = false;
      }
    }

    function exportZip(){
      if (!lastZipBlob) return alert("Convert (preview) first.");
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-docx");
      downloadBlob(lastZipBlob, `${base}-png.zip`);
    }

    previewInputBtn.addEventListener("click", previewInput);
    convertBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportZip);

    fileInput.addEventListener("change", ()=>{ resetInput(); resetOutput(); });
  }

  // Kick off split conversions for these tools
  initJpgToPngSplit();
  initPngToJpgSplit();
  initDocxToPngSplit();

}


// -------------------- Rotate (interactive preview) --------------------

function initRotateInteractive() {
  const fileInput = $("rotatePdfFile");
  const passInput = $("rotatePdfPassword");
  const unlockBtn = $("rotateUnlockBtn");
  const pagesInput = $("rotatePagesRange");
  const rotLabel = $("rotateRotationLabel");
  const rotateLeftBtn = $("rotateLeftBtn");
  const rotateRightBtn = $("rotateRightBtn");
  const rotateResetBtn = $("rotateResetBtn");
  const exportBtn = $("rotatePdfBtn");
  const ph = $("rotatePreviewPlaceholder");
  const stage = $("rotatePreviewStage");
  const inner = $("rotatePreviewInner");
  const img = $("rotatePreviewImg");
  const prevBtn = $("rotatePrevPageBtn");
  const nextBtn = $("rotateNextPageBtn");
  const pageInput = $("rotatePreviewPage");
  const pageCountEl = $("rotatePageCount");
  const zoomInput = $("rotateZoom");
  const zoomLabel = $("rotateZoomLabel");

  if (!fileInput || !exportBtn || !ph || !stage || !inner || !img) return;

  let currentFile = null;
  let isEncrypted = false;
  let password = "";
  let currentPage = 1;
  let pageCount = null;

  // Rotation is strictly 0/90/180/270.
  let rotationDeg = 90;

  // Zoom slider
  let zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
  const previewCache = new Map(); // key: page -> objectURL
  if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

  function clamp(n, a, b) {
    return Math.max(a, Math.min(b, n));
  }

  function normDeg(n) {
    let d = parseInt(n, 10);
    if (Number.isNaN(d)) d = 0;
    d = ((d % 360) + 360) % 360;
    return d;
  }

  function snap90(n) {
    const d = normDeg(n);
    // Ensure it's exactly one of 0,90,180,270
    return (Math.round(d / 90) % 4) * 90;
  }

  function showPlaceholder(msg) {
    ph.textContent = msg;
    ph.style.display = "";
    stage.style.display = "none";
  }

  function showStage() {
    ph.style.display = "none";
    stage.style.display = "block";
  }

  function clearCache() {
    for (const url of previewCache.values()) {
      try {
        URL.revokeObjectURL(url);
      } catch {}
    }
    previewCache.clear();
  }

  async function isProbablyEncryptedPdf(file) {
    try {
      const headSlice = file.slice(0, Math.min(65536, file.size));
      const tailSlice = file.slice(Math.max(0, file.size - 65536), file.size);
      const [headBuf, tailBuf] = await Promise.all([headSlice.arrayBuffer(), tailSlice.arrayBuffer()]);
      const dec = new TextDecoder("latin1");
      const head = dec.decode(new Uint8Array(headBuf));
      const tail = dec.decode(new Uint8Array(tailBuf));
      return /\/Encrypt\b/i.test(head) || /\/Encrypt\b/i.test(tail);
    } catch {
      return false;
    }
  }

  function computeFitScale(deg) {
    // Fit the *rotated* bounding box into the viewer wrapper.
    const wrapper = stage.parentElement;
    if (!wrapper) return 1;

    const availW = Math.max(100, wrapper.clientWidth - 24);
    const availH = Math.max(100, wrapper.clientHeight - 24);

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return 1;

    const d = snap90(deg);
    const swapped = d === 90 || d === 270;
    const rw = swapped ? h : w;
    const rh = swapped ? w : h;

    const scale = Math.min(availW / rw, availH / rh, 1.25);
    if (!Number.isFinite(scale) || scale <= 0) return 1;
    return scale;
  }

  function applyRotationAndZoom() {
    rotationDeg = snap90(rotationDeg);
    if (rotLabel) rotLabel.textContent = `${rotationDeg}Â°`;

    zoomPct = clamp(parseInt(zoomPct, 10) || 100, 50, 200);
    if (zoomInput) zoomInput.value = String(zoomPct);
    if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return;

    const swapped = rotationDeg === 90 || rotationDeg === 270;
    const rw = swapped ? h : w;
    const rh = swapped ? w : h;

    const fit = computeFitScale(rotationDeg);
    const scale = fit * (zoomPct / 100);

    // IMPORTANT: transforms do not affect layout, so we size the inner container
    // to the rotated/scaled bounding box. This prevents "cut off" areas when rotated.
    inner.style.width = `${Math.max(1, Math.round(rw * scale))}px`;
    inner.style.height = `${Math.max(1, Math.round(rh * scale))}px`;

    img.style.transform = `translate(-50%, -50%) rotate(${rotationDeg}deg) scale(${scale})`;
  }

  async function loadPreview(page) {
    if (!currentFile) return;
    const p = clamp(page, 1, pageCount || 999999);
    currentPage = p;
    if (pageInput) pageInput.value = String(currentPage);

    if (previewCache.has(currentPage)) {
      img.src = previewCache.get(currentPage);
      showStage();
      return;
    }

    showPlaceholder("Rendering previewâ€¦");
    try {
      const fd = new FormData();
      fd.append("file", currentFile);
      fd.append("page", String(currentPage));
      fd.append("dpi", "200");
      if (password) fd.append("password", password);

      const res = await fetch("/api/render/page", { method: "POST", body: fd });
      if (!res.ok) {
        const data = await res.json().catch(() => null);
        const msg = (data?.error || `Preview failed (${res.status})`).toString();
        if (/password|encrypt/i.test(msg)) {
          isEncrypted = true;
          showPlaceholder('Encrypted PDF â€” enter the password and click Decrypt / Unlock.');
          return;
        }
        throw new Error(msg);
      }

      const pc = res.headers.get("x-pdf-page-count") || res.headers.get("X-PDF-Page-Count");
      const maybeCount = pc ? parseInt(pc, 10) : NaN;
      if (Number.isFinite(maybeCount) && maybeCount > 0) {
        pageCount = maybeCount;
        if (pageCountEl) pageCountEl.textContent = String(pageCount);
      }

      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      previewCache.set(currentPage, url);
      img.src = url;
      showStage();
    } catch (e) {
      console.error(e);
      showPlaceholder(e?.message || "Preview not available");
    }
  }

  img.addEventListener("load", () => {
    // Ensure the inner container fits the rotated/scaled bounds after the image dimensions are known.
    applyRotationAndZoom();
  });

  function resetStateForFile(file) {
    currentFile = file;
    password = "";
    if (passInput) passInput.value = "";
    isEncrypted = false;
    currentPage = 1;
    pageCount = null;
    if (pageCountEl) pageCountEl.textContent = "?";
    if (pageInput) pageInput.value = "1";
    clearCache();
    // Reset rotation/zoom to sane defaults
    rotationDeg = 90;
    zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
    if (rotLabel) rotLabel.textContent = `${rotationDeg}Â°`;
  }

  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      resetStateForFile(null);
      showPlaceholder("Upload a PDF to preview. If it's encrypted, enter the password then click Decrypt / Unlock.");
      return;
    }

    resetStateForFile(f);
    showPlaceholder("Analyzing PDFâ€¦");
    isEncrypted = await detectEncryptedPdfReliable(f);
    if (isEncrypted) {
      showPlaceholder("Encrypted PDF â€” enter the password and click Decrypt / Unlock.");
      return;
    }

    await loadPreview(1);
  });

  unlockBtn?.addEventListener("click", async () => {
    if (!currentFile) return alert("Upload a PDF first.");
    const pw = String(passInput?.value || "");
    if (!pw) return alert("Enter the PDF password.");
    password = pw;
    await loadPreview(currentPage || 1);
  });

  rotateLeftBtn?.addEventListener("click", () => {
    rotationDeg = snap90(rotationDeg - 90);
    applyRotationAndZoom();
  });

  rotateRightBtn?.addEventListener("click", () => {
    rotationDeg = snap90(rotationDeg + 90);
    applyRotationAndZoom();
  });

  rotateResetBtn?.addEventListener("click", () => {
    rotationDeg = 0;
    applyRotationAndZoom();
  });

  zoomInput?.addEventListener("input", () => {
    zoomPct = clamp(parseInt(zoomInput.value || "100", 10) || 100, 50, 200);
    applyRotationAndZoom();
  });

  prevBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) - 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  nextBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) + 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  pageInput?.addEventListener("change", () => {
    const p = parseInt(pageInput.value || "1", 10) || 1;
    loadPreview(p);
  });

  exportBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    let pw = password;
    const encrypted = isEncrypted || (await detectEncryptedPdfReliable(f));

    if (encrypted && !pw) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    fd.append("file", f);

    // Only 90-degree increments, always.
    fd.append("degrees", String(snap90(rotationDeg)));

    const pagesSpec = String(pagesInput?.value || "").trim();
    if (pagesSpec) fd.append("pages", pagesSpec);

    if (encrypted && pw) {
      fd.append("password", pw);
      // Default: keep output encrypted with same password
      fd.append("outputPassword", pw);
    }

    await runPaidPdfExport({
      tool: "rotate",
      endpoint: ENDPOINTS.ROTATE,
      formData: fd,
      filename: "pdfrealm-rotated.pdf",
    });
  });

  // Initial state
  if (rotLabel) rotLabel.textContent = `${rotationDeg}Â°`;
  showPlaceholder("Upload a PDF to preview. If it's encrypted, enter the password then click Decrypt / Unlock.");
}



// -------------------- Secure single-file tools (unlock to preview/export) --------------------
function initSinglePdfToolWithUnlock({
  fileInputId,
  passwordInputId,
  unlockBtnId,
  actionBtnId,
  tool,
  endpoint,
  filename,
  previewFrameId,
  placeholderId,
  extraFields = () => ({}),
  previewBtnId = null,
  previewTool = null,
  previewEndpoint = null,
  previewHintId = null,
  exportBtnId = null,
  exportHintId = null,
  validate = null,
}) {
  const fileInput = $(fileInputId);
  const passInput = $(passwordInputId);
  const unlockBtn = $(unlockBtnId);
  const actionBtn = $(actionBtnId);

  const previewBtn = previewBtnId ? $(previewBtnId) : null;
  const previewHint = previewHintId ? $(previewHintId) : null;

  const exportBtn = exportBtnId ? $(exportBtnId) : null;
  const exportHint = exportHintId ? $(exportHintId) : null;

  if (!fileInput || !actionBtn) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmptyPreview(msg) {
    revokePreviewUrl();
    resetPrepared();
    setIframeSrc(previewFrameId, "");
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    // Hide native PDF toolbar/tools by clipping (same approach as other tabs)
    try {
      const fr = $(previewFrameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmptyPreview("Upload a PDF to preview it here.");
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(previewFrameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmptyPreview("Upload a PDF to preview it here.");

    // Block iframe load until we know encryption status (prevents browser password popups)
    setIframeSrc(previewFrameId, "");
    const ph = $(placeholderId);
    if (ph) ph.textContent = "Checking PDFâ€¦";
    showPlaceholder(placeholderId, true);

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    if (ph) ph.textContent = "Upload a PDF to preview it here.";
    setPreviewFile(f);
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decryptingâ€¦';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      resetPrepared();
      if (previewHint) {
        try { previewHint.style.display = 'none'; } catch {}
      }
      const ph = $(placeholderId);
      if (ph) ph.textContent = "Upload a PDF to preview it here.";
      setPreviewFile(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });


  // Preview (no download) â€” used by tools like Watermark / Page Numbers
  previewBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);
    const fields = extraFields() || {};
    for (const [k, v] of Object.entries(fields)) {
      if (v == null) continue;
      fd.append(k, String(v));
    }

    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }

    const btn = previewBtn;
    if (btn) {
      btn.disabled = true;
      btn.dataset._label = btn.dataset._label || btn.textContent;
      btn.textContent = 'Updatingâ€¦';
    }

    try {
      const r = await runPaidPdfExport({
        tool: previewTool || tool,
        endpoint: previewEndpoint || endpoint,
        formData: fd,
        filename: null,
        setPreviewFrameId: previewFrameId,
        placeholderId,
      });

      if (r?.ok && previewHint) {
        try { previewHint.style.display = 'block'; } catch {}
      }
    } finally {
      if (btn) {
        btn.disabled = false;
        btn.textContent = btn.dataset._label || 'Preview';
      }
    }
  });

  actionBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('action');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);
    const fields = extraFields() || {};
    for (const [k, v] of Object.entries(fields)) {
      if (v == null) continue;
      fd.append(k, String(v));
    }

    await runPaidPdfExport({
      tool,
      endpoint,
      formData: fd,
      filename,
      setPreviewFrameId: previewFrameId,
      placeholderId,
    });
  });

  // Initial state
  setEmptyPreview('Upload a PDF to preview it here.');
}

function initCompressSecure() {
  const normalizeBtn = $('compressNormalizeBtn');

  initSinglePdfToolWithUnlock({
    fileInputId: 'compressPdfFile',
    passwordInputId: 'compressPdfPassword',
    unlockBtnId: 'compressUnlockBtn',
    actionBtnId: 'compressPdfBtn',
    tool: 'compress',
    endpoint: ENDPOINTS.COMPRESS,
    filename: 'pdfrealm-compressed.pdf',
    previewFrameId: 'compressPreviewFrame',
    placeholderId: 'compressPreviewPlaceholder',  });

  // Optional: â€œDecompress / Normalizeâ€ for editing/compatibility (not a quality restore)
  if (normalizeBtn) {
    normalizeBtn.addEventListener('click', async () => {
      const inp = $('compressPdfFile');
      const f = inp?.files?.[0];
      if (!f) return alert('Upload a PDF first.');

      // Use decrypted file if the user unlocked; easiest is to read from the preview iframe URL? No.
      // Instead, if encrypted, require unlock first (same pattern as other tools).
      const encrypted = await detectEncryptedPdfReliable(f);
      const pw = String($('compressPdfPassword')?.value || '').trim();
      let work = f
      if (encrypted) {
        if (!pw) return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
        // Decrypt on the fly for normalize
        work = await decryptPdfToFile(f, pw);
      }

      const fd = new FormData();
      fd.append('file', work);

      await runPaidPdfExport({
        tool: 'normalize',
        endpoint: ENDPOINTS.QPDF_NORMALIZE,
        formData: fd,
        filename: 'pdfrealm-normalized.pdf',
        setPreviewFrameId: 'compressPreviewFrame',
        placeholderId: 'compressPreviewPlaceholder',
      });
    });
  }
}

function initWatermarkSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'watermarkPdfFile',
    previewBtnId: 'watermarkPreviewBtn',
    passwordInputId: 'watermarkPdfPassword',
    unlockBtnId: 'watermarkUnlockBtn',
    actionBtnId: 'watermarkPdfBtn',
    tool: 'watermark',
    endpoint: ENDPOINTS.WATERMARK,
    filename: 'pdfrealm-watermarked.pdf',
    previewFrameId: 'watermarkPreviewFrame',
    placeholderId: 'watermarkPreviewPlaceholder',
    extraFields: () => ({ text: String($('watermarkText')?.value || '').trim() || 'CONFIDENTIAL' }),
  });
}

function initPageNumsSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'pageNumsPdfFile',
    previewBtnId: 'pageNumsPreviewBtn',
    previewHintId: 'pageNumsPreviewHint',
    passwordInputId: 'pageNumsPdfPassword',
    unlockBtnId: 'pageNumsUnlockBtn',
    actionBtnId: 'pageNumsBtn',
    tool: 'page-numbers',
    endpoint: ENDPOINTS.PAGE_NUMBERS,
    filename: 'pdfrealm-page-numbers.pdf',
    previewFrameId: 'pageNumsPreviewFrame',
    placeholderId: 'pageNumsPreviewPlaceholder',
    extraFields: () => ({
      start: String(parseInt(String($('pageNumsStart')?.value || '1'), 10) || 1),
      prefix: String($('pageNumsPrefix')?.value || ''),
    }),
  });
}


function initMetadataSecure() {
  const fileInput = $('metaPdfFile');
  const passInput = $('metaPdfPassword');
  const unlockBtn = $('metaUnlockBtn');
  const removeBtn = $('metaRemoveBtn');
  const applyBtn = $('metaApplyBtn');
  const exportBtn = $('metaExportBtn');
  const exportHint = $('metaExportHint');
  const previewFrameId = 'metaPreviewFrame';
  const placeholderId = 'metaPreviewPlaceholder';

  if (!fileInput || !removeBtn || !applyBtn || !exportBtn) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmptyPreview(msg) {
    revokePreviewUrl();
    resetPrepared();
    setIframeSrc(previewFrameId, '');
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    // Hide native PDF toolbar/tools by clipping (same approach as other tabs)
    try {
      const fr = $(previewFrameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmptyPreview('Upload a PDF to preview it here.');
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(previewFrameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmptyPreview('Upload a PDF to preview it here.');

    // Block iframe load until we know encryption status (prevents browser password popups)
    setIframeSrc(previewFrameId, '');
    const ph = $(placeholderId);
    if (ph) ph.textContent = 'Checking PDFâ€¦';
    showPlaceholder(placeholderId, true);

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    if (ph) ph.textContent = 'Upload a PDF to preview it here.';
    setPreviewFile(f);
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decryptingâ€¦';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      resetPrepared();
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Upload a PDF to preview it here.';
      setPreviewFile(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  async function runMeta(kind) {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);

    const isApply = kind === 'apply';
    if (isApply) {
      fd.append('title', String($('metaTitle')?.value || ''));
      fd.append('author', String($('metaAuthor')?.value || ''));
      fd.append('subject', String($('metaSubject')?.value || ''));
      fd.append('keywords', String($('metaKeywords')?.value || ''));
    }

    const btn = isApply ? applyBtn : removeBtn;
    const originalLabel = btn?.textContent || (isApply ? 'Apply Metadata' : 'Remove Metadata');

    if (btn) {
      btn.disabled = true;
      btn.dataset._label = btn.dataset._label || originalLabel;
      btn.textContent = 'Workingâ€¦';
    }

    try {      const out = await runPaidPdfExport({
        tool: isApply ? 'meta-apply' : 'meta-remove',
        endpoint: isApply ? ENDPOINTS.META_APPLY : ENDPOINTS.META_REMOVE,
        formData: fd,
        filename: null, // preview only; Export button controls downloads
        setPreviewFrameId: previewFrameId,
        placeholderId: placeholderId,
      });
      if (out?.ok) {
        try { if (processedUrl && processedUrl !== out.objectUrl) URL.revokeObjectURL(processedUrl); } catch {}
        processedUrl = out.objectUrl;
        lastBlob = out.blob;
        lastKind = kind;
        lastFilename = isApply ? 'pdfrealm-metadata-applied.pdf' : 'pdfrealm-metadata-sanitized.pdf';
        if (exportBtn) exportBtn.disabled = false;
        if (exportHint) exportHint.textContent = 'Preview ready. Click Export to download.';
      }

    } finally {
      if (btn) {
        btn.disabled = false;
        btn.textContent = btn.dataset._label || originalLabel;
      }
    }
  }

  removeBtn.addEventListener('click', () => runMeta('remove'));
  applyBtn.addEventListener('click', () => runMeta('apply'));

  // Export downloads only (Remove/Apply are preview-only)
  if (exportBtn) exportBtn.disabled = true;
  exportBtn.addEventListener('click', () => {
    if (!lastBlob || !lastFilename) {
      return alert('Click a Preview button first (Remove or Apply), then click Export to download.');
    }
    downloadBlob(lastBlob, lastFilename);
  });

  // If user edits metadata fields after previewing, require re-preview before exporting
  ['metaTitle','metaAuthor','metaSubject','metaKeywords'].forEach((id) => {
    const el = $(id);
    if (!el) return;
    el.addEventListener('input', () => {
      if (lastKind === 'apply') markStale('Fields changed. Click Preview Apply Metadata again, then Export.');
    });
  });

  setEmptyPreview('Upload a PDF to preview it here.');
}

function initFlattenSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'flattenPdfFile',
    passwordInputId: 'flattenPdfPassword',
    unlockBtnId: 'flattenUnlockBtn',
    actionBtnId: 'flattenPdfBtn',
    tool: 'flatten',
    endpoint: ENDPOINTS.FLATTEN,
    filename: 'pdfrealm-flattened.pdf',
    previewFrameId: 'flattenPreviewFrame',
    placeholderId: 'flattenPreviewPlaceholder',
  });
}


// -------------------- Timestamp (Stamp) helpers --------------------
function _pad2(n) {
  return String(n).padStart(2, '0');
}

function _formatDatetimeLocal(d) {
  const yyyy = d.getFullYear();
  const mm = _pad2(d.getMonth() + 1);
  const dd = _pad2(d.getDate());
  const HH = _pad2(d.getHours());
  const MI = _pad2(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${HH}:${MI}`;
}

function _parseDatetimeLocal(v) {
  // Expected: YYYY-MM-DDTHH:MM (optionally with seconds)
  const s = String(v || '').trim();
  const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2})(?::(\d{2}))?$/);
  if (!m) return null;
  const y = parseInt(m[1], 10);
  const mo = parseInt(m[2], 10) - 1;
  const da = parseInt(m[3], 10);
  const h = parseInt(m[4], 10);
  const mi = parseInt(m[5], 10);
  const se = m[6] ? parseInt(m[6], 10) : 0;
  return new Date(y, mo, da, h, mi, se);
}

function buildTimestampText() {
  const fmt = String($('stampFormat')?.value || 'us-dt');
  const prefix = String($('stampPrefix')?.value || '');

  // Optional custom date/time override (pre/post-dating)
  let d = new Date();
  const useCustom = Boolean($('stampUseCustomDate')?.checked);
  const customVal = String($('stampCustomDate')?.value || '').trim();
  if (useCustom && customVal) {
    const parsed = _parseDatetimeLocal(customVal);
    if (parsed && !Number.isNaN(parsed.getTime())) d = parsed;
  }

  const yyyy = d.getFullYear();
  const mm = _pad2(d.getMonth() + 1);
  const dd = _pad2(d.getDate());
  const HH = _pad2(d.getHours());
  const MI = _pad2(d.getMinutes());

  let core = '';
  if (fmt === 'us') core = `${mm}/${dd}/${yyyy}`;
  else if (fmt === 'us-dt') core = `${mm}/${dd}/${yyyy} ${HH}:${MI}`;
  else if (fmt === 'iso') core = `${yyyy}-${mm}-${dd}`;
  else if (fmt === 'iso-dt') core = `${yyyy}-${mm}-${dd} ${HH}:${MI}`;
  else if (fmt === 'locale') core = d.toLocaleString();
  else core = `${mm}/${dd}/${yyyy} ${HH}:${MI}`;

  return `${prefix}${core}`;
}

function initStampSecure() {
  // Custom date/time UI wiring (optional)
  const useCb = $('stampUseCustomDate');
  const dtInput = $('stampCustomDate');
  if (useCb && dtInput) {
    const sync = () => {
      dtInput.disabled = !useCb.checked;
      if (useCb.checked && !String(dtInput.value || '').trim()) {
        dtInput.value = _formatDatetimeLocal(new Date());
      }
    };
    useCb.addEventListener('change', sync);
    sync();
  }

  initSinglePdfToolWithUnlock({
    fileInputId: 'stampPdfFile',
    previewBtnId: 'stampPreviewBtn',
    previewHintId: 'stampPreviewHint',
    passwordInputId: 'stampPdfPassword',
    unlockBtnId: 'stampUnlockBtn',
    actionBtnId: 'stampPdfBtn',
    tool: 'stamp',
    endpoint: ENDPOINTS.STAMP,
    filename: 'pdfrealm-timestamp.pdf',
    previewFrameId: 'stampPreviewFrame',
    placeholderId: 'stampPreviewPlaceholder',
    extraFields: () => ({ text: buildTimestampText() }),
  });
}

function initRedactSecure() {
  initRedactInteractive();
}

function initRedactInteractive() {
  const fileInput = $('redactPdfFile');
  const pwInput = $('redactPdfPassword');
  const unlockBtn = $('redactUnlockBtn');
  const previewBtn = $('redactPreviewBtn');
  const exportBtn = $('redactPdfBtn');

  const placeholder = $('redactPreviewPlaceholder');
  const wrapper = $('redactViewerWrapper');
  const shell = $('redactCanvasShell');
  const pdfCanvas = $('redactPdfCanvas');
  const inkCanvas = $('redactInkCanvas');
  const hitCanvas = $('redactHitCanvas');
  const boxLayer = $('redactBoxLayer');

  const pageLabel = $('redactPageLabel');
  const prevPageBtn = $('redactPrevPageBtn');
  const nextPageBtn = $('redactNextPageBtn');

  const modeBoxBtn = $('redactModeBox');
  const modeMarkerBtn = $('redactModeMarker');
  const markerSize = $('redactMarkerSize');

  const undoBtn = $('redactUndoBtn');
  const clearPageBtn = $('redactClearPageBtn');

  const hint = $('redactPreviewHint');
  // --- PDF.js bootstrap (dynamic import; avoids CDN 404/mime issues) ---
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      // Try cdnjs (pdf.min.mjs exists for v4+)
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        // Fallback to jsDelivr (npm pdfjs-dist)
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // --- State ---
  let originalFile = null;
  let unlockedFile = null;
  let pdfDoc = null;
  let pageCount = 0;
  let pageNum = 1;
  let renderScale = 1;

  // Per-page annotations (normalized, top-left origin)
  const pages = []; // { rects: [{x,y,w,h}], strokes: [{points:[{x,y}], size}] }
  const history = []; // {page, kind:'rect'|'stroke'}

  let mode = 'box'; // 'box'|'marker'
  let selectedRectId = null; // `${pageIndex}:${rectIndex}`

  function ensurePages(n) {
    while (pages.length < n) pages.push({ rects: [], strokes: [] });
  }

  function setMode(m) {
    mode = m;
    selectedRectId = null;
    [modeBoxBtn, modeMarkerBtn].forEach((b) => b && b.classList.remove('active'));
    if (m === 'box') modeBoxBtn && modeBoxBtn.classList.add('active');
    if (m === 'marker') modeMarkerBtn && modeMarkerBtn.classList.add('active');

    // The interaction layer is always the hitCanvas. The boxLayer is visual-only.
    if (boxLayer) boxLayer.style.pointerEvents = 'none';
    if (hitCanvas) hitCanvas.style.pointerEvents = 'auto';
  }

  function showEmpty(msg) {
    if (placeholder) {
      placeholder.textContent = msg || 'Upload a PDF to preview it here.';
      placeholder.style.display = 'flex';
    }
    if (shell) shell.style.display = 'none';
  }

  function showCanvas() {
    if (placeholder) placeholder.style.display = 'none';
    if (shell) shell.style.display = 'block';
  }

  function updatePageLabel() {
    if (pageLabel) pageLabel.textContent = `Page ${pageNum} / ${pageCount || 1}`;
    if (prevPageBtn) prevPageBtn.disabled = pageNum <= 1;
    if (nextPageBtn) nextPageBtn.disabled = pageNum >= pageCount;
  }

  function clearCanvas(c) {
    if (!c) return;
    const ctx = c.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, c.width, c.height);
  }

  async function loadPdfFromFile(file) {
    const lib = await getPdfJsAsync();
    if (!lib) {
      alert('PDF.js failed to load. Please refresh the page.');
      return;
    }

    showEmpty('Checking encryption...');

    const encrypted = await detectEncryptedPdfReliable(file);
    if (encrypted) {
      showEmpty('Encrypted PDF â€” enter the password and click Decrypt / Unlock.');
      return;
    }

    const data = await file.arrayBuffer();
    pdfDoc = await lib.getDocument({ data }).promise;
    pageCount = pdfDoc.numPages || 1;
    ensurePages(pageCount);
    pageNum = Math.min(Math.max(1, pageNum), pageCount);
    updatePageLabel();
    await renderPage(pageNum);
  }

  function currentPageState() {
    ensurePages(pageCount || 1);
    return pages[pageNum - 1];
  }

  function normFromEvent(ev) {
    const rect = hitCanvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) / rect.width;
    const y = (ev.clientY - rect.top) / rect.height;
    return { x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y)) };
  }

  function pxFromNorm(nx, ny) {
    return { x: nx * pdfCanvas.width, y: ny * pdfCanvas.height };
  }

  function rebuildBoxLayer() {
    if (!boxLayer) return;
    boxLayer.innerHTML = '';
    const st = currentPageState();

    st.rects.forEach((r, idx) => {
      const el = document.createElement('div');
      el.className = 'redact-box';
      el.dataset.rectIndex = String(idx);

      const left = r.x * pdfCanvas.width;
      const top = r.y * pdfCanvas.height;
      const w = r.w * pdfCanvas.width;
      const h = r.h * pdfCanvas.height;

      el.style.left = `${left}px`;
      el.style.top = `${top}px`;
      el.style.width = `${w}px`;
      el.style.height = `${h}px`;

      // selection outline
      const id = `${pageNum - 1}:${idx}`;
      if (selectedRectId === id) el.classList.add('selected');

      // handles
      ['tl','tr','bl','br'].forEach((pos) => {
        const hnd = document.createElement('div');
        hnd.className = `rb-handle ${pos}`;
        hnd.dataset.handle = pos;
        el.appendChild(hnd);
      });

      boxLayer.appendChild(el);
    });
  }

  function redrawInk() {
    clearCanvas(inkCanvas);
    const ctx = inkCanvas.getContext('2d');
    if (!ctx) return;

    const st = currentPageState();
    st.strokes.forEach((s) => {
      const sizePx = Math.max(2, (s.size || 0.02) * Math.min(pdfCanvas.width, pdfCanvas.height));
      ctx.lineWidth = sizePx;
      ctx.strokeStyle = '#000';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const pts = s.points || [];
      if (pts.length < 2) return;
      ctx.beginPath();
      const p0 = pxFromNorm(pts[0].x, pts[0].y);
      ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < pts.length; i++) {
        const p = pxFromNorm(pts[i].x, pts[i].y);
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    });
  }

  async function renderPage(n) {
    if (!pdfDoc) return;
    showCanvas();

    const page = await pdfDoc.getPage(n);

    // Fit to wrapper width, keep true pixel sizing for correct overlays
    const baseVp = page.getViewport({ scale: 1 });
    const wrapW = Math.max(320, (wrapper?.clientWidth || 800) - 24);
    renderScale = wrapW / baseVp.width;
    renderScale = Math.min(2.5, Math.max(0.6, renderScale));

    const vp = page.getViewport({ scale: renderScale });

    // Size canvases in device pixels
    const dpr = window.devicePixelRatio || 1;
    const cssW = Math.floor(vp.width);
    const cssH = Math.floor(vp.height);

    shell.style.width = cssW + 'px';
    shell.style.height = cssH + 'px';

    ;[pdfCanvas, inkCanvas, hitCanvas].forEach((c) => {
      if (!c) return;
      c.width = Math.floor(cssW * dpr);
      c.height = Math.floor(cssH * dpr);
      c.style.width = cssW + 'px';
      c.style.height = cssH + 'px';
      const ctx = c.getContext('2d');
      if (ctx) ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });

    if (boxLayer) {
      boxLayer.style.width = cssW + 'px';
      boxLayer.style.height = cssH + 'px';
    }

    // Render PDF page
    const ctx = pdfCanvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport: vp }).promise;

    // Overlays
    redrawInk();
    rebuildBoxLayer();
    updatePageLabel();

    if (hint) {
      hint.style.display = 'block';
      hint.textContent = 'Preview updated.';
    }
  }

  // --- Box creation (drag on hitCanvas) ---
  let boxDrag = null; // {startX,startY, el}

  function startBox(ev) {
    if (mode !== 'box' || !hitCanvas || !boxLayer) return;
    const st = normFromEvent(ev);
    const tmp = document.createElement('div');
    tmp.className = 'redact-box temp';
    tmp.style.left = (st.x * pdfCanvas.width) + 'px';
    tmp.style.top = (st.y * pdfCanvas.height) + 'px';
    tmp.style.width = '0px';
    tmp.style.height = '0px';
    boxLayer.appendChild(tmp);
    boxDrag = { start: st, el: tmp };
  }

  function moveBox(ev) {
    if (!boxDrag) return;
    const st = boxDrag.start;
    const cur = normFromEvent(ev);
    const x1 = min(st.x, cur.x);
    const y1 = min(st.y, cur.y);
    const x2 = max(st.x, cur.x);
    const y2 = max(st.y, cur.y);
    const left = x1 * pdfCanvas.width;
    const top = y1 * pdfCanvas.height;
    const w = (x2 - x1) * pdfCanvas.width;
    const h = (y2 - y1) * pdfCanvas.height;
    const el = boxDrag.el;
    el.style.left = left + 'px';
    el.style.top = top + 'px';
    el.style.width = w + 'px';
    el.style.height = h + 'px';
  }

  function endBox() {
    if (!boxDrag) return;
    const el = boxDrag.el;
    const left = parseFloat(el.style.left) || 0;
    const top = parseFloat(el.style.top) || 0;
    const w = parseFloat(el.style.width) || 0;
    const h = parseFloat(el.style.height) || 0;
    el.remove();

    boxDrag = null;

    if (w < 8 || h < 8) {
      rebuildBoxLayer();
      return;
    }

    const st = currentPageState();
    st.rects.push({
      x: left / pdfCanvas.width,
      y: top / pdfCanvas.height,
      w: w / pdfCanvas.width,
      h: h / pdfCanvas.height,
    });
    history.push({ page: pageNum - 1, kind: 'rect' });
    rebuildBoxLayer();
  }

  // --- Marker drawing (drag on hitCanvas) ---
  let marker = null; // { stroke, last }

  function startMarker(ev) {
    if (mode !== 'marker' || !hitCanvas) return;
    const pt = normFromEvent(ev);
    const sizePx = parseInt(markerSize?.value || '14', 10) || 14;
    const sizeNorm = sizePx / Math.min(pdfCanvas.width, pdfCanvas.height);
    marker = { stroke: { points: [pt], size: sizeNorm } };
  }

  function moveMarker(ev) {
    if (!marker) return;
    const pt = normFromEvent(ev);
    marker.stroke.points.push(pt);

    // Draw incremental for responsiveness
    const ctx = inkCanvas.getContext('2d');
    if (!ctx) return;
    const pts = marker.stroke.points;
    if (pts.length < 2) return;

    const sizePx = Math.max(2, (marker.stroke.size || 0.02) * Math.min(pdfCanvas.width, pdfCanvas.height));
    ctx.lineWidth = sizePx;
    ctx.strokeStyle = '#000';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const a = pxFromNorm(pts[pts.length - 2].x, pts[pts.length - 2].y);
    const b = pxFromNorm(pts[pts.length - 1].x, pts[pts.length - 1].y);

    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }

  function endMarker() {
    if (!marker) return;
    const st = currentPageState();
    if ((marker.stroke.points || []).length >= 2) {
      st.strokes.push(marker.stroke);
      history.push({ page: pageNum - 1, kind: 'stroke' });
    }
    marker = null;
  }

  // --- Select/move/resize boxes ---
  let selectDrag = null; // { kind:'move'|'resize', rectIndex, start, baseRect, handle }

  // Hit-test in BOX mode (no separate Select mode):
  // - drag empty area => create new box
  // - drag inside an existing box => move
  // - drag near a corner => resize
  function hitTestRect(ptNorm) {
    const st = currentPageState();
    const rects = st.rects || [];
    // Prefer the last rect (most recently created) when overlaps occur
    for (let i = rects.length - 1; i >= 0; i--) {
      const r = rects[i];
      const inside = ptNorm.x >= r.x && ptNorm.x <= (r.x + r.w) && ptNorm.y >= r.y && ptNorm.y <= (r.y + r.h);
      if (!inside) continue;

      // Corner-handle detection in pixels (feels consistent across zoom)
      const px = pxFromNorm(ptNorm.x, ptNorm.y);
      const tl = pxFromNorm(r.x, r.y);
      const tr = pxFromNorm(r.x + r.w, r.y);
      const bl = pxFromNorm(r.x, r.y + r.h);
      const br = pxFromNorm(r.x + r.w, r.y + r.h);
      const TH = 12; // px
      const near = (a, b) => Math.abs(a.x - b.x) <= TH && Math.abs(a.y - b.y) <= TH;
      let handle = null;
      if (near(px, tl)) handle = 'tl';
      else if (near(px, tr)) handle = 'tr';
      else if (near(px, bl)) handle = 'bl';
      else if (near(px, br)) handle = 'br';
      return { index: i, handle };
    }
    return null;
  }

  function selectRect(idx) {
    selectedRectId = `${pageNum - 1}:${idx}`;
    rebuildBoxLayer();
  }

  function startSelectAt(ev, idx, handle) {
    selectRect(idx);
    const st = currentPageState();
    const base = { ...st.rects[idx] };
    const pt = normFromEvent(ev);
    selectDrag = {
      rectIndex: idx,
      handle: handle || null,
      start: pt,
      baseRect: base,
      kind: handle ? 'resize' : 'move',
    };
    try { hitCanvas.setPointerCapture?.(ev.pointerId); } catch {}
  }

  function moveSelect(ev) {
    if (!selectDrag) return;
    const st = currentPageState();
    const idx = selectDrag.rectIndex;
    const cur = normFromEvent(ev);

    const dx = cur.x - selectDrag.start.x;
    const dy = cur.y - selectDrag.start.y;

    let r = { ...selectDrag.baseRect };

    if (selectDrag.kind === 'move') {
      r.x = clamp01(r.x + dx);
      r.y = clamp01(r.y + dy);
      r.x = Math.min(r.x, 1 - r.w);
      r.y = Math.min(r.y, 1 - r.h);
    } else {
      const h = selectDrag.handle;
      if (h == 'tl') {
        const nx = clamp01(r.x + dx);
        const ny = clamp01(r.y + dy);
        const nw = (r.x + r.w) - nx;
        const nh = (r.y + r.h) - ny;
        r = { x: nx, y: ny, w: clamp01(nw), h: clamp01(nh) };
      } else if (h == 'tr') {
        const ny = clamp01(r.y + dy);
        const nw = clamp01(r.w + dx);
        const nh = (r.y + r.h) - ny;
        r = { x: r.x, y: ny, w: nw, h: clamp01(nh) };
      } else if (h == 'bl') {
        const nx = clamp01(r.x + dx);
        const nw = (r.x + r.w) - nx;
        const nh = clamp01(r.h + dy);
        r = { x: nx, y: r.y, w: clamp01(nw), h: nh };
      } else if (h == 'br') {
        r.w = clamp01(r.w + dx);
        r.h = clamp01(r.h + dy);
      }

      // minimum size
      r.w = Math.max(r.w, 0.01);
      r.h = Math.max(r.h, 0.01);

      // clamp inside page
      r.x = clamp01(r.x);
      r.y = clamp01(r.y);
      r.w = Math.min(r.w, 1 - r.x);
      r.h = Math.min(r.h, 1 - r.y);
    }

    st.rects[idx] = r;
    rebuildBoxLayer();
  }

  function endSelect(ev) {
    if (!selectDrag) return;
    try { hitCanvas.releasePointerCapture?.(ev.pointerId); } catch {}
    selectDrag = null;
  }

  function exportBoxesString() {
    const lines = [];
    for (let pi = 0; pi < pages.length; pi++) {
      const rects = pages[pi].rects || [];
      for (const r of rects) {
        lines.push(`${pi + 1},${r.x.toFixed(6)},${r.y.toFixed(6)},${r.w.toFixed(6)},${r.h.toFixed(6)}`);
      }
    }
    const s = lines.join('\n');
    const ta = $('redactBoxes');
    if (ta) ta.value = s;
    return s;
  }

  function exportAnnotationsJSON() {
    return JSON.stringify({ pages });
  }

  async function onPreview() {
    if (!originalFile && !unlockedFile) return;
    await renderPage(pageNum);
  }

  async function onExport() {
    const f = unlockedFile || originalFile;
    if (!f) return alert('Upload a PDF first.');

    // Require at least one action
    const any = pages.some((p) => (p.rects?.length || 0) + (p.strokes?.length || 0) > 0);
    if (!any) return alert('Add at least one black box or marker stroke before exporting.');

    const fd = new FormData();
    fd.append('file', f);
    fd.append('boxes', exportBoxesString());
    fd.append('annotations', exportAnnotationsJSON());

    const result = await runPaidPdfExport({
      tool: 'redact',
      endpoint: ENDPOINTS.REDACT,
      formData: fd,
      filename: 'pdfrealm-redacted.pdf',
      setPreviewFrameId: null,
      placeholderId: null,
    });

    if (!result?.ok) return;

    // Load the returned PDF into the viewer (redactions are now baked).
    try {
      const outFile = new File([result.blob], 'pdfrealm-redacted.pdf', { type: 'application/pdf' });
      // Reset annotations after bake
      pages.splice(0, pages.length);
      history.splice(0, history.length);
      selectedRectId = null;
      unlockedFile = null;
      originalFile = outFile;
      await loadPdfFromFile(outFile);
    } catch {}
  }

  async function onUnlock() {
    const f = originalFile;
    if (!f) return alert('Upload a PDF first.');

    const encrypted = await detectEncryptedPdfReliable(f);
    if (!encrypted) {
      alert('This PDF is not encrypted.');
      return;
    }

    const pw = String(pwInput?.value || '').trim();
    if (!pw) return alert('Enter a password first.');

    try {
      const dec = await decryptPdfToFile(f, pw);
      unlockedFile = dec;
      await loadPdfFromFile(dec);
    } catch (e) {
      alert(e.message || 'Decrypt failed.');
    }
  }

  // --- Undo / clear ---
  function undo() {
    if (!history.length) return;
    const last = history.pop();
    const st = pages[last.page];
    if (!st) return;
    if (last.kind === 'rect' && st.rects.length) st.rects.pop();
    if (last.kind === 'stroke' && st.strokes.length) st.strokes.pop();

    if ((last.page + 1) === pageNum) {
      redrawInk();
      rebuildBoxLayer();
    }
  }

  function clearPage() {
    if (!pageCount) return;
    const st = currentPageState();
    st.rects = [];
    st.strokes = [];
    // remove history entries for this page
    for (let i = history.length - 1; i >= 0; i--) {
      if (history[i].page === pageNum - 1) history.splice(i, 1);
    }
    redrawInk();
    rebuildBoxLayer();
  }

  // --- UI wiring ---
  setMode('box');

  modeBoxBtn?.addEventListener('click', () => setMode('box'));
  modeMarkerBtn?.addEventListener('click', () => setMode('marker'));

  previewBtn?.addEventListener('click', onPreview);
  exportBtn?.addEventListener('click', onExport);
  unlockBtn?.addEventListener('click', onUnlock);

  undoBtn?.addEventListener('click', undo);
  clearPageBtn?.addEventListener('click', clearPage);

  prevPageBtn?.addEventListener('click', async () => {
    if (pageNum <= 1) return;
    pageNum -= 1;
    updatePageLabel();
    await renderPage(pageNum);
  });
  nextPageBtn?.addEventListener('click', async () => {
    if (pageNum >= pageCount) return;
    pageNum += 1;
    updatePageLabel();
    await renderPage(pageNum);
  });

  // Pointer handlers
  if (hitCanvas) {
    hitCanvas.addEventListener('pointerdown', (ev) => {
      if (!pdfDoc) return;
      if (mode === 'box') {
        // If the pointer is on an existing box, move/resize it.
        const hit = hitTestRect(normFromEvent(ev));
        if (hit) {
          startSelectAt(ev, hit.index, hit.handle);
        } else {
          selectedRectId = null;
          startBox(ev);
        }
      } else if (mode === 'marker') {
        startMarker(ev);
      }
    });
    hitCanvas.addEventListener('pointermove', (ev) => {
      if (!pdfDoc) return;
      if (mode === 'box') {
        if (selectDrag) moveSelect(ev);
        else moveBox(ev);
      } else if (mode === 'marker') {
        moveMarker(ev);
      }
    });
    hitCanvas.addEventListener('pointerup', (ev) => {
      if (mode === 'box') {
        if (selectDrag) endSelect(ev);
        else endBox();
      } else if (mode === 'marker') {
        endMarker();
      }
    });
    hitCanvas.addEventListener('pointercancel', (ev) => {
      if (mode === 'box') {
        if (selectDrag) endSelect(ev);
        else endBox();
      } else if (mode === 'marker') {
        endMarker();
      }
    });
  }

  // Load on file selection
  fileInput?.addEventListener('change', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      originalFile = null;
      unlockedFile = null;
      pdfDoc = null;
      pageCount = 0;
      pageNum = 1;
      pages.splice(0, pages.length);
      history.splice(0, history.length);
      selectedRectId = null;
      showEmpty('Upload a PDF to preview it here.');
      updatePageLabel();
      return;
    }

    originalFile = f;
    unlockedFile = null;
    pdfDoc = null;
    pageCount = 0;
    pageNum = 1;
    pages.splice(0, pages.length);
    history.splice(0, history.length);
    selectedRectId = null;
    clearCanvas(pdfCanvas);
    clearCanvas(inkCanvas);
    if (boxLayer) boxLayer.innerHTML = '';

    await loadPdfFromFile(f);
  });

  // Re-render on resize (keeps overlays aligned)
  window.addEventListener('resize', debounce(async () => {
    if (!pdfDoc) return;
    await renderPage(pageNum);
  }, 150));

  // Initial
  showEmpty('Upload a PDF to preview it here.');
  updatePageLabel();

  // small utils
  function clamp01(v) { return Math.min(1, Math.max(0, v)); }
  function min(a,b){ return a<b?a:b; }
  function max(a,b){ return a>b?a:b; }
  function debounce(fn, ms) {
    let t = null;
    return (...args) => {
      if (t) clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }
}

// -------------------- More Tools preview helper --------------------
function initMoreToolsPreview() {
  const map = [
    ["pdfToJpgFile", "pdfToJpgPreviewFrame", "pdfToJpgPreviewPlaceholder"],
    ["pdfToPngFile", "pdfToPngPreviewFrame", "pdfToPngPreviewPlaceholder"],
  ];
  map.forEach(([inp, fr, ph]) => wireLocalPdfPreview(inp, fr, ph));
}

function initMoreToolsActions() {
  function oneFileToExport(tool, endpoint, fileInputId, extraFields, filename, previewFrameId, placeholderId) {
    return async () => {
      const f = $(fileInputId)?.files?.[0];
      if (!f) return alert("Upload a PDF first.");

      const fd = new FormData();
      fd.append("file", f);
      for (const [k, v] of Object.entries(extraFields || {})) fd.append(k, String(v ?? ""));

      await runPaidPdfExport({
        tool,
        endpoint,
        formData: fd,
        filename,
        setPreviewFrameId: previewFrameId,
        placeholderId: placeholderId,
      });
    };
  }
// ---- JPG â†’ PDF (split preview: input left, output right) ----
  (function initJpgToPdfSplit() {
    const fileInput = $("jpgToPdfFile");
    const convertBtn = $("jpgToPdfPreviewBtn");
    const exportBtn = $("jpgToPdfExportBtn");
    const statusEl = $("jpg2pdfStatus");

    const inputHost = $("jpg2pdfInputPreviewHost");
    const outputHost = $("jpg2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    // Lock down previews (no right-click copy)
    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("jpg2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("jpg2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap (dynamic import; matches our OCR/QuickSign pattern)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      // Render up to 10 pages for preview (scrollable).
      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("jpg2pdfOutputPlaceholder", false);
    }

    // Input preview (image)
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      exportBtn.disabled = true;
      setStatus("");

      if (!f) {
        resetInput();
        return;
      }

      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = URL.createObjectURL(f);

      inputHost.innerHTML = "";
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "JPG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);

      showPlaceholder("jpg2pdfInputPlaceholder", false);
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a JPG first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const fd = new FormData();
        fd.append("file", f);

        const result = await runPaidPdfExport({
          tool: "jpg-to-pdf",
          endpoint: ENDPOINTS.JPG_TO_PDF,
          formData: fd,
          filename: null,
        });

        if (!result || !result.ok || !result.blob) {
          throw new Error("JPG â†’ PDF failed.");
        }

        // runPaidPdfExport always creates an object URL; we don't need it here.
        try { if (result.objectUrl) URL.revokeObjectURL(result.objectUrl); } catch {}

        lastOutputBlob = result.blob;
        await renderPdfBlobToHost(result.blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready. Click Export PDF to download.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-jpg.pdf");
    });

    // Initial state
    resetInput();
    resetOutput();
  })();

  // ---- PNG â†’ PDF (split preview: input left, output right) ----
  (function initPngToPdfSplit() {
    const fileInput = $("pngToPdfFile");
    const convertBtn = $("pngToPdfPreviewBtn");
    const exportBtn = $("pngToPdfExportBtn");
    const statusEl = $("png2pdfStatus");

    const inputHost = $("png2pdfInputPreviewHost");
    const outputHost = $("png2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    // Lock down previews (no right-click copy)
    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("png2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("png2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap (dynamic import)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("png2pdfOutputPlaceholder", false);
    }

    // Input preview (image)
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      exportBtn.disabled = true;
      setStatus("");

      if (!f) {
        resetInput();
        return;
      }

      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = URL.createObjectURL(f);

      inputHost.innerHTML = "";
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "PNG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);

      showPlaceholder("png2pdfInputPlaceholder", false);
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a PNG first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const fd = new FormData();
        fd.append("file", f);

        const result = await runPaidPdfExport({
          tool: "png-to-pdf",
          endpoint: ENDPOINTS.PNG_TO_PDF,
          formData: fd,
          filename: null,
        });

        if (!result || !result.ok || !result.blob) {
          throw new Error("PNG â†’ PDF failed.");
        }

        try { if (result.objectUrl) URL.revokeObjectURL(result.objectUrl); } catch {}

        lastOutputBlob = result.blob;
        await renderPdfBlobToHost(result.blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready. Click Export PDF to download.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-png.pdf");
    });

    resetInput();
    resetOutput();
  })();

  // ---- TIFF â†’ PDF (split preview: input left, output right) ----
  (function initTiffToPdfSplit() {
    const fileInput = $("tiffToPdfFile");
    const convertBtn = $("tiffToPdfPreviewBtn");
    const exportBtn = $("tiffToPdfExportBtn");
    const statusEl = $("tiff2pdfStatus");

    const inputHost = $("tiff2pdfInputPreviewHost");
    const outputHost = $("tiff2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("tiff2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      inputHost.innerHTML = "";
      showPlaceholder("tiff2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap (dynamic import)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("tiff2pdfOutputPlaceholder", false);
    }

    // UTIF loader (for TIFF input preview)
    let _utifPromise = null;
    function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        const existing = Array.from(document.scripts || []).find((s) => s.src === src);
        if (existing) return resolve();
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error("Failed to load " + src));
        document.head.appendChild(s);
      });
    }
    async function getUTIF() {
      if (window.UTIF) return window.UTIF;
      if (_utifPromise) return _utifPromise;
      _utifPromise = (async () => {
        try {
          await loadScriptOnce('https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js');
          return window.UTIF || null;
        } catch (e) {
          console.error(e);
          return null;
        }
      })();
      return _utifPromise;
    }

    async function renderTiffToHost(file, host) {
      const UTIF = await getUTIF();
      if (!UTIF) {
        host.innerHTML = '<div class="muted">TIFF preview requires UTIF.js (failed to load).</div>';
        return;
      }

      const buf = await file.arrayBuffer();
      const ifds = UTIF.decode(buf);
      if (!ifds || !ifds.length) {
        host.innerHTML = '<div class="muted">Unable to decode TIFF.</div>';
        return;
      }
      UTIF.decodeImages(buf, ifds);
      const first = ifds[0];
      const rgba = UTIF.toRGBA8(first);
      const w = first.width;
      const h = first.height;

      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      canvas.style.maxWidth = "100%";
      canvas.style.height = "auto";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      const ctx = canvas.getContext("2d");
      const imgData = new ImageData(new Uint8ClampedArray(rgba), w, h);
      ctx.putImageData(imgData, 0, 0);

      host.innerHTML = "";
      host.appendChild(canvas);
    }

    fileInput.addEventListener("change", async () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      exportBtn.disabled = true;
      setStatus("");

      if (!f) {
        resetInput();
        return;
      }

      try {
        inputHost.innerHTML = "";
        await renderTiffToHost(f, inputHost);
        showPlaceholder("tiff2pdfInputPlaceholder", false);
      } catch (e) {
        console.error(e);
        inputHost.innerHTML = '<div class="muted">Unable to preview this TIFF in your browser.</div>';
        showPlaceholder("tiff2pdfInputPlaceholder", false);
      }
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a TIFF first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const fd = new FormData();
        fd.append("file", f);

        const result = await runPaidPdfExport({
          tool: "tiff-to-pdf",
          endpoint: ENDPOINTS.TIFF_TO_PDF,
          formData: fd,
          filename: null,
        });

        if (!result || !result.ok || !result.blob) {
          throw new Error("TIFF â†’ PDF failed.");
        }

        try { if (result.objectUrl) URL.revokeObjectURL(result.objectUrl); } catch {}

        lastOutputBlob = result.blob;
        await renderPdfBlobToHost(result.blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready. Click Export PDF to download.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-tiff.pdf");
    });

    resetInput();
    resetOutput();
  })();


function initSvgToPdfSplit() {
    const fileInput = $("svgToPdfFile");
    const convertBtn = $("svgToPdfPreviewBtn");
    const exportBtn = $("svgToPdfExportBtn");
    const statusEl = $("svg2pdfStatus");

    const inputHost = $("svg2pdfInputPreviewHost");
    const outputHost = $("svg2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("svg2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("svg2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }
      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("svg2pdfOutputPlaceholder", false);
    }

    // Input preview (svg)
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      resetInput();
      if (!f) return;

      inputUrl = URL.createObjectURL(f);
      inputHost.innerHTML = "";

      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "SVG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";

      inputHost.appendChild(img);
      showPlaceholder("svg2pdfInputPlaceholder", false);
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload an SVG first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const result = await runPaidPdfExport({
          tool: "svg-to-pdf",
          endpoint: ENDPOINTS.SVG_TO_PDF,
          file: f,
        });

        // result is a Blob (application/pdf)
        lastOutputBlob = result;
        exportBtn.disabled = false;

        outputHost.innerHTML = "";
        await renderPdfBlobToHost(lastOutputBlob, outputHost);
        setStatus("Ready.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-svg.pdf");
    });
}



// -------------------- PDF â†’ Word (split preview) --------------------
function initPdfToWordSplit() {
  const fileInput = $("p2wFile");
  const pwInput = $("pdfToWordPassword");
  const previewInputBtn = $("p2wPreviewBtn");
  const convertBtn = $("pdfToWordPreviewBtn");
  const exportBtn = $("pdfToWordExportBtn");
  const statusEl = $("p2wStatus");

  const inputHost = $("pdf2wordInputPreviewHost");
  const outputHost = $("pdf2wordOutputPreviewHost");

  if (!fileInput || !previewInputBtn || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

  // Lock down preview interactions
  inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  outputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  inputHost.style.userSelect = "none";
  outputHost.style.userSelect = "none";

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg || "";
  }

  function reset() {
    exportBtn.disabled = true;
    inputHost.innerHTML = "";
    outputHost.innerHTML = "";
    showPlaceholder("pdf2wordInputPlaceholder", true);
    showPlaceholder("pdf2wordOutputPlaceholder", true);
    setStatus("");
  }

  // PDF.js bootstrap
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs");
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs";
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import("https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs");
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs";
          }
          return lib2;
        } catch (e2) {
          console.error("PDF.js failed to load from CDN.", e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  async function renderPdfFileToHost(file, host, password, placeholderId) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Preview unavailable.</div>';
      if (placeholderId) showPlaceholder(placeholderId, false);
      return;
    }

    const buf = await file.arrayBuffer();
    const params = { data: new Uint8Array(buf) };
    if (password) params.password = password;

    const task = pdfjs.getDocument(params);
    if (password) {
      task.onPassword = (updatePassword) => updatePassword(password);
    }

    const doc = await task.promise;
    host.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 6);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let i = 1; i <= maxPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }

    if (placeholderId) showPlaceholder(placeholderId, false);
  }

  function buildFormData() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return null;
    const fd = new FormData();
    fd.append("file", f, f.name || "document.pdf");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");
    if (pw) fd.append("password", pw);
    return fd;
  }
  async function previewInput() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    // If the PDF is encrypted and no password was provided, don't let PDF.js throw;
    // instead, guide the user to enter the password (consistent with other tools).
    if (!pw) {
      try {
        const enc = await detectEncryptedPdf(f);
        if (enc) {
          setStatus("This PDF is password-protected. Enter the password on the left and click Preview.");
          try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
          return;
        }
      } catch { /* ignore heuristic errors */ }
    }

    setStatus("Rendering input preview...");
    try {
      await renderPdfFileToHost(f, inputHost, pw, "pdf2wordInputPlaceholder");
      setStatus("");
    } catch (e) {
      // PDF.js throws PasswordException if password is missing/incorrect.
      if (e && (e.name === "PasswordException" || String(e.message || "").toLowerCase().includes("password"))) {
        setStatus("Password required or incorrect. Enter the password on the left and try again.");
        try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
        return;
      }
      console.error(e);
      setStatus("Input preview failed.");
    }
  }
  async function convertPreview() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    if (!pw) {
      try {
        const enc = await detectEncryptedPdf(f);
        if (enc) {
          setStatus("This PDF is password-protected. Enter the password on the left and click Convert (preview).");
          try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
          return;
        }
      } catch {}
    }

    const fd = buildFormData();
    if (!fd) return alert("Upload a PDF first.");

    exportBtn.disabled = true;
    outputHost.innerHTML = "";
    showPlaceholder("pdf2wordOutputPlaceholder", true);

    setStatus("Converting (preview)...");
    try {
      const res = await fetch(ENDPOINTS.PDF_TO_WORD + "/preview", { method: "POST", body: fd });
      if (!res.ok) {
        let data = null;
        try { data = await res.json(); } catch {}
        throw new Error(data?.error || `Preview failed (${res.status})`);
      }

      const data = await res.json();
      const htmlRaw = String(data?.html || "");
      const html = htmlRaw.replace(/<script[\s\S]*?<\/script>/gi, "");

      outputHost.innerHTML = "";
      const paper = document.createElement("div");
      paper.style.background = "white";
      paper.style.color = "#111";
      paper.style.borderRadius = "14px";
      paper.style.boxShadow = "0 8px 28px rgba(0,0,0,.18)";
      paper.style.padding = "18px";
      paper.style.maxWidth = "980px";
      paper.style.width = "100%";
      paper.innerHTML = html || '<div class="muted">No preview available.</div>';

      outputHost.appendChild(paper);
      showPlaceholder("pdf2wordOutputPlaceholder", false);

      exportBtn.disabled = false;
      setStatus("Ready to export.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Preview failed."));
      showPlaceholder("pdf2wordOutputPlaceholder", true);
    }
  }
  async function exportWord() {
    const f0 = fileInput.files && fileInput.files[0];
    if (!f0) return alert("Upload a PDF first.");
    const pw0 = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    if (!pw0) {
      try {
        const enc = await detectEncryptedPdf(f0);
        if (enc) {
          setStatus("This PDF is password-protected. Enter the password on the left and export again.");
          try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
          return;
        }
      } catch {}
    }

    const fd = buildFormData();
    if (!fd) return alert("Upload a PDF first.");
    if (exportBtn.disabled) return alert("Convert (preview) first.");

    const f = fileInput.files && fileInput.files[0];
    const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-pdf");
    const filename = `${base}.docx`;

    setStatus("Exporting Word...");
    try {
      await runPaidPdfExport({
        tool: "pdf-to-word",
        endpoint: ENDPOINTS.PDF_TO_WORD,
        formData: fd,
        filename,
        setPreviewFrameId: null,
        placeholderId: null,
      });
      setStatus("Exported.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Export failed."));
    }
  }

  // Auto-preview input on file select
  fileInput.addEventListener("change", () => {
    reset();
    previewInput();
  });

  previewInputBtn.addEventListener("click", previewInput);
  convertBtn.addEventListener("click", convertPreview);
  exportBtn.addEventListener("click", exportWord);
}

// -------------------- PDF â†’ JPG (split preview, ZIP export) --------------------
function initPdfToJpgSplit() {
  const fileInput = $("pdfToJpgFile");
  const pwInput = $("pdfToJpgPassword");
  const previewInputBtn = $("pdfToJpgInputPreviewBtn");
  const convertBtn = $("pdfToJpgPreviewBtn");
  const exportBtn = $("pdfToJpgExportBtn");
  const statusEl = $("pdf2jpgStatus");

  const inputHost = $("pdf2jpgInputPreviewHost");
  const outputHost = $("pdf2jpgOutputPreviewHost");

  if (!fileInput || !previewInputBtn || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

  inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  outputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  inputHost.style.userSelect = "none";
  outputHost.style.userSelect = "none";

  let lastZipBlob = null;

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg || "";
  }

  function reset() {
    lastZipBlob = null;
    exportBtn.disabled = true;
    inputHost.innerHTML = "";
    outputHost.innerHTML = "";
    showPlaceholder("pdf2jpgInputPlaceholder", true);
    showPlaceholder("pdf2jpgOutputPlaceholder", true);
    setStatus("");
  }

  // PDF.js bootstrap
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs");
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs";
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import("https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs");
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs";
          }
          return lib2;
        } catch (e2) {
          console.error("PDF.js failed to load from CDN.", e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // JSZip bootstrap
  let _jsZipPromise = null;
  async function getJsZipAsync() {
    if (_jsZipPromise) return _jsZipPromise;
    _jsZipPromise = (async () => {
      try {
        const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
        return mod?.default || mod;
      } catch (e1) {
        try {
          await import("https://unpkg.com/jszip@3.10.1/dist/jszip.min.js");
          return window.JSZip || null;
        } catch (e2) {
          console.error("JSZip failed to load from CDN.", e1, e2);
          return window.JSZip || null;
        }
      }
    })();
    return _jsZipPromise;
  }

  async function renderPdfFileToHost(file, host, password, placeholderId) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Preview unavailable.</div>';
      if (placeholderId) showPlaceholder(placeholderId, false);
      return;
    }

    const buf = await file.arrayBuffer();
    const params = { data: new Uint8Array(buf) };
    if (password) params.password = password;

    const task = pdfjs.getDocument(params);
    if (password) task.onPassword = (updatePassword) => updatePassword(password);

    const doc = await task.promise;
    host.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 6);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let i = 1; i <= maxPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }

    if (placeholderId) showPlaceholder(placeholderId, false);
  }

  function buildFormData() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return null;
    const fd = new FormData();
    fd.append("file", f, f.name || "document.pdf");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");
    if (pw) fd.append("password", pw);
    return fd;
  }

  async function previewInput() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");
    setStatus("Rendering input preview...");
    try {
      await renderPdfFileToHost(f, inputHost, pw, "pdf2jpgInputPlaceholder");
      setStatus("");
    } catch (e) {
      console.error(e);
      setStatus("Input preview failed.");
    }
  }

  async function buildZipFromPdfToJpg(file, password) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) throw new Error("PDF.js failed to load.");

    const JSZip = await getJsZipAsync();
    if (!JSZip) throw new Error("JSZip failed to load.");

    const buf = await file.arrayBuffer();
    const params = { data: new Uint8Array(buf) };
    if (password) params.password = password;

    const task = pdfjs.getDocument(params);
    if (password) task.onPassword = (updatePassword) => updatePassword(password);

    const doc = await task.promise;
    const zip = new JSZip();

    // Output preview
    outputHost.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    outputHost.appendChild(wrap);

    const previewPages = Math.min(doc.numPages, 6);
    const quality = 0.95;

    for (let i = 1; i <= doc.numPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });

      // "Full quality": render larger. Clamp to avoid blowing up memory.
      const targetWidth = 1800;
      const scale = Math.max(1.0, Math.min(3.0, targetWidth / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      // Add to zip
      const dataUrl = canvas.toDataURL("image/jpeg", quality);
      const blob = await (await fetch(dataUrl)).blob();
      zip.file(`page-${String(i).padStart(3, "0")}.jpg`, blob);

      // Preview only first few pages
      if (i <= previewPages) {
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";
        wrap.appendChild(canvas);
      }
    }

    showPlaceholder("pdf2jpgOutputPlaceholder", false);

    const zipBlob = await zip.generateAsync({ type: "blob" });
    return zipBlob;
  }

  async function convertPreview() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    exportBtn.disabled = true;
    lastZipBlob = null;
    outputHost.innerHTML = "";
    showPlaceholder("pdf2jpgOutputPlaceholder", true);

    setStatus("Converting (preview)...");
    try {
      lastZipBlob = await buildZipFromPdfToJpg(f, pw);
      exportBtn.disabled = false;
      setStatus("Ready to export ZIP.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Convert failed."));
      showPlaceholder("pdf2jpgOutputPlaceholder", true);
    }
  }

  async function exportZip() {
    if (!lastZipBlob) return alert("Convert (preview) first.");

    const f = fileInput.files && fileInput.files[0];
    const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-pdf");
    const filename = `${base}-jpg.zip`;

    // Enforce paywall/export access server-side (no conversion on server).
    const fd = buildFormData();
    if (!fd) return alert("Upload a PDF first.");

    setStatus("Authorizing export...");
    try {
      const out = await runPaidPdfExport({
        tool: "pdf-to-jpg",
        endpoint: "/api/pdf-to-jpg/authorize",
        formData: fd,
        filename: null, // don't download server blob
        setPreviewFrameId: null,
        placeholderId: null,
      });
      try { if (out?.objectUrl) URL.revokeObjectURL(out.objectUrl); } catch {}
      downloadBlob(lastZipBlob, filename);
      setStatus("Exported.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Export blocked."));
    }
  }

  fileInput.addEventListener("change", () => {
    reset();
    previewInput();
  });

  previewInputBtn.addEventListener("click", previewInput);
  convertBtn.addEventListener("click", convertPreview);
  exportBtn.addEventListener("click", exportZip);
}

function initPdfToPngSplit() {
  const fileInput = $("pdfToPngFile");
  const pwInput = $("pdfToPngPassword");
  const convertBtn = $("pdfToPngPreviewBtn");
  let unlockBtn = $("pdfToPngUnlockBtn");
  const exportBtn = $("pdfToPngExportBtn");
  const statusEl = $("pdf2pngStatus");

  const inputHost = $("pdf2pngInputPreviewHost");
  const outputHost = $("pdf2pngOutputPreviewHost");

  if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

  // Backward-compatible: if HTML hasn't been patched, inject an Unlock button next to Convert
  if (!unlockBtn) {
    unlockBtn = document.createElement("button");
    unlockBtn.id = "pdfToPngUnlockBtn";
    unlockBtn.className = "btn btn-secondary";
    unlockBtn.type = "button";
    unlockBtn.textContent = "Decrypt / Unlock";
    const actions = convertBtn.parentElement;
    if (actions) actions.insertBefore(unlockBtn, convertBtn);
  }

  inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  outputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  inputHost.style.userSelect = "none";
  outputHost.style.userSelect = "none";

  let lastZipBlob = null;
  let previewUrls = [];
  let unlockedFile = null;
  let isEncrypted = false;

  function setStatus(msg) { if (statusEl) statusEl.textContent = msg || ""; }

  function cleanupPreviewUrls() {
    for (const u of previewUrls) { try { URL.revokeObjectURL(u); } catch {} }
    previewUrls = [];
  }

  function resetOutput() {
    cleanupPreviewUrls();
    lastZipBlob = null;
    exportBtn.disabled = true;
    outputHost.innerHTML = "";
    showPlaceholder("pdf2pngOutputPlaceholder", true);
  }

  function resetInput() {
    inputHost.innerHTML = "";
    showPlaceholder("pdf2pngInputPlaceholder", true);
  }

  function setInputPlaceholderText(t) {
    const ph = $("pdf2pngInputPlaceholder");
    if (ph && t) ph.textContent = t;
  }

  // PDF.js bootstrap
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // JSZip bootstrap
  let _jsZipPromise = null;
  async function getJsZipAsync() {
    if (_jsZipPromise) return _jsZipPromise;
    _jsZipPromise = (async () => {
      try {
        const mod = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm');
        return mod?.default || mod;
      } catch (e1) {
        try {
          await import('https://unpkg.com/jszip@3.10.1/dist/jszip.min.js');
          return window.JSZip || null;
        } catch (e2) {
          console.error('JSZip failed to load from CDN.', e1, e2);
          return window.JSZip || null;
        }
      }
    })();
    return _jsZipPromise;
  }

  async function renderPdfBytesToHost(bytes, host) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Preview unavailable.</div>';
      return;
    }

    const task = pdfjs.getDocument({ data: bytes });
    const doc = await task.promise;

    host.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 6);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let p = 1; p <= maxPages; p++) {
      const page = await doc.getPage(p);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }

    showPlaceholder("pdf2pngInputPlaceholder", false);
  }

  async function buildZipFromPdf(file) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) throw new Error("PDF.js failed to load.");

    const JSZip = await getJsZipAsync();
    if (!JSZip) throw new Error("JSZip failed to load.");

    const buf = await file.arrayBuffer();
    const bytes = new Uint8Array(buf);

    const task = pdfjs.getDocument({ data: bytes });
    const doc = await task.promise;

    const zip = new JSZip();

    outputHost.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    outputHost.appendChild(wrap);

    const previewPages = Math.min(doc.numPages, 6);
    const scaleFull = 3.0;

    for (let p = 1; p <= doc.numPages; p++) {
      setStatus(`Rendering page ${p}/${doc.numPages}...`);

      const page = await doc.getPage(p);
      const viewport = page.getViewport({ scale: scaleFull });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png", 1.0));
      if (!blob) throw new Error("Failed to encode PNG.");

      const name = `page-${String(p).padStart(3, "0")}.png`;
      zip.file(name, blob);

      if (p <= previewPages) {
        const url = URL.createObjectURL(blob);
        previewUrls.push(url);
        const img = document.createElement("img");
        img.src = url;
        img.alt = `Page ${p}`;
        img.draggable = false;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.borderRadius = "12px";
        img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        img.style.background = "white";
        wrap.appendChild(img);
      }

      canvas.width = 0; canvas.height = 0;
    }

    showPlaceholder("pdf2pngOutputPlaceholder", false);
    setStatus("Building ZIP...");
    const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
    return zipBlob;
  }

  async function refreshInputPreview() {
    const f = fileInput.files && fileInput.files[0];
    resetInput();
    if (!f) return;

    if (isEncrypted && !unlockedFile) {
      setInputPlaceholderText('Encrypted PDF detected. Enter the password and click Decrypt / Unlock.');
      showPlaceholder("pdf2pngInputPlaceholder", true);
      return;
    }

    setStatus("Loading preview...");
    try {
      const src = unlockedFile || f;
      const bytes = new Uint8Array(await src.arrayBuffer());
      await renderPdfBytesToHost(bytes, inputHost);
      setStatus("");
    } catch (e) {
      console.error(e);
      setStatus("");
      setInputPlaceholderText("Preview failed.");
      showPlaceholder("pdf2pngInputPlaceholder", true);
    }
  }

  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    unlockedFile = null;
    isEncrypted = false;
    resetOutput();
    resetInput();
    exportBtn.disabled = true;

    if (!f) return;

    setStatus("Checking PDFâ€¦");
    try {
      isEncrypted = await detectEncryptedPdfReliable(f);
    } catch {
      isEncrypted = false;
    }

    if (isEncrypted) {
      convertBtn.disabled = false; // allow user to click Convert (it will require unlock), but keep preview gated
      setStatus("Encrypted PDF detected.");
      setInputPlaceholderText('Encrypted PDF detected. Enter the password and click Decrypt / Unlock.');
      showPlaceholder("pdf2pngInputPlaceholder", true);
      return;
    }

    convertBtn.disabled = false;
    setStatus("");
    await refreshInputPreview();
  });

  unlockBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = String(pwInput?.value || "").trim();
    if (!pw) return alert("Enter the PDF password.");

    unlockBtn.disabled = true;
    unlockBtn.textContent = "Decryptingâ€¦";
    try {
      setStatus("Decryptingâ€¦");
      unlockedFile = await decryptPdfToFile(f, pw);
      isEncrypted = false;
      resetOutput();
      await refreshInputPreview();
      setStatus("Unlocked. Ready.");
    } catch (e) {
      alert(String(e?.message || e || "Decrypt failed."));
      setStatus("");
    } finally {
      unlockBtn.disabled = false;
      unlockBtn.textContent = "Decrypt / Unlock";
    }
  });

  convertBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");

    convertBtn.disabled = true;
    exportBtn.disabled = true;
    resetOutput();

    try {
      // If encrypted and not unlocked yet, try to unlock (same UX as other tools)
      if (isEncrypted && !unlockedFile) {
        const pw = String(pwInput?.value || "").trim();
        if (!pw) {
          setStatus("");
          return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
        }
        setStatus("Decryptingâ€¦");
        unlockedFile = await decryptPdfToFile(f, pw);
        isEncrypted = false;
        await refreshInputPreview();
      }

      setStatus("Converting (preview)...");
      const sourceFile = unlockedFile || f;

      const zipBlob = await buildZipFromPdf(sourceFile);
      lastZipBlob = zipBlob;
      exportBtn.disabled = false;
      setStatus("Ready.");
    } catch (err) {
      console.error(err);
      alert(String(err?.message || err || "Conversion failed."));
      setStatus("");
    } finally {
      convertBtn.disabled = false;
    }
  });

  exportBtn.addEventListener("click", () => {
    if (!lastZipBlob) return alert("Convert (preview) first.");
    downloadBlob(lastZipBlob, "pdfrealm-pdf-to-png.zip");
  });

  // Initial state
  convertBtn.disabled = false;
}

  initPdfToJpgSplit();
    initPdfToWordSplit();
  initPdfToPngSplit();
}

// -------------------- OCR --------------------
function initOcr() {
  // Input preview (image) using the same iframe previewer.
  wireLocalPdfPreview("ocrFile", "ocrPreviewFrame", "ocrPreviewPlaceholder");

  const btn = $("ocrRunBtn");
  if (!btn) return;

  btn.addEventListener("click", async () => {
    const f = $("ocrFile")?.files?.[0];
    if (!f) return alert("Upload an image first.");
    const lang = ($("ocrLang")?.value || "eng").trim() || "eng";

    const fd = new FormData();
    fd.append("file", f);
    fd.append("lang", lang);

    try {
      const res = await fetch(ENDPOINTS.OCR, { method: "POST", body: fd });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error(data?.error || "OCR failed");
      $("ocrOutput").value = data?.text || "";
    } catch (e) {
      alert(e.message || "OCR failed");
    }
  });
}


// -------------------- Templates --------------------
function initTemplates() {
  const btn = $("refreshTemplatesBtn");
  const list = $("templateList");

  async function refresh() {
    if (!list) return;
    list.innerHTML = "Loading...";
    try {
      const res = await fetch(ENDPOINTS.TEMPLATES);
      const items = await res.json();
      list.innerHTML = "";

      if (!Array.isArray(items) || !items.length) {
        list.innerHTML = `<div class="pill">No templates found. Add PDFs to /templates folder.</div>`;
        return;
      }

      items.forEach((t) => {
        const row = document.createElement("div");
        row.className = "card";
        row.style.padding = "12px";
        row.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
            <div>
              <div style="font-weight:900;">${escapeHtml(t.name || t.id)}</div>
              <div style="color:var(--muted);font-size:.95em;margin-top:4px;">${escapeHtml(t.description || "")}</div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
              <button class="btn btn-secondary" data-template-preview="${escapeAttr(t.id)}" type="button">Preview</button>
              <a class="btn btn-primary" href="${ENDPOINTS.TEMPLATE_DOWNLOAD}?id=${encodeURIComponent(t.id)}">Download</a>
            </div>
          </div>
        `;
        list.appendChild(row);
      });
    } catch {
      list.innerHTML = `<div class="pill">Failed to load templates.</div>`;
    }
  }

  document.addEventListener("click", (e) => {
    const b = e.target?.closest?.("[data-template-preview]");
    if (!b) return;
    const id = b.getAttribute("data-template-preview");
    setIframeSrc("templatePreviewFrame", `${ENDPOINTS.TEMPLATE_PREVIEW}?id=${encodeURIComponent(id)}`);
    showPlaceholder("templatePreviewPlaceholder", false);
  });

  if (btn) btn.addEventListener("click", refresh);
  refresh();
}

// -------------------- Secure Vault (S3) UI --------------------
// Expected HTML IDs (see list below):
// vaultStatus, vaultRefreshBtn, vaultFile, vaultFolder, vaultLabel, vaultUploadBtn,
// vaultNewFolder, vaultCreateFolderBtn, vaultList

async function refreshVaultList() {
  const list = $("vaultList");
  const status = $("vaultStatus");
  if (!list) return; // vault tab not present on this page
  list.innerHTML = "";
  if (!getToken()) {
    list.innerHTML = `<div class="pill">Login required to use Secure Vault.</div>`;
    if (status) setStatus(status, "Status: Login required");
    return;
  }

  try {
    if (status) setStatus(status, "Status: Loading...");
    const data = await fetchJson(ENDPOINTS.VAULT_LIST, {
      method: "GET",
      headers: authHeaders(),
    });

    const items = Array.isArray(data?.items) ? data.items : [];
    if (!items.length) {
      list.innerHTML = `<div class="pill">No files yet. Upload something to your Vault.</div>`;
      if (status) setStatus(status, "Status: Ready");
      return;
    }

    // Sort newest first (if lastModified exists)
    items.sort((a, b) => {
      const da = a?.lastModified ? new Date(a.lastModified).getTime() : 0;
      const db = b?.lastModified ? new Date(b.lastModified).getTime() : 0;
      return db - da;
    });

    items.forEach((it) => {
      const row = document.createElement("div");
      row.className = "card";
      row.style.padding = "12px";

      const safeName = escapeHtml(it.filename || it.key || "");
      const size = typeof it.size === "number" ? formatBytes(it.size) : "";
      const lm = it.lastModified ? new Date(it.lastModified).toLocaleString() : "";

      row.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;">
          <div style="min-width:0;">
            <div style="font-weight:900;word-break:break-word;">${safeName}</div>
            <div style="color:var(--muted);font-size:.92em;margin-top:4px;">
              ${escapeHtml(size)}${size && lm ? " â€¢ " : ""}${escapeHtml(lm)}
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;flex-shrink:0;">
            <button class="btn btn-secondary" type="button" data-vault-open="${escapeAttr(it.id)}">Open</button>
            <button class="btn btn-danger" type="button" data-vault-delete="${escapeAttr(it.id)}">Delete</button>
          </div>
        </div>
      `;
      list.appendChild(row);
    });

    if (status) setStatus(status, "Status: Ready");
  } catch (e) {
    if (status) setStatus(status, "Status: Error");
    list.innerHTML = `<div class="pill">Failed to load Vault list: ${escapeHtml(e.message || "Unknown error")}</div>`;
  }
}

function initVault() {
  const refreshBtn = $("vaultRefreshBtn");
  const uploadBtn = $("vaultUploadBtn");
  const createFolderBtn = $("vaultCreateFolderBtn");
  const status = $("vaultStatus");

  if (refreshBtn) refreshBtn.addEventListener("click", refreshVaultList);

  // Delegated actions: Open/Delete
  document.addEventListener("click", async (e) => {
    const openBtn = e.target?.closest?.("[data-vault-open]");
    const delBtn = e.target?.closest?.("[data-vault-delete]");

    if (openBtn) {
      const id = openBtn.getAttribute("data-vault-open");
      if (!id) return;
      if (!getToken()) return openModal("accountModal");

      try {
        if (status) setStatus(status, "Status: Generating link...");
        const data = await fetchJson(`${ENDPOINTS.VAULT_FILE}/${encodeURIComponent(id)}`, {
          method: "GET",
          headers: authHeaders(),
        });
        if (data?.url) { const w = window.open(data.url, "_blank"); if (w) w.opener = null; }
        if (status) setStatus(status, "Status: Ready");
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Failed to open file.");
      }
      return;
    }

    if (delBtn) {
      const id = delBtn.getAttribute("data-vault-delete");
      if (!id) return;
      if (!getToken()) return openModal("accountModal");

      const ok = confirm("Delete this file from your Vault? This cannot be undone.");
      if (!ok) return;

      try {
        if (status) setStatus(status, "Status: Deleting...");
        await fetchJson(`${ENDPOINTS.VAULT_FILE}/${encodeURIComponent(id)}`, {
          method: "DELETE",
          headers: authHeaders(),
        });
        if (status) setStatus(status, "Status: Ready");
        await refreshVaultList();
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Failed to delete file.");
      }
    }
  });

  if (uploadBtn) {
    uploadBtn.addEventListener("click", async () => {
      const file = $("vaultFile")?.files?.[0];
      const folder = ($("vaultFolder")?.value || "").trim();
      const label = ($("vaultLabel")?.value || "").trim();

      if (!getToken()) return openModal("accountModal");
      if (!file) return alert("Choose a file to upload.");

      const fd = new FormData();
      fd.append("file", file);
      if (folder) fd.append("folder", folder);
      if (label) fd.append("label", label);

      try {
        if (status) setStatus(status, "Status: Uploading...");
        const res = await fetch(ENDPOINTS.VAULT_UPLOAD, {
          method: "POST",
          headers: authHeaders(), // DO NOT set Content-Type for FormData
          body: fd,
        });

        const data = await res.json().catch(() => null);
        if (!res.ok) throw new Error(data?.error || `Upload failed (${res.status})`);

        if (status) setStatus(status, "Status: Uploaded");
        // Clear file input (safely)
        const fi = $("vaultFile");
        if (fi) fi.value = "";
        await refreshVaultList();
        if (status) setStatus(status, "Status: Ready");
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Upload failed.");
      }
    });
  }

  if (createFolderBtn) {
    createFolderBtn.addEventListener("click", async () => {
      const folderPath = ($("vaultNewFolder")?.value || "").trim();
      if (!getToken()) return openModal("accountModal");
      if (!folderPath) return alert("Enter a folder name/path (e.g., Freight/2026).");

      try {
        if (status) setStatus(status, "Status: Creating folder...");
        await fetchJson(ENDPOINTS.VAULT_FOLDER, {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ folderPath }),
        });
        if (status) setStatus(status, "Status: Folder created");
        const nf = $("vaultNewFolder");
        if (nf) nf.value = "";
        // folders are markers; list refresh still useful for UX
        await refreshVaultList();
        if (status) setStatus(status, "Status: Ready");
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Folder create failed.");
      }
    });
  }

  // Initial load if vault exists on this page
  refreshVaultList().catch(() => {});
}

// -------------------- Escaping helpers --------------------
function escapeHtml(s) {
  return String(s || "").replace(/[&<>"']/g, (c) =>
    ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[c])
  );
}
function escapeAttr(s) {
  return String(s || "").replace(/"/g, "&quot;");
}

function clamp01(n) {
  const x = Number(n);
  if (!isFinite(x)) return 0;
  return Math.max(0, Math.min(1, x));
}

function formatBytes(bytes) {
  const b = Number(bytes || 0);
  if (!isFinite(b) || b <= 0) return "0 B";
  const units = ["B", "KB", "MB", "GB", "TB"];
  const k = 1024;
  const i = Math.min(units.length - 1, Math.floor(Math.log(b) / Math.log(k)));
  const v = b / Math.pow(k, i);
  return `${v.toFixed(v >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
}



// -------------------- Capability gating (audited tools only) --------------------
async function initCapabilities() {
  try {
    const res = await fetch("/api/capabilities");
    const data = await res.json().catch(() => null);
    if (!res.ok || !data || !data.tools) return;
    applyToolAvailability(data);
  } catch {
    // ignore
  }
}

function applyToolAvailability(cap) {
  const tools = cap?.tools || {};
  // Client-only conversion tools: force-enable even if server capabilities are conservative.
  tools.jpg2png = true;
  tools.png2jpg = true;
  tools.docx2png = true;
  const tabs = Array.from(document.querySelectorAll(".tool-tab"));

  tabs.forEach((btn) => {
    const key = btn.getAttribute("data-tool");
    if (!key) return;

    if (tools[key] === false) {
      btn.disabled = true;
      btn.setAttribute("aria-disabled", "true");
      btn.title = "Not available on this server (coming soon).";

      const view = document.querySelector(`.tool-view[data-tool-view="${key}"]`);
      if (view && !view.querySelector(".tool-unavailable")) {
        const body = view.querySelector(".tool-body") || view;
        const div = document.createElement("div");
        div.className = "card tool-unavailable";
        div.style.marginBottom = "14px";
        div.innerHTML = `
          <div style="font-weight:900;margin-bottom:6px;">Not available on this server</div>
          <div style="color:var(--muted);">This tool needs a backend route that isn't enabled yet.</div>
        `;
        body.prepend(div);
      }
    }
  });

  const active = document.querySelector(".tool-tab.tool-tab-active");
  if (active && (active.disabled || active.getAttribute("aria-disabled") === "true")) {
    const first = tabs.find((x) => !x.disabled && x.getAttribute("aria-disabled") !== "true");
    if (first && typeof window.__pdfrealmActivateTool === "function") {
      window.__pdfrealmActivateTool(first.getAttribute("data-tool"));
    }
  }
}

  // -------------------- Boot --------------------
  document.addEventListener("DOMContentLoaded", () => {
    const __safeInit = (name, fn) => {
      try {
        if (typeof fn === "function") fn();
      } catch (e) {
        console.error(`[pdfrealm] init failed: ${name}`, e);
      }
    };

  __safeInit("setYear", setYear);
  __safeInit("initTabs", initTabs);
  __safeInit("initCapabilities", initCapabilities);
  __safeInit("initAccount", initAccount);
  __safeInit("updateAccountDot", updateAccountDot);
  __safeInit("capturePpeSuccessFromUrl", capturePpeSuccessFromUrl);
  __safeInit("initStudio", initStudio);
  __safeInit("initQuickSign", initQuickSign);
  __safeInit("initPassword", initPassword);
  __safeInit("initMerge", initMerge);
  __safeInit("initDeletePages", initDeletePages);
  __safeInit("initSplit", initSplit);
  __safeInit("initReorderSecure", initReorderSecure);
  __safeInit("initCompressSecure", initCompressSecure);
  __safeInit("initWatermarkSecure", initWatermarkSecure);
  __safeInit("initPageNumsSecure", initPageNumsSecure);
  __safeInit("initStampSecure", initStampSecure);
  __safeInit("initRedactSecure", initRedactSecure);
  __safeInit("initFlattenSecure", initFlattenSecure);
  __safeInit("initMetadataSecure", initMetadataSecure);
  __safeInit("initConvert", initConvert);
  __safeInit("initMoreToolsPreview", initMoreToolsPreview);
  __safeInit("initMoreToolsActions", initMoreToolsActions);
  __safeInit("initRotateInteractive", initRotateInteractive);
  __safeInit("initOcr", initOcr);
  __safeInit("initTemplates", initTemplates);
// Secure Vault tab wiring (no-op if elements are absent)
  __safeInit("initVault", initVault);

  });
