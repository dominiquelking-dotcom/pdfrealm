
// [pdfrealm] GLOBAL_CALL_HELPERS_SHIM
(function(){
  function getTokenSafe(){
    try { if (typeof getAuthToken === "function") return (getAuthToken()||"").trim(); } catch {}
    try {
      const m = document.cookie.match(/(?:^|;\s*)pdfrealm_token=([^;]+)/);
      if (m) return decodeURIComponent(m[1]).trim();
    } catch {}
    try { return (localStorage.getItem("pdfrealm_token")||localStorage.getItem("token")||"").trim(); } catch {}
    return "";
  }

  if (typeof globalThis.callJson !== "function") {
    globalThis.callJson = async function callJson(url, body, opts = {}) {
      const method = opts.method || "POST";
      const headers = new Headers(opts.headers || {});
      const token = getTokenSafe();
      if (token && !headers.has("Authorization")) headers.set("Authorization","Bearer "+token);

      const isForm = (typeof FormData !== "undefined") && body instanceof FormData;
      if (!isForm && body != null && !headers.has("Content-Type")) headers.set("Content-Type","application/json");

      const res = await fetch(url, {
        method,
        headers,
        credentials: "same-origin",
        body: body == null ? undefined : (isForm ? body : (typeof body === "string" ? body : JSON.stringify(body)))
      });
      if (!res.ok) {
        let msg = "HTTP "+res.status;
        try { const t = await res.text(); if (t) msg += ": " + t.slice(0,400); } catch {}
        throw new Error(msg);
      }
      const ct = (res.headers.get("content-type")||"").toLowerCase();
      if (ct.includes("application/json")) return await res.json();
      const text = await res.text();
      try { return JSON.parse(text); } catch { return { ok:true, text }; }
    };
  }

  if (typeof globalThis.callBlob !== "function") {
    globalThis.callBlob = async function callBlob(url, body, opts = {}) {
      const method = opts.method || "POST";
      const headers = new Headers(opts.headers || {});
      const token = getTokenSafe();
      if (token && !headers.has("Authorization")) headers.set("Authorization","Bearer "+token);

      const res = await fetch(url, {
        method,
        headers,
        credentials: "same-origin",
        body: body == null ? undefined : body
      });
      if (!res.ok) {
        let msg = "HTTP "+res.status;
        try { const t = await res.text(); if (t) msg += ": " + t.slice(0,400); } catch {}
        throw new Error(msg);
      }
      return await res.blob();
    };
  }
})();

// public/app.js — PDFRealm frontend wiring
// - Preview PDFs locally using object URLs
// - PDF Studio overlay placement via click-layer (not iframe)
// - Pay-per-export ($1.49) when export is blocked (402 PAYWALL)
// - Optional account login/subscription support
// - Secure Vault UI (S3-backed): list/upload/folder/download/delete

const ENDPOINTS = {
  // Auth
  ME: "/api/me",
  LOGIN: "/api/login",

  // Stripe
  PAYWALL_CHECKOUT: "/api/paywall/create-checkout-session",
  BILLING_CHECKOUT: "/api/billing/create-checkout-session",
  PPE_CHECKOUT: "/api/pay-per-export/create-checkout-session",

  // Tools
  PDF_STUDIO: "/api/pdf-studio",
  QUICK_SIGN: "/api/quick-sign",
  ENCRYPT: "/api/encrypt",
  DECRYPT: "/api/decrypt",
  IS_ENCRYPTED: "/api/is-encrypted",
  QPDF_NORMALIZE: "/api/qpdf/normalize",

  INVOICE: "/api/invoice",
  RECEIPT: "/api/receipt",
  PAYSTUB: "/api/paystub",

  // Legacy preview endpoints (kept for compatibility)
  INVOICE_PREVIEW: "/api/invoice/preview",
  RECEIPT_PREVIEW: "/api/receipt/preview",
  PAYSTUB_PREVIEW: "/api/paystub/preview",

  MERGE: "/api/merge",
  DELETE_PAGE: "/api/delete-page",
  DELETE_PAGES: "/api/delete-pages",
  SPLIT: "/api/split",

  COMPRESS: "/api/compress",
  ROTATE: "/api/rotate",
  REORDER: "/api/reorder",
  WATERMARK: "/api/watermark",

  META_REMOVE: "/api/meta/remove",
  META_APPLY: "/api/meta/apply",
  FLATTEN: "/api/flatten",
  REMOVE_BLANK: "/api/remove-blank-pages",

  PAGE_NUMBERS: "/api/page-numbers",
  STAMP: "/api/stamp",
  REDACT: "/api/redact",
  REDACT_BURN: "/api/redact/burn",
  META_SANITIZE: "/api/meta/sanitize",
  RASTERIZE: "/api/rasterize",
  PDF_TO_PAGES_ZIP_AUTH: "/api/pdf-to-pages-zip/authorize",
  // Premium: Embed media into PDF
  EMBED_IMAGE_PREVIEW: "/api/embed/image/preview",
  EMBED_IMAGE_EXPORT: "/api/embed/image",
  EMBED_AUDIO_PREVIEW: "/api/embed/audio/preview",
  EMBED_AUDIO_EXPORT: "/api/embed/audio",
  EMBED_VIDEO_PREVIEW: "/api/embed/video/preview",
  EMBED_VIDEO_EXPORT: "/api/embed/video",

  REPAIR: "/api/repair",
  RESIZE_PAGES: "/api/resize-pages",

  JPG_TO_PDF: "/api/jpg-to-pdf",
  PNG_TO_PDF: "/api/png-to-pdf",
  PDF_TO_JPG: "/api/pdf-to-jpg",
  PDF_TO_PNG: "/api/pdf-to-png",
  WORD_TO_PDF: "/api/word-to-pdf",
  WORD_TO_PDF_PREVIEW: "/api/word-to-pdf/preview",
  WORD_TO_PDF_INPUT_PREVIEW: "/api/word-to-pdf/input-preview",
  PDF_TO_WORD: "/api/pdf-to-word",

  // Extended conversions
  JPG_TO_PNG: "/api/jpg-to-png",
  PNG_TO_JPG: "/api/png-to-jpg",
  PDF_TO_TIFF: "/api/pdf-to-tiff",
  TIFF_TO_PDF: "/api/tiff-to-pdf",
  MULTI_IMAGE_TO_PDF: "/api/multi-image-to-pdf",
  DOCX_TO_PNG: "/api/docx-to-png",
  PDF_TO_SVG: "/api/pdf-to-svg",
  SVG_TO_PDF: "/api/svg-to-pdf",

  // Dev/Text → PDF
  HTML_TO_PDF: "/api/html-to-pdf",
  HTML_TO_PDF_PREVIEW: "/api/html-to-pdf/preview",
  URL_TO_PDF: "/api/url-to-pdf",
  URL_TO_PDF_PREVIEW: "/api/url-to-pdf/preview",
  JSON_TO_PDF: "/api/json-to-pdf",
  JSON_TO_PDF_PREVIEW: "/api/json-to-pdf/preview",
  MARKDOWN_TO_PDF: "/api/markdown-to-pdf",
  MARKDOWN_TO_PDF_PREVIEW: "/api/markdown-to-pdf/preview",
  CSV_TO_PDF: "/api/csv-to-pdf",
  CSV_TO_PDF_PREVIEW: "/api/csv-to-pdf/preview",
  TEXT_TO_PDF: "/api/text-to-pdf",
  TEXT_TO_PDF_PREVIEW: "/api/text-to-pdf/preview",

  OCR: "/api/ocr",
TEMPLATES: "/api/templates",
  TEMPLATE_PREVIEW: "/api/templates/preview",
  TEMPLATE_DOWNLOAD: "/api/templates/download",

  // Secure Vault
  VAULT_S3_TEST: "/api/vault/s3-test",
  VAULT_WHOAMI: "/api/vault/whoami", // optional server route (if present)
  VAULT_LIST: "/api/vault/list",
  VAULT_UPLOAD: "/api/vault/upload",
  VAULT_FOLDER: "/api/vault/folder",
  VAULT_FILE: "/api/vault/file", // GET/DELETE with /:id
};

const STORAGE = {
  token: "pdfrealm_token",
  ppe: "pdfrealm_ppe_sessions_by_tool", // JSON map tool -> session_id
};

// -------------------- Helpers --------------------
function $(id) {
  return document.getElementById(id);
}

function setYear() {
  const y = $("year");
  if (y) y.textContent = String(new Date().getFullYear());
}

function getToken() {
  return localStorage.getItem(STORAGE.token) || "";
}

function setToken(t) {
  if (!t) {
    localStorage.removeItem(STORAGE.token);
    try { document.cookie = "pdfrealm_token=; Max-Age=0; path=/; samesite=lax" + (location.protocol === "https:" ? "; secure" : ""); } catch (_) {}
  } else {
    localStorage.setItem(STORAGE.token, t);
    try { document.cookie = "pdfrealm_token=" + encodeURIComponent(t) + "; path=/; samesite=lax" + (location.protocol === "https:" ? "; secure" : ""); } catch (_) {}
  }
  updateAccountDot();
}

function getPpeMap() {
  try {
    return JSON.parse(localStorage.getItem(STORAGE.ppe) || "{}");
  } catch {
    return {};
  }
}

function setPpeForTool(tool, sessionId) {
  const m = getPpeMap();
  m[tool] = sessionId;
  localStorage.setItem(STORAGE.ppe, JSON.stringify(m));
}

function getPpeForTool(tool) {
  const m = getPpeMap();
  return m[tool] || "";
}

function updateAccountDot() {
  const btn = $("accountLoginBtn");
  if (!btn) return;
  const dot = btn.querySelector(".dot");
  if (!dot) return;
  if (getToken()) dot.classList.add("dot-logged-in");
  else dot.classList.remove("dot-logged-in");
}

function openModal(id) {
  const el = $(id);
  if (!el) return;

  // Many PDFRealm pages (e.g., broker.html) style modals using `.modal.open`.
  // Some newer pages used `.modal.modal-open`. Support BOTH so the UI never appears "dead".
  el.classList.add("open");
  el.classList.add("modal-open");
  el.setAttribute("aria-hidden", "false");
}

function closeModal(id) {
  const el = $(id);
  if (!el) return;
  el.classList.remove("open");
  el.classList.remove("modal-open");
  el.setAttribute("aria-hidden", "true");
}

function setStatus(el, text) {
  if (!el) return;
  el.innerHTML = `<span class="pill">${text}</span>`;
}

function showPlaceholder(placeholderId, show) {
  const el = $(placeholderId);
  if (!el) return;
  el.style.display = show ? "flex" : "none";
}

function setIframeSrc(frameId, src) {
  const fr = $(frameId);
  if (!fr) return;
  let out = src || "";
  // For Merge + Split previews, try to suppress built-in PDF viewer toolbars.
  // (Some browsers may still show minimal UI; this is the best we can do without PDF.js.)
  if (out && (frameId === "mergePreviewFrame" || frameId === "splitPreviewFrame" || frameId === "reorderPreviewFrame" || frameId === "compressPreviewFrame" || frameId === "watermarkPreviewFrame" || frameId === "pageNumsPreviewFrame")) {
    if (!out.includes("#")) out += "#toolbar=0&navpanes=0&scrollbar=0";
  }
  fr.setAttribute("src", out);
}

function makeObjectUrlFromFile(file) {
  return URL.createObjectURL(file);
}


// Detect whether a PDF is likely encrypted (client-side heuristic).
// IMPORTANT: Do not rely on the embedded PDF viewer's password prompt.
// We block preview/export for encrypted PDFs until the user unlocks via our UI.
async function detectEncryptedPdf(file) {
  try {
    if (!file) return false;

    // Fast, reliable scan for the literal /Encrypt token.
    // Some PDFs (incremental updates) may place the trailer far from the end,
    // so we scan a larger tail section and (if needed) chunk-scan the rest.

    const TOKEN_RE = /\/Encrypt\b/i;

    // Prefer ISO-8859-1/Latin1 decoding so we don't lose bytes.
    let dec;
    try {
      dec = new TextDecoder("iso-8859-1");
    } catch {
      try { dec = new TextDecoder("latin1"); } catch { dec = new TextDecoder(); }
    }

    const MB = 1024 * 1024;
    const HEAD = Math.min(1 * MB, file.size);
    const TAIL = Math.min(8 * MB, file.size);

    // Head scan
    {
      const buf = await file.slice(0, HEAD).arrayBuffer();
      const txt = dec.decode(new Uint8Array(buf));
      if (TOKEN_RE.test(txt)) return true;
    }

    // Tail scan (larger than head because trailers + incremental updates usually live near the end)
    {
      const start = Math.max(0, file.size - TAIL);
      const buf = await file.slice(start, file.size).arrayBuffer();
      const txt = dec.decode(new Uint8Array(buf));
      if (TOKEN_RE.test(txt)) return true;
    }

    // Chunk scan the middle only if necessary.
    // This keeps things responsive while still catching odd layouts.
    const middleStart = HEAD;
    const middleEnd = Math.max(middleStart, file.size - TAIL);
    if (middleEnd <= middleStart) return false;

    const CHUNK = 2 * MB;
    const OVERLAP = 128; // bytes

    for (let off = middleStart; off < middleEnd; off += CHUNK) {
      const a = Math.max(0, off - OVERLAP);
      const b = Math.min(file.size, off + CHUNK);
      const buf = await file.slice(a, b).arrayBuffer();
      const txt = dec.decode(new Uint8Array(buf));
      if (TOKEN_RE.test(txt)) return true;
    }

    return false;
  } catch {
    return false;
  }
}

// Reliable encryption detection for previews:
// 1) Fast client-side scan for /Encrypt
// 2) If not found, ask the server (qpdf) for a definitive answer
async function detectEncryptedPdfReliable(file) {
  if (!file) return false;

  const local = await detectEncryptedPdf(file);
  if (local) return true;

  try {
    const fd = new FormData();
    fd.append("file", file);

    const headers = {};
    const token = getToken();
    if (token) headers.Authorization = `Bearer ${token}`;

    const res = await fetch(ENDPOINTS.IS_ENCRYPTED || "/api/is-encrypted", {
      method: "POST",
      body: fd,
      headers,
    });

    if (!res.ok) return false;
    const j = await res.json().catch(() => ({}));
    return !!j.encrypted;
  } catch {
    return false;
  }
}


// Server-side decrypt using /api/decrypt (qpdf). Returns a new File instance.
async function decryptPdfToFile(file, password) {
  if (!file) throw new Error("No file provided.");
  const pw = String(password || "").trim();
  if (!pw) throw new Error("Password required.");

  const fd = new FormData();
  fd.append("file", file);
  fd.append("password", pw);

  const headers = {};
  const token = getToken();
  if (token) headers.Authorization = `Bearer ${token}`;

  const res = await fetch(ENDPOINTS.DECRYPT, { method: "POST", body: fd, headers });
  if (!res.ok) {
    let msg = `Decrypt failed (HTTP ${res.status}).`;
    try {
      const j = await res.json();
      msg = j?.error || msg;
      if (j?.details) msg += `

${j.details}`;
    } catch {}
    throw new Error(msg);
  }

  const blob = await res.blob();
  const origName = file.name || "document.pdf";
  const base = origName.replace(/\.pdf$/i, "");
  const outName = base ? `${base}-decrypted.pdf` : "decrypted.pdf";
  return new File([blob], outName, { type: "application/pdf" });
}



// Load PDF-Lib in the browser only when needed (client-side page splitting)
let __pdfLibPromise = null;
async function ensurePDFLib() {
  if (window.PDFLib) return window.PDFLib;
  if (__pdfLibPromise) return __pdfLibPromise;
  __pdfLibPromise = new Promise((resolve, reject) => {
    const el = document.createElement("script");
    el.src = "https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js";
    el.async = true;
    el.onload = () => resolve(window.PDFLib);
    el.onerror = () => reject(new Error("Failed to load PDF-Lib"));
    document.head.appendChild(el);
  });
  return __pdfLibPromise;
}
function authHeaders(extra = {}) {
  const h = { ...(extra || {}) };
  const token = getToken();
  if (token) h["Authorization"] = `Bearer ${token}`;
  return h;
}

async function fetchJson(url, opts = {}) {
  const res = await fetch(url, {
    ...opts,
    headers: {
      "Content-Type": "application/json",
      ...(opts.headers || {}),
    },
  });
  const data = await res.json().catch(() => null);
  if (!res.ok) {
    const msg = data?.error || data?.message || `Request failed (${res.status})`;
    const err = new Error(msg);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  return data;
}

async function fetchBlob(url, opts = {}) {
  const res = await fetch(url, opts);
  if (!res.ok) {
    const data = await res.json().catch(() => null);
    const msg = data?.error || data?.message || `Export failed (${res.status})`;
    const err = new Error(msg);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  const blob = await res.blob();
  return blob;
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename || "output.pdf";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 10_000);
  return url;
}

// -------------------- Pay-Per-Export flow --------------------
async function beginPayPerExport(tool) {
  const out = await fetchJson(ENDPOINTS.PPE_CHECKOUT, {
    method: "POST",
    body: JSON.stringify({ tool }),
  });
  if (out?.url) window.location.href = out.url;
  else alert("Could not start checkout.");
}

function capturePpeSuccessFromUrl() {
  const u = new URL(window.location.href);
  const ok = u.searchParams.get("ppe_success") === "1";
  const sessionId = u.searchParams.get("session_id");
  const tool = u.searchParams.get("tool");

  if (ok && sessionId && tool) {
    setPpeForTool(tool, sessionId);

    u.searchParams.delete("ppe_success");
    u.searchParams.delete("session_id");
    u.searchParams.delete("tool");
    u.searchParams.delete("ppe_cancel");
    window.history.replaceState({}, "", u.toString());

    return { tool, sessionId };
  }
  return null;
}

// -------------------- Paid export wrapper --------------------
async function runPaidPdfExport({
  tool,
  endpoint,
  formData,
  filename,
  setPreviewFrameId,
  placeholderId,
}) {
  const token = getToken();
  const ppeSession = getPpeForTool(tool);

  const headers = {};
  if (token) headers["Authorization"] = `Bearer ${token}`;
  if (ppeSession) headers["x-ppe-session"] = ppeSession;

  try {
    const res = await fetch(endpoint, { method: "POST", headers, body: formData });

    if (!res.ok) {
      let data = null;
      try {
        data = await res.json();
      } catch {}
      const err = new Error(
        data?.error || data?.message || `Export failed (${res.status})`
      );
      err.status = res.status;
      err.data = data;
      throw err;
    }

    const blob = await res.blob();

    // If filename is provided, download; otherwise this is a preview-only run (no download).
    const objectUrl = filename ? downloadBlob(blob, filename) : URL.createObjectURL(blob);

    if (setPreviewFrameId) setIframeSrc(setPreviewFrameId, objectUrl);
    if (placeholderId) showPlaceholder(placeholderId, false);

    return { ok: true, blob, objectUrl };
  } catch (e) {
    if (e.status === 402) {
      const payData = e.data || {};
      const toolId = (window.PDFREALM_TIER && typeof window.PDFREALM_TIER.getActiveToolId === "function") ? window.PDFREALM_TIER.getActiveToolId() : null;
      const priceLabel = (window.PDFREALM_TIER && typeof window.PDFREALM_TIER.getPriceLabelForTool === "function") ? window.PDFREALM_TIER.getPriceLabelForTool(toolId) : "$2.99";
      const wantsPpe = confirm(
        `Payment required to export.

OK = Pay ${priceLabel} for this export (no account)
Cancel = Open Account modal (subscribe/login)`
      );

      if (wantsPpe) {
        if (payData.checkoutUrl) {
          window.location.href = payData.checkoutUrl;
        } else {
          alert("Payment required, but no checkout URL was provided by the server.");
        }
        return { ok: false, blocked: true };
      } else {
        openModal("accountModal");
        return { ok: false, blocked: true };
      }
    }

    if (e.status === 401) {
      openModal("accountModal");
      return { ok: false, blocked: true };
    }

    alert(e.message || "Export failed");
    return { ok: false, blocked: false };
  }
}

// -------------------- Tabs --------------------


// -------------------- PDFREALM_TIER_UI_REBUILD_V1 --------------------
// Single source of truth for tool tiering + pricing (prevents duplicate/flicker issues)
const PDFREALM_TIER = (() => {
  const STORAGE_KEY = "pdfrealm_active_tier";
  const DEFAULT_TIER = "standard";
  const PRICES = {
    standard: 2.99,
    premium: 3.49,
  };
  const TOOL_TIER /* PDFREALM_TIER_MAPPING_RESOURCES_V1 */ = {
  // PDFREALM_PREMIUM_EMBED_MEDIA_APP_V1
  "embedvideo": "premium",
  "embedaudio": "premium",
  "embedimage": "premium",

  "barcodestamp": "standard",
  "batchrename": "premium",
  "blank": "standard",
  "bulkqrbarcode": "premium",
  "chainrunner": "premium",
  "code2pdf": "standard",
  "compare": "premium",
  "compress": "premium",
  "csv2pdf": "standard",
  "datestamp": "standard",
  "delete": "standard",
  "deskewclean": "premium",
  "docx2png": "premium",
  "eml2pdf": "premium",
  "epub2pdf": "premium",
  "extractattach": "premium",
  "extractembedded": "premium",
  "extractfonts": "premium",
  "extractimgzip": "standard",
  "extracttext": "standard",
  "flatten": "standard",
  "flattenforms": "standard",
  "headerfooter": "standard",
  "heic2pdf": "premium",
  "html2pdf": "premium",
  "jpg2pdf": "standard",
  "jpg2png": "standard",
  "json2pdf": "standard",
  "md2pdf": "standard",
  "merge": "standard",
  "metadata": "standard",
  "metasanitize": "standard",
  "ocr": "premium",
  "pagenums": "standard",
  "pageszip": "standard",
  "password": "standard",
  "pdf2csv": "standard",
  "pdf2epub": "premium",
  "pdf2html": "standard",
  "pdf2jpg": "premium",
  "pdf2json": "standard",
  "pdf2layoutjson": "premium",
  "pdf2md": "standard",
  "pdf2outline": "premium",
  "pdf2png": "premium",
  "pdf2pptx": "premium",
  "pdf2txt": "standard",
  "pdf2word": "premium",
  "pdf2xlsx": "premium",
  "pdfcrop": "standard",
  "pdfflatten": "standard",
  "pdfperms": "standard",
  "png2jpg": "standard",
  "png2pdf": "standard",
  "qrbarcode": "standard",
  "qrstamp": "standard",
  "quick": "standard",
  "rasterize": "premium",
  "redact": "standard",
  "reorder": "standard",
  "repair": "standard",
  "resize": "standard",
  "rotate": "standard",
  "rotate90": "standard",
  "secure_chat": "secure",
  "secure_containers": "secure",
  "secure_send": "secure",
  "secure_video": "secure",
  "secure_voip": "secure",
  "breakthrough": "secure",
  "smartcompress": "premium",
  "split": "standard",
  "stamp": "standard",
  "studio": "premium",
  "svg2pdf": "standard",
  "tableextract": "premium",
  "templaterun": "premium",
  "tiff2pdf": "standard",
  "txt2pdf": "standard",
  "url2pdf": "premium",
  "visualdiff": "premium",
  "watermark": "standard",
  "watermarkimage": "standard",
  "watermarktext": "standard",
  "webhooksend": "premium",
  "word2pdf": "premium",
  "xml2pdf": "standard",
  "zip2pdf": "standard"
};

  function getTierForTool(toolId) {
    return TOOL_TIER[toolId] || "standard";
  }

  function getPriceLabelForTool(toolId) {
    const tier = getTierForTool(toolId);
    if (toolId === "secure_send") return "$3.49 / send (7-day storage)";
    if (toolId === "secure_chat" || toolId === "secure_video" || toolId === "secure_voip") return "$4.99 / hr";
    if (tier === "standard") return `$${PRICES.standard.toFixed(2)}`;
    if (tier === "premium") return `$${PRICES.premium.toFixed(2)}`;
    return `$${PRICES.premium.toFixed(2)}`;
  }

  function getActiveToolId() {
    const active = document.querySelector('.tool-tab.tool-tab-active');
    return active ? active.getAttribute("data-tool") : null;
  }

  function setTierActiveButton(tier) {
    const btns = Array.from(document.querySelectorAll(".tier-tab"));
    btns.forEach((b) => {
      const is = b.getAttribute("data-tier") === tier;
      b.classList.toggle("tier-tab-active", is);
      b.setAttribute("aria-selected", is ? "true" : "false");
    });
  }

  function applyTierFilter(tier) {
    // Tag tabs/views once (data-tier), then filter by tier
    const tabs = Array.from(document.querySelectorAll(".tool-tab"));
    const views = Array.from(document.querySelectorAll(".tool-view"));

    tabs.forEach((t) => {
      const toolId = t.getAttribute("data-tool");
      const tt = getTierForTool(toolId);
      t.dataset.tier = tt;
      const show = tt === tier;
      t.style.display = show ? "" : "none";
      t.setAttribute("aria-hidden", show ? "false" : "true");
    });

    // Views are still controlled by activate(); we only ensure we don't show a tool outside the tier.
    views.forEach((v) => {
      const toolId = v.getAttribute("data-tool-view");
      v.dataset.tier = getTierForTool(toolId);
    });

    // If current active tool is hidden, activate the first visible tool in the tier.
    const active = document.querySelector(".tool-tab.tool-tab-active");
    if (!active || active.style.display === "none" || active.getAttribute("aria-hidden") === "true") {
      const first = tabs.find((x) => x.style.display !== "none" && !x.disabled && x.getAttribute("aria-disabled") !== "true");
      if (first && typeof window.__pdfrealmActivateTool === "function") {
        window.__pdfrealmActivateTool(first.getAttribute("data-tool"));
      }
    }
  }

  function setTier(tier) {
    const safe = (tier === "standard" || tier === "premium" || tier === "secure") ? tier : DEFAULT_TIER;
    try { localStorage.setItem(STORAGE_KEY, safe); } catch {}
    window.__pdfrealmActiveTier = safe;
    setTierActiveButton(safe);
    applyTierFilter(safe);
  }

  function init() {
    const btns = Array.from(document.querySelectorAll(".tier-tab"));
    if (!btns.length) {
      document.body && document.body.setAttribute("data-tier-ready", "1");
      return;
    }

    btns.forEach((b) => {
      b.addEventListener("click", () => setTier(b.getAttribute("data-tier")));
    });

    let tier = DEFAULT_TIER;
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) tier = saved;
    } catch {}

    setTier(tier);
    // QT_TIER_FAILSAFE_V1: if saved tier produces zero visible tools, fall back to standard
    try {
      const tabs = Array.from(document.querySelectorAll('.tool-tab'));
      const visible = tabs.filter(t => t.style.display !== 'none' && t.getAttribute('aria-hidden') !== 'true');
      if (!visible.length) setTier('standard');
    } catch {}

    // Reveal tool list only after we’ve filtered it (prevents flicker)
    document.body && document.body.setAttribute("data-tier-ready", "1");
  }

  return {
    init,
    setTier,
    getTierForTool,
    getPriceLabelForTool,
    getActiveToolId,
    PRICES,
  };
})();
window.PDFREALM_TIER = PDFREALM_TIER;
// ------------------ /PDFREALM_TIER_UI_REBUILD_V1 ------------------

function initTabs() {
  const tabs = Array.from(document.querySelectorAll(".tool-tab"));
  const views = Array.from(document.querySelectorAll(".tool-view"));

  function activate(tool) {
    tabs.forEach((t) => {
      const is = t.getAttribute("data-tool") === tool;
      t.classList.toggle("tool-tab-active", is);
      t.setAttribute("aria-selected", is ? "true" : "false");
    });
    views.forEach((v) => {
      const is = v.getAttribute("data-tool-view") === tool;
      v.classList.toggle("tool-view-active", is);
      v.style.display = is ? "block" : "none";
    });
  }

  // Expose for capability gating (used after we fetch /api/capabilities)
  window.__pdfrealmActivateTool = activate;

  tabs.forEach((t) => {
    t.addEventListener("click", () => {
      if (t.disabled || t.getAttribute("aria-disabled") === "true") return;
      activate(t.getAttribute("data-tool"));
    });
  });

  let initial = document.querySelector(".tool-tab.tool-tab-active");
  if (!initial || initial.disabled || initial.getAttribute("aria-disabled") === "true") {
    initial = tabs.find((x) => !x.disabled && x.getAttribute("aria-disabled") !== "true") || null;
  }
  if (initial) activate(initial.getAttribute("data-tool"));
}

// -------------------- Account modal --------------------

function initAccount() {
  const openBtn = $("accountLoginBtn");
  const closeBtn = $("accountModalClose");

  if (openBtn) openBtn.addEventListener("click", () => openModal("accountModal"));
  if (closeBtn) closeBtn.addEventListener("click", () => closeModal("accountModal"));

  const loginBtn = $("loginSubmitBtn");
  const status = $("loginStatus");

  if (loginBtn) {
    loginBtn.addEventListener("click", async () => {
      try {
        if (status) status.textContent = "Logging in...";
        const email = $("loginEmail")?.value || "";
        const password = $("loginPassword")?.value || "";
        const out = await fetchJson(ENDPOINTS.LOGIN, {
          method: "POST",
          body: JSON.stringify({ email, password }),
        });
        setToken(out.token || "");
        if (status) status.textContent = out.token ? "Logged in." : "Login returned no token.";
        // If Vault tab exists, refresh it after login
        try { await refreshVaultList(); } catch {}
      } catch (e) {
        if (status) status.textContent = e.message || "Login failed.";
      }
    });
  }

  const subM = $("subscribeMonthlyBtn");
  const subY = $("subscribeYearlyBtn");

  async function goCheckout(kind) {
    try {
      const out = await fetchJson(ENDPOINTS.PAYWALL_CHECKOUT, {
        method: "POST",
        body: JSON.stringify({ plan: kind }),
      });
      if (out?.url) window.location.href = out.url;
      else alert("Checkout not configured on server.");
    } catch (e) {
      alert(e.message || "Checkout failed.");
    }
  }

  if (subM) subM.addEventListener("click", () => goCheckout("monthly"));
  if (subY) subY.addEventListener("click", () => goCheckout("yearly"));
}

// -------------------- Preview wiring (PDF inputs) --------------------
function wireLocalPdfPreview(fileInputId, iframeId, placeholderId) {
  const inp = $(fileInputId);
  if (!inp) return;
  inp.addEventListener("change", () => {
    const f = inp.files && inp.files[0];
    if (!f) return;
    const url = makeObjectUrlFromFile(f);
    setIframeSrc(iframeId, url);
    showPlaceholder(placeholderId, false);
  });
}

function wireLocalImagePreview(fileInputId, imgId, placeholderId) {
  const inp = $(fileInputId);
  const img = $(imgId);
  if (!inp || !img) return;

  inp.addEventListener("change", () => {
    const f = inp.files && inp.files[0];
    if (!f) return;
    const url = makeObjectUrlFromFile(f);
    img.src = url;
    img.style.display = "block";
    if (placeholderId) showPlaceholder(placeholderId, false);
  });
}

// -------------------- PDF Studio overlays --------------------
function initStudio() {
  const fileInput = $("studioFile");
  // If the legacy overlay studio UI is not present (we embed full PDF Studio), skip.
  if (!fileInput) return;
  const frameId = "studioFrame";
  const placeholderId = "studioPlaceholder";
  const wrapper = $("studioViewerWrapper");
  const clickLayer = $("studioClickLayer");

  const sigOverlay = $("studioSignatureOverlay");
  const noteOverlay = $("studioNoteOverlay");
  const sigTextEl = $("studioSignatureText");
  const noteTextEl = $("studioNoteText");

  const sigName = $("studioSignatureName");
  const noteText = $("studioNoteText");

  let placing = null;

  if (fileInput) {
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      const url = makeObjectUrlFromFile(f);
      setIframeSrc(frameId, url);
      showPlaceholder(placeholderId, false);
    });
  }

  function enableClickLayer(on) {
    if (!clickLayer) return;
    clickLayer.classList.toggle("inactive", !on);
  }

  function setOverlayPosition(overlay, x, y) {
    if (!overlay) return;
    overlay.style.left = `${x}px`;
    overlay.style.top = `${y}px`;
    overlay.style.display = "inline-flex";
  }

  if (wrapper && clickLayer) {
    clickLayer.addEventListener("click", (e) => {
      if (!placing) return;
      const rect = wrapper.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (placing === "sig") setOverlayPosition(sigOverlay, x, y);
      if (placing === "note") setOverlayPosition(noteOverlay, x, y);

      placing = null;
      enableClickLayer(false);
    });
  }

  function getOverlayNormalized(overlay) {
    if (!overlay || overlay.style.display === "none") return null;
    const rect = wrapper.getBoundingClientRect();
    const left = parseFloat(overlay.style.left || "0");
    const top = parseFloat(overlay.style.top || "0");
    const nx = left / rect.width;
    const ny = top / rect.height;
    return { x: clamp01(nx), y: clamp01(ny) };
  }

  function makeDraggable(overlay) {
    if (!overlay || !wrapper) return;
    let dragging = false;

    overlay.addEventListener("pointerdown", (e) => {
      dragging = true;
      overlay.setPointerCapture(e.pointerId);
      overlay.style.cursor = "grabbing";
      e.preventDefault();
    });

    overlay.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const rect = wrapper.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      setOverlayPosition(overlay, x, y);
    });

    overlay.addEventListener("pointerup", () => {
      dragging = false;
      overlay.style.cursor = "grab";
    });

    overlay.addEventListener("pointercancel", () => {
      dragging = false;
      overlay.style.cursor = "grab";
    });
  }

  makeDraggable(sigOverlay);
  makeDraggable(noteOverlay);

  const placeSigBtn = $("studioAddSignatureBtn");
  const placeNoteBtn = $("studioAddTextBtn");
  const exportBtn = $("studioExportBtn");

  if (placeSigBtn) {
    placeSigBtn.addEventListener("click", () => {
      placing = "sig";
      enableClickLayer(true);
    });
  }
  if (placeNoteBtn) {
    placeNoteBtn.addEventListener("click", () => {
      placing = "note";
      enableClickLayer(true);
    });
  }

  if (exportBtn) {
    exportBtn.addEventListener("click", async () => {
      const f = fileInput?.files?.[0];
      if (!f) return alert("Upload a PDF first.");

      const sigVal = (sigName?.value || "").trim();
      const noteVal = (noteText?.value || "").trim();
      if (sigTextEl) sigTextEl.textContent = sigVal || "Signature";
      if (noteTextEl) noteTextEl.textContent = noteVal || "Note";

      const sigPos = getOverlayNormalized(sigOverlay) || { x: 0.08, y: 0.12 };
      const notePos = getOverlayNormalized(noteOverlay) || { x: 0.08, y: 0.22 };

      const fd = new FormData();
      fd.append("file", f);
      fd.append("signatureText", sigVal);
      fd.append("noteText", noteVal);
      fd.append("sigX", String(sigPos.x));
      fd.append("sigY", String(sigPos.y));
      fd.append("noteX", String(notePos.x));
      fd.append("noteY", String(notePos.y));

      await runPaidPdfExport({
        tool: "pdf-studio",
        endpoint: ENDPOINTS.PDF_STUDIO,
        formData: fd,
        filename: "pdfrealm-studio.pdf",
        setPreviewFrameId: frameId,
        placeholderId,
      });
    });
  }
}

// -------------------- Quick Sign --------------------
// -------------------- Quick Sign --------------------

// -------------------- Quick Sign --------------------
// -------------------- Quick Sign --------------------
function initQuickSign() {
  const fileInput = $("qsFile");
  const passInput = $("qsPassword");
  const unlockBtn = $("qsUnlockBtn");
  const status = $("qsStatus");

  const placeholder = $("qsQuickPlaceholder");
  const wrapper = $("qsViewerWrapper");
  const shell = $("qsCanvasShell");
  const pdfCanvas = $("qsPdfCanvas");
  const overlayCanvas = $("qsSigCanvas");
  const hint = $("qsPreviewHint");

  // Signature source controls
  const modeDrawBtn = $("qsSigModeDraw");
  const modeUploadBtn = $("qsSigModeUpload");
  const modeGenerateBtn = $("qsSigModeGenerate");
  const drawPanel = $("qsSigDrawPanel");
  const uploadPanel = $("qsSigUploadPanel");
  const genPanel = $("qsSigGeneratePanel");

  const sigPad = $("qsSigPad");
  const sigClearBtn = $("qsSigClearBtn");
  const sigPenSize = $("qsSigPenSize");

  const sigUpload = $("qsSigUpload");
  const sigGenName = $("qsSigGenName");
  const sigGenBtn = $("qsSigGenerateBtn");

  const sigScaleRange = $("qsSigScale");

  // Initials
  const initEnable = $("qsInitEnable");
  const initText = $("qsInitText");
  const initCreateBtn = $("qsInitCreateBtn");
  const initScaleRange = $("qsInitScale");

  // Active item + locking
  const activeSigBtn = $("qsActiveSigBtn");
  const activeInitBtn = $("qsActiveInitBtn");
  const lockSigBtn = $("qsLockSigBtn");
  const lockInitBtn = $("qsLockInitBtn");
  const lockNextBtn = $("qsLockNextBtn");
  const addSigBtn = $("qsAddSigBtn");
  const addInitBtn = $("qsAddInitBtn");

  // Page nav + actions
  const prevPageBtn = $("qsPrevPageBtn");
  const nextPageBtn = $("qsNextPageBtn");
  const pageLabel = $("qsPageLabel");
  const exportBtn = $("qsApplyBtn");

  if (!fileInput || !pdfCanvas || !overlayCanvas || !exportBtn) return;

  // --- PDF.js bootstrap (dynamic import; avoids CDN 404/mime issues) ---
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // ---- State ----
  let pdfJs = null;
  let pdfDoc = null;
  let pageNum = 1;
  let pageCount = 1;
  let viewportCss = { w: 0, h: 0, scale: 1 };

  let srcFile = null;        // original file
  let unlockedFile = null;   // decrypted file (if needed)
  let enc = null;            // null=pending, true/false

  let sigDataUrl = null;
  const sigImg = new Image();
  let sigReady = false;

  let initDataUrl = null;
  const initImg = new Image();
  let initReady = false;

  // placements per page (normalized coords + scale pct)
  // { '1': [ {id,x,y,scale,locked}, ... ] }
  const sigByPage = {};
  const initByPage = {};

  let activeItem = 'sig';
  let selected = { type: 'sig', id: null };

  // interaction
  let isDrag = false;
  let isResize = false;
  let dragOff = { x: 0, y: 0 };
  let start = { x: 0, y: 0, w: 0, scale: 0 };
  let dragTarget = { type: 'sig', id: null };

  // draw cache
  let sigBoxes = []; // [{id, rect:{x,y,w,h}, locked, pl}]
  let initBoxes = [];

  // Auto-placement: drop newly created/uploaded items ~2 inches from top so users see them immediately.
  const AUTO_TOP_INCHES = 2;
  const CSS_PX_PER_INCH = 96;
  let pendingAutoPlaceSig = false;
  let pendingAutoPlaceInit = false;

  let uidSeq = 0;
  const uid = (p) => `${p}_${Date.now().toString(36)}_${(++uidSeq).toString(36)}`;

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function pageKey(pn) { return String(parseInt(String(pn || 1), 10) || 1); }

  function setHint(msg, show = true) {
    if (!hint) return;
    hint.textContent = msg || '';
    hint.style.display = show && msg ? 'block' : 'none';
  }

  function showEmpty(msg) {
    if (shell) shell.style.display = 'none';
    if (placeholder) {
      placeholder.textContent = msg || 'Upload a PDF to preview it here.';
      placeholder.style.display = 'flex';
    }
  }

  function showCanvas() {
    if (placeholder) placeholder.style.display = 'none';
    if (shell) shell.style.display = 'block';
  }

  function setActiveItem(item) {
    activeItem = item === 'init' ? 'init' : 'sig';
    selected.type = activeItem;

    [activeSigBtn, activeInitBtn].forEach((b) => b && b.classList.remove('active'));
    if (activeItem === 'sig') activeSigBtn && activeSigBtn.classList.add('active');
    if (activeItem === 'init') activeInitBtn && activeInitBtn.classList.add('active');

    drawOverlay();
    updateLockButtons();
  }

  function initEnabled() {
    return !!(initEnable && initEnable.checked);
  }

  function getSigScalePct() {
    const v = parseFloat(sigScaleRange?.value || '20');
    return isFinite(v) ? v : 20;
  }

  function getInitScalePct() {
    const v = parseFloat(initScaleRange?.value || '10');
    return isFinite(v) ? v : 10;
  }

  function autoTopYNorm() {
    const yPx = AUTO_TOP_INCHES * CSS_PX_PER_INCH;
    if (viewportCss && viewportCss.h) return clamp(yPx / viewportCss.h, 0.01, 0.90);
    return 0.15;
  }

  function scrollPreviewToYNorm(yNorm) {
    if (!wrapper || !viewportCss || !viewportCss.h) return;
    const y = yNorm * viewportCss.h;
    const target = Math.max(0, y - 80);
    try { wrapper.scrollTop = target; } catch (_) {}
  }

  function listFor(type, pn, create = false) {
    const key = pageKey(pn);
    const store = type === 'init' ? initByPage : sigByPage;
    let v = store[key];
    if (!v && create) {
      store[key] = [];
      v = store[key];
    }
    if (!v) return [];
    if (Array.isArray(v)) return v;
    // defensive: if something ever wrote a single object here, normalize to array
    store[key] = [v];
    return store[key];
  }

  function getSelectedPlacement(type, pn) {
    const list = listFor(type, pn, false);
    const id = type === 'sig' ? (selected.type === 'sig' ? selected.id : null) : (selected.type === 'init' ? selected.id : null);
    if (id) {
      const found = list.find((p) => p && p.id === id);
      if (found) return found;
    }
    // fallback: last
    if (list.length) return list[list.length - 1];
    return null;
  }

  function selectPlacement(type, id) {
    selected = { type, id };
    setActiveItem(type);
  }

  function createPlacement(type, pn, xNorm, yNorm, scalePct) {
    const list = listFor(type, pn, true);
    const pl = {
      id: uid(type),
      x: clamp(xNorm, 0, 1),
      y: clamp(yNorm, 0, 1),
      scale: clamp(scalePct, type === 'sig' ? 8 : 0.5, type === 'sig' ? 50 : 25),
      locked: false,
    };
    list.push(pl);
    selectPlacement(type, pl.id);
    return pl;
  }

  function ensureAtLeastOnePlacement(type) {
    const list = listFor(type, pageNum, true);
    if (list.length) {
      if (!selected.id || !getSelectedPlacement(type, pageNum)) {
        selectPlacement(type, list[list.length - 1].id);
      }
      return list[list.length - 1];
    }
    // create default
    const y = autoTopYNorm();
    const x = type === 'init' ? 0.72 : 0.12;
    const scale = type === 'init' ? getInitScalePct() : getSigScalePct();
    return createPlacement(type, pageNum, x, y, scale);
  }

  function setMode(mode) {
    [modeDrawBtn, modeUploadBtn, modeGenerateBtn].forEach((b) => b && b.classList.remove('active'));
    if (mode === 'draw') modeDrawBtn && modeDrawBtn.classList.add('active');
    if (mode === 'upload') modeUploadBtn && modeUploadBtn.classList.add('active');
    if (mode === 'generate') modeGenerateBtn && modeGenerateBtn.classList.add('active');

    if (drawPanel) drawPanel.style.display = mode === 'draw' ? 'block' : 'none';
    if (uploadPanel) uploadPanel.style.display = mode === 'upload' ? 'block' : 'none';
    if (genPanel) genPanel.style.display = mode === 'generate' ? 'block' : 'none';
  }

  async function loadPdfFromFile(file) {
    pdfJs = pdfJs || await getPdfJsAsync();
    if (!pdfJs) throw new Error('PDF renderer failed to load.');

    const ab = await __pdfrealmPdfFileToArrayBufferMaybeDecrypt(file);
    const task = pdfJs.getDocument({ data: ab });
    const doc = await task.promise;
    return doc;
  }

  function updatePageLabel() {
    if (!pageLabel) return;
    pageLabel.textContent = `Page ${pageNum} / ${pageCount}`;
  }

  async function renderPage() {
    if (!pdfDoc || !shell) return;
    const page = await pdfDoc.getPage(pageNum);

    const pad = 24;
    const availableW = Math.max(300, (wrapper?.clientWidth || shell.clientWidth || 800) - pad);
    const v0 = page.getViewport({ scale: 1 });
    const scale = availableW / v0.width;
    const viewport = page.getViewport({ scale });
    viewportCss = { w: viewport.width, h: viewport.height, scale };

    const dpr = window.devicePixelRatio || 1;

    pdfCanvas.width = Math.floor(viewport.width * dpr);
    pdfCanvas.height = Math.floor(viewport.height * dpr);
    pdfCanvas.style.width = viewport.width + 'px';
    pdfCanvas.style.height = viewport.height + 'px';

    const ctx = pdfCanvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, viewport.width, viewport.height);

    await page.render({ canvasContext: ctx, viewport }).promise;

    overlayCanvas.width = pdfCanvas.width;
    overlayCanvas.height = pdfCanvas.height;
    overlayCanvas.style.width = pdfCanvas.style.width;
    overlayCanvas.style.height = pdfCanvas.style.height;

    showCanvas();
    updatePageLabel();

    // If assets were created/uploaded before the page was ready, drop them now.
    if (pendingAutoPlaceSig && sigReady) {
      pendingAutoPlaceSig = false;
      ensureAtLeastOnePlacement('sig');
      const pl = getSelectedPlacement('sig', pageNum);
      if (pl) scrollPreviewToYNorm(pl.y);
    }
    if (pendingAutoPlaceInit && initReady && initEnabled()) {
      pendingAutoPlaceInit = false;
      ensureAtLeastOnePlacement('init');
      const pl = getSelectedPlacement('init', pageNum);
      if (pl) scrollPreviewToYNorm(pl.y);
    }

    drawOverlay();
    updateLockButtons();
  }

  function rectHitTest(pt, rect) {
    const x = pt.x, y = pt.y;
    const inside = x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
    const handleBase = 16;
    const hs = Math.max(8, Math.min(handleBase, Math.min(rect.w, rect.h) * 0.25));
    const hx = rect.x + rect.w - hs;
    const hy = rect.y + rect.h - hs;
    const onHandle = x >= hx && x <= hx + hs && y >= hy && y <= hy + hs;
    return { inside, onHandle, hs };
  }

  function cssPointFromEvent(ev) {
    const r = overlayCanvas.getBoundingClientRect();
    return { x: ev.clientX - r.left, y: ev.clientY - r.top, r };
  }

  function drawOne(ctx, img, pl, type, active) {
    const w = viewportCss.w;
    const h = viewportCss.h;
    const scalePct = type === 'sig' ? pl.scale : pl.scale;

    const boxW = w * (scalePct / 100);
    const aspect = img.naturalHeight / img.naturalWidth;
    const boxH = boxW * aspect;

    let x = pl.x * w;
    let y = pl.y * h;

    x = clamp(x, 0, Math.max(0, w - boxW));
    y = clamp(y, 0, Math.max(0, h - boxH));

    pl.x = w ? x / w : 0;
    pl.y = h ? y / h : 0;

    ctx.drawImage(img, x, y, boxW, boxH);

    // Outline + handle
    ctx.save();
    ctx.lineWidth = active ? 2.5 : 2;
    ctx.strokeStyle = active ? 'rgba(255,255,255,0.90)' : 'rgba(255,255,255,0.55)';
    if (!pl.locked) ctx.setLineDash([6, 4]);
    ctx.strokeRect(x, y, boxW, boxH);
    ctx.setLineDash([]);

    if (!pl.locked) {
      const hs = Math.max(8, Math.min(16, Math.min(boxW, boxH) * 0.25));
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.fillRect(x + boxW - hs, y + boxH - hs, hs, hs);
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText('Locked', x + 6, y + 14);
    }

    ctx.restore();

    return { x, y, w: boxW, h: boxH };
  }

  function drawOverlay() {
    const dpr = window.devicePixelRatio || 1;
    const w = viewportCss.w;
    const h = viewportCss.h;

    const ctx = overlayCanvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, w, h);

    sigBoxes = [];
    initBoxes = [];

    if (!pdfDoc) {
      setHint('Upload a PDF to preview and sign.', true);
      return;
    }

    const sigVisible = sigReady && sigImg.naturalWidth;
    const initVisible = initEnabled() && initReady && initImg.naturalWidth;

    if (!sigVisible && !initVisible) {
      if (!sigReady) setHint('Tip: Generate, draw, or upload a signature, then place it on the PDF.', true);
      else if (initEnabled() && !initReady) setHint('Tip: Create initials (optional), then place them on the PDF.', true);
      else setHint('', false);
      return;
    }

    // Ensure selection is sensible per page
    if (sigVisible && !getSelectedPlacement('sig', pageNum) && !listFor('sig', pageNum, false).length) {
      // no placement yet; don't auto-create unless user just created/uploaded
    }

    // Draw signatures first
    if (sigVisible) {
      const list = listFor('sig', pageNum, false);
      for (const pl of list) {
        if (!pl) continue;
        const isActive = (selected.type === 'sig' && selected.id === pl.id);
        const rect = drawOne(ctx, sigImg, pl, 'sig', isActive);
        sigBoxes.push({ id: pl.id, rect, locked: !!pl.locked, pl });
      }
    }

    // Draw initials on top
    if (initVisible) {
      const list = listFor('init', pageNum, false);
      for (const pl of list) {
        if (!pl) continue;
        const isActive = (selected.type === 'init' && selected.id === pl.id);
        const rect = drawOne(ctx, initImg, pl, 'init', isActive);
        initBoxes.push({ id: pl.id, rect, locked: !!pl.locked, pl });
      }
    }

    // hint
    const selPl = getSelectedPlacement(selected.type, pageNum);
    if (selPl && selPl.locked) {
      setHint('This item is locked. Click Unlock to move it, or click elsewhere to place another.', true);
    } else {
      setHint('Drag to move. Drag the corner handle to resize. Click elsewhere to place another when locked.', true);
    }
  }

  function hitTestAll(pt) {
    // check handles first, top layer first (initials drawn on top)
    const scan = (boxes) => {
      for (let i = boxes.length - 1; i >= 0; i--) {
        const b = boxes[i];
        const hit = rectHitTest(pt, b.rect);
        if (hit.onHandle) return { box: b, hit, onHandle: true, inside: true };
      }
      for (let i = boxes.length - 1; i >= 0; i--) {
        const b = boxes[i];
        const hit = rectHitTest(pt, b.rect);
        if (hit.inside) return { box: b, hit, onHandle: false, inside: true };
      }
      return null;
    };

    return scan(initBoxes) || scan(sigBoxes);
  }

  function movePlacementCentered(pl, type, pt) {
    const w = viewportCss.w;
    const h = viewportCss.h;
    const img = type === 'sig' ? sigImg : initImg;
    const scalePct = pl.scale;

    const boxW = w * (scalePct / 100);
    const aspect = img.naturalHeight / img.naturalWidth;
    const boxH = boxW * aspect;

    const nx = clamp((pt.x - boxW * 0.5) / w, 0, 1);
    const ny = clamp((pt.y - boxH * 0.5) / h, 0, 1);

    pl.x = nx;
    pl.y = ny;
  }

  // --- Overlay interaction (drag/resize + multi-placement) ---
  overlayCanvas.addEventListener('pointerdown', (ev) => {
    if (!pdfDoc) return;

    const pt = cssPointFromEvent(ev);

    // empty click: move selected if unlocked; if locked/no selection -> create a new placement at click
    const hitAny = hitTestAll(pt);
    if (!hitAny) {
      let type = activeItem;
      if (type === 'init' && !(initEnabled() && initReady)) type = 'sig';

      const ready = type === 'sig' ? sigReady : (initEnabled() && initReady);
      if (!ready) return;

      let sel = getSelectedPlacement(type, pageNum);
      if (!sel) {
        // create new
        const scale = type === 'sig' ? getSigScalePct() : getInitScalePct();
        sel = createPlacement(type, pageNum, 0.12, autoTopYNorm(), scale);
      }

      if (sel.locked) {
        // create another placement centered at click
        const scale = type === 'sig' ? getSigScalePct() : getInitScalePct();
        sel = createPlacement(type, pageNum, 0.12, autoTopYNorm(), scale);
        movePlacementCentered(sel, type, pt);
      } else {
        movePlacementCentered(sel, type, pt);
      }

      selectPlacement(type, sel.id);
      scrollPreviewToYNorm(sel.y);
      drawOverlay();
      updateLockButtons();
      return;
    }

    const { box, hit, onHandle } = hitAny;
    const type = initBoxes.some((b) => b.id === box.id) ? 'init' : 'sig';

    selectPlacement(type, box.id);

    const pl = box.pl;
    if (!pl || pl.locked) return;

    ev.preventDefault();
    overlayCanvas.setPointerCapture(ev.pointerId);

    dragTarget = { type, id: box.id };

    if (onHandle) {
      isResize = true;
      start = { x: pt.x, y: pt.y, w: box.rect.w, scale: pl.scale };
    } else {
      isDrag = true;
      dragOff = { x: pt.x - box.rect.x, y: pt.y - box.rect.y };
    }
  });

  overlayCanvas.addEventListener('pointermove', (ev) => {
    if (!isDrag && !isResize) return;
    if (!pdfDoc) return;

    ev.preventDefault();
    const pt = cssPointFromEvent(ev);

    const type = dragTarget.type;
    const sel = getSelectedPlacement(type, pageNum);
    if (!sel || sel.id !== dragTarget.id) return;
    if (sel.locked) return;

    const w = viewportCss.w;
    const h = viewportCss.h;

    // find current rect
    const boxes = type === 'sig' ? sigBoxes : initBoxes;
    const box = boxes.find((b) => b.id === sel.id);
    if (!box) return;

    if (isDrag) {
      const boxW = box.rect.w;
      const boxH = box.rect.h;
      const x = clamp(pt.x - dragOff.x, 0, Math.max(0, w - boxW));
      const y = clamp(pt.y - dragOff.y, 0, Math.max(0, h - boxH));
      sel.x = w ? x / w : 0;
      sel.y = h ? y / h : 0;
      drawOverlay();
      return;
    }

    if (isResize) {
      const dx = pt.x - start.x;
      const minPct = type === 'sig' ? 8 : 0.5;
      const maxPct = type === 'sig' ? 50 : 25;
      const minW = w * (minPct / 100);
      const maxW = w * (maxPct / 100);
      const newW = clamp(start.w + dx, minW, maxW);
      const newScale = clamp((newW / w) * 100, minPct, maxPct);
      sel.scale = newScale;
      if (type === 'sig' && sigScaleRange) sigScaleRange.value = String(Math.round(newScale));
      if (type === 'init' && initScaleRange) initScaleRange.value = String(newScale.toFixed(1));
      drawOverlay();
    }
  });

  function endPointer() {
    isDrag = false;
    isResize = false;
    dragTarget = { type: activeItem, id: null };
  }

  overlayCanvas.addEventListener('pointerup', (ev) => { ev.preventDefault(); endPointer(); });
  overlayCanvas.addEventListener('pointercancel', (ev) => { ev.preventDefault(); endPointer(); });

  function updateLockButtons() {
    const initOn = initEnabled();

    // signature lock
    const s = getSelectedPlacement('sig', pageNum);
    if (lockSigBtn) {
      lockSigBtn.disabled = !sigReady;
      lockSigBtn.textContent = (s && s.locked) ? 'Unlock Signature' : 'Lock Signature';
    }

    // initials lock
    const i = getSelectedPlacement('init', pageNum);
    if (lockInitBtn) {
      lockInitBtn.disabled = !(initOn && initReady);
      lockInitBtn.textContent = (i && i.locked) ? 'Unlock Initials' : 'Lock Initials';
    }

    if (activeInitBtn) activeInitBtn.disabled = !(initOn && initReady);

    // add buttons
    if (addSigBtn) addSigBtn.disabled = !sigReady;
    if (addInitBtn) addInitBtn.disabled = !(initOn && initReady);
  }

  // --- Asset helpers ---
  function trimCanvasToDataUrl(canvas) {
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    const img = ctx.getImageData(0, 0, width, height);
    const data = img.data;

    let minX = width, minY = height, maxX = 0, maxY = 0;
    let found = false;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const a = data[(y * width + x) * 4 + 3];
        if (a > 12) {
          found = true;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (!found) return null;

    const pad = 10;
    minX = clamp(minX - pad, 0, width - 1);
    minY = clamp(minY - pad, 0, height - 1);
    maxX = clamp(maxX + pad, 0, width - 1);
    maxY = clamp(maxY + pad, 0, height - 1);

    const tw = maxX - minX + 1;
    const th = maxY - minY + 1;

    const out = document.createElement('canvas');
    out.width = tw;
    out.height = th;
    const octx = out.getContext('2d');
    octx.putImageData(ctx.getImageData(minX, minY, tw, th), 0, 0);
    return out.toDataURL('image/png');
  }

  async function loadImageAsDataUrl(file) {
    return await new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(String(r.result || ''));
      r.onerror = () => reject(new Error('Failed to read image.'));
      r.readAsDataURL(file);
    });
  }

  async function normalizeImageDataUrl(dataUrl) {
    return await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const c = document.createElement('canvas');
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        const ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const trimmed = trimCanvasToDataUrl(c);
        resolve(trimmed || dataUrl);
      };
      img.onerror = () => resolve(dataUrl);
      img.src = dataUrl;
    });
  }

  function generateSignatureFromName(name) {
    const n = (name || '').trim() || 'Signature';
    const c = document.createElement('canvas');
    c.width = 1200;
    c.height = 360;
    const ctx = c.getContext('2d');

    ctx.clearRect(0, 0, c.width, c.height);

    ctx.fillStyle = '#111';
    ctx.textBaseline = 'middle';
    ctx.font = '120px "Brush Script MT", "Segoe Script", "Lucida Handwriting", cursive';

    ctx.save();
    ctx.translate(40, 190);
    ctx.transform(1, 0, -0.12, 1, 0, 0);
    ctx.fillText(n, 0, 0);
    ctx.restore();

    return trimCanvasToDataUrl(c);
  }

  function generateInitialsFromText(txt) {
    const t = (txt || "").trim() || "XX";
    const c = document.createElement("canvas");
    c.width = 1000;
    c.height = 420;
    const ctx = c.getContext("2d");

    ctx.clearRect(0, 0, c.width, c.height);
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    ctx.font = '900 260px "Segoe UI", system-ui, -apple-system, Arial, sans-serif';
    const x = c.width / 2;
    const y = c.height / 2;

    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.lineWidth = 26;
    ctx.strokeText(t, x, y);

    ctx.fillStyle = "#111";
    ctx.fillText(t, x, y);

    ctx.strokeStyle = "rgba(0,0,0,0.9)";
    ctx.lineWidth = 8;
    ctx.strokeText(t, x, y);

    return trimCanvasToDataUrl(c);
  }

  function setSignatureDataUrl(url) {
    sigDataUrl = url || null;
    sigReady = false;

    if (!sigDataUrl) {
      drawOverlay();
      updateLockButtons();
      return;
    }

    sigImg.onload = () => {
      sigReady = true;
      // place new signature near top so user sees it
      if (pdfDoc && viewportCss && viewportCss.h) {
        const pl = ensureAtLeastOnePlacement('sig');
        if (pl) scrollPreviewToYNorm(pl.y);
      } else {
        pendingAutoPlaceSig = true;
      }
      drawOverlay();
      updateLockButtons();
    };
    sigImg.onerror = () => {
      sigReady = false;
      drawOverlay();
      updateLockButtons();
    };
    sigImg.src = sigDataUrl;
  }

  function setInitialsDataUrl(url) {
    initDataUrl = url || null;
    initReady = false;

    if (!initDataUrl) {
      drawOverlay();
      updateLockButtons();
      return;
    }

    initImg.onload = () => {
      initReady = true;
      if (pdfDoc && viewportCss && viewportCss.h && initEnabled()) {
        const pl = ensureAtLeastOnePlacement('init');
        if (pl) scrollPreviewToYNorm(pl.y);
      } else {
        pendingAutoPlaceInit = true;
      }
      drawOverlay();
      updateLockButtons();
    };
    initImg.onerror = () => {
      initReady = false;
      drawOverlay();
      updateLockButtons();
    };
    initImg.src = initDataUrl;
  }

  // --- Signature pad (draw) ---
  function initSignaturePad() {
    if (!sigPad) return;
    const ctx = sigPad.getContext('2d');
    ctx.clearRect(0, 0, sigPad.width, sigPad.height);

    let drawing = false;
    let last = null;

    function getPt(ev) {
      const r = sigPad.getBoundingClientRect();
      const x = (ev.clientX - r.left) * (sigPad.width / r.width);
      const y = (ev.clientY - r.top) * (sigPad.height / r.height);
      return { x, y };
    }

    function strokeWidth() {
      const v = parseFloat(sigPenSize?.value || '4');
      return isFinite(v) ? v : 4;
    }

    function drawSegment(p0, p1) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#111';
      ctx.lineWidth = strokeWidth();

      ctx.beginPath();
      if (!last) {
        ctx.moveTo(p0.x, p0.y);
      } else {
        const mx = (last.x + p1.x) / 2;
        const my = (last.y + p1.y) / 2;
        ctx.moveTo(last.x, last.y);
        ctx.quadraticCurveTo(last.x, last.y, mx, my);
      }
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    }

    sigPad.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      drawing = true;
      last = getPt(ev);
      sigPad.setPointerCapture(ev.pointerId);
    });

    sigPad.addEventListener('pointermove', (ev) => {
      if (!drawing) return;
      ev.preventDefault();
      const pt = getPt(ev);
      drawSegment(last, pt);
      last = pt;
    });

    function endStroke() {
      if (!drawing) return;
      drawing = false;
      last = null;
      const url = trimCanvasToDataUrl(sigPad);
      if (url) {
        setSignatureDataUrl(url);
        // create a new placement for this signature (supports multiple on same page)
        if (pdfDoc) {
          const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
          scrollPreviewToYNorm(pl.y);
          drawOverlay();
        } else {
          pendingAutoPlaceSig = true;
        }
      }
    }

    sigPad.addEventListener('pointerup', (ev) => { ev.preventDefault(); endStroke(); });
    sigPad.addEventListener('pointercancel', (ev) => { ev.preventDefault(); endStroke(); });

    sigClearBtn?.addEventListener('click', () => {
      ctx.clearRect(0, 0, sigPad.width, sigPad.height);
      setSignatureDataUrl(null);
    });
  }

  // --- Encryption-aware PDF load ---
  async function loadCurrentPdf() {
    if (!srcFile) {
      pdfDoc = null;
      showEmpty('Upload a PDF to preview it here.');
      return;
    }

    // Block rendering until encryption status known
    enc = null;
    pdfDoc = null;
    showEmpty('Checking PDF…');

    let encrypted = true; // fail-closed
    try {
      encrypted = await detectEncryptedPdfReliable(srcFile);
      if (!encrypted) encrypted = await serverSaysEncrypted(srcFile);
    } catch {
      encrypted = true;
    }

    enc = !!encrypted;

    if (enc && !unlockedFile) {
      showEmpty('Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.');
      updateLockButtons();
      return;
    }

    try {
      const loadFile = unlockedFile || srcFile;
      pdfDoc = await loadPdfFromFile(loadFile);
      pageCount = pdfDoc.numPages || 1;
      pageNum = clamp(pageNum, 1, pageCount);
      await renderPage();
      updateLockButtons();
    } catch (e) {
      console.error(e);
      showEmpty('Preview failed. Try unlocking the PDF if it is encrypted.');
    }
  }

  // --- File input ---
  async function onFileChange() {
    const files = Array.from(fileInput.files || []).filter((f) => f && /pdf/i.test(f.type || 'application/pdf'));
    if (!files.length) {
      srcFile = null;
      unlockedFile = null;
      pdfDoc = null;
      pageNum = 1;
      pageCount = 1;
      showEmpty('Upload a PDF to preview it here.');
      return;
    }

    // use the first PDF (prev/next pdf controls removed by design)
    srcFile = files[0];
    unlockedFile = null;
    enc = null;
    pageNum = 1;

    // reset placements for new PDF
    
    // reset placements for new PDF
    for (const k of Object.keys(sigByPage)) delete sigByPage[k];
    for (const k of Object.keys(initByPage)) delete initByPage[k];
    selected = { type: 'sig', id: null };
    activeItem = 'sig';

    if (initEnable) initEnable.checked = false;
    if (initText) initText.value = '';
    initDataUrl = null;
    initReady = false;

    // keep signature asset as-is (user might be signing multiple docs), but clear selection

    showEmpty('Checking PDF…');
    await loadCurrentPdf();


  }

  

  // Capture prevents any legacy wiring from loading before encryption guard
  fileInput.addEventListener('change', (e) => {
    try { e.stopImmediatePropagation(); } catch {}
    onFileChange();
  }, true);

  // --- Unlock (decrypt) ---
  unlockBtn?.addEventListener('click', async () => {
    if (!srcFile) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '');
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting…';
    }

    try {
      unlockedFile = await decryptPdfToFile(srcFile, pw);
      enc = false;
      await loadCurrentPdf();
    } catch (err) {
      alert(String(err?.message || err));
      showEmpty('Unlock failed. Check the password and try again.');
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  // --- Signature source wiring ---
  modeGenerateBtn?.addEventListener('click', () => setMode('generate'));
  modeDrawBtn?.addEventListener('click', () => setMode('draw'));
  modeUploadBtn?.addEventListener('click', () => setMode('upload'));
  setMode('generate');

  sigGenBtn?.addEventListener('click', async () => {
    const url = generateSignatureFromName(String(sigGenName?.value || ''));
    if (!url) return alert('Enter a name to generate a signature.');
    setSignatureDataUrl(await normalizeImageDataUrl(url));
    // always create a new placement near top when a signature is created
    if (pdfDoc) {
      const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
      scrollPreviewToYNorm(pl.y);
      drawOverlay();
    } else {
      pendingAutoPlaceSig = true;
    }
  });

  sigUpload?.addEventListener('change', async () => {
    const f = (sigUpload.files && sigUpload.files[0]) || null;
    if (!f) return;
    const url = await normalizeImageDataUrl(await loadImageAsDataUrl(f));
    setSignatureDataUrl(url);
    // create a new placement near top
    if (pdfDoc) {
      const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
      scrollPreviewToYNorm(pl.y);
      drawOverlay();
    } else {
      pendingAutoPlaceSig = true;
    }
  });

  // Initials create
  initCreateBtn?.addEventListener('click', async () => {
    if (!initEnable) return;
    if (!initEnable.checked) initEnable.checked = true;

    const url = generateInitialsFromText(String(initText?.value || ''));
    if (!url) return alert('Enter initials (e.g., JS).');

    setInitialsDataUrl(await normalizeImageDataUrl(url));

    // Create a new placement near top each time initials are created
    if (pdfDoc) {
      const pl = createPlacement('init', pageNum, 0.72, autoTopYNorm(), getInitScalePct());
      scrollPreviewToYNorm(pl.y);
      drawOverlay();
    } else {
      pendingAutoPlaceInit = true;
    }
  });

  initEnable?.addEventListener('change', () => {
    if (!initEnable.checked) {
      // keep existing placements but hide initials
      setActiveItem('sig');
    }
    drawOverlay();
    updateLockButtons();
  });

  // Scale changes update selected placement
  sigScaleRange?.addEventListener('input', () => {
    const pl = getSelectedPlacement('sig', pageNum);
    if (pl && !pl.locked) pl.scale = getSigScalePct();
    drawOverlay();
  });

  initScaleRange?.addEventListener('input', () => {
    const pl = getSelectedPlacement('init', pageNum);
    if (pl && !pl.locked) pl.scale = getInitScalePct();
    drawOverlay();
  });

  activeSigBtn?.addEventListener('click', () => setActiveItem('sig'));
  activeInitBtn?.addEventListener('click', () => setActiveItem('init'));

  // Add another placement (makes multi-signing obvious)
  addSigBtn?.addEventListener('click', () => {
    if (!pdfDoc || !sigReady) return;
    const pl = createPlacement('sig', pageNum, 0.12, autoTopYNorm(), getSigScalePct());
    scrollPreviewToYNorm(pl.y);
    drawOverlay();
    updateLockButtons();
  });

  addInitBtn?.addEventListener('click', () => {
    if (!pdfDoc) return;
    if (!initEnable) return;
    if (!initEnable.checked) initEnable.checked = true;
    if (!(initEnabled() && initReady)) return;
    const pl = createPlacement('init', pageNum, 0.72, autoTopYNorm(), getInitScalePct());
    scrollPreviewToYNorm(pl.y);
    drawOverlay();
    updateLockButtons();
  });

  // Lock toggles (selected placement)
  lockSigBtn?.addEventListener('click', () => {
    if (!sigReady) return;
    const pl = getSelectedPlacement('sig', pageNum) || ensureAtLeastOnePlacement('sig');
    if (!pl) return;
    pl.locked = !pl.locked;
    selectPlacement('sig', pl.id);
    drawOverlay();
    updateLockButtons();
  });

  lockInitBtn?.addEventListener('click', () => {
    if (!(initEnabled() && initReady)) return;
    const pl = getSelectedPlacement('init', pageNum) || ensureAtLeastOnePlacement('init');
    if (!pl) return;
    pl.locked = !pl.locked;
    selectPlacement('init', pl.id);
    drawOverlay();
    updateLockButtons();
  });

  // Lock & Next Page
  lockNextBtn?.addEventListener('click', async () => {
    if (!pdfDoc) return;
    // lock selected sig/init (if any)
    const sp = getSelectedPlacement('sig', pageNum);
    if (sp) sp.locked = true;
    const ip = getSelectedPlacement('init', pageNum);
    if (ip) ip.locked = true;

    if (pageNum < pageCount) {
      pageNum = Math.min(pageCount, pageNum + 1);
      await renderPage();
    }
    drawOverlay();
    updateLockButtons();
  });

  prevPageBtn?.addEventListener('click', async () => {
    if (!pdfDoc) return;
    pageNum = Math.max(1, pageNum - 1);
    // clear selection for new page (will re-select last on draw)
    selected.id = null;
    await renderPage();
  });

  nextPageBtn?.addEventListener('click', async () => {
    if (!pdfDoc) return;
    pageNum = Math.min(pageCount, pageNum + 1);
    selected.id = null;
    await renderPage();
  });

  async function getPageWH(pn) {
    try {
      const pg = await pdfDoc.getPage(pn);
      const v = pg.getViewport({ scale: 1 });
      return { w: v.width || 1, h: v.height || 1 };
    } catch {
      return { w: viewportCss.w || 1, h: viewportCss.h || 1 };
    }
  }

  exportBtn.addEventListener('click', async () => {
    if (!srcFile) return alert('Upload a PDF first.');
    if (enc === null) return alert('Checking encryption… please try again in a moment.');
    if (enc && !unlockedFile) return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    if (!sigDataUrl) return alert('Add a signature first (generate, draw, or upload).');

    if (status) setStatus(status, 'Status: Exporting...');

    const sigAspect = sigImg.naturalHeight / sigImg.naturalWidth;
    const sigPlacements = [];
    for (const [k, list] of Object.entries(sigByPage)) {
      const pn = parseInt(k, 10);
      if (!(pn >= 1) || !Array.isArray(list)) continue;
      for (const pl of list) {
        if (!pl) continue;
        const { w: pw, h: ph } = await getPageWH(pn);
        const wNorm = (parseFloat(pl.scale) || 20) / 100;
        const hNorm = wNorm * ((pw / ph) * sigAspect);
        sigPlacements.push({ page: pn, x: pl.x, y: pl.y, w: wNorm, h: hNorm });
      }
    }

    // If user never placed anything, export one default placement
    if (!sigPlacements.length) {
      const pl = ensureAtLeastOnePlacement('sig');
      const { w: pw, h: ph } = await getPageWH(pageNum);
      const wNorm = (parseFloat(pl.scale) || 20) / 100;
      const hNorm = wNorm * ((pw / ph) * sigAspect);
      sigPlacements.push({ page: pageNum, x: pl.x, y: pl.y, w: wNorm, h: hNorm });
    }

    const initPlacements = [];
    if (initEnabled() && initDataUrl && initReady) {
      const initAspect = initImg.naturalHeight / initImg.naturalWidth;
      for (const [k, list] of Object.entries(initByPage)) {
        const pn = parseInt(k, 10);
        if (!(pn >= 1) || !Array.isArray(list)) continue;
        for (const pl of list) {
          if (!pl) continue;
          const { w: pw, h: ph } = await getPageWH(pn);
          const wNorm = (parseFloat(pl.scale) || 10) / 100;
          const hNorm = wNorm * ((pw / ph) * initAspect);
          initPlacements.push({ page: pn, x: pl.x, y: pl.y, w: wNorm, h: hNorm });
        }
      }
    }

    const fd = new FormData();
    fd.append('file', unlockedFile || srcFile);
    fd.append('signerName', (sigGenName?.value || '').trim());
    fd.append('signatureDataUrl', sigDataUrl);

    fd.append('sigPlacements', JSON.stringify(sigPlacements));
    if (sigPlacements.length) {
      const s0 = sigPlacements[0];
      fd.append('sigPage', String(s0.page));
      fd.append('sigX', String(s0.x));
      fd.append('sigY', String(s0.y));
      fd.append('sigW', String(s0.w));
      fd.append('sigH', String(s0.h));
    }

    if (initPlacements.length) {
      fd.append('initialsDataUrl', initDataUrl);
      fd.append('initialsText', String(initText?.value || '').trim());
      fd.append('initPlacements', JSON.stringify(initPlacements));
      const i0 = initPlacements[0];
      fd.append('initPage', String(i0.page));
      fd.append('initX', String(i0.x));
      fd.append('initY', String(i0.y));
      fd.append('initW', String(i0.w));
      fd.append('initH', String(i0.h));
    }

    const out = await runPaidPdfExport({
      tool: 'quick-sign',
      endpoint: ENDPOINTS.QUICK_SIGN,
      formData: fd,
      filename: 'pdfrealm-quick-sign.pdf',
      setPreviewFrameId: null,
      placeholderId: null,
    });

    if (status) setStatus(status, out.ok ? 'Status: Done' : 'Status: Ready');
  });

  // Init
  initSignaturePad();
  updateLockButtons();
  setActiveItem('sig');
  showEmpty('Upload a PDF to preview it here. If it is encrypted, unlock it first.');
}

// -------------------- Password Protect --------------------
// -------------------- Password Protect --------------------
function initPassword() {
  const fileInput = $("passwordPdfFile");
  const currentPwInput = $("passwordCurrentInput");
  const unlockBtn = $("passwordUnlockBtn");
  const newPwInput = $("passwordInput");
  const encryptBtn = $("passwordEncryptBtn");

  const frameId = "passwordPreviewFrame";
  const placeholderId = "passwordPreviewPlaceholder";

  if (!fileInput || !encryptBtn) return;

  let unlocked = null;
  let enc = null; // null=pending, true=encrypted, false=not encrypted
  let previewUrl = null;
  let seq = 0;

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmpty(msg) {
    revokePreviewUrl();
    setIframeSrc(frameId, "");
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    // Clip the built-in PDF toolbar/tools (Edge draw, etc.)
    try {
      const fr = $(frameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmpty('Upload a PDF to preview it here.');
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(frameId, previewUrl + '#toolbar=0&navpanes=0&scrollbar=0');
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmpty('Upload a PDF to preview it here.');

    // Block iframe load until we know encryption status (prevents browser password popups)
    enc = null;
    setIframeSrc(frameId, "");
    const ph = $(placeholderId);
    if (ph) ph.textContent = 'Checking PDF…';
    showPlaceholder(placeholderId, true);

    const mySeq = ++seq;
    let encrypted = true; // fail-closed
    try {
      encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        encrypted = await serverSaysEncrypted(f);
      }
    } catch {
      encrypted = true;
    }

    if (mySeq != seq) return;

    enc = !!encrypted;
    if (enc) {
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the current password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    if (ph) ph.textContent = 'Upload a PDF to preview it here.';
    setPreviewFile(f);
  }

  // Capture prevents any legacy wiring from loading the file before encryption guard
  fileInput.addEventListener('change', (e) => {
    try { e.stopImmediatePropagation(); } catch {}
    onFileChange();
  }, true);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(currentPwInput?.value || '');
    if (!pw) return alert('Enter the current PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting…';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Upload a PDF to preview it here.';
      setPreviewFile(unlocked);
    } catch (err) {
      alert(String(err?.message || err));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  encryptBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    const newPw = String(newPwInput?.value || '');
    if (!newPw) return alert('Enter a new password.');

    if (enc === null) {
      return alert('Checking encryption… please try again in a moment.');
    }

    const fd = new FormData();

    // If the input is encrypted and the user did NOT unlock it,
    // send the raw file + the current password so qpdf can open it.
    if (enc && !unlocked) {
      const cur = String(currentPwInput?.value || '');
      if (!cur) {
        return alert('This PDF is already encrypted. Enter the current password (or decrypt/unlock it) before changing the password.');
      }
      fd.append('file', f);
      fd.append('inputPassword', cur);
    } else {
      fd.append('file', unlocked || f);
    }

    fd.append('password', newPw);

    // IMPORTANT: Do NOT set preview to the encrypted output (would trigger the browser password UI).
    await runPaidPdfExport({
      tool: 'encrypt',
      endpoint: ENDPOINTS.ENCRYPT,
      formData: fd,
      filename: 'pdfrealm-protected.pdf',
      setPreviewFrameId: null,
      placeholderId: null,
    });
  });

  // Initial state
  setEmpty('Upload a PDF to preview it here. If it\'s encrypted, unlock first.');
}


// -------------------- Merge / Delete / Split --------------------
function initMerge() {
  const inp1 = $("mergeFile1");
  const inp2 = $("mergeFile2");

  const pw1 = $("mergePassword1");
  const pw2 = $("mergePassword2");
  const unlock1Btn = $("mergeUnlock1Btn");
  const unlock2Btn = $("mergeUnlock2Btn");

  const frameId = "mergePreviewFrame";
  const placeholderId = "mergePreviewPlaceholder";

  if (!inp1 && !inp2) return;

  let unlocked1 = null;
  let unlocked2 = null;

  // encX tri-state:
  //   null  => pending/unknown (block preview to avoid the browser PDF password UI)
  //   true  => encrypted (block preview until unlocked)
  //   false => not encrypted (safe to preview)
  let enc1 = null;
  let enc2 = null;

  // Sequence guards to avoid out-of-order async checks overriding the latest selection
  let encSeq1 = 0;
  let encSeq2 = 0;

  let previewDocUrl = null;
  let innerPdfUrls = [];

  function revokePreviewUrls() {
    try {
      if (previewDocUrl) URL.revokeObjectURL(previewDocUrl);
    } catch {}
    previewDocUrl = null;

    for (const u of innerPdfUrls) {
      try { URL.revokeObjectURL(u); } catch {}
    }
    innerPdfUrls = [];
  }

  function setEmptyPreview() {
    revokePreviewUrls();
    setIframeSrc(frameId, "");
    showPlaceholder(placeholderId, true);
    try { if (previewHint) previewHint.style.display = 'none'; } catch {}
  }

  
  function updatePreview() {
    const f1 = inp1?.files?.[0] || null;
    const f2 = inp2?.files?.[0] || null;

    if (!f1 && !f2) return setEmptyPreview();

    const d1 = unlocked1 || (enc1 === false ? f1 : null);
    const d2 = unlocked2 || (enc2 === false ? f2 : null);

    const msg1 = !f1
      ? "No file selected"
      : enc1 === null && !unlocked1
      ? "Checking encryption…"
      : enc1 === true && !unlocked1
      ? "Encrypted — enter password and click Decrypt / Unlock"
      : "";

    const msg2 = !f2
      ? "No file selected"
      : enc2 === null && !unlocked2
      ? "Checking encryption…"
      : enc2 === true && !unlocked2
      ? "Encrypted — enter password and click Decrypt / Unlock"
      : "";

    // Reset URLs each rebuild so we don't leak blob URLs.
    revokePreviewUrls();

    const topUrl = d1 ? URL.createObjectURL(d1) : null;
    const bottomUrl = d2 ? URL.createObjectURL(d2) : null;
    if (topUrl) innerPdfUrls.push(topUrl);
    if (bottomUrl) innerPdfUrls.push(bottomUrl);

    // Load a same-origin preview shell (stable), then postMessage blob URLs into it.
    setIframeSrc(frameId, "/merge_preview_shell.html");
    showPlaceholder(placeholderId, false);

    const frame = document.getElementById(frameId);

    const payload = {
      type: "pdfrealm:mergePreview",
      top: { url: topUrl, label: "Top PDF", msg: msg1, hasFile: !!d1 },
      bottom: { url: bottomUrl, label: "Bottom PDF", msg: msg2, hasFile: !!d2 }
    };

    const send = () => {
      try {
        // same-origin shell => safe to target location.origin
        frame?.contentWindow?.postMessage(payload, location.origin);
      } catch {}
    };

    if (frame) {
      // Fire after shell loads
      frame.onload = () => send();
      // Also try soon in case onload already fired (browser caching)
      setTimeout(send, 120);
      setTimeout(send, 350);
    } else {
      setTimeout(send, 120);
    }
  }


  async function onFileChange(which) {
    if (which === 1) {
      unlocked1 = null;
      const f = inp1?.files?.[0] || null;

      // Block preview immediately until we definitively know encryption status.
      enc1 = null;
      updatePreview();

      if (!f) return;

      const seq = ++encSeq1;
      let encrypted = true; // fail-closed: never allow the browser PDF password UI
      try {
        encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        // Extra safety: some encrypted PDFs may evade token scan.
        encrypted = await serverSaysEncrypted(f);
      }
      } catch {
        encrypted = true;
      }
      if (seq !== encSeq1) return; // stale result (user picked another file)

      enc1 = !!encrypted;
      updatePreview();
      return;
    }

    // which === 2
    unlocked2 = null;
    const f = inp2?.files?.[0] || null;

    enc2 = null;
    updatePreview();

    if (!f) return;

    const seq = ++encSeq2;
    let encrypted = true;
    try {
      encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        // Extra safety: some encrypted PDFs may evade token scan.
        encrypted = await serverSaysEncrypted(f);
      }
    } catch {
      encrypted = true;
    }
    if (seq !== encSeq2) return;

    enc2 = !!encrypted;
    updatePreview();
  }

  // Capture + stopImmediatePropagation prevents any legacy preview wiring from loading the PDF before our encryption guard runs.
  inp1?.addEventListener(
    "change",
    (e) => {
      try { e.stopImmediatePropagation(); } catch {}
      onFileChange(1);
    },
    true
  );

  inp2?.addEventListener(
    "change",
    (e) => {
      try { e.stopImmediatePropagation(); } catch {}
      onFileChange(2);
    },
    true
  );

  async function unlock(which) {
    const file = which === 1 ? inp1?.files?.[0] : inp2?.files?.[0];
    const pwEl = which === 1 ? pw1 : pw2;
    const btnEl = which === 1 ? unlock1Btn : unlock2Btn;

    if (!file) return alert(which === 1 ? "Select PDF 1 first." : "Select PDF 2 first.");
    const password = String(pwEl?.value || "").trim();
    if (!password) return alert("Enter the PDF password.");

    if (btnEl) {
      btnEl.disabled = true;
      btnEl.textContent = "Decrypting...";
    }

    try {
      const decFile = await decryptPdfToFile(file, password);
      if (which === 1) {
        unlocked1 = decFile;
        enc1 = false;
      } else {
        unlocked2 = decFile;
        enc2 = false;
      }
      updatePreview();
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (btnEl) {
        btnEl.disabled = false;
        btnEl.textContent = "Decrypt / Unlock";
      }
    }
  }

  unlock1Btn?.addEventListener("click", () => unlock(1));
  unlock2Btn?.addEventListener("click", () => unlock(2));

  const btn = $("mergePdfBtn");
  if (!btn) return;

  btn.addEventListener("click", async () => {
    const f1 = inp1?.files?.[0] || null;
    const f2 = inp2?.files?.[0] || null;
    if (!f1 && !f2) return alert("Select at least one PDF.");

    if (f1 && enc1 !== false && !unlocked1) {
      return alert('PDF 1 is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }
    if (f2 && enc2 !== false && !unlocked2) {
      return alert('PDF 2 is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    if (f1) fd.append("files", unlocked1 || f1);
    if (f2) fd.append("files", unlocked2 || f2);

    await runPaidPdfExport({
      tool: "merge",
      endpoint: ENDPOINTS.MERGE,
      formData: fd,
      filename: "pdfrealm-merged.pdf",
      setPreviewFrameId: frameId,
      placeholderId,
    });
  });

  // Initial state
  setEmptyPreview();
}



function initDeletePages() {
  const fileInput = $("deletePdfFile");
  const passInput = $("deletePdfPassword");
  const unlockBtn = $("deleteUnlockBtn");
  const pagesInput = $("deletePagesSpec");
  const exportBtn = $("deletePagesBtn");

  const ph = $("deletePreviewPlaceholder");
  const stage = $("deletePreviewStage");
  const inner = $("deletePreviewInner");
  const img = $("deletePreviewImg");

  const prevBtn = $("deletePrevPageBtn");
  const nextBtn = $("deleteNextPageBtn");
  const pageInput = $("deletePreviewPage");
  const pageCountEl = $("deletePageCount");
  const zoomInput = $("deleteZoom");
  const zoomLabel = $("deleteZoomLabel");

  if (!fileInput || !exportBtn || !ph || !stage || !inner || !img) return;

  let currentFile = null;
  let isEncrypted = false;
  let password = "";
  let currentPage = 1;
  let pageCount = null;

  // Zoom slider
  let zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
  const previewCache = new Map(); // page -> objectURL
  if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

  function clamp(n, a, b) {
    return Math.max(a, Math.min(b, n));
  }

  async function isProbablyEncryptedPdf(file) {
    try {
      const headSlice = file.slice(0, Math.min(65536, file.size));
      const tailSlice = file.slice(Math.max(0, file.size - 65536), file.size);
      const [headBuf, tailBuf] = await Promise.all([headSlice.arrayBuffer(), tailSlice.arrayBuffer()]);
      const dec = new TextDecoder("latin1");
      const head = dec.decode(new Uint8Array(headBuf));
      const tail = dec.decode(new Uint8Array(tailBuf));
      return /\/Encrypt/i.test(head) || /\/Encrypt/i.test(tail);
    } catch {
      return false;
    }
  }

  function showPlaceholder(msg) {
    ph.textContent = msg;
    ph.style.display = "";
    stage.style.display = "none";
  }

  function showStage() {
    ph.style.display = "none";
    stage.style.display = "block";
  }

  function clearCache() {
    for (const url of previewCache.values()) {
      try { URL.revokeObjectURL(url); } catch {}
    }
    previewCache.clear();
  }

  function computeFitScale() {
    const wrapper = stage.parentElement;
    if (!wrapper) return 1;

    const availW = Math.max(100, wrapper.clientWidth - 24);
    const availH = Math.max(100, wrapper.clientHeight - 24);

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return 1;

    const scale = Math.min(availW / w, availH / h, 1.25);
    if (!Number.isFinite(scale) || scale <= 0) return 1;
    return scale;
  }

  function applyZoom() {
    zoomPct = clamp(parseInt(zoomPct, 10) || 100, 50, 200);
    if (zoomInput) zoomInput.value = String(zoomPct);
    if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return;

    const fit = computeFitScale();
    const scale = fit * (zoomPct / 100);

    inner.style.width = `${Math.max(1, Math.round(w * scale))}px`;
    inner.style.height = `${Math.max(1, Math.round(h * scale))}px`;

    img.style.transform = `translate(-50%, -50%) scale(${scale})`;
  }

  async function loadPreview(page) {
    if (!currentFile) return;
    const p = clamp(page, 1, pageCount || 999999);
    currentPage = p;
    if (pageInput) pageInput.value = String(currentPage);

    if (previewCache.has(currentPage)) {
      img.src = previewCache.get(currentPage);
      showStage();
      return;
    }

    showPlaceholder("Rendering preview…");

    try {
      const fd = new FormData();
      fd.append("file", currentFile);
      fd.append("page", String(currentPage));
      fd.append("dpi", "200");
      if (password) fd.append("password", password);

      const res = await fetch("/api/render/page", { method: "POST", body: fd });
      if (!res.ok) {
        const data = await res.json().catch(() => null);
        const msg = (data?.error || `Preview failed (${res.status})`).toString();
        if (/password|encrypt/i.test(msg)) {
          isEncrypted = true;
          showPlaceholder('Encrypted PDF — enter the password and click Decrypt / Unlock.');
          return;
        }
        throw new Error(msg);
      }

      const pc = res.headers.get("x-pdf-page-count") || res.headers.get("X-PDF-Page-Count");
      const maybeCount = pc ? parseInt(pc, 10) : NaN;
      if (Number.isFinite(maybeCount) && maybeCount > 0) {
        pageCount = maybeCount;
        if (pageCountEl) pageCountEl.textContent = String(pageCount);
      }

      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      previewCache.set(currentPage, url);
      img.src = url;
      showStage();
    } catch (e) {
      console.error(e);
      showPlaceholder(e?.message || "Preview not available");
    }
  }

  img.addEventListener("load", () => {
    applyZoom();
  });

  function resetStateForFile(file) {
    currentFile = file;
    password = "";
    if (passInput) passInput.value = "";
    isEncrypted = false;
    currentPage = 1;
    pageCount = null;
    if (pageCountEl) pageCountEl.textContent = "?";
    if (pageInput) pageInput.value = "1";
    clearCache();
    zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
    if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;
  }

  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      resetStateForFile(null);
      showPlaceholder("Upload a PDF to preview. If it's encrypted, enter the password then click Decrypt / Unlock.");
      return;
    }

    resetStateForFile(f);
    showPlaceholder("Analyzing PDF…");

    isEncrypted = await detectEncryptedPdfReliable(f);
    if (isEncrypted) {
      showPlaceholder("Encrypted PDF — enter the password and click Decrypt / Unlock.");
      return;
    }

    await loadPreview(1);
  });

  unlockBtn?.addEventListener("click", async () => {
    if (!currentFile) return alert("Upload a PDF first.");
    const pw = String(passInput?.value || "");
    if (!pw) return alert("Enter the PDF password.");
    password = pw;
    await loadPreview(currentPage || 1);
  });

  zoomInput?.addEventListener("input", () => {
    zoomPct = clamp(parseInt(zoomInput.value || "100", 10) || 100, 50, 200);
    applyZoom();
  });

  prevBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) - 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  nextBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) + 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  pageInput?.addEventListener("change", () => {
    const p = parseInt(pageInput.value || "1", 10) || 1;
    loadPreview(p);
  });

  exportBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");

    const pages = String(pagesInput?.value || "").trim();
    if (!pages) return alert("Enter pages to delete (e.g., 2,4-6). ");
    let pw = password;
    if (isEncrypted && !pw) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    fd.append("file", f);
    fd.append("pages", pages);

    // Keep encrypted output by default when encrypted input.
    if (isEncrypted && pw) {
      fd.append("password", pw);
      fd.append("outputPassword", pw);
    }

    await runPaidPdfExport({
      tool: "delete-pages",
      endpoint: ENDPOINTS.DELETE_PAGES,
      formData: fd,
      filename: "pdfrealm-pages-deleted.pdf",
    });
  });
}


/* PDFREALM_EXCEPTIONAL_UX_PACK_V1_HELPERS */
function __pdfrealm_baseName(name) {
  try {
    const n = String(name || "document").replace(/\.[a-z0-9]+$/i, "");
    return n || "document";
  } catch { return "document"; }
}

function __pdfrealm_parseRanges(str, maxPage) {
  const out = new Set();
  const s = String(str || "").trim();
  if (!s) return [];
  const parts = s.split(",").map(p => p.trim()).filter(Boolean);
  for (const part of parts) {
    if (part.includes("-")) {
      const [a,b] = part.split("-").map(x => parseInt(String(x).trim(), 10));
      if (!Number.isFinite(a) || !Number.isFinite(b)) continue;
      const start = Math.max(1, Math.min(a,b));
      const end = Math.min(maxPage || 999999, Math.max(a,b));
      for (let i=start;i<=end;i++) out.add(i);
    } else {
      const n = parseInt(part, 10);
      if (Number.isFinite(n) && n>=1 && (!maxPage || n<=maxPage)) out.add(n);
    }
  }
  return Array.from(out).sort((x,y)=>x-y);
}

function __pdfrealm_pagesToRanges(pages) {
  const arr = Array.from(new Set((pages||[]).filter(n=>Number.isFinite(n)&&n>0))).sort((a,b)=>a-b);
  if (!arr.length) return "";
  const chunks = [];
  let start = arr[0], prev = arr[0];
  for (let i=1;i<arr.length;i++) {
    const n = arr[i];
    if (n === prev + 1) { prev = n; continue; }
    chunks.push(start === prev ? String(start) : `${start}-${prev}`);
    start = prev = n;
  }
  chunks.push(start === prev ? String(start) : `${start}-${prev}`);
  return chunks.join(",");
}

function __pdfrealm_parseChunkList(str, maxPage) {
  // chunks separated by ';' (or newlines). each chunk is a range list like "1-3,7"
  const raw = String(str || "").trim();
  if (!raw) return [];
  const chunks = raw.split(/\s*;\s*|\n+/).map(x=>x.trim()).filter(Boolean);
  return chunks.map((c, idx) => {
    const pages = __pdfrealm_parseRanges(c, maxPage);
    return { label: `chunk-${String(idx+1).padStart(2,"0")}`, pages };
  }).filter(x=>x.pages && x.pages.length);
}

function __pdfrealm_applyTemplate(tpl, base, page, ext) {
  const t = String(tpl || "{base}_p{page:0000}.{ext}");
  const p = Number(page || 1);
  const m = t.match(/\{page:(0+)\}/);
  let pageStr = String(p);
  if (m && m[1]) pageStr = String(p).padStart(m[1].length, "0");
  return t
    .replaceAll("{base}", String(base || "document"))
    .replaceAll("{page}", String(p))
    .replace(/\{page:(0+)\}/g, pageStr)
    .replaceAll("{ext}", String(ext || "pdf"));
}

async function __pdfrealm_fetchThumbUrl(file, page, dpi=96) {
  const fd = new FormData();
  fd.append("file", file);
  fd.append("page", String(page));
  fd.append("dpi", String(dpi));
  const res = await fetch("/api/render/page", { method: "POST", body: fd });
  if (!res.ok) {
    const data = await res.json().catch(() => null);
    const msg = String((data?.error || data?.message || `Preview failed (${res.status})`).toString());
    throw new Error(msg);
  }
  const blob = await res.blob();
  return URL.createObjectURL(blob);
}

function __pdfrealm_buildThumbStrip(containerEl, opts) {
  const { file, pageCount, selectedSet, onToggle, dpi=84 } = opts || {};
  if (!containerEl) return () => {};
  containerEl.innerHTML = "";
  const urls = new Map();
  let observer = null;

  function makeItem(p) {
    const item = document.createElement("div");
    item.className = "page-thumb";
    item.dataset.page = String(p);

    const img = document.createElement("img");
    img.alt = "Page " + p;
    img.loading = "lazy";
    item.appendChild(img);

    const cap = document.createElement("div");
    cap.className = "pnum";
    cap.textContent = "Page " + p;
    item.appendChild(cap);

    item.addEventListener("click", () => {
      if (!selectedSet) return;
      if (selectedSet.has(p)) selectedSet.delete(p);
      else selectedSet.add(p);
      item.classList.toggle("selected", selectedSet.has(p));
      try { onToggle && onToggle(); } catch {}
    });

    if (selectedSet && selectedSet.has(p)) item.classList.add("selected");
    return item;
  }

  const frag = document.createDocumentFragment();
  for (let p=1;p<=pageCount;p++) frag.appendChild(makeItem(p));
  containerEl.appendChild(frag);

  observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (!entry.isIntersecting) continue;
      const el = entry.target;
      const p = parseInt(el.dataset.page || "", 10);
      if (!Number.isFinite(p) || p<1) continue;
      const img = el.querySelector("img");
      if (!img || img.src) continue;

      __pdfrealm_fetchThumbUrl(file, p, dpi)
        .then((u) => { urls.set(p, u); img.src = u; })
        .catch(() => {});
    }
  }, { root: containerEl, threshold: 0.12 });

  containerEl.querySelectorAll(".page-thumb").forEach(el => observer.observe(el));

  return () => {
    try { observer && observer.disconnect(); } catch {}
    for (const u of urls.values()) { try { URL.revokeObjectURL(u); } catch {} }
    urls.clear();
  };
}

function initSplit() {
  const fileInput = $("splitPdfFile");
  const passInput = $("splitPdfPassword");
  const unlockBtn = $("splitUnlockBtn");
  const rangesInput = $("splitPageRanges");
  const outputMode = $("splitOutputMode");

  const stripEl = $("splitThumbStrip");
  const outputsEl = $("splitOutputsPreview");
  const summaryEl = $("splitOutputSummary");

  const selAllBtn = $("splitSelectAllBtn");
  const clearBtn = $("splitClearSelBtn");
  const oddsBtn = $("splitSelectOddsBtn");
  const evensBtn = $("splitSelectEvensBtn");

  const frameId = "splitPreviewFrame";
  const placeholderId = "splitPreviewPlaceholder";

  const btn = $("splitPdfBtn");
  if (!btn || !fileInput) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let outputUrl = null;
  let pageCount = 0;
  let cleanupStrip = null;

  const selected = new Set(); // selected pages (1-indexed)

  function setEmptyPreview() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
    setIframeSrc(frameId, "");
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    try {
      const fr = $(frameId);
      if (fr) { fr.style.position = 'relative'; fr.style.top='-64px'; fr.style.height='calc(100% + 64px)'; }
    } catch {}
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = file ? URL.createObjectURL(file) : null;
    if (previewUrl) {
      setIframeSrc(frameId, previewUrl);
      showPlaceholder(placeholderId, false);
    } else {
      setEmptyPreview();
    }
  }

  function clearStrip() {
    try { cleanupStrip && cleanupStrip(); } catch {}
    cleanupStrip = null;
    selected.clear();
    pageCount = 0;
    if (stripEl) stripEl.innerHTML = '<div class="muted">Upload a PDF to generate selectable pages.</div>';
    renderOutputsPreview();
  }

  function syncRangesFromSelection() {
    if (!rangesInput) return;
    const pages = Array.from(selected).sort((a,b)=>a-b);
    rangesInput.value = __pdfrealm_pagesToRanges(pages);
  }

  function syncSelectionFromRanges() {
    const pages = __pdfrealm_parseRanges(String(rangesInput?.value||""), pageCount || 999999);
    selected.clear();
    for (const p of pages) selected.add(p);
    // reflect in DOM
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el) => {
      const p = parseInt(el.dataset.page || "", 10);
      el.classList.toggle("selected", selected.has(p));
    });
    renderOutputsPreview();
  }

  async function buildStrip(file) {
    clearStrip();
    if (!file || !stripEl) return;

    try {
      await ensurePDFLib();
      const { PDFDocument } = window.PDFLib;
      const ab = await __pdfrealmPdfFileToArrayBufferMaybeDecrypt(file);
      const doc = await PDFDocument.load(ab);
      pageCount = doc.getPageCount() || 0;

      // Default selection: none (user can select or type ranges)
      cleanupStrip = __pdfrealm_buildThumbStrip(stripEl, {
        file,
        pageCount,
        selectedSet: selected,
        onToggle: () => { syncRangesFromSelection(); renderOutputsPreview(); },
        dpi: 84
      });

      renderOutputsPreview();
    } catch (e) {
      console.error(e);
      if (stripEl) stripEl.innerHTML = '<div class="muted">Failed to generate pages.</div>';
    }
  }

  function renderOutputsPreview() {
    if (!outputsEl) return;
    const mode = String(outputMode?.value || "single");

    const base = __pdfrealm_baseName((fileInput.files && fileInput.files[0] && fileInput.files[0].name) || "pdfrealm");
    const rangesStr = String(rangesInput?.value || "").trim();

    let rows = [];

    if (mode === "single") {
      const pages = rangesStr ? __pdfrealm_parseRanges(rangesStr, pageCount || 999999) : Array.from(selected).sort((a,b)=>a-b);
      if (pages.length) {
        rows = [{ name: base + "_extract.pdf", info: "Pages: " + __pdfrealm_pagesToRanges(pages) }];
        if (summaryEl) summaryEl.textContent = pages.length + " page(s)";
      } else {
        rows = [{ name: base + "_extract.pdf", info: "Choose pages or type ranges" }];
        if (summaryEl) summaryEl.textContent = "";
      }
    } else if (mode === "zip_pages") {
      const pages = rangesStr ? __pdfrealm_parseRanges(rangesStr, pageCount || 999999) : Array.from(selected).sort((a,b)=>a-b);
      rows = pages.slice(0, 200).map(p => ({ name: __pdfrealm_applyTemplate("{base}_p{page:0000}.pdf", base, p, "pdf"), info: "Page " + p }));
      if (pages.length > 200) rows.push({ name: "…", info: "and " + (pages.length-200) + " more" });
      if (summaryEl) summaryEl.textContent = pages.length + " file(s)";
    } else if (mode === "zip_chunks") {
      const chunks = __pdfrealm_parseChunkList(rangesStr, pageCount || 999999);
      rows = chunks.slice(0, 200).map(ch => ({ name: base + "_" + ch.label + ".pdf", info: "Pages: " + __pdfrealm_pagesToRanges(ch.pages) }));
      if (chunks.length > 200) rows.push({ name: "…", info: "and " + (chunks.length-200) + " more" });
      if (summaryEl) summaryEl.textContent = chunks.length + " file(s)";
    }

    outputsEl.innerHTML = rows.map(r => (
      '<div class="row"><div>' + escapeHtml(r.name) + '</div><div class="muted">' + escapeHtml(r.info) + '</div></div>'
    )).join("") || '<div class="muted">No output yet.</div>';
  }

  async function onFileChange() {
    unlocked = null;
    clearStrip();

    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmptyPreview();

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      setIframeSrc(frameId, "");
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    const ph = $(placeholderId);
    if (ph) ph.textContent = 'Upload a PDF to preview it here.';
    setPreviewFile(f);
    await buildStrip(f);
  }

  fileInput.addEventListener("change", onFileChange);

  unlockBtn?.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const password = String(passInput?.value || "").trim();
    if (!password) return alert("Enter the PDF password.");

    if (unlockBtn) { unlockBtn.disabled = true; unlockBtn.textContent = "Decrypting..."; }

    try {
      unlocked = await decryptPdfToFile(f, password);
      enc = false;
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Upload a PDF to preview it here.';
      setPreviewFile(unlocked);
      await buildStrip(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) { unlockBtn.disabled = false; unlockBtn.textContent = "Decrypt / Unlock"; }
    }
  });

  // Selection action buttons
  selAllBtn?.addEventListener("click", () => {
    if (!pageCount) return;
    selected.clear();
    for (let p=1;p<=pageCount;p++) selected.add(p);
    syncRangesFromSelection();
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=> el.classList.add("selected"));
    renderOutputsPreview();
  });
  clearBtn?.addEventListener("click", () => {
    selected.clear();
    if (rangesInput) rangesInput.value = "";
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=> el.classList.remove("selected"));
    renderOutputsPreview();
  });
  oddsBtn?.addEventListener("click", () => {
    if (!pageCount) return;
    selected.clear();
    for (let p=1;p<=pageCount;p+=2) selected.add(p);
    syncRangesFromSelection();
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=>{
      const p = parseInt(el.dataset.page||"",10);
      el.classList.toggle("selected", selected.has(p));
    });
    renderOutputsPreview();
  });
  evensBtn?.addEventListener("click", () => {
    if (!pageCount) return;
    selected.clear();
    for (let p=2;p<=pageCount;p+=2) selected.add(p);
    syncRangesFromSelection();
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=>{
      const p = parseInt(el.dataset.page||"",10);
      el.classList.toggle("selected", selected.has(p));
    });
    renderOutputsPreview();
  });

  rangesInput?.addEventListener("input", () => {
    // typing overrides selection
    syncSelectionFromRanges();
  });
  outputMode?.addEventListener("change", renderOutputsPreview);

  btn.addEventListener("click", async () => {
    const f0 = fileInput.files && fileInput.files[0];
    if (!f0) return alert("Upload a PDF first.");

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const file = unlocked || f0;
    const mode = String(outputMode?.value || "single");
    const base = __pdfrealm_baseName(f0.name);

    // Determine pages from ranges or selection
    const rangesStr = String(rangesInput?.value || "").trim();
    const pages = rangesStr ? __pdfrealm_parseRanges(rangesStr, pageCount || 999999) : Array.from(selected).sort((a,b)=>a-b);

    if (mode === "single") {
      if (!rangesStr && !pages.length) return alert("Select pages or enter ranges like 1-3,5");
      const fd = new FormData();
      fd.append("file", file);
      fd.append("ranges", rangesStr || __pdfrealm_pagesToRanges(pages));

      const out = await runPaidPdfExport({
        tool: "split",
        endpoint: ENDPOINTS.SPLIT,
        formData: fd,
        filename: null,
      });

      if (out?.ok && out.objectUrl && out.blob) {
        try { if (outputUrl) URL.revokeObjectURL(outputUrl); } catch {}
        outputUrl = out.objectUrl;
        setIframeSrc(frameId, outputUrl);
        showPlaceholder(placeholderId, false);
        downloadBlob(out.blob, base + "_extract.pdf");
      }
      return;
    }

    // ZIP modes are generated in-browser using PDF-Lib + JSZip (enterprise batch UX).
    // Authorize once (reuses the existing Pages→ZIP authorize endpoint).
    const authFd = new FormData();
    authFd.append("file", file);
    await runPaidPdfExport({
      tool: "split-zip",
      endpoint: (ENDPOINTS.PDF_TO_PAGES_ZIP_AUTH || "/api/pdf-to-pages-zip/authorize"),
      formData: authFd,
      filename: null,
    });

    await ensurePDFLib();
    const { PDFDocument } = window.PDFLib;
    const JSZip = (typeof getJsZipAsync === "function")
        ? await getJsZipAsync()
        : await (async () => {
            const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
            return mod.default || mod;
          })();

    const ab = await __pdfrealmPdfFileToArrayBufferMaybeDecrypt(file);
    const src = await PDFDocument.load(ab);

    const zip = new JSZip();

    if (mode === "zip_pages") {
      if (!pages.length) return alert("Select pages or enter ranges first.");
      for (let i=0;i<pages.length;i++) {
        const p = pages[i];
        const outDoc = await PDFDocument.create();
        const [pg] = await outDoc.copyPages(src, [p-1]);
        outDoc.addPage(pg);
        const bytes = await outDoc.save();
        const name = __pdfrealm_applyTemplate("{base}_p{page:0000}.pdf", base, p, "pdf");
        zip.file(name, bytes);
      }
      const blob = await zip.generateAsync({ type: "blob" });
      downloadBlob(blob, base + "_pages.zip");
      return;
    }

    if (mode === "zip_chunks") {
      const chunks = __pdfrealm_parseChunkList(rangesStr, src.getPageCount());
      if (!chunks.length) return alert('Enter chunk ranges separated by ";" (example: 1-3;4-6;7-9)');
      for (const ch of chunks) {
        const outDoc = await PDFDocument.create();
        const idxs = ch.pages.map(p=>p-1).filter(n=>n>=0);
        const copied = await outDoc.copyPages(src, idxs);
        for (const pg of copied) outDoc.addPage(pg);
        const bytes = await outDoc.save();
        zip.file(base + "_" + ch.label + ".pdf", bytes);
      }
      const blob = await zip.generateAsync({ type: "blob" });
      downloadBlob(blob, base + "_chunks.zip");
      return;
    }
  });

  // Init
  setEmptyPreview();
  renderOutputsPreview();
}




function initReorderSecure() {
  const fileInput = $("reorderPdfFile");
  const passInput = $("reorderPdfPassword");
  const unlockBtn = $("reorderUnlockBtn");
  const orderInput = $("reorderPages");
  const exportBtn = $("reorderPdfBtn");
  const listEl = $("reorderPageList");
  const resetBtn = $("reorderResetBtn");

  const refreshBtn = $("reorderRefreshBtn");
  const statusEl = $("reorderPreviewStatus");

  const frameId = "reorderPreviewFrame";
  const placeholderId = "reorderPreviewPlaceholder";

  if (!fileInput || !exportBtn) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }
  let previewOutUrl = null;
  let lastPreviewOrder = null;

  // Drag/list state (reorder tool only)
  let pageCount = 0;
  let pageOrder = [];
  let currentThumbFile = null;
  let thumbObserver = null;
  let dragEl = null;
  let buildToken = 0;
  let dragHandlersBound = false;

  const thumbUrls = new Map(); // page -> objectURL
  const thumbState = new Map(); // page -> 'loading'|'loaded'

  // Simple concurrency limiter for thumbnail rendering.
  let inFlight = 0;
  const pending = [];
  const MAX_THUMB_INFLIGHT = 3;

  function enqueue(task) {
    return new Promise((resolve, reject) => {
      pending.push({ task, resolve, reject });
      drain();
    });
  }

  async function drain() {
    if (inFlight >= MAX_THUMB_INFLIGHT) return;
    const next = pending.shift();
    if (!next) return;
    inFlight++;
    try {
      const out = await next.task();
      next.resolve(out);
    } catch (e) {
      next.reject(e);
    } finally {
      inFlight--;
      drain();
    }
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function revokeOutUrl() {
    try { if (previewOutUrl) URL.revokeObjectURL(previewOutUrl); } catch {}
    previewOutUrl = null;
  }

  function clearThumbs() {
    try {
      if (thumbObserver) thumbObserver.disconnect();
    } catch {}
    thumbObserver = null;

    for (const u of thumbUrls.values()) {
      try { URL.revokeObjectURL(u); } catch {}
    }
    thumbUrls.clear();
    thumbState.clear();
    pageCount = 0;
    pageOrder = [];
    currentThumbFile = null;
    dragEl = null;
  }

  function setListEmpty(message) {
    if (!listEl) return;
    listEl.innerHTML = `<div class="reorder-list-empty">${escapeHtml(message || "Upload a PDF to generate draggable pages.")}</div>`;
  }

  function syncOrderFromDom() {
    if (!listEl) return;
    const items = Array.from(listEl.querySelectorAll(".reorder-page-item"));
    const nums = items
      .map((el) => parseInt(el.dataset.page || "", 10))
      .filter((n) => Number.isFinite(n) && n > 0);
    pageOrder = nums;
    if (orderInput && nums.length) {
      orderInput.value = nums.join(",");
    }
    updatePreviewSyncUI();
  }

  function resetToOriginalOrder() {
    if (!listEl || !pageCount) return;
    const map = new Map();
    for (const el of Array.from(listEl.querySelectorAll(".reorder-page-item"))) {
      const p = parseInt(el.dataset.page || "", 10);
      if (Number.isFinite(p)) map.set(p, el);
    }
    listEl.innerHTML = "";
    for (let p = 1; p <= pageCount; p++) {
      const el = map.get(p);
      if (el) listEl.appendChild(el);
    }
    syncOrderFromDom();
  }

  function parseOrderInput(value) {
    const raw = String(value || "")
      .split(/[,\s]+/)
      .map((s) => s.trim())
      .filter(Boolean);
    const nums = raw
      .map((s) => parseInt(s, 10))
      .filter((n) => Number.isFinite(n));
    // De-dupe while preserving order
    const seen = new Set();
    const unique = [];
    for (const n of nums) {
      if (!seen.has(n)) {
        seen.add(n);
        unique.push(n);
      }
    }
    return unique;
  }

  function currentOrderString() {
    if (pageOrder && pageOrder.length) return pageOrder.join(',');
    const nums = parseOrderInput(orderInput?.value || '');
    return nums.length ? nums.join(',') : '';
  }

  function setStatus(text) {
    if (!statusEl) return;
    if (!text) {
      statusEl.style.display = 'none';
      statusEl.textContent = '';
      return;
    }
    statusEl.textContent = text;
    statusEl.style.display = 'block';
  }

  function updatePreviewSyncUI() {
    const cur = currentOrderString();
    const stale = Boolean(lastPreviewOrder && cur && cur !== lastPreviewOrder);
    if (refreshBtn) refreshBtn.disabled = !stale;
    setStatus(stale ? 'Order changed — click Refresh Preview to update the preview.' : '');
  }

  function syncListFromInput() {
    if (!listEl || !pageCount || !orderInput) return;
    const nums = parseOrderInput(orderInput.value);
    if (nums.length !== pageCount) return; // ignore partial/invalid
    if (nums.some((n) => n < 1 || n > pageCount)) return;

    const map = new Map();
    for (const el of Array.from(listEl.querySelectorAll(".reorder-page-item"))) {
      const p = parseInt(el.dataset.page || "", 10);
      if (Number.isFinite(p)) map.set(p, el);
    }
    // Ensure all pages exist
    for (let p = 1; p <= pageCount; p++) {
      if (!map.has(p)) return;
    }

    listEl.innerHTML = "";
    for (const p of nums) {
      listEl.appendChild(map.get(p));
    }
    syncOrderFromDom();
  }

  function setEmptyPreview(msg) {
    revokeOutUrl();
    revokePreviewUrl();
    setIframeSrc(frameId, "");
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    revokeOutUrl();
    revokePreviewUrl();
    if (!file) {
      return setEmptyPreview('Upload a PDF to preview it here.');
    }
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(frameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function probePageCount(file) {
    // Use render/page because it returns X-PDF-Page-Count when possible.
    const fd = new FormData();
    fd.append("file", file);
    fd.append("page", "1");
    fd.append("dpi", "60");
    const res = await fetch("/api/render/page", { method: "POST", body: fd });
    if (!res.ok) {
      const data = await res.json().catch(() => null);
      const msg = String((data?.error || data?.message || `Preview failed (${res.status})`).toString());
      throw new Error(msg);
    }
    const pc = res.headers.get("x-pdf-page-count") || res.headers.get("X-PDF-Page-Count");
    const count = pc ? parseInt(pc, 10) : NaN;
    const blob = await res.blob();
    return { count: Number.isFinite(count) && count > 0 ? count : 0, firstBlob: blob };
  }

  async function fetchThumb(file, page, dpi = 96) {
    const fd = new FormData();
    fd.append("file", file);
    fd.append("page", String(page));
    fd.append("dpi", String(dpi));
    const res = await fetch("/api/render/page", { method: "POST", body: fd });
    if (!res.ok) {
      const data = await res.json().catch(() => null);
      const msg = String((data?.error || data?.message || `Preview failed (${res.status})`).toString());
      throw new Error(msg);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    thumbUrls.set(page, url);
    return url;
  }

  function buildListDom(count) {
    if (!listEl) return;
    listEl.innerHTML = "";

    const frag = document.createDocumentFragment();
    for (let p = 1; p <= count; p++) {
      const item = document.createElement("div");
      item.className = "reorder-page-item";
      item.draggable = true;
      item.dataset.page = String(p);

      const handle = document.createElement("div");
      handle.className = "reorder-drag-handle";
      handle.textContent = "⋮⋮";

      const thumb = document.createElement("div");
      thumb.className = "reorder-thumb";
      const img = document.createElement("img");
      img.alt = `Page ${p}`;
      img.loading = "lazy";
      thumb.appendChild(img);

      const meta = document.createElement("div");
      meta.className = "reorder-meta";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = `Page ${p}`;
      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = "Drag to move";
      meta.appendChild(title);
      meta.appendChild(sub);

      item.appendChild(handle);
      item.appendChild(thumb);
      item.appendChild(meta);
      frag.appendChild(item);
    }
    listEl.appendChild(frag);
  }

  function attachDragHandlers() {
    if (!listEl) return;
    if (dragHandlersBound) return;
    dragHandlersBound = true;

    function clearDropTargets() {
      listEl.querySelectorAll(".reorder-page-item.drop-target").forEach((el) => el.classList.remove("drop-target"));
    }

    listEl.addEventListener("dragstart", (e) => {
      const item = e.target?.closest?.(".reorder-page-item");
      if (!item) return;
      dragEl = item;
      item.classList.add("dragging");
      try {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", item.dataset.page || "");
      } catch {}
    });

    listEl.addEventListener("dragover", (e) => {
      if (!dragEl) return;
      e.preventDefault();
      const target = e.target?.closest?.(".reorder-page-item");
      if (!target || target === dragEl) return;

      clearDropTargets();
      target.classList.add("drop-target");

      const rect = target.getBoundingClientRect();
      const after = (e.clientY - rect.top) > rect.height / 2;
      if (after) target.after(dragEl);
      else target.before(dragEl);
    });

    listEl.addEventListener("drop", (e) => {
      if (!dragEl) return;
      e.preventDefault();
      clearDropTargets();
      syncOrderFromDom();
    });

    listEl.addEventListener("dragend", () => {
      clearDropTargets();
      if (dragEl) dragEl.classList.remove("dragging");
      dragEl = null;
      syncOrderFromDom();
    });
  }

  async function buildPageList(file) {
    if (!listEl) return;
    const myToken = ++buildToken;
    clearThumbs();
    currentThumbFile = file;
    setListEmpty("Generating pages…");

    try {
      const { count, firstBlob } = await probePageCount(file);
      if (myToken !== buildToken) return;
      if (!count || count < 1) {
        setListEmpty("Couldn't detect page count for this PDF.");
        return;
      }

      pageCount = count;
      pageOrder = Array.from({ length: pageCount }, (_, i) => i + 1);
      if (orderInput) orderInput.value = pageOrder.join(",");

      // Input preview matches the default order on load.
      lastPreviewOrder = pageOrder.join(',');
      updatePreviewSyncUI();

      buildListDom(pageCount);
      attachDragHandlers();

      // Seed page 1 thumbnail from the probe.
      try {
        const url1 = URL.createObjectURL(firstBlob);
        thumbUrls.set(1, url1);
        const item1 = listEl.querySelector('.reorder-page-item[data-page="1"]');
        const img1 = item1?.querySelector('img');
        if (img1) {
          img1.src = url1;
          thumbState.set(1, "loaded");
        }
      } catch {}

      // Lazy-load thumbnails as items scroll into view.
      thumbObserver = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (!entry.isIntersecting) continue;
            const item = entry.target;
            const p = parseInt(item.dataset.page || "", 10);
            if (!Number.isFinite(p) || p < 1) continue;
            if (thumbState.get(p) === "loaded" || thumbState.get(p) === "loading") continue;
            const img = item.querySelector("img");
            if (!img) continue;

            thumbState.set(p, "loading");
            enqueue(async () => {
              // If user changed files mid-load, drop it.
              if (myToken !== buildToken) return null;
              if (!currentThumbFile) return null;
              const url = await fetchThumb(currentThumbFile, p, 96);
              return url;
            })
              .then((url) => {
                if (!url) return;
                if (myToken !== buildToken) return;
                img.src = url;
                thumbState.set(p, "loaded");
              })
              .catch(() => {
                // Keep placeholder; user can still drag/order.
                thumbState.delete(p);
              });
          }
        },
        { root: listEl, threshold: 0.12 }
      );

      for (const item of Array.from(listEl.querySelectorAll(".reorder-page-item"))) {
        thumbObserver.observe(item);
      }
    } catch (e) {
      if (myToken !== buildToken) return;
      setListEmpty(e?.message || "Failed to generate pages.");
    }
  }

  async function serverSaysEncrypted(file) {
    try {
      const fd = new FormData();
      fd.append('file', file);
      fd.append('page', '1');
      fd.append('dpi', '50');
      const res = await fetch('/api/render/page', { method: 'POST', body: fd });
      if (res.ok) {
        // We don't need the image; just a signal.
        try {
          const b = await res.blob();
          // revoke quickly
          const u = URL.createObjectURL(b);
          setTimeout(() => { try { URL.revokeObjectURL(u); } catch {} }, 1000);
        } catch {}
        return false;
      }
      const data = await res.json().catch(() => null);
      const msg = String((data?.error || data?.message || '').toString());
      return /password|encrypt/i.test(msg);
    } catch {
      return false;
    }
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      enc = false;
      clearThumbs();
      lastPreviewOrder = null;
      updatePreviewSyncUI();
      setListEmpty("Upload a PDF to generate draggable pages.");
      return setEmptyPreview('Upload a PDF to preview it here.');
    }

    // Fail-closed: block iframe until encryption status is known.
    enc = true;
    setEmptyPreview('Checking encryption…');
    clearThumbs();
    setListEmpty("Checking encryption…");

    let encrypted = true
    try {
      encrypted = await detectEncryptedPdfReliable(f);
      if (!encrypted) {
        // Extra safety: some encrypted PDFs may evade token scan.
        encrypted = await serverSaysEncrypted(f);
      }
    } catch {
      encrypted = true
    }

    enc = encrypted
    if (enc) {
      lastPreviewOrder = null;
      updatePreviewSyncUI();
      setListEmpty('Encrypted PDF — enter the password and click "Decrypt / Unlock" to build draggable pages.');
      return setEmptyPreview('Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.');
    }

    setPreviewFile(f);
    buildPageList(f);
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting...';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      resetPrepared();
      if (previewHint) {
        try { previewHint.style.display = 'none'; } catch {}
      }
      try { if (previewHint) previewHint.style.display = 'none'; } catch {}
      setPreviewFile(unlocked);
      buildPageList(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  exportBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    let order = String(orderInput?.value || '').trim();
    if (!order && pageOrder && pageOrder.length) {
      order = pageOrder.join(',');
      if (orderInput) orderInput.value = order;
    }
    if (!order) return alert('Enter a page order (e.g., 3,1,2) || drag pages to set the order.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);
    fd.append('order', order);

    const out = await runPaidPdfExport({
      tool: 'reorder',
      endpoint: ENDPOINTS.REORDER,
      formData: fd,
      filename: 'pdfrealm-reordered.pdf',
      setPreviewFrameId: frameId,
      placeholderId,
    });

    if (out?.ok) {
      lastPreviewOrder = order;
      updatePreviewSyncUI();
    }
  });

  async function refreshReorderPreview() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    // Prefer the drag-derived order; fall back to the input box.
    let order = currentOrderString();
    if (!order) order = String(orderInput?.value || '').trim();
    if (!order) return alert('Set a page order first (drag pages || type an order).');

    const nums = parseOrderInput(order);
    if (pageCount && nums.length && nums.length != pageCount) {
      return alert('Order must include exactly ' + pageCount + ' pages.');
    }
    if (nums.length) order = nums.join(',');

    if (refreshBtn) {
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'Refreshing...';
    }

    try {
      const fd = new FormData();
      fd.append('file', unlocked || f);
      fd.append('order', order);

      // Preview-only run (no download).
      revokeOutUrl();
      revokePreviewUrl();
      const out = await runPaidPdfExport({
        tool: 'reorder',
        endpoint: ENDPOINTS.REORDER,
        formData: fd,
        filename: null,
        setPreviewFrameId: frameId,
        placeholderId,
      });

      if (out?.ok && out.objectUrl) {
        previewOutUrl = out.objectUrl;
        lastPreviewOrder = order;
        updatePreviewSyncUI();
      }
    } finally {
      if (refreshBtn) refreshBtn.textContent = 'Refresh Preview';
      updatePreviewSyncUI();
    }
  }

  refreshBtn?.addEventListener('click', () => {
    refreshReorderPreview();
  });

  // Initial
  setEmptyPreview('Upload a PDF to preview it here.');
  setListEmpty("Upload a PDF to generate draggable pages.");

  updatePreviewSyncUI();

  resetBtn?.addEventListener("click", () => {
    resetToOriginalOrder();
  });

  orderInput?.addEventListener("change", () => {
    syncListFromInput();
  });
}
// -------------------- Docs (invoice / receipt / paystub) --------------------
function initDocs() {
  function getDocModel(kind) {
    if (kind === "invoice") {
      return {
        kind: "invoice",
        senderName: $("invSenderName")?.value || "",
        senderCompany: $("invSenderCompany")?.value || "",
        senderAddress: $("invSenderAddress")?.value || "",
        senderPhone: $("invSenderPhone")?.value || "",
        senderEmail: $("invSenderEmail")?.value || "",
        senderWebsite: $("invSenderWebsite")?.value || "",
        to: $("invTo")?.value || "",
        invoice_number: $("invNumber")?.value || "",
        amount: $("invAmount")?.value || "",
        notes: $("invNotes")?.value || "",
      };
    }

    if (kind === "receipt") {
      return {
        kind: "receipt",
        senderName: $("recSenderName")?.value || "",
        senderCompany: $("recSenderCompany")?.value || "",
        senderAddress: $("recSenderAddress")?.value || "",
        senderPhone: $("recSenderPhone")?.value || "",
        senderEmail: $("recSenderEmail")?.value || "",
        senderWebsite: $("recSenderWebsite")?.value || "",
        to: $("recTo")?.value || "",
        amount: $("recAmount")?.value || "",
        reason: $("recReason")?.value || "",
        method: $("recMethod")?.value || "",
      };
    }

    return {
      kind: "paystub",
      employee: $("psEmployee")?.value || "",
      employer: $("psEmployer")?.value || "",
      gross: $("psGross")?.value || "",
      deductions: $("psDeductions")?.value || "",
      period: $("psPeriod")?.value || "",
      payPeriodStart: $("psPeriodStart")?.value || "",
      payPeriodEnd: $("psPeriodEnd")?.value || "",
    };
  }

  function buildDocsPreviewHtml(model) {
    const kind = model.kind;
    const title = kind === "invoice" ? "INVOICE" : kind === "receipt" ? "RECEIPT" : "PAYSTUB";
    const today = new Date().toLocaleDateString();

    const senderBlock =
      kind === "paystub"
        ? `
      <div class="row">
        <div class="block">
          <div class="label">Employer</div>
          <div class="value">${escapeHtml(model.employer || "")}</div>
        </div>
      </div>
    `
        : `
      <div class="row">
        <div class="block">
          <div class="label">From</div>
          <div class="value">
            ${escapeHtml(model.senderName || "")}<br/>
            ${escapeHtml(model.senderCompany || "")}<br/>
            ${escapeHtml(model.senderAddress || "")}<br/>
            ${escapeHtml(model.senderPhone || "")}<br/>
            ${escapeHtml(model.senderEmail || "")}<br/>
            ${escapeHtml(model.senderWebsite || "")}
          </div>
        </div>
      </div>
    `;

    let bodySpecific = "";

    if (kind === "invoice") {
      bodySpecific = `
        <div class="row">
          <div class="block">
            <div class="label">Bill To</div>
            <div class="value">${escapeHtml(model.to || "")}</div>
          </div>
          <div class="block">
            <div class="label">Invoice #</div>
            <div class="value">${escapeHtml(model.invoice_number || "")}</div>
          </div>
          <div class="block">
            <div class="label">Amount</div>
            <div class="value big">${escapeHtml(model.amount || "")}</div>
          </div>
        </div>
        <div class="row">
          <div class="block full">
            <div class="label">Notes</div>
            <div class="value">${escapeHtml(model.notes || "")}</div>
          </div>
        </div>
      `;
    } else if (kind === "receipt") {
      bodySpecific = `
        <div class="row">
          <div class="block">
            <div class="label">Receipt For</div>
            <div class="value">${escapeHtml(model.to || "")}</div>
          </div>
          <div class="block">
            <div class="label">Amount</div>
            <div class="value big">${escapeHtml(model.amount || "")}</div>
          </div>
          <div class="block">
            <div class="label">Method</div>
            <div class="value">${escapeHtml(model.method || "")}</div>
          </div>
        </div>
        <div class="row">
          <div class="block full">
            <div class="label">Reason</div>
            <div class="value">${escapeHtml(model.reason || "")}</div>
          </div>
        </div>
      `;
    } else {
      const payPeriodText =
        model.payPeriodStart || model.payPeriodEnd
          ? `${model.payPeriodStart || ""} – ${model.payPeriodEnd || ""}`
          : model.period || "";

      bodySpecific = `
        <div class="row">
          <div class="block">
            <div class="label">Employee</div>
            <div class="value">${escapeHtml(model.employee || "")}</div>
          </div>
          <div class="block">
            <div class="label">Employer</div>
            <div class="value">${escapeHtml(model.employer || "")}</div>
          </div>
          <div class="block">
            <div class="label">Pay Period</div>
            <div class="value">${escapeHtml(payPeriodText || "")}</div>
          </div>
        </div>
        <div class="row">
          <div class="block">
            <div class="label">Gross Pay</div>
            <div class="value big">${escapeHtml(model.gross || "")}</div>
          </div>
          <div class="block">
            <div class="label">Deductions</div>
            <div class="value">${escapeHtml(model.deductions || "")}</div>
          </div>
          <div class="block">
            <div class="label">Net Pay</div>
            <div class="value big">
              ${escapeHtml(model.gross || "")}
            </div>
          </div>
        </div>
      `;
    }

    return `
<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>${escapeHtml(title)} Preview</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    html,body{margin:0;padding:0;background:#f3f4f6;color:#111827;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif;}
    .page{max-width:900px;margin:24px auto;background:#ffffff;border-radius:12px;border:1px solid #e5e7eb;box-shadow:0 10px 30px rgba(15,23,42,.18);padding:24px 24px 28px;}
    .top-row{display:flex;justify-content:space-between;gap:24px;align-items:flex-start;border-bottom:1px solid #e5e7eb;padding-bottom:16px;margin-bottom:18px;}
    .logo-box{width:150px;height:90px;border-radius:10px;border:1px dashed #d1d5db;display:flex;align-items:center;justify-content:center;font-size:0.8rem;color:#6b7280;text-align:center;padding:6px;box-sizing:border-box;overflow:hidden;position:relative;}
    .logo-placeholder{width:100%;height:100%;display:flex;align-items:center;justify-content:center;text-align:center;font-size:0.75rem;color:#9ca3af;padding:4px;box-sizing:border-box;}
    .logo-box img{max-width:100%;max-height:80px;object-fit:contain;border-radius:10px;position:relative;left:0;top:0;display:none;cursor:grab;}
    .doc-meta{text-align:right;}
    .doc-title{font-size:1.4rem;font-weight:800;letter-spacing:.12em;}
    .doc-date{margin-top:6px;font-size:.9rem;color:#6b7280;}
    .row{display:flex;flex-wrap:wrap;gap:16px;margin-bottom:12px;}
    .block{flex:1 1 180px;padding:12px 12px;border-radius:10px;background:#f9fafb;border:1px solid #e5e7eb;}
    .block.full{flex-basis:100%;}
    .label{font-size:.78rem;text-transform:uppercase;letter-spacing:.12em;color:#6b7280;margin-bottom:6px;}
    .value{font-size:.95rem;white-space:pre-line;}
    .big{font-size:1.05rem;font-weight:750;}
  </style>
</head>
<body>
  <div class="page">
    <div class="top-row">
      <div class="logo-box" id="logoBox">
        <div class="logo-placeholder" id="logoPlaceholder">
          Logo can be added here in the pop-out window (optional).
        </div>
        <img id="logoImg" alt="Logo"/>
      </div>
      <div class="doc-meta">
        <div class="doc-title">${escapeHtml(title)}</div>
        <div class="doc-date">Preview • ${escapeHtml(today)}</div>
      </div>
    </div>

    ${senderBlock}
    ${bodySpecific}
  </div>

  <script>
    (function(){
      var isPopup = !!window.opener;
      var box = document.getElementById("logoBox");
      var placeholder = document.getElementById("logoPlaceholder");
      var img = document.getElementById("logoImg");
      if (!box || !img || !placeholder) return;

      if (!isPopup) return;

      var input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.style.display = "none";
      document.body.appendChild(input);

      box.style.cursor = "pointer";
      box.title = "Click to upload a logo, then drag to position it";

      box.addEventListener("click", function(){ input.click(); });

      input.addEventListener("change", function(){
        var f = input.files && input.files[0];
        if (!f) return;
        var url = URL.createObjectURL(f);
        img.src = url;
        img.style.display = "block";
        placeholder.style.display = "none";
      });

      var dragging = false;
      var startX = 0, startY = 0;
      var origX = 0, origY = 0;

      img.addEventListener("pointerdown", function(e){
        if (!img.src) return;
        dragging = true;
        img.setPointerCapture(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        origX = parseFloat(img.style.left || "0");
        origY = parseFloat(img.style.top || "0");
        img.style.cursor = "grabbing";
        e.preventDefault();
      });

      img.addEventListener("pointermove", function(e){
        if (!dragging) return;
        var dx = e.clientX - startX;
        var dy = e.clientY - startY;
        img.style.left = (origX + dx) + "px";
        img.style.top  = (origY + dy) + "px";
      });

      img.addEventListener("pointerup", function(){
        dragging = false;
        img.style.cursor = "grab";
      });

      img.addEventListener("pointercancel", function(){
        dragging = false;
        img.style.cursor = "grab";
      });
    })();
  </script>
</body>
</html>
    `;
  }

  function setPreviewFromModel(kind) {
    try {
      const model = getDocModel(kind);
      const html = buildDocsPreviewHtml(model);
      const blob = new Blob([html], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      setIframeSrc("invoicePreviewFrame", url);
      showPlaceholder("invoicePreviewPlaceholder", false);
      const frame = $("invoicePreviewFrame");
      if (frame) frame.classList.add("active");
    } catch (e) {
      console.error("Docs preview error:", e);
      alert("Preview failed: " + (e.message || "Unknown error"));
    }
  }

  async function exportDoc(kind, endpoint, filename) {
    const fd = new FormData();
    const model = getDocModel(kind);
    for (const [k, v] of Object.entries(model)) fd.append(k, v);

    await runPaidPdfExport({
      tool: kind,
      endpoint,
      formData: fd,
      filename,
      setPreviewFrameId: "invoicePreviewFrame",
      placeholderId: "invoicePreviewPlaceholder",
    });
  }

  $("invoicePreviewBtn")?.addEventListener("click", () => setPreviewFromModel("invoice"));
  $("receiptPreviewBtn")?.addEventListener("click", () => setPreviewFromModel("receipt"));
  $("paystubPreviewBtn")?.addEventListener("click", () => setPreviewFromModel("paystub"));

  $("invoiceExportBtn")?.addEventListener("click", () => exportDoc("invoice", ENDPOINTS.INVOICE, "pdfrealm-invoice.pdf"));
  $("receiptExportBtn")?.addEventListener("click", () => exportDoc("receipt", ENDPOINTS.RECEIPT, "pdfrealm-receipt.pdf"));
  $("paystubExportBtn")?.addEventListener("click", () => exportDoc("paystub", ENDPOINTS.PAYSTUB, "pdfrealm-paystub.pdf"));
}

// -------------- Convert (documents + images) --------------
function initConvert() {
  function wirePdfPreview(inputId, frameId, placeholderId) {
    const inp = $(inputId);
    if (!inp) return;
    inp.addEventListener("change", () => {
      const f = inp.files && inp.files[0];
      if (!f) return;
      const url = makeObjectUrlFromFile(f);
      if (frameId) setIframeSrc(frameId, url);
      if (placeholderId) showPlaceholder(placeholderId, false);
    });
  }

  // Image input previews (use the same iframe previewer for consistency)
  wirePdfPreview("jpgToPngFile", "jpg2pngPreviewFrame", "jpg2pngPreviewPlaceholder");
  wirePdfPreview("pngToJpgFile", "png2jpgPreviewFrame", "png2jpgPreviewPlaceholder");
  

  // ---- Word → PDF (split preview: input left, output right) ----
  function initWordToPdfSplit() {
    const fileInput = $("w2pFile");
    const pwInput = $("w2pPassword");
    const previewInputBtn = $("w2pPreviewBtn");
    const convertPreviewBtn = $("wordToPdfPreviewBtn");
    const exportBtn = $("wordToPdfExportBtn");
    const statusEl = $("w2pStatus");

    const inputHost = $("w2pInputPreviewHost");
    const outputHost = $("w2pOutputPreviewHost");

    if (!fileInput || !previewInputBtn || !convertPreviewBtn || !exportBtn || !inputHost || !outputHost) return;

    // Keep output preview clean (no browser PDF tools, no context menu)
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    // PDF.js bootstrap (dynamic import; matches our OCR/QuickSign pattern)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    function renderInputHtml(html) {
      inputHost.innerHTML = "";
      const iframe = document.createElement("iframe");
      // No scripts; same-origin so CSS applies; srcdoc is isolated.
      iframe.setAttribute("sandbox", "allow-same-origin");
      iframe.style.width = "100%";
      iframe.style.height = "100%";
      iframe.style.border = "0";
      iframe.style.background = "white";

      // Wrap in a minimal document so the preview is readable.
      const doc = `<!doctype html><html><head><meta charset="utf-8" />
        <style>
          body{margin:0;padding:18px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#111;background:#fff;}
          img{max-width:100%;height:auto;}
          table{max-width:100%;}
        </style></head><body>${html || "<div>No preview available.</div>"}</body></html>`;
      iframe.srcdoc = doc;
      inputHost.appendChild(iframe);
      showPlaceholder("w2pInputPlaceholder", false);
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      // Render up to 10 pages for preview (scrollable).
      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("w2pOutputPlaceholder", false);
    }

    async function callJson(endpoint, fd) {
      const token = getToken();
      const headers = {};
      if (token) headers["Authorization"] = `Bearer ${token}`;
      const res = await fetch(endpoint, { method: "POST", headers, body: fd });
      let data = null;
      try { data = await res.json(); } catch {}
      if (!res.ok) {
        const msg = data?.error || data?.message || `Request failed (${res.status})`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
      }
      return data;
    }

    async function callBlob(endpoint, fd) {
      const token = getToken();
      const headers = {};
      if (token) headers["Authorization"] = `Bearer ${token}`;
      const res = await fetch(endpoint, { method: "POST", headers, body: fd });
      if (!res.ok) {
        let data = null;
        try { data = await res.json(); } catch {}
        const msg = data?.error || data?.message || `Request failed (${res.status})`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
      }
      return await res.blob();
    }

    function buildFormData() {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return null;
      const fd = new FormData();
      fd.append("file", f);
      const pw = pwInput ? String(pwInput.value || "") : "";
      if (pw) fd.append("password", pw);
      return fd;
    }

    async function previewInput() {
      const fd = buildFormData();
      if (!fd) return alert("Upload a Word document first.");
      setStatus("Generating input preview...");
      try {
        const out = await callJson(ENDPOINTS.WORD_TO_PDF_INPUT_PREVIEW, fd);
        renderInputHtml(out.html || "");
        setStatus("");
      } catch (e) {
        setStatus(e.message || "Input preview failed.");
      }
    }

    async function convertPreview() {
      const fd = buildFormData();
      if (!fd) return alert("Upload a Word document first.");
      setStatus("Converting to PDF (preview)...");
      exportBtn.disabled = true;
      try {
        const blob = await callBlob(ENDPOINTS.WORD_TO_PDF_PREVIEW, fd);
        lastOutputBlob = blob;
        await renderPdfBlobToHost(blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch (e) {
        setStatus(e.message || "Convert preview failed.");
      }
    }

    async function exportPdf() {
      const fd = buildFormData();
      if (!fd) return alert("Upload a Word document first.");
      // Use original filename if available
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-word");
      const filename = `${base}.pdf`;

      setStatus("Exporting PDF...");
      const out = await runPaidPdfExport({
        tool: "word-to-pdf",
        endpoint: ENDPOINTS.WORD_TO_PDF,
        formData: fd,
        filename,
        setPreviewFrameId: null,
        placeholderId: null,
      });

      if (out && out.ok && out.blob) {
        lastOutputBlob = out.blob;
        try { await renderPdfBlobToHost(out.blob, outputHost); } catch {}
        exportBtn.disabled = false;
        setStatus("Exported.");
      }
    }

    // Auto-preview input on file select
    fileInput.addEventListener("change", () => {
      exportBtn.disabled = true;
      showPlaceholder("w2pOutputPlaceholder", true);
      showPlaceholder("w2pInputPlaceholder", true);
      // clear hosts
      inputHost.innerHTML = "";
      outputHost.innerHTML = "";
      setStatus("");
      previewInput();
    });

    previewInputBtn.addEventListener("click", previewInput);
    convertPreviewBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportPdf);
  }

  function wireConversionButton({ buttonId, fileInputId, endpoint, tool, filename, multiple = false, previewFrameId = null, placeholderId = null }) {
    const btn = $(buttonId);
    if (!btn) return;

    btn.addEventListener("click", async () => {
      const inp = $(fileInputId);
      if (!inp) return alert("Missing input for " + tool);

      const files = multiple ? Array.from(inp.files || []) : (inp.files && [inp.files[0]]) || [];
      if (!files.length) return alert("Upload a file first.");

      const fd = new FormData();
      if (multiple) files.forEach((f) => fd.append("files", f));
      else fd.append("file", files[0]);

      await runPaidPdfExport({
        tool,
        endpoint,
        formData: fd,
        filename,
        setPreviewFrameId: previewFrameId,
        placeholderId: placeholderId,
      });
    });
  }
  // Word → PDF (split preview)
  initWordToPdfSplit();
  // SVG → PDF (split preview)
  if (typeof initSvgToPdfSplit === "function") initSvgToPdfSplit();
// PDF → Images (mostly stubbed server-side)
  wireConversionButton({ buttonId: "pdfToJpgBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_JPG, tool: "pdf-to-jpg", filename: "pdfrealm-pdf-to-jpg.zip" });
  wireConversionButton({ buttonId: "pdfToPngBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_PNG, tool: "pdf-to-png", filename: "pdfrealm-pdf-to-png.zip" });
  wireConversionButton({ buttonId: "pdfToTiffBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_TIFF, tool: "pdf-to-tiff", filename: "pdfrealm-pdf-to-tiff.zip" });
  wireConversionButton({ buttonId: "pdfToSvgBtnConv", fileInputId: "pdfToImgFile", endpoint: ENDPOINTS.PDF_TO_SVG, tool: "pdf-to-svg", filename: "pdfrealm-pdf-to-svg.zip" });
  wireConversionButton({ buttonId: "tiffToPdfBtn", fileInputId: "tiffToPdfFile", endpoint: ENDPOINTS.TIFF_TO_PDF, tool: "tiff-to-pdf", filename: "pdfrealm-tiff.pdf", previewFrameId: "tiff2pdfPreviewFrame", placeholderId: "tiff2pdfPreviewPlaceholder" });

  // Image ↔ Image (stubbed)
  wireConversionButton({ buttonId: "jpgToPngBtn", fileInputId: "jpgToPngFile", endpoint: ENDPOINTS.JPG_TO_PNG, tool: "jpg-to-png", filename: "pdfrealm-jpg-to-png.png" });
  wireConversionButton({ buttonId: "pngToJpgBtn", fileInputId: "pngToJpgFile", endpoint: ENDPOINTS.PNG_TO_JPG, tool: "png-to-jpg", filename: "pdfrealm-png-to-jpg.jpg" });

  // SVG / DOCX preview conversions (stubbed)
  wireConversionButton({ buttonId: "svgToPdfBtn", fileInputId: "svgToPdfFile", endpoint: ENDPOINTS.SVG_TO_PDF, tool: "svg-to-pdf", filename: "pdfrealm-svg.pdf", previewFrameId: "svg2pdfPreviewFrame", placeholderId: "svg2pdfPreviewPlaceholder" });
  wireConversionButton({ buttonId: "docxToPngBtn", fileInputId: "docxToPngFile", endpoint: ENDPOINTS.DOCX_TO_PNG, tool: "docx-to-png", filename: "pdfrealm-docx-preview.zip" });



  // ---- JPG → PNG (split preview: input left, output right) ----
  function initJpgToPngSplit() {
    const fileInput = $("jpgToPngFile");
    const convertBtn = $("jpgToPngPreviewBtn");
    const exportBtn = $("jpgToPngExportBtn");
    const statusEl = $("jpg2pngStatus");
    const inputHost = $("jpg2pngInputPreviewHost");
    const outputHost = $("jpg2pngOutputPreviewHost");
    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastBlob = null;

    function setStatus(msg){ if (statusEl) statusEl.textContent = msg || ""; }

    function resetOutput(){
      lastBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("jpg2pngOutputPlaceholder", true);
    }
    function resetInput(){
      if (inputUrl) { try { URL.revokeObjectURL(inputUrl); } catch {} }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("jpg2pngInputPlaceholder", true);
    }

    fileInput.addEventListener("change", () => {
      resetOutput(); resetInput();
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      inputUrl = URL.createObjectURL(f);
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "JPG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);
      showPlaceholder("jpg2pngInputPlaceholder", false);
      setStatus("");
    });

    async function convertPreview(){
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a JPG first.");
      convertBtn.disabled = true;
      resetOutput();
      setStatus("Converting to PNG...");
      try{
        const bitmap = await createImageBitmap(f);
        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(bitmap, 0, 0);
        const blob = await new Promise((resolve)=>canvas.toBlob(resolve, "image/png", 1.0));
        if (!blob) throw new Error("Failed to encode PNG.");
        lastBlob = blob;

        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        img.alt = "PNG output preview";
        img.draggable = false;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.borderRadius = "12px";
        img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        img.style.background = "white";
        outputHost.innerHTML = "";
        outputHost.appendChild(img);
        showPlaceholder("jpg2pngOutputPlaceholder", false);

        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch(e){
        console.error(e);
        alert(String(e?.message || e || "Conversion failed."));
        setStatus("");
      } finally{
        convertBtn.disabled = false;
      }
    }

    function exportPng(){
      if (!lastBlob) return alert("Convert (preview) first.");
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-jpg");
      downloadBlob(lastBlob, `${base}.png`);
    }

    convertBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportPng);
  }

  // ---- PNG → JPG (split preview: input left, output right) ----
  function initPngToJpgSplit() {
    const fileInput = $("pngToJpgFile");
    const convertBtn = $("pngToJpgPreviewBtn");
    const exportBtn = $("pngToJpgExportBtn");
    const statusEl = $("png2jpgStatus");
    const inputHost = $("png2jpgInputPreviewHost");
    const outputHost = $("png2jpgOutputPreviewHost");
    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastBlob = null;

    function setStatus(msg){ if (statusEl) statusEl.textContent = msg || ""; }

    function resetOutput(){
      lastBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("png2jpgOutputPlaceholder", true);
    }
    function resetInput(){
      if (inputUrl) { try { URL.revokeObjectURL(inputUrl); } catch {} }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("png2jpgInputPlaceholder", true);
    }

    fileInput.addEventListener("change", () => {
      resetOutput(); resetInput();
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      inputUrl = URL.createObjectURL(f);
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "PNG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);
      showPlaceholder("png2jpgInputPlaceholder", false);
      setStatus("");
    });

    async function convertPreview(){
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a PNG first.");
      convertBtn.disabled = true;
      resetOutput();
      setStatus("Converting to JPG...");
      try{
        const bitmap = await createImageBitmap(f);
        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext("2d");
        // Fill white background (PNG may have alpha)
        ctx.fillStyle = "white";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(bitmap, 0, 0);
        const blob = await new Promise((resolve)=>canvas.toBlob(resolve, "image/jpeg", 0.95));
        if (!blob) throw new Error("Failed to encode JPG.");
        lastBlob = blob;

        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        img.alt = "JPG output preview";
        img.draggable = false;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.borderRadius = "12px";
        img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        img.style.background = "white";
        outputHost.innerHTML = "";
        outputHost.appendChild(img);
        showPlaceholder("png2jpgOutputPlaceholder", false);

        exportBtn.disabled = false;
        setStatus("Preview ready.");
      } catch(e){
        console.error(e);
        alert(String(e?.message || e || "Conversion failed."));
        setStatus("");
      } finally{
        convertBtn.disabled = false;
      }
    }

    function exportJpg(){
      if (!lastBlob) return alert("Convert (preview) first.");
      const f = fileInput.files && fileInput.files[0];
      const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-png");
      downloadBlob(lastBlob, `${base}.jpg`);
    }

    convertBtn.addEventListener("click", convertPreview);
    exportBtn.addEventListener("click", exportJpg);
  }

  // ---- DOCX → PNG (split preview: input left, output right; export ZIP) ----
  function initDocxToPngSplit() {
  // DOCX -> PNG tool should NOT use PDF encryption detection (DOCX is a ZIP and false-positives happen).
  const getById = (id) => (typeof $ === "function" ? $(id) : document.getElementById(id));

  // Prefer id-based lookup; fallback to "docx+png" file input pattern
  const fileInput =
    getById("docxToPngFile") ||
    getById("docx2pngFile") ||
    getById("docxPngFile") ||
    document.querySelector('input[type="file"][id*="docx" i][id*="png" i]') ||
    document.querySelector('input[type="file"][id*="docx2png" i]');

  if (!fileInput) return;

  const root =
    fileInput.closest(".tool-card") ||
    fileInput.closest(".tool") ||
    fileInput.closest("section") ||
    document;

  const q = (sel) => root.querySelector(sel);
  const qa = (sel) => Array.from(root.querySelectorAll(sel));

  const pwInput =
    getById("docxToPngPassword") ||
    getById("docx2pngPassword") ||
    getById("docxPngPassword") ||
    q('input[type="password"][id*="docx" i][id*="png" i]') ||
    q('input[type="password"]');

  const btnByText = (txt) => {
    const t = txt.toLowerCase();
    return qa("button").find(b => (b.textContent || "").trim().toLowerCase() === t)
        || qa("button").find(b => (b.textContent || "").trim().toLowerCase().includes(t));
  };

  const previewInputBtn =
    getById("docxToPngInputPreviewBtn") ||
    getById("docx2pngInputPreviewBtn") ||
    getById("docxToPngPreviewInputBtn") ||
    btnByText("preview input");

  const convertBtn =
    getById("docxToPngPreviewBtn") ||
    getById("docx2pngPreviewBtn") ||
    getById("docxToPngConvertBtn") ||
    btnByText("convert (preview)") ||
    btnByText("convert");

  const exportBtn =
    getById("docxToPngExportBtn") ||
    getById("docx2pngExportBtn") ||
    btnByText("export") ||
    btnByText("download");

  const statusEl =
    getById("docx2pngStatus") ||
    getById("docxToPngStatus") ||
    q('[id*="Status"]') ||
    null;

  const inputHost =
    getById("docx2pngInputPreviewHost") ||
    getById("docxToPngInputPreviewHost") ||
    q('[id*="InputPreviewHost"]') ||
    null;

  const outputHost =
    getById("docx2pngOutputPreviewHost") ||
    getById("docxToPngOutputPreviewHost") ||
    q('[id*="OutputPreviewHost"]') ||
    null;

  const inputPlaceholder =
    getById("docx2pngInputPlaceholder") ||
    getById("docxToPngInputPlaceholder") ||
    q('[id*="InputPlaceholder"]') ||
    null;

  const outputPlaceholder =
    getById("docx2pngOutputPlaceholder") ||
    getById("docxToPngOutputPlaceholder") ||
    q('[id*="OutputPlaceholder"]') ||
    null;

  function setStatus(t) { if (statusEl) statusEl.textContent = t || ""; }
  function showPh(el, show) { if (!el) return; el.style.display = show ? "" : "none"; }

  // If your placeholder contains the wrong PDF-encrypted message, replace it.
  if (inputPlaceholder && /pdf file is encrypted/i.test(inputPlaceholder.textContent || "")) {
    inputPlaceholder.textContent = "Upload a DOCX to preview it here. If it is password-protected, enter the password then Preview input.";
  }

  let lastZipBlob = null;
  let previewUrls = [];

  function cleanupUrls() {
    for (const u of previewUrls) { try { URL.revokeObjectURL(u); } catch {} }
    previewUrls = [];
  }

  function resetViews() {
    cleanupUrls();
    lastZipBlob = null;
    if (inputHost) inputHost.innerHTML = "";
    if (outputHost) outputHost.innerHTML = "";
    showPh(inputPlaceholder, true);
    showPh(outputPlaceholder, true);
    if (exportBtn) exportBtn.disabled = true;
  }

  function downloadBlobFallback(blob, name) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = name || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  async function ensureJSZip() {
    if (window.JSZip) return window.JSZip;
    try {
      const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
      return mod?.default || mod;
    } catch {
      await import("https://unpkg.com/jszip@3.10.1/dist/jszip.min.js");
      return window.JSZip;
    }
  }

  async function renderInputPreview(file) {
    if (!inputHost) return;
    inputHost.innerHTML = "";
    showPh(inputPlaceholder, false);
    setStatus("Rendering input preview...");

    const fd = new FormData();
    fd.append("file", file);

    // Use global callJson shim if available
    const call = (typeof callJson === "function") ? callJson : (typeof globalThis.callJson === "function" ? globalThis.callJson : null);
    if (!call) {
      inputHost.innerHTML = '<div class="muted">Input preview helper missing.</div>';
      setStatus("");
      return;
    }

    try {
      const r = await call("/api/word-to-pdf/input-preview", fd);
      const html = (r && r.html) ? String(r.html) : "";
      inputHost.innerHTML = html || '<div class="muted">No preview available.</div>';
    } catch (e) {
      inputHost.innerHTML = '<div class="muted">Input preview unavailable on this server.</div>';
    } finally {
      setStatus("");
    }
  }

  async function convertDocxToPngZip(file, password) {
    const fd = new FormData();
    fd.append("file", file);
    if (password) fd.append("password", password);

    const call = (typeof callBlob === "function") ? callBlob : (typeof globalThis.callBlob === "function" ? globalThis.callBlob : null);
    if (!call) throw new Error("callBlob missing");

    const endpoints = [
      "/api/docx-to-png/preview",
      "/api/docx-to-png",
      "/api/docx2png/preview",
      "/api/docx2png",
      "/api/docx-to-png/convert",
      "/api/docx2png/convert",
      "/api/word-to-png",
      "/api/word2png"
    ];

    let lastErr = null;
    for (const ep of endpoints) {
      try {
        const blob = await call(ep, fd);
        if (blob && blob.size > 0) return blob;
      } catch (e) {
        lastErr = e;
        // Keep trying if it's a 404/405
        const msg = String(e?.message || e || "");
        if (!/HTTPs+(404|405)/.test(msg)) break;
      }
    }
    throw lastErr || new Error("No DOCX→PNG endpoint available on server.");
  }

  async function previewZip(zipBlob) {
    if (!outputHost) return;
    outputHost.innerHTML = "";
    showPh(outputPlaceholder, false);

    const JSZip = await ensureJSZip();
    const zip = await JSZip.loadAsync(zipBlob);

    const names = Object.keys(zip.files)
      .filter(n => !zip.files[n].dir)
      .filter(n => /.(png|jpg|jpeg)$/i.test(n))
      .sort();

    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    outputHost.appendChild(wrap);

    const max = Math.min(names.length, 6);
    for (let i = 0; i < max; i++) {
      const name = names[i];
      const blob = await zip.file(name).async("blob");
      const url = URL.createObjectURL(blob);
      previewUrls.push(url);

      const img = document.createElement("img");
      img.src = url;
      img.alt = name;
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      wrap.appendChild(img);
    }
  }

  // Wire events
  fileInput.addEventListener("change", async () => {
    resetViews();
    const f = fileInput.files && fileInput.files[0];
    if (!f) return;
    if (previewInputBtn) previewInputBtn.disabled = false;
    if (convertBtn) convertBtn.disabled = false;

    // Auto-run input preview for better UX
    await renderInputPreview(f);
  });

  if (previewInputBtn) {
    previewInputBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a DOCX first.");
      await renderInputPreview(f);
    });
  }

  if (convertBtn) {
    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a DOCX first.");
      const pw = (pwInput && String(pwInput.value || "").trim()) || "";

      convertBtn.disabled = true;
      if (exportBtn) exportBtn.disabled = true;

      try {
        setStatus("Converting (preview)...");
        const zipBlob = await convertDocxToPngZip(f, pw);
        lastZipBlob = zipBlob;
        await previewZip(zipBlob);
        if (exportBtn) exportBtn.disabled = false;
        setStatus("Ready.");
      } catch (e) {
        console.error(e);
        alert(String(e?.message || e || "DOCX→PNG failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });
  }

  if (exportBtn) {
    exportBtn.addEventListener("click", () => {
      if (!lastZipBlob) return alert("Convert (preview) first.");
      if (typeof downloadBlob === "function") downloadBlob(lastZipBlob, "pdfrealm-docx-to-png.zip");
      else downloadBlobFallback(lastZipBlob, "pdfrealm-docx-to-png.zip");
    });
  }

  // Initial state
  if (exportBtn) exportBtn.disabled = true;
  showPh(inputPlaceholder, true);
  showPh(outputPlaceholder, true);
}


  // Kick off split conversions for these tools
  initJpgToPngSplit();
  initPngToJpgSplit();
  initDocxToPngSplit();

}


// -------------------- Rotate (interactive preview) --------------------

function initRotateInteractive() {
  const fileInput = $("rotatePdfFile");
  const passInput = $("rotatePdfPassword");
  const unlockBtn = $("rotateUnlockBtn");
  const pagesInput = $("rotatePagesRange");
  const rotLabel = $("rotateRotationLabel");
  const rotateLeftBtn = $("rotateLeftBtn");
  const rotateRightBtn = $("rotateRightBtn");
  const rotateResetBtn = $("rotateResetBtn");
  const exportBtn = $("rotatePdfBtn");
  const ph = $("rotatePreviewPlaceholder");
  const stage = $("rotatePreviewStage");
  const inner = $("rotatePreviewInner");
  const img = $("rotatePreviewImg");
  const prevBtn = $("rotatePrevPageBtn");
  const nextBtn = $("rotateNextPageBtn");
  const pageInput = $("rotatePreviewPage");
  const pageCountEl = $("rotatePageCount");
  const zoomInput = $("rotateZoom");
  const zoomLabel = $("rotateZoomLabel");

  if (!fileInput || !exportBtn || !ph || !stage || !inner || !img) return;

  let currentFile = null;
  let isEncrypted = false;
  let password = "";
  let currentPage = 1;
  let pageCount = null;

  // Rotation is strictly 0/90/180/270.
  let rotationDeg = 90;

  // Zoom slider
  let zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
  const previewCache = new Map(); // key: page -> objectURL
  if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

  function clamp(n, a, b) {
    return Math.max(a, Math.min(b, n));
  }

  function normDeg(n) {
    let d = parseInt(n, 10);
    if (Number.isNaN(d)) d = 0;
    d = ((d % 360) + 360) % 360;
    return d;
  }

  function snap90(n) {
    const d = normDeg(n);
    // Ensure it's exactly one of 0,90,180,270
    return (Math.round(d / 90) % 4) * 90;
  }

  function showPlaceholder(msg) {
    ph.textContent = msg;
    ph.style.display = "";
    stage.style.display = "none";
  }

  function showStage() {
    ph.style.display = "none";
    stage.style.display = "block";
  }

  function clearCache() {
    for (const url of previewCache.values()) {
      try {
        URL.revokeObjectURL(url);
      } catch {}
    }
    previewCache.clear();
  }

  async function isProbablyEncryptedPdf(file) {
    try {
      const headSlice = file.slice(0, Math.min(65536, file.size));
      const tailSlice = file.slice(Math.max(0, file.size - 65536), file.size);
      const [headBuf, tailBuf] = await Promise.all([headSlice.arrayBuffer(), tailSlice.arrayBuffer()]);
      const dec = new TextDecoder("latin1");
      const head = dec.decode(new Uint8Array(headBuf));
      const tail = dec.decode(new Uint8Array(tailBuf));
      return /\/Encrypt\b/i.test(head) || /\/Encrypt\b/i.test(tail);
    } catch {
      return false;
    }
  }

  function computeFitScale(deg) {
    // Fit the *rotated* bounding box into the viewer wrapper.
    const wrapper = stage.parentElement;
    if (!wrapper) return 1;

    const availW = Math.max(100, wrapper.clientWidth - 24);
    const availH = Math.max(100, wrapper.clientHeight - 24);

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return 1;

    const d = snap90(deg);
    const swapped = d === 90 || d === 270;
    const rw = swapped ? h : w;
    const rh = swapped ? w : h;

    const scale = Math.min(availW / rw, availH / rh, 1.25);
    if (!Number.isFinite(scale) || scale <= 0) return 1;
    return scale;
  }

  function applyRotationAndZoom() {
    rotationDeg = snap90(rotationDeg);
    if (rotLabel) rotLabel.textContent = `${rotationDeg}°`;

    zoomPct = clamp(parseInt(zoomPct, 10) || 100, 50, 200);
    if (zoomInput) zoomInput.value = String(zoomPct);
    if (zoomLabel) zoomLabel.textContent = `${zoomPct}%`;

    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return;

    const swapped = rotationDeg === 90 || rotationDeg === 270;
    const rw = swapped ? h : w;
    const rh = swapped ? w : h;

    const fit = computeFitScale(rotationDeg);
    const scale = fit * (zoomPct / 100);

    // IMPORTANT: transforms do not affect layout, so we size the inner container
    // to the rotated/scaled bounding box. This prevents "cut off" areas when rotated.
    inner.style.width = `${Math.max(1, Math.round(rw * scale))}px`;
    inner.style.height = `${Math.max(1, Math.round(rh * scale))}px`;

    img.style.transform = `translate(-50%, -50%) rotate(${rotationDeg}deg) scale(${scale})`;
  }

  async function loadPreview(page) {
    if (!currentFile) return;
    const p = clamp(page, 1, pageCount || 999999);
    currentPage = p;
    if (pageInput) pageInput.value = String(currentPage);

    if (previewCache.has(currentPage)) {
      img.src = previewCache.get(currentPage);
      showStage();
      return;
    }

    showPlaceholder("Rendering preview…");
    try {
      const fd = new FormData();
      fd.append("file", currentFile);
      fd.append("page", String(currentPage));
      fd.append("dpi", "200");
      if (password) fd.append("password", password);

      const res = await fetch("/api/render/page", { method: "POST", body: fd });
      if (!res.ok) {
        const data = await res.json().catch(() => null);
        const msg = (data?.error || `Preview failed (${res.status})`).toString();
        if (/password|encrypt/i.test(msg)) {
          isEncrypted = true;
          showPlaceholder('Encrypted PDF — enter the password and click Decrypt / Unlock.');
          return;
        }
        throw new Error(msg);
      }

      const pc = res.headers.get("x-pdf-page-count") || res.headers.get("X-PDF-Page-Count");
      const maybeCount = pc ? parseInt(pc, 10) : NaN;
      if (Number.isFinite(maybeCount) && maybeCount > 0) {
        pageCount = maybeCount;
        if (pageCountEl) pageCountEl.textContent = String(pageCount);
      }

      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      previewCache.set(currentPage, url);
      img.src = url;
      showStage();
    } catch (e) {
      console.error(e);
      showPlaceholder(e?.message || "Preview not available");
    }
  }

  img.addEventListener("load", () => {
    // Ensure the inner container fits the rotated/scaled bounds after the image dimensions are known.
    applyRotationAndZoom();
  });

  function resetStateForFile(file) {
    currentFile = file;
    password = "";
    if (passInput) passInput.value = "";
    isEncrypted = false;
    currentPage = 1;
    pageCount = null;
    if (pageCountEl) pageCountEl.textContent = "?";
    if (pageInput) pageInput.value = "1";
    clearCache();
    // Reset rotation/zoom to sane defaults
    rotationDeg = 90;
    zoomPct = zoomInput ? (parseInt(zoomInput.value || "110", 10) || 110) : 110;
    if (rotLabel) rotLabel.textContent = `${rotationDeg}°`;
  }

  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      resetStateForFile(null);
      showPlaceholder("Upload a PDF to preview. If it's encrypted, enter the password then click Decrypt / Unlock.");
      return;
    }

    resetStateForFile(f);
    showPlaceholder("Analyzing PDF…");
    isEncrypted = await detectEncryptedPdfReliable(f);
    if (isEncrypted) {
      showPlaceholder("Encrypted PDF — enter the password and click Decrypt / Unlock.");
      return;
    }

    await loadPreview(1);
  });

  unlockBtn?.addEventListener("click", async () => {
    if (!currentFile) return alert("Upload a PDF first.");
    const pw = String(passInput?.value || "");
    if (!pw) return alert("Enter the PDF password.");
    password = pw;
    await loadPreview(currentPage || 1);
  });

  rotateLeftBtn?.addEventListener("click", () => {
    rotationDeg = snap90(rotationDeg - 90);
    applyRotationAndZoom();
  });

  rotateRightBtn?.addEventListener("click", () => {
    rotationDeg = snap90(rotationDeg + 90);
    applyRotationAndZoom();
  });

  rotateResetBtn?.addEventListener("click", () => {
    rotationDeg = 0;
    applyRotationAndZoom();
  });

  zoomInput?.addEventListener("input", () => {
    zoomPct = clamp(parseInt(zoomInput.value || "100", 10) || 100, 50, 200);
    applyRotationAndZoom();
  });

  prevBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) - 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  nextBtn?.addEventListener("click", () => {
    const nextPage = clamp((currentPage || 1) + 1, 1, pageCount || 999999);
    loadPreview(nextPage);
  });

  pageInput?.addEventListener("change", () => {
    const p = parseInt(pageInput.value || "1", 10) || 1;
    loadPreview(p);
  });

  exportBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    let pw = password;
    const encrypted = isEncrypted || (await detectEncryptedPdfReliable(f));

    if (encrypted && !pw) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    fd.append("file", f);

    // Only 90-degree increments, always.
    fd.append("degrees", String(snap90(rotationDeg)));

    const pagesSpec = String(pagesInput?.value || "").trim();
    if (pagesSpec) fd.append("pages", pagesSpec);

    if (encrypted && pw) {
      fd.append("password", pw);
      // Default: keep output encrypted with same password
      fd.append("outputPassword", pw);
    }

    await runPaidPdfExport({
      tool: "rotate",
      endpoint: ENDPOINTS.ROTATE,
      formData: fd,
      filename: "pdfrealm-rotated.pdf",
    });
  });

  // Initial state
  if (rotLabel) rotLabel.textContent = `${rotationDeg}°`;
  showPlaceholder("Upload a PDF to preview. If it's encrypted, enter the password then click Decrypt / Unlock.");
}



// -------------------- Secure single-file tools (unlock to preview/export) --------------------
function initSinglePdfToolWithUnlock({
  fileInputId,
  passwordInputId,
  unlockBtnId,
  actionBtnId,
  tool,
  endpoint,
  filename,
  previewFrameId,
  placeholderId,
  extraFields = () => ({}),
  previewBtnId = null,
  previewTool = null,
  previewEndpoint = null,
  previewHintId = null,
  exportBtnId = null,
  exportHintId = null,
  validate = null,
}) {
  const fileInput = $(fileInputId);
  const passInput = $(passwordInputId);
  const unlockBtn = $(unlockBtnId);
  const actionBtn = $(actionBtnId);

  const previewBtn = previewBtnId ? $(previewBtnId) : null;
  const previewHint = previewHintId ? $(previewHintId) : null;

  const exportBtn = exportBtnId ? $(exportBtnId) : null;
  const exportHint = exportHintId ? $(exportHintId) : null;

  if (!fileInput || !actionBtn) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmptyPreview(msg) {
    revokePreviewUrl();
    resetPrepared();
    setIframeSrc(previewFrameId, "");
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    // Hide native PDF toolbar/tools by clipping (same approach as other tabs)
    try {
      const fr = $(previewFrameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmptyPreview("Upload a PDF to preview it here.");
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(previewFrameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmptyPreview("Upload a PDF to preview it here.");

    // Block iframe load until we know encryption status (prevents browser password popups)
    setIframeSrc(previewFrameId, "");
    const ph = $(placeholderId);
    if (ph) ph.textContent = "Checking PDF…";
    showPlaceholder(placeholderId, true);

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    if (ph) ph.textContent = "Upload a PDF to preview it here.";
    setPreviewFile(f);
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting…';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      resetPrepared();
      if (previewHint) {
        try { previewHint.style.display = 'none'; } catch {}
      }
      const ph = $(placeholderId);
      if (ph) ph.textContent = "Upload a PDF to preview it here.";
      setPreviewFile(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });


  // Preview (no download) — used by tools like Watermark / Page Numbers
  previewBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('preview');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);
    const fields = extraFields() || {};
    for (const [k, v] of Object.entries(fields)) {
      if (v == null) continue;
      fd.append(k, String(v));
    }

    if (previewHint) {
      try { previewHint.style.display = 'none'; } catch {}
    }

    const btn = previewBtn;
    if (btn) {
      btn.disabled = true;
      btn.dataset._label = btn.dataset._label || btn.textContent;
      btn.textContent = 'Updating…';
    }

    try {
      const r = await runPaidPdfExport({
        tool: previewTool || tool,
        endpoint: previewEndpoint || endpoint,
        formData: fd,
        filename: null,
        setPreviewFrameId: previewFrameId,
        placeholderId,
      });

      if (r?.ok && previewHint) {
        try { previewHint.style.display = 'block'; } catch {}
      }
    } finally {
      if (btn) {
        btn.disabled = false;
        btn.textContent = btn.dataset._label || 'Preview';
      }
    }
  });

  actionBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');

    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    if (typeof validate === 'function') {
      const ok = validate('action');
      if (ok === false) return;
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);
    const fields = extraFields() || {};
    for (const [k, v] of Object.entries(fields)) {
      if (v == null) continue;
      fd.append(k, String(v));
    }

    await runPaidPdfExport({
      tool,
      endpoint,
      formData: fd,
      filename,
      setPreviewFrameId: previewFrameId,
      placeholderId,
    });
  });

  // Initial state
  setEmptyPreview('Upload a PDF to preview it here.');
}

function initCompressSecure() {
  const normalizeBtn = $('compressNormalizeBtn');

  initSinglePdfToolWithUnlock({
    fileInputId: 'compressPdfFile',
    passwordInputId: 'compressPdfPassword',
    unlockBtnId: 'compressUnlockBtn',
    actionBtnId: 'compressPdfBtn',
    tool: 'compress',
    endpoint: ENDPOINTS.COMPRESS,
    filename: 'pdfrealm-compressed.pdf',
    previewFrameId: 'compressPreviewFrame',
    placeholderId: 'compressPreviewPlaceholder',  });

  // Optional: “Decompress / Normalize” for editing/compatibility (not a quality restore)
  if (normalizeBtn) {
    normalizeBtn.addEventListener('click', async () => {
      const inp = $('compressPdfFile');
      const f = inp?.files?.[0];
      if (!f) return alert('Upload a PDF first.');

      // Use decrypted file if the user unlocked; easiest is to read from the preview iframe URL? No.
      // Instead, if encrypted, require unlock first (same pattern as other tools).
      const encrypted = await detectEncryptedPdfReliable(f);
      const pw = String($('compressPdfPassword')?.value || '').trim();
      let work = f
      if (encrypted) {
        if (!pw) return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
        // Decrypt on the fly for normalize
        work = await decryptPdfToFile(f, pw);
      }

      const fd = new FormData();
      fd.append('file', work);

      await runPaidPdfExport({
        tool: 'normalize',
        endpoint: ENDPOINTS.QPDF_NORMALIZE,
        formData: fd,
        filename: 'pdfrealm-normalized.pdf',
        setPreviewFrameId: 'compressPreviewFrame',
        placeholderId: 'compressPreviewPlaceholder',
      });
    });
  }
}

function initWatermarkSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'watermarkPdfFile',
    previewBtnId: 'watermarkPreviewBtn',
    passwordInputId: 'watermarkPdfPassword',
    unlockBtnId: 'watermarkUnlockBtn',
    actionBtnId: 'watermarkPdfBtn',
    tool: 'watermark',
    endpoint: ENDPOINTS.WATERMARK,
    filename: 'pdfrealm-watermarked.pdf',
    previewFrameId: 'watermarkPreviewFrame',
    placeholderId: 'watermarkPreviewPlaceholder',
    extraFields: () => ({ text: String($('watermarkText')?.value || '').trim() || 'CONFIDENTIAL' }),
  });
}

function initPageNumsSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'pageNumsPdfFile',
    previewBtnId: 'pageNumsPreviewBtn',
    previewHintId: 'pageNumsPreviewHint',
    passwordInputId: 'pageNumsPdfPassword',
    unlockBtnId: 'pageNumsUnlockBtn',
    actionBtnId: 'pageNumsBtn',
    tool: 'page-numbers',
    endpoint: ENDPOINTS.PAGE_NUMBERS,
    filename: 'pdfrealm-page-numbers.pdf',
    previewFrameId: 'pageNumsPreviewFrame',
    placeholderId: 'pageNumsPreviewPlaceholder',
    extraFields: () => ({
      start: String(parseInt(String($('pageNumsStart')?.value || '1'), 10) || 1),
      prefix: String($('pageNumsPrefix')?.value || ''),
      pos: String($('pageNumsPos')?.value || 'br'),
      size: String($('pageNumsSize')?.value || '10'),
      margin: String($('pageNumsMargin')?.value || '30'),
    }),
  });
}


function initMetadataSecure() {
  const fileInput = $('metaPdfFile');
  const passInput = $('metaPdfPassword');
  const unlockBtn = $('metaUnlockBtn');
  const removeBtn = $('metaRemoveBtn');
  const applyBtn = $('metaApplyBtn');
  const exportBtn = $('metaExportBtn');
  const exportHint = $('metaExportHint');
  const previewFrameId = 'metaPreviewFrame';
  const placeholderId = 'metaPreviewPlaceholder';

  if (!fileInput || !removeBtn || !applyBtn || !exportBtn) return;

  let unlocked = null;
  let enc = false;
  let previewUrl = null;
  let processedUrl = null;
  let lastBlob = null;
  let lastFilename = null;
  let lastKind = null;

  function resetPrepared() {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    try { if (processedUrl) URL.revokeObjectURL(processedUrl); } catch {}
    processedUrl = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = 'Click a Preview button, then Export to download.';
  }

  function markStale(msg) {
    lastBlob = null;
    lastFilename = null;
    lastKind = null;
    if (exportBtn) exportBtn.disabled = true;
    if (exportHint) exportHint.textContent = msg || 'Changes updated. Click a Preview button again, then Export.';
  }

  function revokePreviewUrl() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
  }

  function setEmptyPreview(msg) {
    revokePreviewUrl();
    resetPrepared();
    setIframeSrc(previewFrameId, '');
    const ph = $(placeholderId);
    if (ph && msg) ph.textContent = msg;
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    // Hide native PDF toolbar/tools by clipping (same approach as other tabs)
    try {
      const fr = $(previewFrameId);
      if (fr) {
        fr.style.position = 'relative';
        fr.style.top = '-64px';
        fr.style.height = 'calc(100% + 64px)';
      }
    } catch {}

    revokePreviewUrl();
    if (!file) return setEmptyPreview('Upload a PDF to preview it here.');
    previewUrl = URL.createObjectURL(file);
    setIframeSrc(previewFrameId, previewUrl);
    showPlaceholder(placeholderId, false);
  }

  async function onFileChange() {
    unlocked = null;
    resetPrepared();
    const f = fileInput.files && fileInput.files[0];
    if (!f) return setEmptyPreview('Upload a PDF to preview it here.');

    // Block iframe load until we know encryption status (prevents browser password popups)
    setIframeSrc(previewFrameId, '');
    const ph = $(placeholderId);
    if (ph) ph.textContent = 'Checking PDF…';
    showPlaceholder(placeholderId, true);

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      if (ph) ph.textContent = 'Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" to preview.';
      showPlaceholder(placeholderId, true);
      return;
    }

    if (ph) ph.textContent = 'Upload a PDF to preview it here.';
    setPreviewFile(f);
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    if (unlockBtn) {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting…';
    }

    try {
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      resetPrepared();
      const ph = $(placeholderId);
      if (ph) ph.textContent = 'Upload a PDF to preview it here.';
      setPreviewFile(unlocked);
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      if (unlockBtn) {
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Decrypt / Unlock';
      }
    }
  });

  async function runMeta(kind) {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    if (enc && !unlocked) {
      return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
    }

    const fd = new FormData();
    fd.append('file', unlocked || f);

    const isApply = kind === 'apply';
    if (isApply) {
      fd.append('title', String($('metaTitle')?.value || ''));
      fd.append('author', String($('metaAuthor')?.value || ''));
      fd.append('subject', String($('metaSubject')?.value || ''));
      fd.append('keywords', String($('metaKeywords')?.value || ''));
    }

    const btn = isApply ? applyBtn : removeBtn;
    const originalLabel = btn?.textContent || (isApply ? 'Apply Metadata' : 'Remove Metadata');

    if (btn) {
      btn.disabled = true;
      btn.dataset._label = btn.dataset._label || originalLabel;
      btn.textContent = 'Working…';
    }

    try {      const out = await runPaidPdfExport({
        tool: isApply ? 'meta-apply' : 'meta-remove',
        endpoint: isApply ? ENDPOINTS.META_APPLY : ENDPOINTS.META_REMOVE,
        formData: fd,
        filename: null, // preview only; Export button controls downloads
        setPreviewFrameId: previewFrameId,
        placeholderId: placeholderId,
      });
      if (out?.ok) {
        try { if (processedUrl && processedUrl !== out.objectUrl) URL.revokeObjectURL(processedUrl); } catch {}
        processedUrl = out.objectUrl;
        lastBlob = out.blob;
        lastKind = kind;
        lastFilename = isApply ? 'pdfrealm-metadata-applied.pdf' : 'pdfrealm-metadata-sanitized.pdf';
        if (exportBtn) exportBtn.disabled = false;
        if (exportHint) exportHint.textContent = 'Preview ready. Click Export to download.';
      }

    } finally {
      if (btn) {
        btn.disabled = false;
        btn.textContent = btn.dataset._label || originalLabel;
      }
    }
  }

  removeBtn.addEventListener('click', () => runMeta('remove'));
  applyBtn.addEventListener('click', () => runMeta('apply'));

  // Export downloads only (Remove/Apply are preview-only)
  if (exportBtn) exportBtn.disabled = true;
  exportBtn.addEventListener('click', () => {
    if (!lastBlob || !lastFilename) {
      return alert('Click a Preview button first (Remove or Apply), then click Export to download.');
    }
    downloadBlob(lastBlob, lastFilename);
  });

  // If user edits metadata fields after previewing, require re-preview before exporting
  ['metaTitle','metaAuthor','metaSubject','metaKeywords'].forEach((id) => {
    const el = $(id);
    if (!el) return;
    el.addEventListener('input', () => {
      if (lastKind === 'apply') markStale('Fields changed. Click Preview Apply Metadata again, then Export.');
    });
  });

  setEmptyPreview('Upload a PDF to preview it here.');
}


// -------------------- NEXT 5 TOOLS (Repair / Compare / Blanks / Extract Text / Resize) --------------------

function __pdfrealmGetPdfJsCached() {
  if (globalThis.__pdfrealmPdfJs) return globalThis.__pdfrealmPdfJs;
  globalThis.__pdfrealmPdfJs = (async () => {
    try {
      const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
      const lib = (mod && (mod.default || mod)) || null;
      if (lib && lib.GlobalWorkerOptions) {
        lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
      }
      return lib;
    } catch (e1) {
      try {
        const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
        const lib2 = (mod2 && (mod2.default || mod2)) || null;
        if (lib2 && lib2.GlobalWorkerOptions) {
          lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
        }
        return lib2;
      } catch (e2) {
        console.error("[pdfrealm] PDF.js failed to load:", e1, e2);
        return null;
      }
    }
  })();
  return globalThis.__pdfrealmPdfJs;
}

function initRepairSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'repairPdfFile',
    passwordInputId: 'repairPdfPassword',
    unlockBtnId: 'repairUnlockBtn',
    actionBtnId: 'repairPdfBtn',
    tool: 'repair',
    endpoint: ENDPOINTS.REPAIR,
    filename: 'pdfrealm-repaired.pdf',
    previewFrameId: 'repairPreviewFrame',
    placeholderId: 'repairPreviewPlaceholder',
  });
}

function initBlankSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'blankPdfFile',
    passwordInputId: 'blankPdfPassword',
    unlockBtnId: 'blankUnlockBtn',
    actionBtnId: 'blankPdfBtn',
    tool: 'remove-blank-pages',
    endpoint: ENDPOINTS.REMOVE_BLANK,
    filename: 'pdfrealm-no-blank-pages.pdf',
    previewFrameId: 'blankPreviewFrame',
    placeholderId: 'blankPreviewPlaceholder',
    extraFields: () => ({ threshold: String($('blankThreshold')?.value || '0.00005') }),
  });
}

function initResizeSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'resizePdfFile',
    passwordInputId: 'resizePdfPassword',
    unlockBtnId: 'resizeUnlockBtn',
    actionBtnId: 'resizePdfBtn',
    tool: 'resize-pages',
    endpoint: ENDPOINTS.RESIZE_PAGES,
    filename: 'pdfrealm-resized.pdf',
    previewFrameId: 'resizePreviewFrame',
    placeholderId: 'resizePreviewPlaceholder',
    extraFields: () => ({
      preset: String($('resizePreset')?.value || 'letter'),
      mode: String($('resizeMode')?.value || 'fit'),
      margin: String($('resizeMargin')?.value || '18'),
    }),
  });
}

function initExtractText() {
  const fileInput = $('textPdfFile');
  const passInput = $('textPdfPassword');
  const unlockBtn = $('textUnlockBtn');
  const extractBtn = $('textExtractBtn');
  const outPre = $('textOutput');
  const dlTxt = $('textDownloadTxtBtn');
  const dlJson = $('textDownloadJsonBtn');

  if (!fileInput || !extractBtn || !outPre) return;

  let unlocked = null;
  let enc = false;
  let lastText = '';
  let lastJson = null;

  function setOutput(t) { outPre.textContent = t || ''; }
  function setDownloads(enabled) {
    if (dlTxt) dlTxt.disabled = !enabled;
    if (dlJson) dlJson.disabled = !enabled;
  }

  async function onFileChange() {
    unlocked = null;
    lastText = '';
    lastJson = null;
    setDownloads(false);

    const f = fileInput.files && fileInput.files[0];
    if (!f) return setOutput('');

    enc = await detectEncryptedPdfReliable(f);
    if (enc) {
      setOutput('Encrypted PDF detected. Enter the password and click "Decrypt / Unlock" first.');
      return;
    }
    setOutput('Ready. Click "Extract".');
  }

  fileInput.addEventListener('change', onFileChange);

  unlockBtn?.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    const pw = String(passInput?.value || '').trim();
    if (!pw) return alert('Enter the PDF password.');

    try {
      unlockBtn.disabled = true;
      unlockBtn.textContent = 'Decrypting…';
      unlocked = await decryptPdfToFile(f, pw);
      enc = false;
      lastText = '';
      lastJson = null;
      setDownloads(false);
      setOutput('Decrypted. Click "Extract".');
    } catch (e) {
      alert(String(e?.message || e));
    } finally {
      unlockBtn.disabled = false;
      unlockBtn.textContent = 'Decrypt / Unlock';
    }
  });

  extractBtn.addEventListener('click', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert('Upload a PDF first.');
    if (enc && !unlocked) return alert('This PDF is encrypted. Decrypt / Unlock first.');

    const pdfjs = await __pdfrealmGetPdfJsCached();
    if (!pdfjs) return alert('PDF.js failed to load. Try again or check your network.');

    extractBtn.disabled = true;
    extractBtn.dataset._label = extractBtn.dataset._label || extractBtn.textContent;
    extractBtn.textContent = 'Extracting…';

    try {
      const buf = await (unlocked || f).arrayBuffer();
      const doc = await pdfjs.getDocument({ data: buf }).promise;

      const pages = doc.numPages;
      const perPage = [];
      let all = '';

      for (let i = 1; i <= pages; i++) {
        const page = await doc.getPage(i);
        const tc = await page.getTextContent();
        const text = (tc.items || []).map(it => (it && it.str) ? String(it.str) : '').join(' ');
        const cleaned = text.replace(/\s+/g, ' ').trim();
        perPage.push({ page: i, text: cleaned });
        all += "\n\n--- Page " + i + " ---\n" + cleaned;
      }

      lastText = all.trim();
      lastJson = { pages: perPage };
      setOutput(lastText || '(No text found)');
      setDownloads(true);
    } catch (e) {
      console.error("[pdfrealm] extract text error", e);
      alert(String(e?.message || e));
    } finally {
      extractBtn.disabled = false;
      extractBtn.textContent = extractBtn.dataset._label || 'Extract';
    }
  });

  dlTxt?.addEventListener('click', () => {
    if (!lastText) return;
    downloadBlob(new Blob([lastText], { type: 'text/plain;charset=utf-8' }), 'pdfrealm-extract.txt');
  });

  dlJson?.addEventListener('click', () => {
    if (!lastJson) return;
    downloadBlob(new Blob([JSON.stringify(lastJson, null, 2)], { type: 'application/json;charset=utf-8' }), 'pdfrealm-extract.json');
  });
}

function initCompare() {
  const fileA = $('compareFileA');
  const fileB = $('compareFileB');
  const passA = $('comparePasswordA');
  const passB = $('comparePasswordB');
  const unlockA = $('compareUnlockABtn');
  const unlockB = $('compareUnlockBBtn');
  const runBtn = $('compareRunBtn');
  const outPre = $('compareResult');
  const dlTxt = $('compareDownloadTxtBtn');
  const dlJson = $('compareDownloadJsonBtn');

  if (!fileA || !fileB || !runBtn || !outPre) return;

  let lastTxt = '';
  let lastJson = null;

  let encA = false;
  let encB = false;
  let unlockedA = null;
  let unlockedB = null;

  function setOutput(t){ outPre.textContent = t || ''; }
  function setDownloads(enabled){
    if (dlTxt) dlTxt.disabled = !enabled;
    if (dlJson) dlJson.disabled = !enabled;
  }
  setDownloads(false);

  async function refreshEncryptionStatus() {
    const a = fileA.files && fileA.files[0];
    const b = fileB.files && fileB.files[0];

    let msg = '';

    if (a) {
      encA = await detectEncryptedPdfReliable(a);
      if (encA) msg += 'PDF A appears encrypted. Enter the password and click "Decrypt / Unlock".\n';
    } else {
      encA = false;
      unlockedA = null;
    }

    if (b) {
      encB = await detectEncryptedPdfReliable(b);
      if (encB) msg += 'PDF B appears encrypted. Enter the password and click "Decrypt / Unlock".\n';
    } else {
      encB = false;
      unlockedB = null;
    }

    if (msg) setOutput(msg.trim());
    else if (a && b) setOutput('Ready. Click "Compare".');
    else setOutput('');
  }

  fileA.addEventListener('change', async () => {
    unlockedA = null;
    lastTxt = '';
    lastJson = null;
    setDownloads(false);
    await refreshEncryptionStatus();
  });

  fileB.addEventListener('change', async () => {
    unlockedB = null;
    lastTxt = '';
    lastJson = null;
    setDownloads(false);
    await refreshEncryptionStatus();
  });

  unlockA?.addEventListener('click', async () => {
    const f = fileA.files && fileA.files[0];
    if (!f) return alert('Upload PDF A first.');
    const pw = String(passA?.value || '').trim();
    if (!pw) return alert('Enter the password for PDF A.');

    try {
      unlockA.disabled = true;
      unlockA.textContent = 'Decrypting…';
      unlockedA = await decryptPdfToFile(f, pw);
      encA = false;
      lastTxt = '';
      lastJson = null;
      setDownloads(false);
      setOutput('PDF A decrypted. Upload PDF B (if needed), then click "Compare".');
    } catch (e) {
      console.error('[pdfrealm] compare unlock A error', e);
      alert(String(e?.message || e));
    } finally {
      unlockA.disabled = false;
      unlockA.textContent = 'Decrypt / Unlock';
    }
  });

  unlockB?.addEventListener('click', async () => {
    const f = fileB.files && fileB.files[0];
    if (!f) return alert('Upload PDF B first.');
    const pw = String(passB?.value || '').trim();
    if (!pw) return alert('Enter the password for PDF B.');

    try {
      unlockB.disabled = true;
      unlockB.textContent = 'Decrypting…';
      unlockedB = await decryptPdfToFile(f, pw);
      encB = false;
      lastTxt = '';
      lastJson = null;
      setDownloads(false);
      setOutput('PDF B decrypted. Upload PDF A (if needed), then click "Compare".');
    } catch (e) {
      console.error('[pdfrealm] compare unlock B error', e);
      alert(String(e?.message || e));
    } finally {
      unlockB.disabled = false;
      unlockB.textContent = 'Decrypt / Unlock';
    }
  });

  async function extractTexts(pdfjs, file) {
    const buf = await file.arrayBuffer();
    const doc = await pdfjs.getDocument({ data: buf }).promise;
    const pages = doc.numPages;
    const texts = [];
    for (let i = 1; i <= pages; i++) {
      const page = await doc.getPage(i);
      const tc = await page.getTextContent();
      const t = (tc.items || []).map(it => (it && it.str) ? String(it.str) : '').join(' ');
      texts.push(t.replace(/\s+/g, ' ').trim());
    }
    return { pages, texts };
  }

  runBtn.addEventListener('click', async () => {
    const a = fileA.files && fileA.files[0];
    const b = fileB.files && fileB.files[0];
    if (!a || !b) return alert('Upload both PDF A and PDF B.');

    if (encA && !unlockedA) return alert('PDF A is encrypted. Decrypt / Unlock it first.');
    if (encB && !unlockedB) return alert('PDF B is encrypted. Decrypt / Unlock it first.');

    const pdfjs = await __pdfrealmGetPdfJsCached();
    if (!pdfjs) return alert('PDF.js failed to load. Try again or check your network.');

    runBtn.disabled = true;
    runBtn.dataset._label = runBtn.dataset._label || runBtn.textContent;
    runBtn.textContent = 'Comparing…';
    setDownloads(false);
    setOutput('');

    try {
      const A = await extractTexts(pdfjs, unlockedA || a);
      const B = await extractTexts(pdfjs, unlockedB || b);

      const max = Math.max(A.pages, B.pages);
      const diffs = [];
      let sameCount = 0;

      for (let i = 0; i < max; i++) {
        const ta = A.texts[i] ?? '';
        const tb = B.texts[i] ?? '';
        const same = ta === tb;
        if (same) sameCount++;
        else {
          diffs.push({
            page: i + 1,
            aSnippet: ta.slice(0, 400),
            bSnippet: tb.slice(0, 400),
          });
        }
      }

      let summary = '';
      summary += 'Compared ' + A.pages + ' vs ' + B.pages + ' pages.\n';
      summary += 'Same pages: ' + sameCount + '/' + max + '\n';
      summary += 'Different pages: ' + diffs.length + '/' + max + '\n\n';

      if (!diffs.length) summary += 'No differences found.';
      else {
        summary += diffs.map(d => {
          return (
            '--- Page ' + d.page + ' ---\n' +
            'A: ' + (d.aSnippet || '(empty)') + '\n' +
            'B: ' + (d.bSnippet || '(empty)')
          );
        }).join('\n\n');
      }

      lastTxt = summary;
      lastJson = {
        aPages: A.pages,
        bPages: B.pages,
        samePages: sameCount,
        differentPages: diffs.length,
        diffs,
      };

      setOutput(summary);
      setDownloads(true);
    } catch (e) {
      console.error('[pdfrealm] compare error', e);
      alert(String(e?.message || e));
    } finally {
      runBtn.disabled = false;
      runBtn.textContent = runBtn.dataset._label || 'Compare';
    }
  });

  dlTxt?.addEventListener('click', () => {
    if (!lastTxt) return;
    downloadBlob(new Blob([lastTxt], { type: 'text/plain;charset=utf-8' }), 'pdfrealm-compare.txt');
  });

  dlJson?.addEventListener('click', () => {
    if (!lastJson) return;
    downloadBlob(new Blob([JSON.stringify(lastJson, null, 2)], { type: 'application/json;charset=utf-8' }), 'pdfrealm-compare.json');
  });

  // Initial status (if inputs are already pre-filled by the browser)
  refreshEncryptionStatus();
}
// --------------------------------------------------------------------------------


function initFlattenSecure() {
  initSinglePdfToolWithUnlock({
    fileInputId: 'flattenPdfFile',
    passwordInputId: 'flattenPdfPassword',
    unlockBtnId: 'flattenUnlockBtn',
    actionBtnId: 'flattenPdfBtn',
    tool: 'flatten',
    endpoint: ENDPOINTS.FLATTEN,
    filename: 'pdfrealm-flattened.pdf',
    previewFrameId: 'flattenPreviewFrame',
    placeholderId: 'flattenPreviewPlaceholder',
  });
}


// -------------------- Timestamp (Stamp) helpers --------------------
function _pad2(n) {
  return String(n).padStart(2, '0');
}

function _formatDatetimeLocal(d) {
  const yyyy = d.getFullYear();
  const mm = _pad2(d.getMonth() + 1);
  const dd = _pad2(d.getDate());
  const HH = _pad2(d.getHours());
  const MI = _pad2(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${HH}:${MI}`;
}

function _parseDatetimeLocal(v) {
  // Expected: YYYY-MM-DDTHH:MM (optionally with seconds)
  const s = String(v || '').trim();
  const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2})(?::(\d{2}))?$/);
  if (!m) return null;
  const y = parseInt(m[1], 10);
  const mo = parseInt(m[2], 10) - 1;
  const da = parseInt(m[3], 10);
  const h = parseInt(m[4], 10);
  const mi = parseInt(m[5], 10);
  const se = m[6] ? parseInt(m[6], 10) : 0;
  return new Date(y, mo, da, h, mi, se);
}

function buildTimestampText() {
  const fmt = String($('stampFormat')?.value || 'us-dt');
  const prefix = String($('stampPrefix')?.value || '');

  // Optional custom date/time override (pre/post-dating)
  let d = new Date();
  const useCustom = Boolean($('stampUseCustomDate')?.checked);
  const customVal = String($('stampCustomDate')?.value || '').trim();
  if (useCustom && customVal) {
    const parsed = _parseDatetimeLocal(customVal);
    if (parsed && !Number.isNaN(parsed.getTime())) d = parsed;
  }

  const yyyy = d.getFullYear();
  const mm = _pad2(d.getMonth() + 1);
  const dd = _pad2(d.getDate());
  const HH = _pad2(d.getHours());
  const MI = _pad2(d.getMinutes());

  let core = '';
  if (fmt === 'us') core = `${mm}/${dd}/${yyyy}`;
  else if (fmt === 'us-dt') core = `${mm}/${dd}/${yyyy} ${HH}:${MI}`;
  else if (fmt === 'iso') core = `${yyyy}-${mm}-${dd}`;
  else if (fmt === 'iso-dt') core = `${yyyy}-${mm}-${dd} ${HH}:${MI}`;
  else if (fmt === 'locale') core = d.toLocaleString();
  else core = `${mm}/${dd}/${yyyy} ${HH}:${MI}`;

  return `${prefix}${core}`;
}

function initStampSecure() {
  // Custom date/time UI wiring (optional)
  const useCb = $('stampUseCustomDate');
  const dtInput = $('stampCustomDate');
  if (useCb && dtInput) {
    const sync = () => {
      dtInput.disabled = !useCb.checked;
      if (useCb.checked && !String(dtInput.value || '').trim()) {
        dtInput.value = _formatDatetimeLocal(new Date());
      }
    };
    useCb.addEventListener('change', sync);
    sync();
  }

  initSinglePdfToolWithUnlock({
    fileInputId: 'stampPdfFile',
    previewBtnId: 'stampPreviewBtn',
    previewHintId: 'stampPreviewHint',
    passwordInputId: 'stampPdfPassword',
    unlockBtnId: 'stampUnlockBtn',
    actionBtnId: 'stampPdfBtn',
    tool: 'stamp',
    endpoint: ENDPOINTS.STAMP,
    filename: 'pdfrealm-timestamp.pdf',
    previewFrameId: 'stampPreviewFrame',
    placeholderId: 'stampPreviewPlaceholder',
    extraFields: () => ({ text: buildTimestampText() }),
  });
}

function initRedactSecure() {
  initRedactInteractive();
}

function initRedactInteractive() {
  const fileInput = $('redactPdfFile');
  const pwInput = $('redactPdfPassword');
  const unlockBtn = $('redactUnlockBtn');
  const previewBtn = $('redactPreviewBtn');
  const exportBtn = $('redactPdfBtn');

  const placeholder = $('redactPreviewPlaceholder');
  const wrapper = $('redactViewerWrapper');
  const shell = $('redactCanvasShell');
  const pdfCanvas = $('redactPdfCanvas');
  const inkCanvas = $('redactInkCanvas');
  const hitCanvas = $('redactHitCanvas');
  const boxLayer = $('redactBoxLayer');

  const pageLabel = $('redactPageLabel');
  const prevPageBtn = $('redactPrevPageBtn');
  const nextPageBtn = $('redactNextPageBtn');

  const modeBoxBtn = $('redactModeBox');
  const modeMarkerBtn = $('redactModeMarker');
  const markerSize = $('redactMarkerSize');

  const undoBtn = $('redactUndoBtn');
  const clearPageBtn = $('redactClearPageBtn');

  const hint = $('redactPreviewHint');
  // --- PDF.js bootstrap (dynamic import; avoids CDN 404/mime issues) ---
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      // Try cdnjs (pdf.min.mjs exists for v4+)
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        // Fallback to jsDelivr (npm pdfjs-dist)
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // --- State ---
  let originalFile = null;
  let unlockedFile = null;
  let pdfDoc = null;
  let pageCount = 0;
  let pageNum = 1;
  let renderScale = 1;

  // Per-page annotations (normalized, top-left origin)
  const pages = []; // { rects: [{x,y,w,h}], strokes: [{points:[{x,y}], size}] }
  const history = []; // {page, kind:'rect'|'stroke'}

  let mode = 'box'; // 'box'|'marker'
  let selectedRectId = null; // `${pageIndex}:${rectIndex}`

  function ensurePages(n) {
    while (pages.length < n) pages.push({ rects: [], strokes: [] });
  }

  function setMode(m) {
    mode = m;
    selectedRectId = null;
    [modeBoxBtn, modeMarkerBtn].forEach((b) => b && b.classList.remove('active'));
    if (m === 'box') modeBoxBtn && modeBoxBtn.classList.add('active');
    if (m === 'marker') modeMarkerBtn && modeMarkerBtn.classList.add('active');

    // The interaction layer is always the hitCanvas. The boxLayer is visual-only.
    if (boxLayer) boxLayer.style.pointerEvents = 'none';
    if (hitCanvas) hitCanvas.style.pointerEvents = 'auto';
  }

  function showEmpty(msg) {
    if (placeholder) {
      placeholder.textContent = msg || 'Upload a PDF to preview it here.';
      placeholder.style.display = 'flex';
    }
    if (shell) shell.style.display = 'none';
  }

  function showCanvas() {
    if (placeholder) placeholder.style.display = 'none';
    if (shell) shell.style.display = 'block';
  }

  function updatePageLabel() {
    if (pageLabel) pageLabel.textContent = `Page ${pageNum} / ${pageCount || 1}`;
    if (prevPageBtn) prevPageBtn.disabled = pageNum <= 1;
    if (nextPageBtn) nextPageBtn.disabled = pageNum >= pageCount;
  }

  function clearCanvas(c) {
    if (!c) return;
    const ctx = c.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, c.width, c.height);
  }

  async function loadPdfFromFile(file) {
    const lib = await getPdfJsAsync();
    if (!lib) {
      alert('PDF.js failed to load. Please refresh the page.');
      return;
    }

    showEmpty('Checking encryption...');

    const encrypted = await detectEncryptedPdfReliable(file);
    if (encrypted) {
      showEmpty('Encrypted PDF — enter the password and click Decrypt / Unlock.');
      return;
    }

    const data = await file.arrayBuffer();
    pdfDoc = await lib.getDocument({ data }).promise;
    pageCount = pdfDoc.numPages || 1;
    ensurePages(pageCount);
    pageNum = Math.min(Math.max(1, pageNum), pageCount);
    updatePageLabel();
    await renderPage(pageNum);
  }

  function currentPageState() {
    ensurePages(pageCount || 1);
    return pages[pageNum - 1];
  }

  function normFromEvent(ev) {
    const rect = hitCanvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) / rect.width;
    const y = (ev.clientY - rect.top) / rect.height;
    return { x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y)) };
  }

  function pxFromNorm(nx, ny) {
    return { x: nx * pdfCanvas.width, y: ny * pdfCanvas.height };
  }

  function rebuildBoxLayer() {
    if (!boxLayer) return;
    boxLayer.innerHTML = '';
    const st = currentPageState();

    st.rects.forEach((r, idx) => {
      const el = document.createElement('div');
      el.className = 'redact-box';
      el.dataset.rectIndex = String(idx);

      const left = r.x * pdfCanvas.width;
      const top = r.y * pdfCanvas.height;
      const w = r.w * pdfCanvas.width;
      const h = r.h * pdfCanvas.height;

      el.style.left = `${left}px`;
      el.style.top = `${top}px`;
      el.style.width = `${w}px`;
      el.style.height = `${h}px`;

      // selection outline
      const id = `${pageNum - 1}:${idx}`;
      if (selectedRectId === id) el.classList.add('selected');

      // handles
      ['tl','tr','bl','br'].forEach((pos) => {
        const hnd = document.createElement('div');
        hnd.className = `rb-handle ${pos}`;
        hnd.dataset.handle = pos;
        el.appendChild(hnd);
      });

      boxLayer.appendChild(el);
    });
  }

  function redrawInk() {
    clearCanvas(inkCanvas);
    const ctx = inkCanvas.getContext('2d');
    if (!ctx) return;

    const st = currentPageState();
    st.strokes.forEach((s) => {
      const sizePx = Math.max(2, (s.size || 0.02) * Math.min(pdfCanvas.width, pdfCanvas.height));
      ctx.lineWidth = sizePx;
      ctx.strokeStyle = '#000';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const pts = s.points || [];
      if (pts.length < 2) return;
      ctx.beginPath();
      const p0 = pxFromNorm(pts[0].x, pts[0].y);
      ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < pts.length; i++) {
        const p = pxFromNorm(pts[i].x, pts[i].y);
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    });
  }

  async function renderPage(n) {
    if (!pdfDoc) return;
    showCanvas();

    const page = await pdfDoc.getPage(n);

    // Fit to wrapper width, keep true pixel sizing for correct overlays
    const baseVp = page.getViewport({ scale: 1 });
    const wrapW = Math.max(320, (wrapper?.clientWidth || 800) - 24);
    renderScale = wrapW / baseVp.width;
    renderScale = Math.min(2.5, Math.max(0.6, renderScale));

    const vp = page.getViewport({ scale: renderScale });

    // Size canvases in device pixels
    const dpr = window.devicePixelRatio || 1;
    const cssW = Math.floor(vp.width);
    const cssH = Math.floor(vp.height);

    shell.style.width = cssW + 'px';
    shell.style.height = cssH + 'px';

    ;[pdfCanvas, inkCanvas, hitCanvas].forEach((c) => {
      if (!c) return;
      c.width = Math.floor(cssW * dpr);
      c.height = Math.floor(cssH * dpr);
      c.style.width = cssW + 'px';
      c.style.height = cssH + 'px';
      const ctx = c.getContext('2d');
      if (ctx) ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });

    if (boxLayer) {
      boxLayer.style.width = cssW + 'px';
      boxLayer.style.height = cssH + 'px';
    }

    // Render PDF page
    const ctx = pdfCanvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport: vp }).promise;

    // Overlays
    redrawInk();
    rebuildBoxLayer();
    updatePageLabel();

    if (hint) {
      hint.style.display = 'block';
      hint.textContent = 'Preview updated.';
    }
  }

  // --- Box creation (drag on hitCanvas) ---
  let boxDrag = null; // {startX,startY, el}

  function startBox(ev) {
    if (mode !== 'box' || !hitCanvas || !boxLayer) return;
    const st = normFromEvent(ev);
    const tmp = document.createElement('div');
    tmp.className = 'redact-box temp';
    tmp.style.left = (st.x * pdfCanvas.width) + 'px';
    tmp.style.top = (st.y * pdfCanvas.height) + 'px';
    tmp.style.width = '0px';
    tmp.style.height = '0px';
    boxLayer.appendChild(tmp);
    boxDrag = { start: st, el: tmp };
  }

  function moveBox(ev) {
    if (!boxDrag) return;
    const st = boxDrag.start;
    const cur = normFromEvent(ev);
    const x1 = min(st.x, cur.x);
    const y1 = min(st.y, cur.y);
    const x2 = max(st.x, cur.x);
    const y2 = max(st.y, cur.y);
    const left = x1 * pdfCanvas.width;
    const top = y1 * pdfCanvas.height;
    const w = (x2 - x1) * pdfCanvas.width;
    const h = (y2 - y1) * pdfCanvas.height;
    const el = boxDrag.el;
    el.style.left = left + 'px';
    el.style.top = top + 'px';
    el.style.width = w + 'px';
    el.style.height = h + 'px';
  }

  function endBox() {
    if (!boxDrag) return;
    const el = boxDrag.el;
    const left = parseFloat(el.style.left) || 0;
    const top = parseFloat(el.style.top) || 0;
    const w = parseFloat(el.style.width) || 0;
    const h = parseFloat(el.style.height) || 0;
    el.remove();

    boxDrag = null;

    if (w < 8 || h < 8) {
      rebuildBoxLayer();
      return;
    }

    const st = currentPageState();
    st.rects.push({
      x: left / pdfCanvas.width,
      y: top / pdfCanvas.height,
      w: w / pdfCanvas.width,
      h: h / pdfCanvas.height,
    });
    history.push({ page: pageNum - 1, kind: 'rect' });
    rebuildBoxLayer();
  }

  // --- Marker drawing (drag on hitCanvas) ---
  let marker = null; // { stroke, last }

  function startMarker(ev) {
    if (mode !== 'marker' || !hitCanvas) return;
    const pt = normFromEvent(ev);
    const sizePx = parseInt(markerSize?.value || '14', 10) || 14;
    const sizeNorm = sizePx / Math.min(pdfCanvas.width, pdfCanvas.height);
    marker = { stroke: { points: [pt], size: sizeNorm } };
  }

  function moveMarker(ev) {
    if (!marker) return;
    const pt = normFromEvent(ev);
    marker.stroke.points.push(pt);

    // Draw incremental for responsiveness
    const ctx = inkCanvas.getContext('2d');
    if (!ctx) return;
    const pts = marker.stroke.points;
    if (pts.length < 2) return;

    const sizePx = Math.max(2, (marker.stroke.size || 0.02) * Math.min(pdfCanvas.width, pdfCanvas.height));
    ctx.lineWidth = sizePx;
    ctx.strokeStyle = '#000';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const a = pxFromNorm(pts[pts.length - 2].x, pts[pts.length - 2].y);
    const b = pxFromNorm(pts[pts.length - 1].x, pts[pts.length - 1].y);

    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }

  function endMarker() {
    if (!marker) return;
    const st = currentPageState();
    if ((marker.stroke.points || []).length >= 2) {
      st.strokes.push(marker.stroke);
      history.push({ page: pageNum - 1, kind: 'stroke' });
    }
    marker = null;
  }

  // --- Select/move/resize boxes ---
  let selectDrag = null; // { kind:'move'|'resize', rectIndex, start, baseRect, handle }

  // Hit-test in BOX mode (no separate Select mode):
  // - drag empty area => create new box
  // - drag inside an existing box => move
  // - drag near a corner => resize
  function hitTestRect(ptNorm) {
    const st = currentPageState();
    const rects = st.rects || [];
    // Prefer the last rect (most recently created) when overlaps occur
    for (let i = rects.length - 1; i >= 0; i--) {
      const r = rects[i];
      const inside = ptNorm.x >= r.x && ptNorm.x <= (r.x + r.w) && ptNorm.y >= r.y && ptNorm.y <= (r.y + r.h);
      if (!inside) continue;

      // Corner-handle detection in pixels (feels consistent across zoom)
      const px = pxFromNorm(ptNorm.x, ptNorm.y);
      const tl = pxFromNorm(r.x, r.y);
      const tr = pxFromNorm(r.x + r.w, r.y);
      const bl = pxFromNorm(r.x, r.y + r.h);
      const br = pxFromNorm(r.x + r.w, r.y + r.h);
      const TH = 12; // px
      const near = (a, b) => Math.abs(a.x - b.x) <= TH && Math.abs(a.y - b.y) <= TH;
      let handle = null;
      if (near(px, tl)) handle = 'tl';
      else if (near(px, tr)) handle = 'tr';
      else if (near(px, bl)) handle = 'bl';
      else if (near(px, br)) handle = 'br';
      return { index: i, handle };
    }
    return null;
  }

  function selectRect(idx) {
    selectedRectId = `${pageNum - 1}:${idx}`;
    rebuildBoxLayer();
  }

  function startSelectAt(ev, idx, handle) {
    selectRect(idx);
    const st = currentPageState();
    const base = { ...st.rects[idx] };
    const pt = normFromEvent(ev);
    selectDrag = {
      rectIndex: idx,
      handle: handle || null,
      start: pt,
      baseRect: base,
      kind: handle ? 'resize' : 'move',
    };
    try { hitCanvas.setPointerCapture?.(ev.pointerId); } catch {}
  }

  function moveSelect(ev) {
    if (!selectDrag) return;
    const st = currentPageState();
    const idx = selectDrag.rectIndex;
    const cur = normFromEvent(ev);

    const dx = cur.x - selectDrag.start.x;
    const dy = cur.y - selectDrag.start.y;

    let r = { ...selectDrag.baseRect };

    if (selectDrag.kind === 'move') {
      r.x = clamp01(r.x + dx);
      r.y = clamp01(r.y + dy);
      r.x = Math.min(r.x, 1 - r.w);
      r.y = Math.min(r.y, 1 - r.h);
    } else {
      const h = selectDrag.handle;
      if (h == 'tl') {
        const nx = clamp01(r.x + dx);
        const ny = clamp01(r.y + dy);
        const nw = (r.x + r.w) - nx;
        const nh = (r.y + r.h) - ny;
        r = { x: nx, y: ny, w: clamp01(nw), h: clamp01(nh) };
      } else if (h == 'tr') {
        const ny = clamp01(r.y + dy);
        const nw = clamp01(r.w + dx);
        const nh = (r.y + r.h) - ny;
        r = { x: r.x, y: ny, w: nw, h: clamp01(nh) };
      } else if (h == 'bl') {
        const nx = clamp01(r.x + dx);
        const nw = (r.x + r.w) - nx;
        const nh = clamp01(r.h + dy);
        r = { x: nx, y: r.y, w: clamp01(nw), h: nh };
      } else if (h == 'br') {
        r.w = clamp01(r.w + dx);
        r.h = clamp01(r.h + dy);
      }

      // minimum size
      r.w = Math.max(r.w, 0.01);
      r.h = Math.max(r.h, 0.01);

      // clamp inside page
      r.x = clamp01(r.x);
      r.y = clamp01(r.y);
      r.w = Math.min(r.w, 1 - r.x);
      r.h = Math.min(r.h, 1 - r.y);
    }

    st.rects[idx] = r;
    rebuildBoxLayer();
  }

  function endSelect(ev) {
    if (!selectDrag) return;
    try { hitCanvas.releasePointerCapture?.(ev.pointerId); } catch {}
    selectDrag = null;
  }

  function exportBoxesString() {
    const lines = [];
    for (let pi = 0; pi < pages.length; pi++) {
      const rects = pages[pi].rects || [];
      for (const r of rects) {
        lines.push(`${pi + 1},${r.x.toFixed(6)},${r.y.toFixed(6)},${r.w.toFixed(6)},${r.h.toFixed(6)}`);
      }
    }
    const s = lines.join('\n');
    const ta = $('redactBoxes');
    if (ta) ta.value = s;
    return s;
  }

  function exportAnnotationsJSON() {
    return JSON.stringify({ pages });
  }

  async function onPreview() {
    if (!originalFile && !unlockedFile) return;
    await renderPage(pageNum);
  }

  async function onExport() {
    const f = unlockedFile || originalFile;
    if (!f) return alert('Upload a PDF first.');

    // Require at least one action
    const any = pages.some((p) => (p.rects?.length || 0) + (p.strokes?.length || 0) > 0);
    if (!any) return alert('Add at least one black box or marker stroke before exporting.');

    const fd = new FormData();
    fd.append('file', f);
    fd.append('boxes', exportBoxesString());
    fd.append('annotations', exportAnnotationsJSON());

    const result = await runPaidPdfExport({
      tool: 'redact',
      endpoint: (document.getElementById("redactBurnIn") && document.getElementById("redactBurnIn").checked) ? (ENDPOINTS.REDACT_BURN || "/api/redact/burn") : ENDPOINTS.REDACT,
      formData: fd,
      filename: 'pdfrealm-redacted.pdf',
      setPreviewFrameId: null,
      placeholderId: null,
    });

    if (!result?.ok) return;

    // Load the returned PDF into the viewer (redactions are now baked).
    try {
      const outFile = new File([result.blob], 'pdfrealm-redacted.pdf', { type: 'application/pdf' });
      // Reset annotations after bake
      pages.splice(0, pages.length);
      history.splice(0, history.length);
      selectedRectId = null;
      unlockedFile = null;
      originalFile = outFile;
      await loadPdfFromFile(outFile);
    } catch {}
  }

  async function onUnlock() {
    const f = originalFile;
    if (!f) return alert('Upload a PDF first.');

    const encrypted = await detectEncryptedPdfReliable(f);
    if (!encrypted) {
      alert('This PDF is not encrypted.');
      return;
    }

    const pw = String(pwInput?.value || '').trim();
    if (!pw) return alert('Enter a password first.');

    try {
      const dec = await decryptPdfToFile(f, pw);
      unlockedFile = dec;
      await loadPdfFromFile(dec);
    } catch (e) {
      alert(e.message || 'Decrypt failed.');
    }
  }

  // --- Undo / clear ---
  function undo() {
    if (!history.length) return;
    const last = history.pop();
    const st = pages[last.page];
    if (!st) return;
    if (last.kind === 'rect' && st.rects.length) st.rects.pop();
    if (last.kind === 'stroke' && st.strokes.length) st.strokes.pop();

    if ((last.page + 1) === pageNum) {
      redrawInk();
      rebuildBoxLayer();
    }
  }

  function clearPage() {
    if (!pageCount) return;
    const st = currentPageState();
    st.rects = [];
    st.strokes = [];
    // remove history entries for this page
    for (let i = history.length - 1; i >= 0; i--) {
      if (history[i].page === pageNum - 1) history.splice(i, 1);
    }
    redrawInk();
    rebuildBoxLayer();
  }

  // --- UI wiring ---
  setMode('box');

  modeBoxBtn?.addEventListener('click', () => setMode('box'));
  modeMarkerBtn?.addEventListener('click', () => setMode('marker'));

  previewBtn?.addEventListener('click', onPreview);
  exportBtn?.addEventListener('click', onExport);
  unlockBtn?.addEventListener('click', onUnlock);

  undoBtn?.addEventListener('click', undo);
  clearPageBtn?.addEventListener('click', clearPage);

  prevPageBtn?.addEventListener('click', async () => {
    if (pageNum <= 1) return;
    pageNum -= 1;
    updatePageLabel();
    await renderPage(pageNum);
  });
  nextPageBtn?.addEventListener('click', async () => {
    if (pageNum >= pageCount) return;
    pageNum += 1;
    updatePageLabel();
    await renderPage(pageNum);
  });

  // Pointer handlers
  if (hitCanvas) {
    hitCanvas.addEventListener('pointerdown', (ev) => {
      if (!pdfDoc) return;
      if (mode === 'box') {
        // If the pointer is on an existing box, move/resize it.
        const hit = hitTestRect(normFromEvent(ev));
        if (hit) {
          startSelectAt(ev, hit.index, hit.handle);
        } else {
          selectedRectId = null;
          startBox(ev);
        }
      } else if (mode === 'marker') {
        startMarker(ev);
      }
    });
    hitCanvas.addEventListener('pointermove', (ev) => {
      if (!pdfDoc) return;
      if (mode === 'box') {
        if (selectDrag) moveSelect(ev);
        else moveBox(ev);
      } else if (mode === 'marker') {
        moveMarker(ev);
      }
    });
    hitCanvas.addEventListener('pointerup', (ev) => {
      if (mode === 'box') {
        if (selectDrag) endSelect(ev);
        else endBox();
      } else if (mode === 'marker') {
        endMarker();
      }
    });
    hitCanvas.addEventListener('pointercancel', (ev) => {
      if (mode === 'box') {
        if (selectDrag) endSelect(ev);
        else endBox();
      } else if (mode === 'marker') {
        endMarker();
      }
    });
  }

  // Load on file selection
  fileInput?.addEventListener('change', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) {
      originalFile = null;
      unlockedFile = null;
      pdfDoc = null;
      pageCount = 0;
      pageNum = 1;
      pages.splice(0, pages.length);
      history.splice(0, history.length);
      selectedRectId = null;
      showEmpty('Upload a PDF to preview it here.');
      updatePageLabel();
      return;
    }

    originalFile = f;
    unlockedFile = null;
    pdfDoc = null;
    pageCount = 0;
    pageNum = 1;
    pages.splice(0, pages.length);
    history.splice(0, history.length);
    selectedRectId = null;
    clearCanvas(pdfCanvas);
    clearCanvas(inkCanvas);
    if (boxLayer) boxLayer.innerHTML = '';

    await loadPdfFromFile(f);
  });

  // Re-render on resize (keeps overlays aligned)
  window.addEventListener('resize', debounce(async () => {
    if (!pdfDoc) return;
    await renderPage(pageNum);
  }, 150));

  // Initial
  showEmpty('Upload a PDF to preview it here.');
  updatePageLabel();

  // small utils
  function clamp01(v) { return Math.min(1, Math.max(0, v)); }
  function min(a,b){ return a<b?a:b; }
  function max(a,b){ return a>b?a:b; }
  function debounce(fn, ms) {
    let t = null;
    return (...args) => {
      if (t) clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }
}

// -------------------- More Tools preview helper --------------------
function initMoreToolsPreview() {
  const map = [
    ["pdfToJpgFile", "pdfToJpgPreviewFrame", "pdfToJpgPreviewPlaceholder"],
    ["pdfToPngFile", "pdfToPngPreviewFrame", "pdfToPngPreviewPlaceholder"],
  ];
  map.forEach(([inp, fr, ph]) => wireLocalPdfPreview(inp, fr, ph));
}

function initMoreToolsActions() {
  function oneFileToExport(tool, endpoint, fileInputId, extraFields, filename, previewFrameId, placeholderId) {
    return async () => {
      const f = $(fileInputId)?.files?.[0];
      if (!f) return alert("Upload a PDF first.");

      const fd = new FormData();
      fd.append("file", f);
      for (const [k, v] of Object.entries(extraFields || {})) fd.append(k, String(v ?? ""));

      await runPaidPdfExport({
        tool,
        endpoint,
        formData: fd,
        filename,
        setPreviewFrameId: previewFrameId,
        placeholderId: placeholderId,
      });
    };
  }
// ---- JPG → PDF (split preview: input left, output right) ----
  (function initJpgToPdfSplit() {
    const fileInput = $("jpgToPdfFile");
    const convertBtn = $("jpgToPdfPreviewBtn");
    const exportBtn = $("jpgToPdfExportBtn");
    const statusEl = $("jpg2pdfStatus");

    const inputHost = $("jpg2pdfInputPreviewHost");
    const outputHost = $("jpg2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    // Lock down previews (no right-click copy)
    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("jpg2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("jpg2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap (dynamic import; matches our OCR/QuickSign pattern)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      // Render up to 10 pages for preview (scrollable).
      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("jpg2pdfOutputPlaceholder", false);
    }

    // Input preview (image)
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      exportBtn.disabled = true;
      setStatus("");

      if (!f) {
        resetInput();
        return;
      }

      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = URL.createObjectURL(f);

      inputHost.innerHTML = "";
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "JPG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);

      showPlaceholder("jpg2pdfInputPlaceholder", false);
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a JPG first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const fd = new FormData();
        fd.append("file", f);

        const result = await runPaidPdfExport({
          tool: "jpg-to-pdf",
          endpoint: ENDPOINTS.JPG_TO_PDF,
          formData: fd,
          filename: null,
        });

        if (!result || !result.ok || !result.blob) {
          throw new Error("JPG → PDF failed.");
        }

        // runPaidPdfExport always creates an object URL; we don't need it here.
        try { if (result.objectUrl) URL.revokeObjectURL(result.objectUrl); } catch {}

        lastOutputBlob = result.blob;
        await renderPdfBlobToHost(result.blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready. Click Export PDF to download.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-jpg.pdf");
    });

    // Initial state
    resetInput();
    resetOutput();
  })();

  // ---- PNG → PDF (split preview: input left, output right) ----
  (function initPngToPdfSplit() {
    const fileInput = $("pngToPdfFile");
    const convertBtn = $("pngToPdfPreviewBtn");
    const exportBtn = $("pngToPdfExportBtn");
    const statusEl = $("png2pdfStatus");

    const inputHost = $("png2pdfInputPreviewHost");
    const outputHost = $("png2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    // Lock down previews (no right-click copy)
    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("png2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("png2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap (dynamic import)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("png2pdfOutputPlaceholder", false);
    }

    // Input preview (image)
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      exportBtn.disabled = true;
      setStatus("");

      if (!f) {
        resetInput();
        return;
      }

      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = URL.createObjectURL(f);

      inputHost.innerHTML = "";
      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "PNG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";
      inputHost.appendChild(img);

      showPlaceholder("png2pdfInputPlaceholder", false);
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a PNG first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const fd = new FormData();
        fd.append("file", f);

        const result = await runPaidPdfExport({
          tool: "png-to-pdf",
          endpoint: ENDPOINTS.PNG_TO_PDF,
          formData: fd,
          filename: null,
        });

        if (!result || !result.ok || !result.blob) {
          throw new Error("PNG → PDF failed.");
        }

        try { if (result.objectUrl) URL.revokeObjectURL(result.objectUrl); } catch {}

        lastOutputBlob = result.blob;
        await renderPdfBlobToHost(result.blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready. Click Export PDF to download.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-png.pdf");
    });

    resetInput();
    resetOutput();
  })();

  // ---- TIFF → PDF (split preview: input left, output right) ----
  (function initTiffToPdfSplit() {
    const fileInput = $("tiffToPdfFile");
    const convertBtn = $("tiffToPdfPreviewBtn");
    const exportBtn = $("tiffToPdfExportBtn");
    const statusEl = $("tiff2pdfStatus");

    const inputHost = $("tiff2pdfInputPreviewHost");
    const outputHost = $("tiff2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("tiff2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      inputHost.innerHTML = "";
      showPlaceholder("tiff2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap (dynamic import)
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }

      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("tiff2pdfOutputPlaceholder", false);
    }

    // UTIF loader (for TIFF input preview)
    let _utifPromise = null;
    function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        const existing = Array.from(document.scripts || []).find((s) => s.src === src);
        if (existing) return resolve();
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error("Failed to load " + src));
        document.head.appendChild(s);
      });
    }
    async function getUTIF() {
      if (window.UTIF) return window.UTIF;
      if (_utifPromise) return _utifPromise;
      _utifPromise = (async () => {
        try {
          await loadScriptOnce('https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js');
          return window.UTIF || null;
        } catch (e) {
          console.error(e);
          return null;
        }
      })();
      return _utifPromise;
    }

    async function renderTiffToHost(file, host) {
      const UTIF = await getUTIF();
      if (!UTIF) {
        host.innerHTML = '<div class="muted">TIFF preview requires UTIF.js (failed to load).</div>';
        return;
      }

      const buf = await file.arrayBuffer();
      const ifds = UTIF.decode(buf);
      if (!ifds || !ifds.length) {
        host.innerHTML = '<div class="muted">Unable to decode TIFF.</div>';
        return;
      }
      UTIF.decodeImages(buf, ifds);
      const first = ifds[0];
      const rgba = UTIF.toRGBA8(first);
      const w = first.width;
      const h = first.height;

      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      canvas.style.maxWidth = "100%";
      canvas.style.height = "auto";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      const ctx = canvas.getContext("2d");
      const imgData = new ImageData(new Uint8ClampedArray(rgba), w, h);
      ctx.putImageData(imgData, 0, 0);

      host.innerHTML = "";
      host.appendChild(canvas);
    }

    fileInput.addEventListener("change", async () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      exportBtn.disabled = true;
      setStatus("");

      if (!f) {
        resetInput();
        return;
      }

      try {
        inputHost.innerHTML = "";
        await renderTiffToHost(f, inputHost);
        showPlaceholder("tiff2pdfInputPlaceholder", false);
      } catch (e) {
        console.error(e);
        inputHost.innerHTML = '<div class="muted">Unable to preview this TIFF in your browser.</div>';
        showPlaceholder("tiff2pdfInputPlaceholder", false);
      }
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload a TIFF first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const fd = new FormData();
        fd.append("file", f);

        const result = await runPaidPdfExport({
          tool: "tiff-to-pdf",
          endpoint: ENDPOINTS.TIFF_TO_PDF,
          formData: fd,
          filename: null,
        });

        if (!result || !result.ok || !result.blob) {
          throw new Error("TIFF → PDF failed.");
        }

        try { if (result.objectUrl) URL.revokeObjectURL(result.objectUrl); } catch {}

        lastOutputBlob = result.blob;
        await renderPdfBlobToHost(result.blob, outputHost);
        exportBtn.disabled = false;
        setStatus("Preview ready. Click Export PDF to download.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-tiff.pdf");
    });

    resetInput();
    resetOutput();
  })();


function initSvgToPdfSplit() {
    const fileInput = $("svgToPdfFile");
    const convertBtn = $("svgToPdfPreviewBtn");
    const exportBtn = $("svgToPdfExportBtn");
    const statusEl = $("svg2pdfStatus");

    const inputHost = $("svg2pdfInputPreviewHost");
    const outputHost = $("svg2pdfOutputPreviewHost");

    if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

    inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
    outputHost.addEventListener("contextmenu", (e) => e.preventDefault());

    let inputUrl = null;
    let lastOutputBlob = null;

    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg || "";
    }

    function resetOutput() {
      lastOutputBlob = null;
      exportBtn.disabled = true;
      outputHost.innerHTML = "";
      showPlaceholder("svg2pdfOutputPlaceholder", true);
    }

    function resetInput() {
      if (inputUrl) {
        try { URL.revokeObjectURL(inputUrl); } catch {}
      }
      inputUrl = null;
      inputHost.innerHTML = "";
      showPlaceholder("svg2pdfInputPlaceholder", true);
    }

    // PDF.js bootstrap
    let _pdfJsPromise = null;
    async function getPdfJsAsync() {
      if (_pdfJsPromise) return _pdfJsPromise;
      _pdfJsPromise = (async () => {
        try {
          const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
          const lib = (mod && (mod.default || mod)) || null;
          if (lib && lib.GlobalWorkerOptions) {
            lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
          }
          return lib;
        } catch (e1) {
          try {
            const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
            const lib2 = (mod2 && (mod2.default || mod2)) || null;
            if (lib2 && lib2.GlobalWorkerOptions) {
              lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
            }
            return lib2;
          } catch (e2) {
            console.error('PDF.js failed to load from CDN.', e1, e2);
            return null;
          }
        }
      })();
      return _pdfJsPromise;
    }

    async function renderPdfBlobToHost(blob, host) {
      const pdfjs = await getPdfJsAsync();
      if (!pdfjs) {
        host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
        return;
      }
      const buf = await blob.arrayBuffer();
      const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

      host.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "center";
      host.appendChild(wrap);

      const maxPages = Math.min(doc.numPages, 10);
      const hostW = Math.max(320, host.clientWidth || 820);
      const targetW = Math.min(940, hostW - 40);

      for (let i = 1; i <= maxPages; i++) {
        const page = await doc.getPage(i);
        const v1 = page.getViewport({ scale: 1 });
        const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";

        await page.render({ canvasContext: ctx, viewport }).promise;
        wrap.appendChild(canvas);
      }

      showPlaceholder("svg2pdfOutputPlaceholder", false);
    }

    // Input preview (svg)
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      resetOutput();
      resetInput();
      if (!f) return;

      inputUrl = URL.createObjectURL(f);
      inputHost.innerHTML = "";

      const img = document.createElement("img");
      img.src = inputUrl;
      img.alt = "SVG preview";
      img.draggable = false;
      img.style.maxWidth = "100%";
      img.style.height = "auto";
      img.style.borderRadius = "12px";
      img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      img.style.background = "white";

      inputHost.appendChild(img);
      showPlaceholder("svg2pdfInputPlaceholder", false);
    });

    convertBtn.addEventListener("click", async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return alert("Upload an SVG first.");

      convertBtn.disabled = true;
      setStatus("Converting (preview)...");

      try {
        const result = await runPaidPdfExport({
          tool: "svg-to-pdf",
          endpoint: ENDPOINTS.SVG_TO_PDF,
          file: f,
        });

        // result is a Blob (application/pdf)
        lastOutputBlob = result;
        exportBtn.disabled = false;

        outputHost.innerHTML = "";
        await renderPdfBlobToHost(lastOutputBlob, outputHost);
        setStatus("Ready.");
      } catch (err) {
        console.error(err);
        alert(String(err?.message || err || "Conversion failed."));
        setStatus("");
      } finally {
        convertBtn.disabled = false;
      }
    });

    exportBtn.addEventListener("click", () => {
      if (!lastOutputBlob) return alert("Convert (preview) first.");
      downloadBlob(lastOutputBlob, "pdfrealm-svg.pdf");
    });
}



// -------------------- PDF → Word (split preview) --------------------
function initPdfToWordSplit() {
  const fileInput = $("p2wFile");
  const pwInput = $("pdfToWordPassword");
  const previewInputBtn = $("p2wPreviewBtn");
  const convertBtn = $("pdfToWordPreviewBtn");
  const exportBtn = $("pdfToWordExportBtn");
  const statusEl = $("p2wStatus");

  const inputHost = $("pdf2wordInputPreviewHost");
  const outputHost = $("pdf2wordOutputPreviewHost");

  if (!fileInput || !previewInputBtn || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

  // Lock down preview interactions
  inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  outputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  inputHost.style.userSelect = "none";
  outputHost.style.userSelect = "none";

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg || "";
  }

  function reset() {
    exportBtn.disabled = true;
    inputHost.innerHTML = "";
    outputHost.innerHTML = "";
    showPlaceholder("pdf2wordInputPlaceholder", true);
    showPlaceholder("pdf2wordOutputPlaceholder", true);
    setStatus("");
  }

  // PDF.js bootstrap
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs");
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs";
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import("https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs");
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs";
          }
          return lib2;
        } catch (e2) {
          console.error("PDF.js failed to load from CDN.", e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  async function renderPdfFileToHost(file, host, password, placeholderId) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Preview unavailable.</div>';
      if (placeholderId) showPlaceholder(placeholderId, false);
      return;
    }

    const buf = await file.arrayBuffer();
    const params = { data: new Uint8Array(buf) };
    if (password) params.password = password;

    const task = pdfjs.getDocument(params);
    if (password) {
      task.onPassword = (updatePassword) => updatePassword(password);
    }

    const doc = await task.promise;
    host.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 6);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let i = 1; i <= maxPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }

    if (placeholderId) showPlaceholder(placeholderId, false);
  }

  function buildFormData() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return null;
    const fd = new FormData();
    fd.append("file", f, f.name || "document.pdf");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");
    if (pw) fd.append("password", pw);
    return fd;
  }
  async function previewInput() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    // If the PDF is encrypted and no password was provided, don't let PDF.js throw;
    // instead, guide the user to enter the password (consistent with other tools).
    if (!pw) {
      try {
        const enc = await detectEncryptedPdf(f);
        if (enc) {
          setStatus("This PDF is password-protected. Enter the password on the left and click Preview.");
          try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
          return;
        }
      } catch { /* ignore heuristic errors */ }
    }

    setStatus("Rendering input preview...");
    try {
      await renderPdfFileToHost(f, inputHost, pw, "pdf2wordInputPlaceholder");
      setStatus("");
    } catch (e) {
      // PDF.js throws PasswordException if password is missing/incorrect.
      if (e && (e.name === "PasswordException" || String(e.message || "").toLowerCase().includes("password"))) {
        setStatus("Password required or incorrect. Enter the password on the left and try again.");
        try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
        return;
      }
      console.error(e);
      setStatus("Input preview failed.");
    }
  }
  async function convertPreview() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    if (!pw) {
      try {
        const enc = await detectEncryptedPdf(f);
        if (enc) {
          setStatus("This PDF is password-protected. Enter the password on the left and click Convert (preview).");
          try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
          return;
        }
      } catch {}
    }

    const fd = buildFormData();
    if (!fd) return alert("Upload a PDF first.");

    exportBtn.disabled = true;
    outputHost.innerHTML = "";
    showPlaceholder("pdf2wordOutputPlaceholder", true);

    setStatus("Converting (preview)...");
    try {
      const res = await fetch(ENDPOINTS.PDF_TO_WORD + "/preview", { method: "POST", body: fd });
      if (!res.ok) {
        let data = null;
        try { data = await res.json(); } catch {}
        throw new Error(data?.error || `Preview failed (${res.status})`);
      }

      const data = await res.json();
      const htmlRaw = String(data?.html || "");
      const html = htmlRaw.replace(/<script[\s\S]*?<\/script>/gi, "");

      outputHost.innerHTML = "";
      const paper = document.createElement("div");
      paper.style.background = "white";
      paper.style.color = "#111";
      paper.style.borderRadius = "14px";
      paper.style.boxShadow = "0 8px 28px rgba(0,0,0,.18)";
      paper.style.padding = "18px";
      paper.style.maxWidth = "980px";
      paper.style.width = "100%";
      paper.innerHTML = html || '<div class="muted">No preview available.</div>';

      outputHost.appendChild(paper);
      showPlaceholder("pdf2wordOutputPlaceholder", false);

      exportBtn.disabled = false;
      setStatus("Ready to export.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Preview failed."));
      showPlaceholder("pdf2wordOutputPlaceholder", true);
    }
  }
  async function exportWord() {
    const f0 = fileInput.files && fileInput.files[0];
    if (!f0) return alert("Upload a PDF first.");
    const pw0 = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    if (!pw0) {
      try {
        const enc = await detectEncryptedPdf(f0);
        if (enc) {
          setStatus("This PDF is password-protected. Enter the password on the left and export again.");
          try { pwInput && pwInput.focus && pwInput.focus(); } catch {}
          return;
        }
      } catch {}
    }

    const fd = buildFormData();
    if (!fd) return alert("Upload a PDF first.");
    if (exportBtn.disabled) return alert("Convert (preview) first.");

    const f = fileInput.files && fileInput.files[0];
    const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-pdf");
    const filename = `${base}.docx`;

    setStatus("Exporting Word...");
    try {
      await runPaidPdfExport({
        tool: "pdf-to-word",
        endpoint: ENDPOINTS.PDF_TO_WORD,
        formData: fd,
        filename,
        setPreviewFrameId: null,
        placeholderId: null,
      });
      setStatus("Exported.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Export failed."));
    }
  }

  // Auto-preview input on file select
  fileInput.addEventListener("change", () => {
    reset();
    previewInput();
  });

  previewInputBtn.addEventListener("click", previewInput);
  convertBtn.addEventListener("click", convertPreview);
  exportBtn.addEventListener("click", exportWord);
}

// -------------------- PDF → JPG (split preview, ZIP export) --------------------
function initPdfToJpgSplit() {
  const fileInput = $("pdfToJpgFile");
  const pwInput = $("pdfToJpgPassword");
  const previewInputBtn = $("pdfToJpgInputPreviewBtn");
  const convertBtn = $("pdfToJpgPreviewBtn");
  const exportBtn = $("pdfToJpgExportBtn");
  const statusEl = $("pdf2jpgStatus");

  const inputHost = $("pdf2jpgInputPreviewHost");
  const outputHost = $("pdf2jpgOutputPreviewHost");

  if (!fileInput || !previewInputBtn || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

  inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  outputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  inputHost.style.userSelect = "none";
  outputHost.style.userSelect = "none";

  let lastZipBlob = null;

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg || "";
  }

  function reset() {
    lastZipBlob = null;
    exportBtn.disabled = true;
    inputHost.innerHTML = "";
    outputHost.innerHTML = "";
    showPlaceholder("pdf2jpgInputPlaceholder", true);
    showPlaceholder("pdf2jpgOutputPlaceholder", true);
    setStatus("");
  }

  // PDF.js bootstrap
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs");
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs";
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import("https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs");
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs";
          }
          return lib2;
        } catch (e2) {
          console.error("PDF.js failed to load from CDN.", e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // JSZip bootstrap
  let _jsZipPromise = null;
  async function getJsZipAsync() {
    if (_jsZipPromise) return _jsZipPromise;
    _jsZipPromise = (async () => {
      try {
        const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
        return mod?.default || mod;
      } catch (e1) {
        try {
          await import("https://unpkg.com/jszip@3.10.1/dist/jszip.min.js");
          return window.JSZip || null;
        } catch (e2) {
          console.error("JSZip failed to load from CDN.", e1, e2);
          return window.JSZip || null;
        }
      }
    })();
    return _jsZipPromise;
  }

  async function renderPdfFileToHost(file, host, password, placeholderId) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Preview unavailable.</div>';
      if (placeholderId) showPlaceholder(placeholderId, false);
      return;
    }

    const buf = await file.arrayBuffer();
    const params = { data: new Uint8Array(buf) };
    if (password) params.password = password;

    const task = pdfjs.getDocument(params);
    if (password) task.onPassword = (updatePassword) => updatePassword(password);

    const doc = await task.promise;
    host.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 6);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let i = 1; i <= maxPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }

    if (placeholderId) showPlaceholder(placeholderId, false);
  }

  function buildFormData() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return null;
    const fd = new FormData();
    fd.append("file", f, f.name || "document.pdf");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");
    if (pw) fd.append("password", pw);
    return fd;
  }

  async function previewInput() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");
    setStatus("Rendering input preview...");
    try {
      await renderPdfFileToHost(f, inputHost, pw, "pdf2jpgInputPlaceholder");
      setStatus("");
    } catch (e) {
      console.error(e);
      setStatus("Input preview failed.");
    }
  }

  async function buildZipFromPdfToJpg(file, password) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) throw new Error("PDF.js failed to load.");

    const JSZip = (typeof getJsZipAsync === "function")
        ? await getJsZipAsync()
        : await (async () => {
            const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
            return mod.default || mod;
          })();
    if (!JSZip) throw new Error("JSZip failed to load.");

    const buf = await file.arrayBuffer();
    const params = { data: new Uint8Array(buf) };
    if (password) params.password = password;

    const task = pdfjs.getDocument(params);
    if (password) task.onPassword = (updatePassword) => updatePassword(password);

    const doc = await task.promise;
    const zip = new JSZip();

    // Output preview
    outputHost.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    outputHost.appendChild(wrap);

    const previewPages = Math.min(doc.numPages, 6);
    const quality = 0.95;

    for (let i = 1; i <= doc.numPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });

      // "Full quality": render larger. Clamp to avoid blowing up memory.
      const targetWidth = 1800;
      const scale = Math.max(1.0, Math.min(3.0, targetWidth / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      // Add to zip
      const dataUrl = canvas.toDataURL("image/jpeg", quality);
      const blob = await (await fetch(dataUrl)).blob();
      zip.file(`page-${String(i).padStart(3, "0")}.jpg`, blob);

      // Preview only first few pages
      if (i <= previewPages) {
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        canvas.style.background = "white";
        wrap.appendChild(canvas);
      }
    }

    showPlaceholder("pdf2jpgOutputPlaceholder", false);

    const zipBlob = await zip.generateAsync({ type: "blob" });
    return zipBlob;
  }

  async function convertPreview() {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = (pwInput && pwInput.value ? String(pwInput.value).trim() : "");

    exportBtn.disabled = true;
    lastZipBlob = null;
    outputHost.innerHTML = "";
    showPlaceholder("pdf2jpgOutputPlaceholder", true);

    setStatus("Converting (preview)...");
    try {
      lastZipBlob = await buildZipFromPdfToJpg(f, pw);
      exportBtn.disabled = false;
      setStatus("Ready to export ZIP.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Convert failed."));
      showPlaceholder("pdf2jpgOutputPlaceholder", true);
    }
  }

  async function exportZip() {
    if (!lastZipBlob) return alert("Convert (preview) first.");

    const f = fileInput.files && fileInput.files[0];
    const base = (f && f.name ? f.name.replace(/\.[^.]+$/, "") : "pdfrealm-pdf");
    const filename = `${base}-jpg.zip`;

    // Enforce paywall/export access server-side (no conversion on server).
    const fd = buildFormData();
    if (!fd) return alert("Upload a PDF first.");

    setStatus("Authorizing export...");
    try {
      const out = await runPaidPdfExport({
        tool: "pdf-to-jpg",
        endpoint: "/api/pdf-to-jpg/authorize",
        formData: fd,
        filename: null, // don't download server blob
        setPreviewFrameId: null,
        placeholderId: null,
      });
      try { if (out?.objectUrl) URL.revokeObjectURL(out.objectUrl); } catch {}
      downloadBlob(lastZipBlob, filename);
      setStatus("Exported.");
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || "Export blocked."));
    }
  }

  fileInput.addEventListener("change", () => {
    reset();
    previewInput();
  });

  previewInputBtn.addEventListener("click", previewInput);
  convertBtn.addEventListener("click", convertPreview);
  exportBtn.addEventListener("click", exportZip);
}

function initPdfToPngSplit() {
  const fileInput = $("pdfToPngFile");
  const pwInput = $("pdfToPngPassword");
  const convertBtn = $("pdfToPngPreviewBtn");
  let unlockBtn = $("pdfToPngUnlockBtn");
  const exportBtn = $("pdfToPngExportBtn");
  const statusEl = $("pdf2pngStatus");

  const inputHost = $("pdf2pngInputPreviewHost");
  const outputHost = $("pdf2pngOutputPreviewHost");

  if (!fileInput || !convertBtn || !exportBtn || !inputHost || !outputHost) return;

  // Backward-compatible: if HTML hasn't been patched, inject an Unlock button next to Convert
  if (!unlockBtn) {
    unlockBtn = document.createElement("button");
    unlockBtn.id = "pdfToPngUnlockBtn";
    unlockBtn.className = "btn btn-secondary";
    unlockBtn.type = "button";
    unlockBtn.textContent = "Decrypt / Unlock";
    const actions = convertBtn.parentElement;
    if (actions) actions.insertBefore(unlockBtn, convertBtn);
  }

  inputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  outputHost.addEventListener("contextmenu", (e) => e.preventDefault());
  inputHost.style.userSelect = "none";
  outputHost.style.userSelect = "none";

  let lastZipBlob = null;
  let previewUrls = [];
  let unlockedFile = null;
  let isEncrypted = false;

  function setStatus(msg) { if (statusEl) statusEl.textContent = msg || ""; }

  function cleanupPreviewUrls() {
    for (const u of previewUrls) { try { URL.revokeObjectURL(u); } catch {} }
    previewUrls = [];
  }

  function resetOutput() {
    cleanupPreviewUrls();
    lastZipBlob = null;
    exportBtn.disabled = true;
    outputHost.innerHTML = "";
    showPlaceholder("pdf2pngOutputPlaceholder", true);
  }

  function resetInput() {
    inputHost.innerHTML = "";
    showPlaceholder("pdf2pngInputPlaceholder", true);
  }

  function setInputPlaceholderText(t) {
    const ph = $("pdf2pngInputPlaceholder");
    if (ph && t) ph.textContent = t;
  }

  // PDF.js bootstrap
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  // JSZip bootstrap
  let _jsZipPromise = null;
  async function getJsZipAsync() {
    if (_jsZipPromise) return _jsZipPromise;
    _jsZipPromise = (async () => {
      try {
        const mod = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm');
        return mod?.default || mod;
      } catch (e1) {
        try {
          await import('https://unpkg.com/jszip@3.10.1/dist/jszip.min.js');
          return window.JSZip || null;
        } catch (e2) {
          console.error('JSZip failed to load from CDN.', e1, e2);
          return window.JSZip || null;
        }
      }
    })();
    return _jsZipPromise;
  }

  async function renderPdfBytesToHost(bytes, host) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Preview unavailable.</div>';
      return;
    }

    const task = pdfjs.getDocument({ data: bytes });
    const doc = await task.promise;

    host.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 6);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let p = 1; p <= maxPages; p++) {
      const page = await doc.getPage(p);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.style.borderRadius = "12px";
      canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
      canvas.style.background = "white";

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }

    showPlaceholder("pdf2pngInputPlaceholder", false);
  }

  async function buildZipFromPdf(file) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) throw new Error("PDF.js failed to load.");

    const JSZip = (typeof getJsZipAsync === "function")
        ? await getJsZipAsync()
        : await (async () => {
            const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
            return mod.default || mod;
          })();
    if (!JSZip) throw new Error("JSZip failed to load.");

    const buf = await file.arrayBuffer();
    const bytes = new Uint8Array(buf);

    const task = pdfjs.getDocument({ data: bytes });
    const doc = await task.promise;

    const zip = new JSZip();

    outputHost.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.gap = "12px";
    wrap.style.alignItems = "center";
    outputHost.appendChild(wrap);

    const previewPages = Math.min(doc.numPages, 6);
    const scaleFull = 3.0;

    for (let p = 1; p <= doc.numPages; p++) {
      setStatus(`Rendering page ${p}/${doc.numPages}...`);

      const page = await doc.getPage(p);
      const viewport = page.getViewport({ scale: scaleFull });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png", 1.0));
      if (!blob) throw new Error("Failed to encode PNG.");

      const name = `page-${String(p).padStart(3, "0")}.png`;
      zip.file(name, blob);

      if (p <= previewPages) {
        const url = URL.createObjectURL(blob);
        previewUrls.push(url);
        const img = document.createElement("img");
        img.src = url;
        img.alt = `Page ${p}`;
        img.draggable = false;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.borderRadius = "12px";
        img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
        img.style.background = "white";
        wrap.appendChild(img);
      }

      canvas.width = 0; canvas.height = 0;
    }

    showPlaceholder("pdf2pngOutputPlaceholder", false);
    setStatus("Building ZIP...");
    const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
    return zipBlob;
  }

  async function refreshInputPreview() {
    const f = fileInput.files && fileInput.files[0];
    resetInput();
    if (!f) return;

    if (isEncrypted && !unlockedFile) {
      setInputPlaceholderText('Encrypted PDF detected. Enter the password and click Decrypt / Unlock.');
      showPlaceholder("pdf2pngInputPlaceholder", true);
      return;
    }

    setStatus("Loading preview...");
    try {
      const src = unlockedFile || f;
      const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(src);
      await renderPdfBytesToHost(bytes, inputHost);
      setStatus("");
    } catch (e) {
      console.error(e);
      setStatus("");
      setInputPlaceholderText("Preview failed.");
      showPlaceholder("pdf2pngInputPlaceholder", true);
    }
  }

  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    unlockedFile = null;
    isEncrypted = false;
    resetOutput();
    resetInput();
    exportBtn.disabled = true;

    if (!f) return;

    setStatus("Checking PDF…");
    try {
      isEncrypted = await detectEncryptedPdfReliable(f);
    } catch {
      isEncrypted = false;
    }

    if (isEncrypted) {
      convertBtn.disabled = false; // allow user to click Convert (it will require unlock), but keep preview gated
      setStatus("Encrypted PDF detected.");
      setInputPlaceholderText('Encrypted PDF detected. Enter the password and click Decrypt / Unlock.');
      showPlaceholder("pdf2pngInputPlaceholder", true);
      return;
    }

    convertBtn.disabled = false;
    setStatus("");
    await refreshInputPreview();
  });

  unlockBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");
    const pw = String(pwInput?.value || "").trim();
    if (!pw) return alert("Enter the PDF password.");

    unlockBtn.disabled = true;
    unlockBtn.textContent = "Decrypting…";
    try {
      setStatus("Decrypting…");
      unlockedFile = await decryptPdfToFile(f, pw);
      isEncrypted = false;
      resetOutput();
      await refreshInputPreview();
      setStatus("Unlocked. Ready.");
    } catch (e) {
      alert(String(e?.message || e || "Decrypt failed."));
      setStatus("");
    } finally {
      unlockBtn.disabled = false;
      unlockBtn.textContent = "Decrypt / Unlock";
    }
  });

  convertBtn.addEventListener("click", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return alert("Upload a PDF first.");

    convertBtn.disabled = true;
    exportBtn.disabled = true;
    resetOutput();

    try {
      // If encrypted and not unlocked yet, try to unlock (same UX as other tools)
      if (isEncrypted && !unlockedFile) {
        const pw = String(pwInput?.value || "").trim();
        if (!pw) {
          setStatus("");
          return alert('This PDF is encrypted. Enter the password and click "Decrypt / Unlock" first.');
        }
        setStatus("Decrypting…");
        unlockedFile = await decryptPdfToFile(f, pw);
        isEncrypted = false;
        await refreshInputPreview();
      }

      setStatus("Converting (preview)...");
      const sourceFile = unlockedFile || f;

      const zipBlob = await buildZipFromPdf(sourceFile);
      lastZipBlob = zipBlob;
      exportBtn.disabled = false;
      setStatus("Ready.");
    } catch (err) {
      console.error(err);
      alert(String(err?.message || err || "Conversion failed."));
      setStatus("");
    } finally {
      convertBtn.disabled = false;
    }
  });

  exportBtn.addEventListener("click", () => {
    if (!lastZipBlob) return alert("Convert (preview) first.");
    downloadBlob(lastZipBlob, "pdfrealm-pdf-to-png.zip");
  });

  // Initial state
  convertBtn.disabled = false;
}

  initPdfToJpgSplit();
    initPdfToWordSplit();
  initPdfToPngSplit();
}

// -------------------- OCR --------------------
function initOcr() {
  // Input preview (image) using the same iframe previewer.
  wireLocalPdfPreview("ocrFile", "ocrPreviewFrame", "ocrPreviewPlaceholder");

  const btn = $("ocrRunBtn");
  if (!btn) return;

  btn.addEventListener("click", async () => {
    const f = $("ocrFile")?.files?.[0];
    if (!f) return alert("Upload an image first.");
    const lang = ($("ocrLang")?.value || "eng").trim() || "eng";

    const fd = new FormData();
    fd.append("file", f);
    fd.append("lang", lang);

    try {
      const res = await fetch(ENDPOINTS.OCR, { method: "POST", body: fd });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error(data?.error || "OCR failed");
      $("ocrOutput").value = data?.text || "";
    } catch (e) {
      alert(e.message || "OCR failed");
    }
  });
}


// -------------------- Templates --------------------
function initTemplates() {
  const btn = $("refreshTemplatesBtn");
  const list = $("templateList");

  async function refresh() {
    if (!list) return;
    list.innerHTML = "Loading...";
    try {
      const res = await fetch(ENDPOINTS.TEMPLATES);
      const items = await res.json();
      list.innerHTML = "";

      if (!Array.isArray(items) || !items.length) {
        list.innerHTML = `<div class="pill">No templates found. Add PDFs to /templates folder.</div>`;
        return;
      }

      items.forEach((t) => {
        const row = document.createElement("div");
        row.className = "card";
        row.style.padding = "12px";
        row.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
            <div>
              <div style="font-weight:900;">${escapeHtml(t.name || t.id)}</div>
              <div style="color:var(--muted);font-size:.95em;margin-top:4px;">${escapeHtml(t.description || "")}</div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
              <button class="btn btn-secondary" data-template-preview="${escapeAttr(t.id)}" type="button">Preview</button>
              <a class="btn btn-primary" href="${ENDPOINTS.TEMPLATE_DOWNLOAD}?id=${encodeURIComponent(t.id)}">Download</a>
            </div>
          </div>
        `;
        list.appendChild(row);
      });
    } catch {
      list.innerHTML = `<div class="pill">Failed to load templates.</div>`;
    }
  }

  document.addEventListener("click", (e) => {
    const b = e.target?.closest?.("[data-template-preview]");
    if (!b) return;
    const id = b.getAttribute("data-template-preview");
    setIframeSrc("templatePreviewFrame", `${ENDPOINTS.TEMPLATE_PREVIEW}?id=${encodeURIComponent(id)}`);
    showPlaceholder("templatePreviewPlaceholder", false);
  });

  if (btn) btn.addEventListener("click", refresh);
  refresh();
}

// -------------------- Secure Vault (S3) UI --------------------
// Expected HTML IDs (see list below):
// vaultStatus, vaultRefreshBtn, vaultFile, vaultFolder, vaultLabel, vaultUploadBtn,
// vaultNewFolder, vaultCreateFolderBtn, vaultList

async function refreshVaultList() {
  const list = $("vaultList");
  const status = $("vaultStatus");
  if (!list) return; // vault tab not present on this page
  list.innerHTML = "";
  if (!getToken()) {
    list.innerHTML = `<div class="pill">Login required to use Secure Vault.</div>`;
    if (status) setStatus(status, "Status: Login required");
    return;
  }

  try {
    if (status) setStatus(status, "Status: Loading...");
    const data = await fetchJson(ENDPOINTS.VAULT_LIST, {
      method: "GET",
      headers: authHeaders(),
    });

    const items = Array.isArray(data?.items) ? data.items : [];
    if (!items.length) {
      list.innerHTML = `<div class="pill">No files yet. Upload something to your Vault.</div>`;
      if (status) setStatus(status, "Status: Ready");
      return;
    }

    // Sort newest first (if lastModified exists)
    items.sort((a, b) => {
      const da = a?.lastModified ? new Date(a.lastModified).getTime() : 0;
      const db = b?.lastModified ? new Date(b.lastModified).getTime() : 0;
      return db - da;
    });

    items.forEach((it) => {
      const row = document.createElement("div");
      row.className = "card";
      row.style.padding = "12px";

      const safeName = escapeHtml(it.filename || it.key || "");
      const size = typeof it.size === "number" ? formatBytes(it.size) : "";
      const lm = it.lastModified ? new Date(it.lastModified).toLocaleString() : "";

      row.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;">
          <div style="min-width:0;">
            <div style="font-weight:900;word-break:break-word;">${safeName}</div>
            <div style="color:var(--muted);font-size:.92em;margin-top:4px;">
              ${escapeHtml(size)}${size && lm ? " • " : ""}${escapeHtml(lm)}
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;flex-shrink:0;">
            <button class="btn btn-secondary" type="button" data-vault-open="${escapeAttr(it.id)}">Open</button>
            <button class="btn btn-danger" type="button" data-vault-delete="${escapeAttr(it.id)}">Delete</button>
          </div>
        </div>
      `;
      list.appendChild(row);
    });

    if (status) setStatus(status, "Status: Ready");
  } catch (e) {
    if (status) setStatus(status, "Status: Error");
    list.innerHTML = `<div class="pill">Failed to load Vault list: ${escapeHtml(e.message || "Unknown error")}</div>`;
  }
}

function initVault() {
  const refreshBtn = $("vaultRefreshBtn");
  const uploadBtn = $("vaultUploadBtn");
  const createFolderBtn = $("vaultCreateFolderBtn");
  const status = $("vaultStatus");

  if (refreshBtn) refreshBtn.addEventListener("click", refreshVaultList);

  // Delegated actions: Open/Delete
  document.addEventListener("click", async (e) => {
    const openBtn = e.target?.closest?.("[data-vault-open]");
    const delBtn = e.target?.closest?.("[data-vault-delete]");

    if (openBtn) {
      const id = openBtn.getAttribute("data-vault-open");
      if (!id) return;
      if (!getToken()) return openModal("accountModal");

      try {
        if (status) setStatus(status, "Status: Generating link...");
        const data = await fetchJson(`${ENDPOINTS.VAULT_FILE}/${encodeURIComponent(id)}`, {
          method: "GET",
          headers: authHeaders(),
        });
        if (data?.url) { const w = window.open(data.url, "_blank"); if (w) w.opener = null; }
        if (status) setStatus(status, "Status: Ready");
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Failed to open file.");
      }
      return;
    }

    if (delBtn) {
      const id = delBtn.getAttribute("data-vault-delete");
      if (!id) return;
      if (!getToken()) return openModal("accountModal");

      const ok = confirm("Delete this file from your Vault? This cannot be undone.");
      if (!ok) return;

      try {
        if (status) setStatus(status, "Status: Deleting...");
        await fetchJson(`${ENDPOINTS.VAULT_FILE}/${encodeURIComponent(id)}`, {
          method: "DELETE",
          headers: authHeaders(),
        });
        if (status) setStatus(status, "Status: Ready");
        await refreshVaultList();
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Failed to delete file.");
      }
    }
  });

  if (uploadBtn) {
    uploadBtn.addEventListener("click", async () => {
      const file = $("vaultFile")?.files?.[0];
      const folder = ($("vaultFolder")?.value || "").trim();
      const label = ($("vaultLabel")?.value || "").trim();

      if (!getToken()) return openModal("accountModal");
      if (!file) return alert("Choose a file to upload.");

      const fd = new FormData();
      fd.append("file", file);
      if (folder) fd.append("folder", folder);
      if (label) fd.append("label", label);

      try {
        if (status) setStatus(status, "Status: Uploading...");
        const res = await fetch(ENDPOINTS.VAULT_UPLOAD, {
          method: "POST",
          headers: authHeaders(), // DO NOT set Content-Type for FormData
          body: fd,
        });

        const data = await res.json().catch(() => null);
        if (!res.ok) throw new Error(data?.error || `Upload failed (${res.status})`);

        if (status) setStatus(status, "Status: Uploaded");
        // Clear file input (safely)
        const fi = $("vaultFile");
        if (fi) fi.value = "";
        await refreshVaultList();
        if (status) setStatus(status, "Status: Ready");
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Upload failed.");
      }
    });
  }

  if (createFolderBtn) {
    createFolderBtn.addEventListener("click", async () => {
      const folderPath = ($("vaultNewFolder")?.value || "").trim();
      if (!getToken()) return openModal("accountModal");
      if (!folderPath) return alert("Enter a folder name/path (e.g., Freight/2026).");

      try {
        if (status) setStatus(status, "Status: Creating folder...");
        await fetchJson(ENDPOINTS.VAULT_FOLDER, {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ folderPath }),
        });
        if (status) setStatus(status, "Status: Folder created");
        const nf = $("vaultNewFolder");
        if (nf) nf.value = "";
        // folders are markers; list refresh still useful for UX
        await refreshVaultList();
        if (status) setStatus(status, "Status: Ready");
      } catch (err) {
        if (status) setStatus(status, "Status: Error");
        alert(err.message || "Folder create failed.");
      }
    });
  }

  // Initial load if vault exists on this page
  refreshVaultList().catch(() => {});
}

// -------------------- Escaping helpers --------------------
function escapeHtml(s) {
  return String(s || "").replace(/[&<>"']/g, (c) =>
    ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[c])
  );
}
function escapeAttr(s) {
  return String(s || "").replace(/"/g, "&quot;");
}

function clamp01(n) {
  const x = Number(n);
  if (!isFinite(x)) return 0;
  return Math.max(0, Math.min(1, x));
}

function formatBytes(bytes) {
  const b = Number(bytes || 0);
  if (!isFinite(b) || b <= 0) return "0 B";
  const units = ["B", "KB", "MB", "GB", "TB"];
  const k = 1024;
  const i = Math.min(units.length - 1, Math.floor(Math.log(b) / Math.log(k)));
  const v = b / Math.pow(k, i);
  return `${v.toFixed(v >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
}



// -------------------- Capability gating (audited tools only) --------------------
async function initCapabilities() {
  try {
    const res = await fetch("/api/capabilities");
    const data = await res.json().catch(() => null);
    if (!res.ok || !data || !data.tools) return;
    applyToolAvailability(data);
  } catch {
    // ignore
  }
}

function applyToolAvailability(cap) {
  const tools = cap?.tools || {};
  // Client-only conversion tools: force-enable even if server capabilities are conservative.
  tools.jpg2png = true;
  tools.png2jpg = true;
  tools.docx2png = true;
  const tabs = Array.from(document.querySelectorAll(".tool-tab"));

  tabs.forEach((btn) => {
    const key = btn.getAttribute("data-tool");
    if (!key) return;

    if (tools[key] === false) {
      btn.disabled = true;
      btn.setAttribute("aria-disabled", "true");
      btn.title = "Not available on this server (coming soon).";

      const view = document.querySelector(`.tool-view[data-tool-view="${key}"]`);
      if (view && !view.querySelector(".tool-unavailable")) {
        const body = view.querySelector(".tool-body") || view;
        const div = document.createElement("div");
        div.className = "card tool-unavailable";
        div.style.marginBottom = "14px";
        div.innerHTML = `
          <div style="font-weight:900;margin-bottom:6px;">Not available on this server</div>
          <div style="color:var(--muted);">This tool needs a backend route that isn't enabled yet.</div>
        `;
        body.prepend(div);
      }
    }
  });

  const active = document.querySelector(".tool-tab.tool-tab-active");
  if (active && (active.disabled || active.getAttribute("aria-disabled") === "true")) {
    const first = tabs.find((x) => !x.disabled && x.getAttribute("aria-disabled") !== "true");
    if (first && typeof window.__pdfrealmActivateTool === "function") {
      window.__pdfrealmActivateTool(first.getAttribute("data-tool"));
    }
  }
}

  

// -------------------- Pack2: Pages → ZIP, Sanitize, Rasterize --------------------
function initPagesZip() {
  const fileInput = $("pagesZipPdfFile");
  const pwInput = $("pagesZipPdfPassword");
  const unlockBtn = $("pagesZipUnlockBtn");
  const runBtn = $("pagesZipBtn");
  const statusEl = $("pagesZipStatus");
  const rangesInput = $("pagesZipRanges");
  const formatSel = $("pagesZipFormat");
  const nameTpl = $("pagesZipNameTemplate");

  const stripEl = $("pagesZipThumbStrip");
  const contentsEl = $("pagesZipZipContents");

  const selAllBtn = $("pagesZipSelectAllBtn");
  const clearBtn = $("pagesZipClearSelBtn");
  const oddsBtn = $("pagesZipSelectOddsBtn");
  const evensBtn = $("pagesZipSelectEvensBtn");

  const frameId = "pagesZipPreviewFrame";
  const placeholderId = "pagesZipPreviewPlaceholder";

  if (!fileInput || !runBtn) return;

  let originalFile = null;
  let unlockedFile = null;
  let previewUrl = null;
  let pageCount = 0;
  let cleanupStrip = null;
  const selected = new Set();

  function setStatus(msg) { if (statusEl) statusEl.textContent = msg || ""; }

  function setEmptyPreview() {
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = null;
    setIframeSrc(frameId, "");
    showPlaceholder(placeholderId, true);
  }

  function setPreviewFile(file) {
    try {
      const fr = $(frameId);
      if (fr) { fr.style.position = 'relative'; fr.style.top='-64px'; fr.style.height='calc(100% + 64px)'; }
    } catch {}
    try { if (previewUrl) URL.revokeObjectURL(previewUrl); } catch {}
    previewUrl = file ? URL.createObjectURL(file) : null;
    if (previewUrl) {
      setIframeSrc(frameId, previewUrl);
      showPlaceholder(placeholderId, false);
    } else {
      setEmptyPreview();
    }
  }

  function clearStrip() {
    try { cleanupStrip && cleanupStrip(); } catch {}
    cleanupStrip = null;
    selected.clear();
    pageCount = 0;
    if (stripEl) stripEl.innerHTML = '<div class="muted">Upload a PDF to generate selectable pages.</div>';
    renderContentsPreview();
  }

  function syncRangesFromSelection() {
    if (!rangesInput) return;
    const pages = Array.from(selected).sort((a,b)=>a-b);
    rangesInput.value = __pdfrealm_pagesToRanges(pages);
  }

  function syncSelectionFromRanges() {
    const pages = __pdfrealm_parseRanges(String(rangesInput?.value||""), pageCount || 999999);
    selected.clear();
    for (const p of pages) selected.add(p);
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=>{
      const p = parseInt(el.dataset.page||"",10);
      el.classList.toggle("selected", selected.has(p));
    });
    renderContentsPreview();
  }

  function renderContentsPreview() {
    if (!contentsEl) return;
    const base = __pdfrealm_baseName(originalFile?.name || "document");
    const fmt = String(formatSel?.value || "pdf");
    const ext = fmt === "pdf" ? "pdf" : (fmt === "png" ? "png" : "jpg");
    const tpl = String(nameTpl?.value || "{base}_p{page:0000}.{ext}");

    const pages = String(rangesInput?.value || "").trim()
      ? __pdfrealm_parseRanges(String(rangesInput.value||""), pageCount || 999999)
      : (selected.size ? Array.from(selected).sort((a,b)=>a-b) : Array.from({length: pageCount}, (_,i)=>i+1));

    const lines = [];
    const show = pages.slice(0, 300);
    for (const p of show) {
      lines.push(__pdfrealm_applyTemplate(tpl, base, p, ext));
    }
    if (pages.length > 300) lines.push("… and " + (pages.length-300) + " more");
    contentsEl.textContent = lines.join("\n") || "(upload a PDF)";
  }

  async function buildStrip(file) {
    clearStrip();
    if (!file || !stripEl) return;
    try {
      await ensurePDFLib();
      const { PDFDocument } = window.PDFLib;
      const ab = await __pdfrealmPdfFileToArrayBufferMaybeDecrypt(file);
      const doc = await PDFDocument.load(ab);
      pageCount = doc.getPageCount() || 0;

      cleanupStrip = __pdfrealm_buildThumbStrip(stripEl, {
        file,
        pageCount,
        selectedSet: selected,
        onToggle: () => { syncRangesFromSelection(); renderContentsPreview(); },
        dpi: 84
      });

      renderContentsPreview();
    } catch (e) {
      console.error(e);
      if (stripEl) stripEl.innerHTML = '<div class="muted">Failed to generate pages.</div>';
    }
  }

  fileInput.addEventListener("change", async () => {
    originalFile = fileInput.files && fileInput.files[0] ? fileInput.files[0] : null;
    unlockedFile = null;
    setStatus("");
    clearStrip();
    if (!originalFile) return setEmptyPreview();
    setPreviewFile(originalFile);
    await buildStrip(originalFile);
  });

  if (unlockBtn) {
    unlockBtn.addEventListener("click", async () => {
      try {
        const file = originalFile || (fileInput.files && fileInput.files[0]);
        if (!file) return setStatus("Choose a PDF first.");
        const password = (pwInput && pwInput.value) ? String(pwInput.value) : "";
        setStatus("Unlocking…");
        const dec = await decryptPdfToFile(file, password);
        if (!dec || !dec.ok) return setStatus(dec && dec.error ? dec.error : "Unlock failed.");
        unlockedFile = dec.file;
        setStatus("Unlocked (in this session).");
        setPreviewFile(unlockedFile);
        await buildStrip(unlockedFile);
      } catch (e) {
        console.error(e);
        setStatus("Unlock failed.");
      }
    });
  }

  // selection buttons
  selAllBtn?.addEventListener("click", () => {
    if (!pageCount) return;
    selected.clear();
    for (let p=1;p<=pageCount;p++) selected.add(p);
    syncRangesFromSelection();
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=> el.classList.add("selected"));
    renderContentsPreview();
  });
  clearBtn?.addEventListener("click", () => {
    selected.clear();
    if (rangesInput) rangesInput.value = "";
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=> el.classList.remove("selected"));
    renderContentsPreview();
  });
  oddsBtn?.addEventListener("click", () => {
    if (!pageCount) return;
    selected.clear();
    for (let p=1;p<=pageCount;p+=2) selected.add(p);
    syncRangesFromSelection();
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=>{
      const p = parseInt(el.dataset.page||"",10);
      el.classList.toggle("selected", selected.has(p));
    });
    renderContentsPreview();
  });
  evensBtn?.addEventListener("click", () => {
    if (!pageCount) return;
    selected.clear();
    for (let p=2;p<=pageCount;p+=2) selected.add(p);
    syncRangesFromSelection();
    stripEl?.querySelectorAll?.(".page-thumb")?.forEach?.((el)=>{
      const p = parseInt(el.dataset.page||"",10);
      el.classList.toggle("selected", selected.has(p));
    });
    renderContentsPreview();
  });

  rangesInput?.addEventListener("input", syncSelectionFromRanges);
  formatSel?.addEventListener("change", renderContentsPreview);
  nameTpl?.addEventListener("input", renderContentsPreview);

  runBtn.addEventListener("click", async () => {
    try {
      const file = unlockedFile || originalFile || (fileInput.files && fileInput.files[0]);
      if (!file) return setStatus("Choose a PDF first.");

      const base = __pdfrealm_baseName(originalFile?.name || "document");
      const fmt = String(formatSel?.value || "pdf");
      const ext = fmt === "pdf" ? "pdf" : (fmt === "png" ? "png" : "jpg");
      const tpl = String(nameTpl?.value || "{base}_p{page:0000}.{ext}");

      // Determine pages: typed ranges > selection > all
      const pages = String(rangesInput?.value || "").trim()
        ? __pdfrealm_parseRanges(String(rangesInput.value||""), pageCount || 999999)
        : (selected.size ? Array.from(selected).sort((a,b)=>a-b) : Array.from({length: pageCount}, (_,i)=>i+1));

      if (!pages.length) return setStatus("No pages selected.");

      // Paywall authorization
      setStatus("Authorizing export…");
      const fdAuth = new FormData();
      fdAuth.append("file", file);
      await runPaidPdfExport({
        tool: "pdf-to-pages-zip",
        endpoint: (ENDPOINTS.PDF_TO_PAGES_ZIP_AUTH || "/api/pdf-to-pages-zip/authorize"),
        formData: fdAuth,
        filename: null,
      });

      const JSZip = (typeof getJsZipAsync === "function")
        ? await getJsZipAsync()
        : await (async () => {
            const mod = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
            return mod.default || mod;
          })();
      const zip = new JSZip();

      if (fmt === "pdf") {
        setStatus("Loading PDF-Lib…");
        await ensurePDFLib();
        const { PDFDocument } = window.PDFLib;

        setStatus("Reading PDF…");
        const ab = await __pdfrealmPdfFileToArrayBufferMaybeDecrypt(file);
        const src = await PDFDocument.load(ab);

        setStatus("Splitting " + pages.length + " page(s)…");
        for (let i=0;i<pages.length;i++) {
          const p = pages[i];
          const out = await PDFDocument.create();
          const [cp] = await out.copyPages(src, [p-1]);
          out.addPage(cp);
          const bytes = await out.save();
          const name = __pdfrealm_applyTemplate(tpl, base, p, ext);
          zip.file(name, bytes);
          if ((i+1)%10===0) setStatus("Added " + (i+1) + " / " + pages.length + "…");
        }
      } else {
        // PNG/JPG via server render/page (enterprise-friendly image export)
        setStatus("Rendering " + pages.length + " page(s)…");
        for (let i=0;i<pages.length;i++) {
          const p = pages[i];
          const fd = new FormData();
          fd.append("file", file);
          fd.append("page", String(p));
          fd.append("dpi", "144"); // print-friendly default
          const res = await fetch("/api/render/page", { method: "POST", body: fd });
          if (!res.ok) throw new Error("Render failed for page " + p);
          const blobPng = await res.blob();

          if (fmt === "png") {
            zip.file(__pdfrealm_applyTemplate(tpl, base, p, "png"), blobPng);
          } else {
            // Convert PNG blob -> JPG in-browser
            const jpgBlob = await new Promise((resolve, reject) => {
              const img = new Image();
              const u = URL.createObjectURL(blobPng);
              img.onload = () => {
                try {
                  const c = document.createElement("canvas");
                  c.width = img.naturalWidth || img.width;
                  c.height = img.naturalHeight || img.height;
                  const ctx = c.getContext("2d");
                  ctx.drawImage(img, 0, 0);
                  c.toBlob((b) => {
                    try { URL.revokeObjectURL(u); } catch {}
                    if (!b) return reject(new Error("JPG conversion failed"));
                    resolve(b);
                  }, "image/jpeg", 0.92);
                } catch (e) { reject(e); }
              };
              img.onerror = () => { try { URL.revokeObjectURL(u); } catch {}; reject(new Error("Image decode failed")); };
              img.src = u;
            });
            zip.file(__pdfrealm_applyTemplate(tpl, base, p, "jpg"), jpgBlob);
          }

          if ((i+1)%10===0) setStatus("Added " + (i+1) + " / " + pages.length + "…");
        }
      }

      setStatus("Building ZIP…");
      const blob = await zip.generateAsync({ type: "blob" });
      downloadBlob(blob, base + "-pages.zip");
      setStatus("Done.");
    } catch (e) {
      console.error(e);
      setStatus("Failed: " + (e && e.message ? e.message : "Unknown error"));
    }
  });

  // Init
  setEmptyPreview();
  renderContentsPreview();
}

function initMetaSanitizeTool() {
  const fileInput = $("metaSanitizePdfFile");
  const pwInput = $("metaSanitizePdfPassword");
  const unlockBtn = $("metaSanitizeUnlockBtn");
  const runBtn = $("metaSanitizeBtn");
  const statusEl = $("metaSanitizeStatus");
  if (!fileInput || !runBtn) return;

  let originalFile = null;
  let unlockedFile = null;

  function setStatus(msg) { if (statusEl) statusEl.textContent = msg || ""; }

  fileInput.addEventListener("change", () => {
    originalFile = fileInput.files && fileInput.files[0] ? fileInput.files[0] : null;
    unlockedFile = null;
    setStatus("");
  });

  if (unlockBtn) {
    unlockBtn.addEventListener("click", async () => {
      try {
        const file = originalFile || (fileInput.files && fileInput.files[0]);
        if (!file) return setStatus("Choose a PDF first.");
        const password = (pwInput && pwInput.value) ? String(pwInput.value) : "";
        setStatus("Unlocking…");
        const dec = await decryptPdfToFile(file, password);
        if (!dec || !dec.ok) return setStatus(dec && dec.error ? dec.error : "Unlock failed.");
        unlockedFile = dec.file;
        setStatus("Unlocked (in this session).");
      } catch (e) {
        console.error(e);
        setStatus("Unlock failed.");
      }
    });
  }

  runBtn.addEventListener("click", async () => {
    try {
      const file = unlockedFile || originalFile || (fileInput.files && fileInput.files[0]);
      if (!file) return setStatus("Choose a PDF first.");
      setStatus("Sanitizing…");
      const fd = new FormData();
      fd.append("file", file);
      await runPaidPdfExport({
        tool: "meta-sanitize",
        endpoint: (ENDPOINTS.META_SANITIZE || "/api/meta/sanitize"),
        formData: fd,
        filename: "pdfrealm-sanitized.pdf",
      });
      setStatus("Done.");
    } catch (e) {
      console.error(e);
      setStatus("Failed: " + (e && e.message ? e.message : "Unknown error"));
    }
  });
}

function initRasterizeTool() {
  const fileInput = $("rasterizePdfFile");
  const pwInput = $("rasterizePdfPassword");
  const unlockBtn = $("rasterizeUnlockBtn");
  const dpiInput = $("rasterizeDpi");
  const runBtn = $("rasterizeBtn");
  const statusEl = $("rasterizeStatus");
  if (!fileInput || !runBtn) return;

  let originalFile = null;
  let unlockedFile = null;

  function setStatus(msg) { if (statusEl) statusEl.textContent = msg || ""; }

  fileInput.addEventListener("change", () => {
    originalFile = fileInput.files && fileInput.files[0] ? fileInput.files[0] : null;
    unlockedFile = null;
    setStatus("");
  });

  if (unlockBtn) {
    unlockBtn.addEventListener("click", async () => {
      try {
        const file = originalFile || (fileInput.files && fileInput.files[0]);
        if (!file) return setStatus("Choose a PDF first.");
        const password = (pwInput && pwInput.value) ? String(pwInput.value) : "";
        setStatus("Unlocking…");
        const dec = await decryptPdfToFile(file, password);
        if (!dec || !dec.ok) return setStatus(dec && dec.error ? dec.error : "Unlock failed.");
        unlockedFile = dec.file;
        setStatus("Unlocked (in this session).");
      } catch (e) {
        console.error(e);
        setStatus("Unlock failed.");
      }
    });
  }

  runBtn.addEventListener("click", async () => {
    try {
      const file = unlockedFile || originalFile || (fileInput.files && fileInput.files[0]);
      if (!file) return setStatus("Choose a PDF first.");

      const dpi = dpiInput && dpiInput.value ? String(dpiInput.value) : "150";

      setStatus("Rasterizing…");
      const fd = new FormData();
      fd.append("file", file);
      fd.append("dpi", dpi);

      await runPaidPdfExport({
        tool: "rasterize",
        endpoint: (ENDPOINTS.RASTERIZE || "/api/rasterize"),
        formData: fd,
        filename: "pdfrealm-rasterized.pdf",
      });
      setStatus("Done.");
    } catch (e) {
      console.error(e);
      setStatus("Failed: " + (e && e.message ? e.message : "Unknown error"));
    }
  });
}

// Run Pack2 initializers (safe even if tabs are hidden by caps)
document.addEventListener("DOMContentLoaded", () => {
  try { initPagesZip(); } catch (e) { console.warn(e); }
  try { initMetaSanitizeTool(); } catch (e) { console.warn(e); }
  try { initRasterizeTool(); } catch (e) { console.warn(e); }
});
// -------------------- Boot --------------------
  

// -------------------- Dev/Text → PDF tools (HTML/URL/JSON/MD/CSV/TXT) --------------------
function initCreatePdfTools() {
  const any = document.querySelector('[data-tool-view="html2pdf"], [data-tool-view="url2pdf"], [data-tool-view="json2pdf"], [data-tool-view="md2pdf"], [data-tool-view="csv2pdf"], [data-tool-view="txt2pdf"]');
  if (!any) return;

  const outputHosts = [
    'html2pdfOutputPreviewHost',
    'url2pdfOutputPreviewHost',
    'json2pdfOutputPreviewHost',
    'md2pdfOutputPreviewHost',
    'csv2pdfOutputPreviewHost',
    'txt2pdfOutputPreviewHost',
  ];
  for (const id of outputHosts) {
    const el = document.getElementById(id);
    if (el) el.addEventListener('contextmenu', (e) => e.preventDefault());
  }

  // PDF.js bootstrap (dynamic import; matches our OCR/QuickSign pattern)
  let _pdfJsPromise = null;
  async function getPdfJsAsync() {
    if (_pdfJsPromise) return _pdfJsPromise;
    _pdfJsPromise = (async () => {
      try {
        const mod = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.mjs');
        const lib = (mod && (mod.default || mod)) || null;
        if (lib && lib.GlobalWorkerOptions) {
          lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.mjs';
        }
        return lib;
      } catch (e1) {
        try {
          const mod2 = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs');
          const lib2 = (mod2 && (mod2.default || mod2)) || null;
          if (lib2 && lib2.GlobalWorkerOptions) {
            lib2.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs';
          }
          return lib2;
        } catch (e2) {
          console.error('PDF.js failed to load from CDN.', e1, e2);
          return null;
        }
      }
    })();
    return _pdfJsPromise;
  }

  async function renderPdfBlobToHost(blob, host) {
    const pdfjs = await getPdfJsAsync();
    if (!pdfjs) {
      host.innerHTML = '<div class="muted">PDF.js failed to load. Output preview unavailable.</div>';
      return;
    }

    const buf = await blob.arrayBuffer();
    const doc = await pdfjs.getDocument({ data: new Uint8Array(buf) }).promise;

    host.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.flexDirection = 'column';
    wrap.style.gap = '12px';
    wrap.style.alignItems = 'center';
    host.appendChild(wrap);

    const maxPages = Math.min(doc.numPages, 10);
    const hostW = Math.max(320, host.clientWidth || 820);
    const targetW = Math.min(940, hostW - 40);

    for (let i = 1; i <= maxPages; i++) {
      const page = await doc.getPage(i);
      const v1 = page.getViewport({ scale: 1 });
      const scale = Math.max(0.5, Math.min(2.0, targetW / v1.width));
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';
      canvas.style.borderRadius = '12px';
      canvas.style.boxShadow = '0 8px 28px rgba(0,0,0,.25)';
      canvas.style.background = 'white';

      await page.render({ canvasContext: ctx, viewport }).promise;
      wrap.appendChild(canvas);
    }
  }

  async function fetchPdfBlob(endpoint, formData) {
    const token = getToken?.();
    const headers = {};
    if (token) headers.Authorization = 'Bearer ' + token;

    const res = await fetch(endpoint, { method: 'POST', headers, body: formData });
    if (!res.ok) {
      let msg = '';
      try {
        const data = await res.json();
        msg = data?.error || JSON.stringify(data);
      } catch {
        msg = await res.text();
      }
      const err = new Error(msg || ('Request failed: ' + res.status));
      err.status = res.status;
      throw err;
    }
    return await res.blob();
  }

  function setStatus(id, msg) {
    const el = document.getElementById(id);
    if (el) el.textContent = msg || '';
  }

  function showOutput(placeholderId, hostId, show) {
    const ph = document.getElementById(placeholderId);
    const host = document.getElementById(hostId);
    if (ph) ph.style.display = show ? '' : 'none';
    if (host) host.style.display = show ? 'none' : '';
  }

  function wireTextTool({
    key,
    inputType,
    inputId,
    fileId,
    fieldName,
    previewBtnId,
    exportBtnId,
    statusId,
    outputPlaceholderId,
    outputHostId,
    previewEndpoint,
    exportEndpoint,
    exportFilename,
  }) {
    const previewBtn = document.getElementById(previewBtnId);
    const exportBtn = document.getElementById(exportBtnId);
    const outputHost = document.getElementById(outputHostId);
    if (!previewBtn || !exportBtn || !outputHost) return;

    // Optional file -> textarea helper
    if (fileId && inputId) {
      const fileInput = document.getElementById(fileId);
      const ta = document.getElementById(inputId);
      if (fileInput && ta) {
        fileInput.addEventListener('change', async () => {
          const f = fileInput.files && fileInput.files[0];
          if (!f) return;
          try {
            ta.value = await f.text();
          } catch (e) {
            console.error(e);
          }
        });
      }
    }

    previewBtn.addEventListener('click', async () => {
      try {
        setStatus(statusId, 'Working...');
        exportBtn.disabled = true;
        showOutput(outputPlaceholderId, outputHostId, true);

        const fd = new FormData();
        if (inputType === 'url') {
          const urlEl = document.getElementById(inputId);
          const url = (urlEl && urlEl.value || '').trim();
          fd.append(fieldName, url);
        } else {
          const ta = document.getElementById(inputId);
          const val = (ta && ta.value) || '';
          fd.append(fieldName, val);
        }

        const blob = await fetchPdfBlob(previewEndpoint, fd);
        await renderPdfBlobToHost(blob, outputHost);
        showOutput(outputPlaceholderId, outputHostId, false);
        exportBtn.disabled = false;
        setStatus(statusId, 'Preview ready.');
      } catch (err) {
        console.error(err);
        setStatus(statusId, String(err?.message || err) || 'Preview failed.');
        exportBtn.disabled = true;
        showOutput(outputPlaceholderId, outputHostId, true);
      }
    });

    exportBtn.addEventListener('click', async () => {
      try {
        const fd = new FormData();
        if (inputType === 'url') {
          const urlEl = document.getElementById(inputId);
          const url = (urlEl && urlEl.value || '').trim();
          fd.append(fieldName, url);
        } else {
          const ta = document.getElementById(inputId);
          const val = (ta && ta.value) || '';
          fd.append(fieldName, val);
        }
        await runPaidPdfExport({ endpoint: exportEndpoint, tool: key, formData: fd, filename: exportFilename });
      } catch (err) {
        console.error(err);
      }
    });
  }

  wireTextTool({
    key: 'html2pdf',
    inputType: 'text',
    inputId: 'html2pdfHtml',
    fileId: 'html2pdfFile',
    fieldName: 'html',
    previewBtnId: 'html2pdfPreviewBtn',
    exportBtnId: 'html2pdfExportBtn',
    statusId: 'html2pdfStatus',
    outputPlaceholderId: 'html2pdfOutputPlaceholder',
    outputHostId: 'html2pdfOutputPreviewHost',
    previewEndpoint: ENDPOINTS.HTML_TO_PDF_PREVIEW,
    exportEndpoint: ENDPOINTS.HTML_TO_PDF,
    exportFilename: 'pdfrealm-html.pdf',
  });

  wireTextTool({
    key: 'url2pdf',
    inputType: 'url',
    inputId: 'url2pdfUrl',
    fileId: null,
    fieldName: 'url',
    previewBtnId: 'url2pdfPreviewBtn',
    exportBtnId: 'url2pdfExportBtn',
    statusId: 'url2pdfStatus',
    outputPlaceholderId: 'url2pdfOutputPlaceholder',
    outputHostId: 'url2pdfOutputPreviewHost',
    previewEndpoint: ENDPOINTS.URL_TO_PDF_PREVIEW,
    exportEndpoint: ENDPOINTS.URL_TO_PDF,
    exportFilename: 'pdfrealm-url.pdf',
  });

  wireTextTool({
    key: 'json2pdf',
    inputType: 'text',
    inputId: 'json2pdfJson',
    fileId: 'json2pdfFile',
    fieldName: 'json',
    previewBtnId: 'json2pdfPreviewBtn',
    exportBtnId: 'json2pdfExportBtn',
    statusId: 'json2pdfStatus',
    outputPlaceholderId: 'json2pdfOutputPlaceholder',
    outputHostId: 'json2pdfOutputPreviewHost',
    previewEndpoint: ENDPOINTS.JSON_TO_PDF_PREVIEW,
    exportEndpoint: ENDPOINTS.JSON_TO_PDF,
    exportFilename: 'pdfrealm-json.pdf',
  });

  wireTextTool({
    key: 'md2pdf',
    inputType: 'text',
    inputId: 'md2pdfMd',
    fileId: null,
    fieldName: 'markdown',
    previewBtnId: 'md2pdfPreviewBtn',
    exportBtnId: 'md2pdfExportBtn',
    statusId: 'md2pdfStatus',
    outputPlaceholderId: 'md2pdfOutputPlaceholder',
    outputHostId: 'md2pdfOutputPreviewHost',
    previewEndpoint: ENDPOINTS.MARKDOWN_TO_PDF_PREVIEW,
    exportEndpoint: ENDPOINTS.MARKDOWN_TO_PDF,
    exportFilename: 'pdfrealm-markdown.pdf',
  });

  wireTextTool({
    key: 'csv2pdf',
    inputType: 'text',
    inputId: 'csv2pdfCsv',
    fileId: 'csv2pdfFile',
    fieldName: 'csv',
    previewBtnId: 'csv2pdfPreviewBtn',
    exportBtnId: 'csv2pdfExportBtn',
    statusId: 'csv2pdfStatus',
    outputPlaceholderId: 'csv2pdfOutputPlaceholder',
    outputHostId: 'csv2pdfOutputPreviewHost',
    previewEndpoint: ENDPOINTS.CSV_TO_PDF_PREVIEW,
    exportEndpoint: ENDPOINTS.CSV_TO_PDF,
    exportFilename: 'pdfrealm-csv.pdf',
  });

  wireTextTool({
    key: 'txt2pdf',
    inputType: 'text',
    inputId: 'txt2pdfText',
    fileId: null,
    fieldName: 'text',
    previewBtnId: 'txt2pdfPreviewBtn',
    exportBtnId: 'txt2pdfExportBtn',
    statusId: 'txt2pdfStatus',
    outputPlaceholderId: 'txt2pdfOutputPlaceholder',
    outputHostId: 'txt2pdfOutputPreviewHost',
    previewEndpoint: ENDPOINTS.TEXT_TO_PDF_PREVIEW,
    exportEndpoint: ENDPOINTS.TEXT_TO_PDF,
    exportFilename: 'pdfrealm-text.pdf',
  });
}

document.addEventListener("DOMContentLoaded", () => {
    const __safeInit = (name, fn) => {
      try {
        if (typeof fn === "function") fn();
      } catch (e) {
        console.error(`[pdfrealm] init failed: ${name}`, e);
      }
    };

  __safeInit("setYear", setYear);
  __safeInit("initTabs", initTabs);
  __safeInit("initCapabilities", initCapabilities);
  __safeInit("initAccount", initAccount);
  __safeInit("updateAccountDot", updateAccountDot);
  __safeInit("capturePpeSuccessFromUrl", capturePpeSuccessFromUrl);
  __safeInit("initStudio", initStudio);
  __safeInit("initQuickSign", initQuickSign);
  __safeInit("initPassword", initPassword);
  __safeInit("initMerge", initMerge);
  __safeInit("initDeletePages", initDeletePages);
  __safeInit("initSplit", initSplit);
  __safeInit("initReorderSecure", initReorderSecure);
  __safeInit("initCompressSecure", initCompressSecure);
  __safeInit("initWatermarkSecure", initWatermarkSecure);
  __safeInit("initPageNumsSecure", initPageNumsSecure);
  __safeInit("initStampSecure", initStampSecure);
  __safeInit("initRedactSecure", initRedactSecure);
  __safeInit("initFlattenSecure", initFlattenSecure);
  __safeInit("initMetadataSecure", initMetadataSecure);
  __safeInit("initRepairSecure", initRepairSecure);
  __safeInit("initBlankSecure", initBlankSecure);
  __safeInit("initResizeSecure", initResizeSecure);
  __safeInit("initExtractText", initExtractText);
  __safeInit("initCompare", initCompare);

  __safeInit("initConvert", initConvert);
  __safeInit("initCreatePdfTools", initCreatePdfTools);
  __safeInit("initMoreToolsPreview", initMoreToolsPreview);
  __safeInit("initMoreToolsActions", initMoreToolsActions);
  __safeInit("initRotateInteractive", initRotateInteractive);
  __safeInit("initOcr", initOcr);
  __safeInit("initTemplates", initTemplates);
// Secure Vault tab wiring (no-op if elements are absent)
  __safeInit("initVault", initVault);

__safeInit("initSecureSend", initSecureSend);
__safeInit("initSecureChat", initQuickSecureChat);
__safeInit("initSecureVideo", initQuickSecureVideo);
__safeInit("initSecureVoip", initQuickSecureVoip);
__safeInit("initEncryptedContainers", initEncryptedContainers);
__safeInit("autoRouteSecureInvites", autoRouteSecureInvites);

  });


// [pdfrealm] FIX_DOCX2PNG_INPUTPREVIEW_V1
(function(){
  if (globalThis.__pdfrealm_docx2png_fix_v1) return;
  globalThis.__pdfrealm_docx2png_fix_v1 = true;

  const BAD_MSG = "This PDF file is encrypted and can't be opened.";

  function findRoot(){
    // Find the DOCX->PNG tool by its unique Output Preview title if possible
    const leafs = Array.from(document.querySelectorAll("*"))
      .filter(el => el.children.length === 0 && (el.textContent || "").trim().length);
    const byTitle = leafs.find(el => /Output Preview\s*\(PNG ZIP\)/i.test(el.textContent || ""));
    const seed = byTitle || leafs.find(el => /^DOCX file$/i.test((el.textContent || "").trim()));
    if (!seed) return null;

    // Walk up until we have file input + Preview input button in the same container
    for (let p = seed; p && p !== document.body; p = p.parentElement) {
      const hasFile = !!p.querySelector('input[type="file"]');
      const hasPrev = Array.from(p.querySelectorAll("button")).some(b => /preview\s*input/i.test(b.textContent || ""));
      if (hasFile && hasPrev) return p;
    }
    return null;
  }

  function pick(root){
    const file = root.querySelector('input[type="file"]');

    const btn = (re) => Array.from(root.querySelectorAll("button")).find(b => re.test((b.textContent || "").trim()));
    const previewBtn = btn(/preview\s*input/i);

    // Best-effort: find input preview host inside the same tool (prefer ids containing input+preview)
    const inputHost =
      root.querySelector('[id*="InputPreviewHost" i]') ||
      root.querySelector('[id*="input" i][id*="preview" i]') ||
      null;

    // Placeholder / message area (where the bad PDF encrypted text lives)
    const inputPlaceholder =
      root.querySelector('[id*="InputPlaceholder" i]') ||
      Array.from(root.querySelectorAll(".placeholder")).find(el => (el.textContent || "").includes(BAD_MSG)) ||
      null;

    return { file, previewBtn, inputHost, inputPlaceholder };
  }

  async function doPreview(file, inputHost, inputPlaceholder){
    // Replace the bad message regardless of preview success
    try {
      if (inputPlaceholder && (inputPlaceholder.textContent || "").includes(BAD_MSG)) {
        inputPlaceholder.textContent = "Upload a DOCX to preview it here.";
      }
      // Sometimes the bad text is inside the host itself:
      if (inputHost && (inputHost.textContent || "").trim() === BAD_MSG) {
        inputHost.textContent = "";
      }
    } catch {}

    if (!file || !inputHost) return;

    inputHost.innerHTML = "";
    if (inputPlaceholder) inputPlaceholder.style.display = "none";

    // Use global callJson if present
    const call = (typeof globalThis.callJson === "function") ? globalThis.callJson : null;
    if (!call) {
      inputHost.innerHTML = '<div class="muted">Preview helper (callJson) missing.</div>';
      return;
    }

    const fd = new FormData();
    fd.append("file", file);

    try {
      const r = await call("/api/word-to-pdf/input-preview", fd);
      const html = (r && r.html) ? String(r.html) : "";
      inputHost.innerHTML = html || '<div class="muted">No input preview available.</div>';
    } catch (e) {
      inputHost.innerHTML = '<div class="muted">Input preview unavailable on this server.</div>';
    }
  }

  function bindOnce(){
    const root = findRoot();
    if (!root) return false;

    if (root.dataset.pdfrealmDocx2pngBound === "1") return true;
    root.dataset.pdfrealmDocx2pngBound = "1";

    const { file, previewBtn, inputHost, inputPlaceholder } = pick(root);

    // Always fix the bad message immediately
    try {
      if (inputPlaceholder && (inputPlaceholder.textContent || "").includes(BAD_MSG)) {
        inputPlaceholder.textContent = "Upload a DOCX to preview it here.";
      }
      // Fix if the text is sitting in the host
      if (inputHost && (inputHost.textContent || "").trim() === BAD_MSG) {
        inputHost.textContent = "";
      }
      // Fix any other occurrence inside this tool only
      Array.from(root.querySelectorAll("*")).forEach(el => {
        if (el.children.length === 0 && (el.textContent || "").trim() === BAD_MSG) {
          el.textContent = "Upload a DOCX to preview it here.";
        }
      });
    } catch {}

    if (file) {
      file.addEventListener("change", async () => {
        const f = file.files && file.files[0];
        if (!f) return;
        await doPreview(f, inputHost, inputPlaceholder);
      });
    }

    if (previewBtn) {
      previewBtn.addEventListener("click", async (e) => {
        const f = file && file.files && file.files[0];
        if (!f) return alert("Upload a DOCX first.");
        await doPreview(f, inputHost, inputPlaceholder);
      });
    }

    return true;
  }

  // Try a few times to bind (tabs can render later)
  let tries = 0;
  const t = setInterval(() => {
    tries++;
    if (bindOnce() || tries > 20) clearInterval(t);
  }, 250);
})();


// [pdfrealm] IMAGE_TO_PDF_INPUTPREVIEW_UI_V1
(function(){
  if (window.__pdfrealm_img2pdf_inputpreview_v1) return;
  window.__pdfrealm_img2pdf_inputpreview_v1 = true;

  const CDN_PAKO = "https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js";
  const CDN_UTIF = "https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js";

  function byId(id){ return document.getElementById(id); }

  function showPH(id, show){
    const el = byId(id);
    if (!el) return;
    el.style.display = show ? "" : "none";
  }

  function loadScriptOnce(src){
    return new Promise((resolve, reject) => {
      const existing = Array.from(document.scripts || []).find(s => s.src === src);
      if (existing) return resolve();
      const s = document.createElement("script");
      s.src = src;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }

  let _utifPromise = null;
  async function getUTIF(){
    if (window.UTIF && (window.UTIF.decode || window.UTIF.decodeImage || window.UTIF.decodeImages)) return window.UTIF;
    if (_utifPromise) return _utifPromise;
    _utifPromise = (async () => {
      try {
        if (!window.pako) await loadScriptOnce(CDN_PAKO);
        await loadScriptOnce(CDN_UTIF);
        return window.UTIF || null;
      } catch (e) {
        console.error(e);
        return null;
      }
    })();
    return _utifPromise;
  }

  async function renderTiffToHost(file, host){
    const UTIF = await getUTIF();
    if (!UTIF) {
      host.innerHTML = '<div class="muted">TIFF preview requires UTIF.js (failed to load).</div>';
      return;
    }
    const buf = await file.arrayBuffer();
    const ifds = UTIF.decode(buf);
    if (!ifds || !ifds.length) {
      host.innerHTML = '<div class="muted">Unable to decode TIFF.</div>';
      return;
    }
    try {
      if (typeof UTIF.decodeImages === "function") UTIF.decodeImages(buf, ifds);
      else if (typeof UTIF.decodeImage === "function") ifds.forEach(ifd => UTIF.decodeImage(buf, ifd));
    } catch (e) {
      console.error(e);
      host.innerHTML = '<div class="muted">Unable to decode this TIFF (compression not supported in-browser).</div>';
      return;
    }

    const first = ifds[0];
    const rgba = UTIF.toRGBA8(first);
    const w = first.width;
    const h = first.height;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    canvas.style.maxWidth = "100%";
    canvas.style.height = "auto";
    canvas.style.borderRadius = "12px";
    canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
    canvas.style.background = "white";

    const ctx = canvas.getContext("2d");
    const imgData = new ImageData(new Uint8ClampedArray(rgba), w, h);
    ctx.putImageData(imgData, 0, 0);

    host.innerHTML = "";
    host.appendChild(canvas);
  }

  function ensureInputPreviewPanel(toolKey, placeholderId, hostId, placeholderText){
    const toolView = document.querySelector('.tool-view[data-tool-view="' + toolKey + '"]');
    if (!toolView) return;

    // if already exists, do nothing
    if (byId(hostId) && byId(placeholderId)) return;

    const leftCol = toolView.querySelector(".grid2 > div");
    if (!leftCol) return;

    const uploadCard = leftCol.querySelector(".card");
    if (!uploadCard) return;

    const card = document.createElement("div");
    card.className = "card viewer-card";
    card.innerHTML =
      '<div class="viewer-top">' +
        '<div class="viewer-title">Input Preview</div>' +
      '</div>' +
      '<div class="viewer-wrapper" style="position:relative;overflow:hidden;">' +
        '<div id="' + placeholderId + '" class="placeholder">' + (placeholderText || "Upload a file to preview it here.") + '</div>' +
        '<div id="' + hostId + '" class="ocr-preview-host" style="position:absolute;inset:0;overflow:auto;padding:12px;user-select:none;"></div>' +
      '</div>';

    // insert right after upload card
    if (uploadCard.nextSibling) leftCol.insertBefore(card, uploadCard.nextSibling);
    else leftCol.appendChild(card);
  }

  function ensurePreviewInputButton(uploadCard, btnId){
    if (byId(btnId)) return;
    const btnRow = document.createElement("div");
    btnRow.style.display = "flex";
    btnRow.style.gap = "10px";
    btnRow.style.alignItems = "flex-end";
    btnRow.style.flexWrap = "wrap";
    btnRow.style.marginTop = "10px";
    btnRow.innerHTML =
      '<div><button id="' + btnId + '" class="btn btn-secondary" type="button">Preview input</button></div>';

    // place before .tool-actions if possible, else at end of card
    const actions = uploadCard.querySelector(".tool-actions");
    if (actions) uploadCard.insertBefore(btnRow, actions);
    else uploadCard.appendChild(btnRow);
  }

  const urls = Object.create(null);

  function renderImageFileToHost(file, host, toolKey, alt){
    if (urls[toolKey]) { try { URL.revokeObjectURL(urls[toolKey]); } catch {} }
    urls[toolKey] = URL.createObjectURL(file);

    host.innerHTML = "";
    const img = document.createElement("img");
    img.src = urls[toolKey];
    img.alt = alt || "Preview";
    img.draggable = false;
    img.style.maxWidth = "100%";
    img.style.height = "auto";
    img.style.borderRadius = "12px";
    img.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
    img.style.background = "white";
    host.appendChild(img);
  }

  function wireTool(cfg){
    const toolView = document.querySelector('.tool-view[data-tool-view="' + cfg.toolKey + '"]');
    if (!toolView) return;

    // Create UI if missing
    ensureInputPreviewPanel(cfg.toolKey, cfg.phId, cfg.hostId, cfg.phText);

    const leftCol = toolView.querySelector(".grid2 > div");
    const uploadCard = leftCol ? leftCol.querySelector(".card") : null;
    if (uploadCard) ensurePreviewInputButton(uploadCard, cfg.btnId);

    const fileInput = byId(cfg.fileId);
    const btn = byId(cfg.btnId);
    const host = byId(cfg.hostId);

    if (!fileInput || !btn || !host) return;

    // avoid double-binding
    if (host.dataset.pdfrealmBound === "1") return;
    host.dataset.pdfrealmBound = "1";

    host.addEventListener("contextmenu", e => e.preventDefault());
    host.style.userSelect = "none";

    async function doPreview(){
      const f = fileInput.files && fileInput.files[0];
      if (!f) {
        host.innerHTML = "";
        showPH(cfg.phId, true);
        return;
      }
      try {
        if (cfg.kind === "tiff") {
          await renderTiffToHost(f, host);
        } else if (cfg.kind === "svg") {
          renderImageFileToHost(f, host, cfg.toolKey, "SVG preview");
        } else {
          renderImageFileToHost(f, host, cfg.toolKey, "Image preview");
        }
        showPH(cfg.phId, false);
      } catch (e) {
        console.error(e);
        host.innerHTML = '<div class="muted">Unable to preview this file in your browser.</div>';
        showPH(cfg.phId, false);
      }
    }

    fileInput.addEventListener("change", doPreview);
    btn.addEventListener("click", () => {
      if (!(fileInput.files && fileInput.files[0])) return alert("Upload a file first.");
      doPreview();
    });
  }

  function init(){
    wireTool({
      toolKey: "jpg2pdf",
      fileId: "jpgToPdfFile",
      btnId: "jpgToPdfInputPreviewBtn",
      phId: "jpg2pdfInputPlaceholder",
      hostId: "jpg2pdfInputPreviewHost",
      phText: "Upload a JPG to preview it here.",
      kind: "image"
    });

    wireTool({
      toolKey: "png2pdf",
      fileId: "pngToPdfFile",
      btnId: "pngToPdfInputPreviewBtn",
      phId: "png2pdfInputPlaceholder",
      hostId: "png2pdfInputPreviewHost",
      phText: "Upload a PNG to preview it here.",
      kind: "image"
    });

    wireTool({
      toolKey: "tiff2pdf",
      fileId: "tiffToPdfFile",
      btnId: "tiffToPdfInputPreviewBtn",
      phId: "tiff2pdfInputPlaceholder",
      hostId: "tiff2pdfInputPreviewHost",
      phText: "Upload a TIFF to preview it here.",
      kind: "tiff"
    });

    wireTool({
      toolKey: "svg2pdf",
      fileId: "svgToPdfFile",
      btnId: "svgToPdfInputPreviewBtn",
      phId: "svg2pdfInputPlaceholder",
      hostId: "svg2pdfInputPreviewHost",
      phText: "Upload an SVG to preview it here.",
      kind: "svg"
    });
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();


/* ===========================================================
   PDFREALM_SECURE_QUICKTOOLS_LEFT_SIDEBAR (Secure Send/Chat/Video/VoIP + Containers)
   - Additive only: does not touch existing tools.
   - Uses server endpoints already present in PDFRealm.
   =========================================================== */

function qtCopy(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(String(text || "")).catch(() => {});
      return;
    }
  } catch (_) {}
  try {
    const ta = document.createElement("textarea");
    ta.value = String(text || "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    document.execCommand("copy");
    ta.remove();
  } catch (_) {}
}

function qtExtractTokenOrLink(raw) {
  const s = String(raw || "").trim();
  if (!s) return "";
  try {
    if (s.includes("://")) {
      const u = new URL(s);
      // try common query params
      const q = u.searchParams.get("invite") || u.searchParams.get("token") || "";
      if (q) return q;
      // fall back to last path segment
      const seg = u.pathname.split("/").filter(Boolean).pop() || "";
      return seg;
    }
  } catch (_) {}
  return s;
}

function qtHashParams() {
  try {
    const h = (window.location.hash || "").replace(/^#/, "");
    const q = new URLSearchParams(h);
    return q;
  } catch (_) {
    return new URLSearchParams();
  }
}

function qtBytesToB64Url(u8) {
  const b64 = btoa(String.fromCharCode(...new Uint8Array(u8)));
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function qtB64UrlToBytes(b64u) {
  const s = String(b64u || "").replace(/-/g, "+").replace(/_/g, "/");
  const pad = s.length % 4 ? "=".repeat(4 - (s.length % 4)) : "";
  const bin = atob(s + pad);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

async function qtImportAesKey(keyB64u) {
  const raw = qtB64UrlToBytes(keyB64u);
  return crypto.subtle.importKey("raw", raw, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
}

async function qtEncrypt(key, plaintext) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(String(plaintext || ""));
  const buf = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc);
  return { ciphertext: qtBytesToB64Url(new Uint8Array(buf)), nonce: qtBytesToB64Url(iv) };
}

async function qtDecrypt(key, ciphertextB64u, nonceB64u) {
  const iv = qtB64UrlToBytes(nonceB64u);
  const ct = qtB64UrlToBytes(ciphertextB64u);
  const buf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
  return new TextDecoder().decode(buf);
}

function qtMergeAuthHeaders(headers) {
  const h = new Headers(headers || {});
  try {
    const t = (typeof getToken === "function") ? getToken() : "";
    if (t && !h.has("Authorization")) h.set("Authorization", "Bearer " + t);
  } catch (_) {}
  return h;
}

async function qtFetchJson(url, opts) {
  const o = Object.assign({ method: "GET" }, (opts || {}));
  o.headers = qtMergeAuthHeaders(o.headers);
  const r = await fetch(url, o);
  const txt = await r.text();
  let data = null;
  try { data = txt ? JSON.parse(txt) : null; } catch (_) {}
  if (!r.ok) {
    const msg = (data && (data.error || data.message)) ? (data.error || data.message) : (txt || `HTTP ${r.status}`);
    const err = new Error(msg);
    err.status = r.status;
    err.data = data;
    throw err;
  }
  return data;
}


/* -----------------------------
   Secure AI Notes Assistant (Option A)
   - Consent modal
   - Active session polling
   - Audio (WebRTC mixed) chunk upload
   - Chat transcript upload + PDF generation
   ----------------------------- */
// /PDFREALM_SECURE_AI_NOTES_ASSISTANT_CLIENT_V1
const SECURE_AI_NOTES = (() => {
  const POLL_MS = 1500;
  const JOB_POLL_MS = 2000;

  const state = {
    consentModalWired: false,
    pendingConsent: null // { sessionId }
  };

  function el(id) { return document.getElementById(id); }

  function setDisabled(node, disabled) {
    if (!node) return;
    node.disabled = !!disabled;
  }

  function setVisible(node, visible) {
    if (!node) return;
    node.style.display = visible ? "" : "none";
  }

  function setText(node, txt) {
    if (!node) return;
    node.textContent = txt || "";
  }

  async function apiJson(url, opts) {
    return await qtFetchJson(url, opts);
  }

  async function createSession({ sessionType, contextId, title }) {
    const body = { sessionType, contextId, title };
    return await apiJson("/api/secure-ai/session", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
  }

  async function getActive({ sessionType, contextId }) {
    const qs = new URLSearchParams({ sessionType, contextId });
    const url = `/api/secure-ai/active?${qs.toString()}`;

    // Don't throw on 403 (guest / not-authed polling). Treat as inactive.
    const res = await fetch(url, { method: "GET", headers: qtMergeAuthHeaders() });
    if (res.status === 403) {
      try { return await res.json(); } catch { return { active: false }; }
    }
    const txt = await res.text();
    let data = null;
    try { data = txt ? JSON.parse(txt) : null; } catch (_) {}
    if (!res.ok) {
      const msg = (data && (data.error || data.message)) ? (data.error || data.message) : (txt || `HTTP ${res.status}`);
      const err = new Error(msg);
      err.status = res.status;
      err.data = data;
      throw err;
    }
    return data;
  }

  async function sendConsent(sessionId, consent) {
    return await apiJson(`/api/secure-ai/session/${encodeURIComponent(sessionId)}/consent`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ consent: !!consent })
    });
  }

  async function markRecordingStarted(sessionId) {
    return await apiJson(`/api/secure-ai/session/${encodeURIComponent(sessionId)}/start`, { method: "POST" });
  }

  async function uploadChunk(sessionId, seq, blob, mimeType) {
    const fd = new FormData();
    fd.append("seq", String(seq));
    fd.append("mimeType", mimeType || "audio/webm");
    fd.append("chunk", blob, `chunk_${String(seq).padStart(6, "0")}.webm`);

    const res = await fetch(`/api/secure-ai/session/${encodeURIComponent(sessionId)}/chunk`, {
      method: "POST",
      headers: qtMergeAuthHeaders(),
      body: fd
    });
    if (!res.ok) {
      const txt = await res.text();
      const err = new Error(txt || `HTTP ${res.status}`);
      err.status = res.status;
      throw err;
    }
    return await res.json().catch(() => ({}));
  }

  async function uploadChatTranscript(sessionId, transcriptObj) {
    return await apiJson(`/api/secure-ai/session/${encodeURIComponent(sessionId)}/chat-transcript`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(transcriptObj || {})
    });
  }

  async function finalize(sessionId) {
    return await apiJson(`/api/secure-ai/session/${encodeURIComponent(sessionId)}/finalize`, { method: "POST" });
  }

  async function getJob(jobId) {
    return await apiJson(`/api/secure-ai/job/${encodeURIComponent(jobId)}`);
  }

  async function deleteSession(sessionId) {
    return await apiJson(`/api/secure-ai/session/${encodeURIComponent(sessionId)}`, { method: "DELETE" });
  }

  function downloadReport(sessionId) {
    window.open(`/api/secure-ai/session/${encodeURIComponent(sessionId)}/report`, "_blank");
  }

  function ensureConsentModalWired() {
    if (state.consentModalWired) return;
    state.consentModalWired = true;

    const modalId = "secureAiConsentModal";
    const acceptBtn = el("secureAiConsentAccept");
    const declineBtn = el("secureAiConsentDecline");
    const closeBtn = el("secureAiConsentClose");

    async function decide(consent) {
      const pending = state.pendingConsent;
      if (!pending || !pending.sessionId) return closeModal(modalId);
      const sid = pending.sessionId;
      try {
        setText(el("secureAiConsentStatus"), "Submitting…");
        setDisabled(acceptBtn, true);
        setDisabled(declineBtn, true);
        await sendConsent(sid, consent);
        closeModal(modalId);
      } catch (e) {
        console.error(e);
        setText(el("secureAiConsentStatus"), "Error: " + (e.message || e));
      } finally {
        setDisabled(acceptBtn, false);
        setDisabled(declineBtn, false);
      }
    }

    acceptBtn?.addEventListener("click", () => decide(true));
    declineBtn?.addEventListener("click", () => decide(false));
    closeBtn?.addEventListener("click", () => closeModal(modalId));
  }

  function showConsentModal({ sessionId, title, sessionType }) {
    ensureConsentModalWired();
    state.pendingConsent = { sessionId };

    setText(el("secureAiConsentStatus"), "");
    const base = title ? `“${title}”` : "This session";
    const isChat = String(sessionType || "") === "chat";

    const msg = isChat
      ? `${base} will be summarized into a PDF report. To generate it, the chat owner uploads a decrypted transcript to the server (not end-to-end encrypted). Do you consent?`
      : `${base} audio will be recorded and uploaded to the server to generate a PDF report (not end-to-end encrypted). Do you consent?`;

    setText(el("secureAiConsentText"), msg);

    openModal("secureAiConsentModal");
  }

  function describeStatus(s) {
    if (!s) return "";
    const st = String(s.status || "");
    const p = String(s.progress || "");
    const err = s.error ? String(s.error) : "";
    const line = st + (p ? ` — ${p}` : "");
    return err ? `${line} — ${err}` : line;
  }

  function startActivePolling(cfg) {
    let timer = null;
    let stopped = false;

    async function tick() {
      if (stopped) return;
      const ctxId = (cfg.getContextId && cfg.getContextId()) || "";
      const sessionType = cfg.sessionType;

      // Always keep UI sane even when no room/thread yet
      if (!ctxId) {
        cfg.onUpdate && cfg.onUpdate({ active: false });
        return;
      }

      try {
        const active = await getActive({ sessionType, contextId: ctxId });
        cfg.onUpdate && cfg.onUpdate(active);
      } catch (e) {
        // Don't spam the UI on transient errors
        cfg.onUpdate && cfg.onUpdate({ active: false, error: e.message || String(e) });
      }
    }

    timer = window.setInterval(tick, POLL_MS);
    tick();

    return () => {
      stopped = true;
      if (timer) window.clearInterval(timer);
    };
  }

  function startJobPolling(cfg) {
    let timer = null;
    let stopped = false;

    async function tick() {
      if (stopped) return;
      const jobId = cfg.jobId;
      if (!jobId) return;
      try {
        const j = await getJob(jobId);
        cfg.onUpdate && cfg.onUpdate(j);
      } catch (e) {
        cfg.onUpdate && cfg.onUpdate({ status: "FAILED", error: e.message || String(e) });
      }
    }

    timer = window.setInterval(tick, JOB_POLL_MS);
    tick();

    return () => {
      stopped = true;
      if (timer) window.clearInterval(timer);
    };
  }

  function attachAudioAddon(cfg) {
    const st = {
      desiredOn: false,
      sessionId: null,
      jobId: null,
      seq: 0,
      recorderHandle: null,
      lastActive: null,
      stopping: false,
      lastPromptSessionId: null,
      activePollStop: null,
      jobPollStop: null
    };

    const toggleEl = cfg.toggleEl;
    const indicatorEl = cfg.indicatorEl;
    const statusEl = cfg.statusEl;
    const finalizeBtn = cfg.finalizeBtn;
    const downloadBtn = cfg.downloadBtn;
    const deleteBtn = cfg.deleteBtn;

    function isHost() {
      try { return !!(cfg.getIsHost && cfg.getIsHost()); } catch (_) { return false; }
    }

    function hasContext() {
      const ctx = (cfg.getContextId && cfg.getContextId()) || "";
      return !!ctx;
    }

    function setUiStatus(msg, isErr) {
      if (!statusEl) return;
      statusEl.style.color = isErr ? "var(--danger, #ef4444)" : "var(--muted)";
      statusEl.textContent = msg || "";
    }

    function syncButtons() {
      const host = isHost();
      setDisabled(finalizeBtn, !host || !st.sessionId);
      setDisabled(deleteBtn, !host || !st.sessionId);
      setDisabled(downloadBtn, !st.sessionId || !(st.lastActive && st.lastActive.reportReady));
    }

    function syncIndicator() {
      const rec = !!(st.lastActive && st.lastActive.status === "RECORDING");
      setVisible(indicatorEl, rec);
    }

    function setToggleEnabled() {
      if (!toggleEl) return;
      const host = isHost();
      // Host can toggle only after room exists; guests see status/indicator and can download
      toggleEl.disabled = !host || !hasContext();
    }

    async function ensureHostSession() {
      if (st.sessionId) return st.sessionId;
      if (!isHost()) throw new Error("Only the room owner can start AI Notes.");
      const ctxId = (cfg.getContextId && cfg.getContextId()) || "";
      if (!ctxId) throw new Error("Create or join a room first.");
      const created = await createSession({
        sessionType: cfg.sessionType,
        contextId: ctxId,
        title: (cfg.getTitle && cfg.getTitle()) || ""
      });
      st.sessionId = created.sessionId;
      st.seq = 0;
      syncButtons();
      return st.sessionId;
    }

    async function stopRecorder() {
      if (!st.recorderHandle) return;
      try {
        await st.recorderHandle.stop();
      } catch (_) {}
      st.recorderHandle = null;
    }

    async function maybeStartRecorder() {
      if (!st.desiredOn) return;
      if (!isHost()) return;
      if (!st.sessionId) return;

      // Need call media available
      const call = cfg.getCall && cfg.getCall();
      const localStream = call && call.getLocalStream ? call.getLocalStream() : null;
      if (!localStream) {
        setUiStatus("AI Notes enabled — start the call to begin recording.");
        return;
      }

      // Only record when server confirms all consents
      if (!(st.lastActive && st.lastActive.allConsented)) {
        await stopRecorder();
        setUiStatus("Waiting for everyone to consent…");
        return;
      }

      // Already recording
      if (st.recorderHandle) return;

      // Mark server state as recording (indicator for everyone)
      try { await markRecordingStarted(st.sessionId); } catch (_) {}

      const getRemoteStreams = () => (call && call.getRemoteStreams) ? call.getRemoteStreams() : [];

      // Wire remote stream updates → recorder
      if (call && call.onRemoteStream) {
        try {
          call.onRemoteStream((stream) => {
            try { st.recorderHandle && st.recorderHandle.addRemoteStream && st.recorderHandle.addRemoteStream(stream); } catch (_) {}
          });
        } catch (_) {}
      }

      setUiStatus("Recording…");
      try {
        st.recorderHandle = await window.SecureAiRecorder.startRecording({
          sessionId: st.sessionId,
          localStream,
          getRemoteStreams,
          timesliceMs: 3000,
          uploadChunk: async (_localSeq, blob, mimeType) => {
            // Global seq across restarts
            return await uploadChunk(st.sessionId, st.seq++, blob, mimeType);
          },
          onState: (ev) => {
            if (!ev) return;
            if (ev.phase === "ERROR") {
              const e = ev.error;
              if (e && e.status === 409) {
                // Consent changed; pause
                stopRecorder();
                setUiStatus("Paused — waiting for consent…");
              } else {
                console.error(e);
                stopRecorder();
                setUiStatus("Upload error: " + (e?.message || e), true);
              }
            }
          }
        });
      } catch (e) {
        console.error(e);
        await stopRecorder();
        setUiStatus("Recorder error: " + (e.message || e), true);
      }
    }

    async function stopAndFinalize() {
      if (!isHost()) return;
      if (!st.sessionId) return;
      if (st.stopping) return;
      st.stopping = true;

      try {
        st.desiredOn = false;
        if (toggleEl) toggleEl.checked = false;
        await stopRecorder();
        setUiStatus("Finalizing…");

        const fin = await finalize(st.sessionId);
        st.jobId = fin.jobId;

        // Poll job status
        if (st.jobPollStop) st.jobPollStop();
        st.jobPollStop = startJobPolling({
          jobId: st.jobId,
          onUpdate: (j) => {
            if (!j) return;
            if (j.status === "READY") {
              setUiStatus("Ready — PDF report available.");
              // refresh active so reportReady toggles
              st.lastActive = Object.assign({}, st.lastActive || {}, { reportReady: true });
              syncButtons();
              if (st.jobPollStop) st.jobPollStop();
            } else if (j.status === "FAILED") {
              setUiStatus("Failed: " + (j.error || "Unknown error"), true);
              if (st.jobPollStop) st.jobPollStop();
            } else {
              setUiStatus(describeStatus(j));
            }
          }
        });

        syncButtons();
      } catch (e) {
        console.error(e);
        setUiStatus("Finalize error: " + (e.message || e), true);
      } finally {
        st.stopping = false;
      }
    }

    // Active session polling
    st.activePollStop = startActivePolling({
      sessionType: cfg.sessionType,
      getContextId: cfg.getContextId,
      onUpdate: async (active) => {
        setToggleEnabled();

        if (!active || !active.active) {
          st.lastActive = null;
          syncIndicator();
          syncButtons();
          if (isHost() && st.sessionId && st.desiredOn) {
            // Host has a session but server says inactive; keep local status
            setUiStatus("AI Notes enabled.");
          }
          return;
        }

        st.lastActive = active;
        if (!st.sessionId) st.sessionId = active.sessionId;
        syncIndicator();
        syncButtons();

        // Consent prompt for all participants
        if (active.needsConsent && active.sessionId && st.lastPromptSessionId !== active.sessionId) {
          st.lastPromptSessionId = active.sessionId;
          showConsentModal({ sessionId: active.sessionId, title: active.title, sessionType: cfg.sessionType });
        }

        // Host: auto-start/pause based on consent
        if (isHost() && st.desiredOn) {
          if (active.status === "FAILED") {
            await stopRecorder();
            if (toggleEl) toggleEl.checked = false;
            st.desiredOn = false;
            setUiStatus("Recording cancelled (someone declined).", true);
            return;
          }
          await maybeStartRecorder();
        }
      }
    });

    // UI wiring
    if (toggleEl) {
      toggleEl.addEventListener("change", async () => {
        st.desiredOn = !!toggleEl.checked;
        if (st.desiredOn) {
          try {
            await ensureHostSession();
            // Host auto-consents via createSession on server; keep polling for others
            setUiStatus("Waiting for everyone to consent…");
            syncButtons();
          } catch (e) {
            console.error(e);
            setUiStatus(e.message || String(e), true);
            toggleEl.checked = false;
            st.desiredOn = false;
          }
        } else {
          await stopAndFinalize();
        }
      });
    }

    finalizeBtn?.addEventListener("click", () => stopAndFinalize());
    downloadBtn?.addEventListener("click", () => st.sessionId && downloadReport(st.sessionId));
    deleteBtn?.addEventListener("click", async () => {
      if (!isHost() || !st.sessionId) return;
      try {
        if (!confirm("Delete AI Notes artifacts (recording/transcript/report) for this session?")) return;
        setUiStatus("Deleting…");
        await deleteSession(st.sessionId);
        st.sessionId = null;
        st.jobId = null;
        st.seq = 0;
        await stopRecorder();
        if (toggleEl) toggleEl.checked = false;
        st.desiredOn = false;
        setUiStatus("Deleted.");
        st.lastActive = null;
        syncIndicator();
        syncButtons();
      } catch (e) {
        console.error(e);
        setUiStatus("Delete error: " + (e.message || e), true);
      }
    });

    // Initial UI
    setToggleEnabled();
    syncIndicator();
    syncButtons();

    return {
      stopAndFinalize,
      stopRecorder
    };
  }

  function attachChatAddon(cfg) {
    const st = {
      desiredOn: false,
      sessionId: null,
      jobId: null,
      lastActive: null,
      stopping: false,
      lastPromptSessionId: null,
      activePollStop: null,
      jobPollStop: null
    };

    const toggleEl = cfg.toggleEl;
    const indicatorEl = cfg.indicatorEl;
    const statusEl = cfg.statusEl;
    const finalizeBtn = cfg.finalizeBtn;
    const downloadBtn = cfg.downloadBtn;
    const deleteBtn = cfg.deleteBtn;

    function isHost() {
      try { return !!(cfg.getIsHost && cfg.getIsHost()); } catch (_) { return false; }
    }

    function hasContext() {
      const ctx = (cfg.getContextId && cfg.getContextId()) || "";
      return !!ctx;
    }

    function setUiStatus(msg, isErr) {
      if (!statusEl) return;
      statusEl.style.color = isErr ? "var(--danger, #ef4444)" : "var(--muted)";
      statusEl.textContent = msg || "";
    }

    function syncButtons() {
      const host = isHost();
      setDisabled(finalizeBtn, !host || !st.sessionId);
      setDisabled(deleteBtn, !host || !st.sessionId);
      setDisabled(downloadBtn, !st.sessionId || !(st.lastActive && st.lastActive.reportReady));
    }

    function syncIndicator() {
      const rec = !!(st.lastActive && st.lastActive.status === "RECORDING");
      setVisible(indicatorEl, rec);
    }

    function setToggleEnabled() {
      if (!toggleEl) return;
      const host = isHost();
      toggleEl.disabled = !host || !hasContext();
    }

    async function ensureHostSession() {
      if (st.sessionId) return st.sessionId;
      if (!isHost()) throw new Error("Only the chat owner can start AI Notes.");
      const ctxId = (cfg.getContextId && cfg.getContextId()) || "";
      if (!ctxId) throw new Error("Create or join a chat first.");
      const created = await createSession({
        sessionType: "chat",
        contextId: ctxId,
        title: (cfg.getTitle && cfg.getTitle()) || "Secure Chat"
      });
      st.sessionId = created.sessionId;
      syncButtons();
      return st.sessionId;
    }

    async function maybeStartCapture() {
      if (!st.desiredOn) return;
      if (!isHost()) return;
      if (!st.sessionId) return;

      if (!(st.lastActive && st.lastActive.allConsented)) {
        setUiStatus("Waiting for everyone to consent…");
        return;
      }

      // Mark server state as recording (for indicator)
      if (st.lastActive && st.lastActive.status !== "RECORDING") {
        try { await markRecordingStarted(st.sessionId); } catch (_) {}
      }
      setUiStatus("AI Notes enabled for this chat (PDF export is not E2E).");
    }

    async function stopAndFinalize() {
      if (!isHost()) return;
      if (!st.sessionId) return;
      if (st.stopping) return;
      st.stopping = true;

      try {
        st.desiredOn = false;
        if (toggleEl) toggleEl.checked = false;

        // Upload plaintext chat transcript (client-side decrypted)
        const msgs = (cfg.getPlainMessages && cfg.getPlainMessages()) || [];
        await uploadChatTranscript(st.sessionId, {
          kind: "chat",
          title: (cfg.getTitle && cfg.getTitle()) || "Secure Chat",
          messages: msgs
        });

        setUiStatus("Finalizing…");
        const fin = await finalize(st.sessionId);
        st.jobId = fin.jobId;

        if (st.jobPollStop) st.jobPollStop();
        st.jobPollStop = startJobPolling({
          jobId: st.jobId,
          onUpdate: (j) => {
            if (!j) return;
            if (j.status === "READY") {
              setUiStatus("Ready — PDF report available.");
              st.lastActive = Object.assign({}, st.lastActive || {}, { reportReady: true });
              syncButtons();
              if (st.jobPollStop) st.jobPollStop();
            } else if (j.status === "FAILED") {
              setUiStatus("Failed: " + (j.error || "Unknown error"), true);
              if (st.jobPollStop) st.jobPollStop();
            } else {
              setUiStatus(describeStatus(j));
            }
          }
        });

        syncButtons();
      } catch (e) {
        console.error(e);
        setUiStatus("Finalize error: " + (e.message || e), true);
      } finally {
        st.stopping = false;
      }
    }

    st.activePollStop = startActivePolling({
      sessionType: "chat",
      getContextId: cfg.getContextId,
      onUpdate: async (active) => {
        setToggleEnabled();

        if (!active || !active.active) {
          st.lastActive = null;
          syncIndicator();
          syncButtons();
          return;
        }

        st.lastActive = active;
        if (!st.sessionId) st.sessionId = active.sessionId;
        syncIndicator();
        syncButtons();

        if (active.needsConsent && active.sessionId && st.lastPromptSessionId !== active.sessionId) {
          st.lastPromptSessionId = active.sessionId;
          showConsentModal({ sessionId: active.sessionId, title: active.title, sessionType: "chat" });
        }

        if (isHost() && st.desiredOn) {
          if (active.status === "FAILED") {
            if (toggleEl) toggleEl.checked = false;
            st.desiredOn = false;
            setUiStatus("AI Notes cancelled (someone declined).", true);
            return;
          }
          await maybeStartCapture();
        }
      }
    });

    if (toggleEl) {
      toggleEl.addEventListener("change", async () => {
        st.desiredOn = !!toggleEl.checked;
        if (st.desiredOn) {
          try {
            await ensureHostSession();
            setUiStatus("Waiting for everyone to consent…");
            syncButtons();
          } catch (e) {
            console.error(e);
            setUiStatus(e.message || String(e), true);
            toggleEl.checked = false;
            st.desiredOn = false;
          }
        } else {
          await stopAndFinalize();
        }
      });
    }

    finalizeBtn?.addEventListener("click", () => stopAndFinalize());
    downloadBtn?.addEventListener("click", () => st.sessionId && downloadReport(st.sessionId));
    deleteBtn?.addEventListener("click", async () => {
      if (!isHost() || !st.sessionId) return;
      try {
        if (!confirm("Delete AI Notes artifacts (transcript/report) for this session?")) return;
        setUiStatus("Deleting…");
        await deleteSession(st.sessionId);
        st.sessionId = null;
        st.jobId = null;
        if (toggleEl) toggleEl.checked = false;
        st.desiredOn = false;
        setUiStatus("Deleted.");
        st.lastActive = null;
        syncIndicator();
        syncButtons();
      } catch (e) {
        console.error(e);
        setUiStatus("Delete error: " + (e.message || e), true);
      }
    });

    // Initial UI
    setToggleEnabled();
    syncIndicator();
    syncButtons();

    return {
      stopAndFinalize
    };
  }

  return {
    attachAudioAddon,
    attachChatAddon
  };
})();
// /PDFREALM_SECURE_AI_NOTES_ASSISTANT_CLIENT_V1


/* -----------------------------
   Secure Send (Vault Share Link)
   ----------------------------- */
function initSecureSend() {
  const elFiles = document.getElementById("qtSendFiles");
  const elDays = document.getElementById("qtSendExpireDays");
  const elCreate = document.getElementById("qtSendCreateBtn");
  const elStatus = document.getElementById("qtSendStatus");
  const elLink = document.getElementById("qtSendLink");
  const elPass = document.getElementById("qtSendPasscode");
  const elCopyLink = document.getElementById("qtSendCopyLink");
  const elCopyPass = document.getElementById("qtSendCopyPasscode");
  if (!elCreate || !elFiles || !elStatus) return;

  const setStatus = (msg, isErr) => {
    elStatus.style.color = isErr ? "var(--danger, #ef4444)" : "var(--muted)";
    elStatus.textContent = msg || "";
  };

  elCopyLink?.addEventListener("click", () => elLink?.value && qtCopy(elLink.value));
  elCopyPass?.addEventListener("click", () => elPass?.value && qtCopy(elPass.value));

  elCreate.addEventListener("click", async () => {
    try {
      const token = (typeof getToken === "function") ? getToken() : "";
      if (!token) {
        setStatus("Please sign in (Account) to use Secure Send.", true);
        return;
      }

      const files = Array.from(elFiles.files || []);
      if (!files.length) {
        setStatus("Choose one or more files.", true);
        return;
      }

      elLink && (elLink.value = "");
      elPass && (elPass.value = "");
      setStatus("Uploading files to Vault…");

      const folderPath = "QuickSend";
      const objectIds = [];
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        setStatus(`Uploading (${i+1}/${files.length}): ${f.name}`);
        const fd = new FormData();
        fd.append("file", f);
        fd.append("folderPath", folderPath);
        const up = await qtFetchJson("/api/vault/upload", { method: "POST", body: fd });
        if (!up || !up.id) throw new Error("Upload failed (missing id).");
        objectIds.push(up.id);
      }

      const days = parseInt(elDays?.value || "3", 10);
      const expiresAt = new Date(Date.now() + (Math.max(1, days) * 24 * 60 * 60 * 1000)).toISOString();

      setStatus("Creating secure link…");
      const created = await qtFetchJson("/api/secure-shares", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ objectIds, expiresAt, requirePasscode: true })
      });

      if (created?.share_url) elLink.value = created.share_url;
      if (created?.passcode) elPass.value = created.passcode;
      setStatus("Secure link created.", false);
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });
}

/* -----------------------------
   Secure Chat (E2EE via server relay)
   ----------------------------- */
function initQuickSecureChat() {
  const createBtn = document.getElementById("qtChatCreateBtn");
  const joinBtn = document.getElementById("qtChatJoinBtn");
  const sendBtn = document.getElementById("qtChatSendBtn");
  const inviteOut = document.getElementById("qtChatInviteLink");
  const copyInvite = document.getElementById("qtChatCopyInvite");
  const nameEl = document.getElementById("qtChatName");
  const tokenEl = document.getElementById("qtChatInviteToken");
  const status = document.getElementById("qtChatStatus");
  const log = document.getElementById("qtChatLog");
  const msgEl = document.getElementById("qtChatMsg");

  if (!createBtn || !joinBtn || !sendBtn || !inviteOut || !log) return;

  const state = { threadId: null, keyB64u: null, key: null, poll: null, isHost: false, plainMessages: [] };

  const setStatus = (msg, isErr) => {
    if (!status) return;
    status.style.color = isErr ? "var(--danger, #ef4444)" : "var(--muted)";
    status.textContent = msg || "";
  };


  // -------------------- Secure AI Notes add-on (Chat) --------------------
  // /PDFREALM_SECURE_AI_NOTES_ASSISTANT_V1
  const qtChatAiToggle = document.getElementById("qtChatAiToggle");
  const qtChatAiIndicator = document.getElementById("qtChatAiIndicator");
  const qtChatAiStatus = document.getElementById("qtChatAiStatus");
  const qtChatAiFinalizeBtn = document.getElementById("qtChatAiFinalizeBtn");
  const qtChatAiDownloadBtn = document.getElementById("qtChatAiDownloadBtn");
  const qtChatAiDeleteBtn = document.getElementById("qtChatAiDeleteBtn");

  const chatAiAddon = SECURE_AI_NOTES.attachChatAddon({
    getContextId: () => state.threadId,
    getIsHost: () => state.isHost,
    getTitle: () => "Secure Chat",
    getPlainMessages: () => state.plainMessages || [],
    toggleEl: qtChatAiToggle,
    indicatorEl: qtChatAiIndicator,
    statusEl: qtChatAiStatus,
    finalizeBtn: qtChatAiFinalizeBtn,
    downloadBtn: qtChatAiDownloadBtn,
    deleteBtn: qtChatAiDeleteBtn
  });
  // /PDFREALM_SECURE_AI_NOTES_ASSISTANT_V1

  copyInvite?.addEventListener("click", () => inviteOut.value && qtCopy(inviteOut.value));

  async function ensureKeyFromUrlOrStorage() {
    if (state.key) return;
    const hash = qtHashParams();
    const k = hash.get("k") || hash.get("key") || "";
    if (k) {
      state.keyB64u = k;
      state.key = await qtImportAesKey(k);
      return;
    }
    if (state.threadId) {
      const stored = localStorage.getItem("pdfrealm_qt_chat_key_" + state.threadId);
      if (stored) {
        state.keyB64u = stored;
        state.key = await qtImportAesKey(stored);
      }
    }
  }

  function renderMessage(meta, text) {
    const wrap = document.createElement("div");
    wrap.style.padding = "8px 10px";
    wrap.style.borderBottom = "1px solid rgba(255,255,255,0.08)";
    const m1 = document.createElement("div");
    m1.style.color = "var(--muted)";
    m1.style.fontSize = "0.85rem";
    m1.style.marginBottom = "4px";
    m1.textContent = meta;
    const m2 = document.createElement("div");
    m2.textContent = text;
    wrap.appendChild(m1);
    wrap.appendChild(m2);
    log.appendChild(wrap);
  }

  async function loadMessages() {
    if (!state.threadId) return;
    await ensureKeyFromUrlOrStorage();
    if (!state.key) return;

    const msgs = await qtFetchJson(`/api/chat/threads/${state.threadId}/messages`, { method: "GET" });
    const rows = (msgs.messages || []).slice().reverse();
    log.innerHTML = "";
    const plain = [];
    for (const m of rows) {
      try {
        const txt = await qtDecrypt(state.key, m.ciphertext, m.nonce);
        const who = (m.actor_display_name || m.actor_kind || "user") + (m.created_at ? " · " + new Date(m.created_at).toLocaleTimeString() : "");
        renderMessage(who, txt);
        plain.push({ who: (m.actor_display_name || m.actor_kind || "user"), created_at: m.created_at || null, text: txt });
      } catch (_) {
        renderMessage("Encrypted message", "(unable to decrypt — wrong key?)");
      }
    }
    state.plainMessages = plain;
    log.scrollTop = log.scrollHeight;
  }

  function startPolling() {
    if (state.poll) return;
    state.poll = setInterval(() => { loadMessages().catch(()=>{}); }, 2000);
  }
  function stopPolling() {
    if (state.poll) clearInterval(state.poll);
    state.poll = null;
  }

  createBtn.addEventListener("click", async () => {
    try {
      const token = (typeof getToken === "function") ? getToken() : "";
      if (!token) return setStatus("Please sign in (Account) to create a chat.", true);

      setStatus("Creating chat…");
      log.innerHTML = "";
      inviteOut.value = "";

      const title = "Quick Secure Chat";
      const created = await qtFetchJson("/api/chat/threads", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title })
      });

      const threadId = created.thread?.id;
      if (!threadId) throw new Error("No thread id returned.");
      state.threadId = threadId;
      state.isHost = false;
      state.isHost = true;

      const inv = await qtFetchJson(`/api/chat/threads/${threadId}/invites`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ allow_write: true, expires_in_seconds: 3600 })
      });

            const inviteToken = qtPickInviteToken(inv);
      if (!inviteToken) {
        console.warn("Chat invite response missing token:", inv);
        throw new Error("No invite token returned.");
      }

      const keyBytes = crypto.getRandomValues(new Uint8Array(32));
      const keyB64u = qtBytesToB64Url(keyBytes);
      localStorage.setItem("pdfrealm_qt_chat_key_" + threadId, keyB64u);
      state.keyB64u = keyB64u;
      state.key = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);

      const base = window.location.origin + window.location.pathname;
      const link = `${base}?tool=secure_chat&invite=${encodeURIComponent(inviteToken)}#k=${encodeURIComponent(keyB64u)}`;
      inviteOut.value = link;

      setStatus("Chat created. Share the invite link.");
      await loadMessages();
      startPolling();
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  joinBtn.addEventListener("click", async () => {
    try {
      stopPolling();
      log.innerHTML = "";

      const raw = qtExtractTokenOrLink(tokenEl.value || new URL(window.location.href).searchParams.get("invite") || "");
      if (!raw) return setStatus("Paste an invite token or link.", true);

      setStatus("Joining…");
      const meta = await qtFetchJson(`/api/chat-invite/${encodeURIComponent(raw)}/meta`, { method: "GET" });

      const display_name = (nameEl?.value || "").trim();
      const joined = await qtFetchJson(`/api/chat-invite/${encodeURIComponent(raw)}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ display_name })
      });

      state.threadId = joined.thread_id || meta.thread?.id;
      await ensureKeyFromUrlOrStorage();

      if (!state.key) setStatus("Joined, but missing encryption key. Use the full invite link (it includes #k=...).", true);
      else setStatus("Joined.");

      await loadMessages();
      startPolling();
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  sendBtn.addEventListener("click", async () => {
    try {
      if (!state.threadId) return setStatus("Create or join a chat first.", true);
      await ensureKeyFromUrlOrStorage();
      if (!state.key) return setStatus("Missing encryption key. Use the full invite link.", true);

      const msg = (msgEl.value || "").trim();
      if (!msg) return;

      const enc = await qtEncrypt(state.key, msg);
      await qtFetchJson(`/api/chat/threads/${state.threadId}/messages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ciphertext: enc.ciphertext, nonce: enc.nonce })
      });

      msgEl.value = "";
      await loadMessages();
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });
}

/* -----------------------------
   WebRTC Signaling (Video + VoIP)
   ----------------------------- */
async function qtStartPollSignals(kind, roomId, peerId, onSignal) {
  let stopped = false;
  let since = "";
  async function tick() {
    if (stopped) return;
    try {
      const base = kind === "video" ? "/api/video" : "/api/voice";
      const url = new URL(window.location.origin + `${base}/rooms/${roomId}/signals`);
      url.searchParams.set("peer_id", peerId);
      if (since) url.searchParams.set("since", since);
      url.searchParams.set("limit", "100");
      const data = await qtFetchJson(url.pathname + url.search, { method: "GET" });
      const signals = data.signals || [];
      for (const s of signals) {
        since = s.id || since;
        await onSignal(s);
      }
    } catch (_) {}
    setTimeout(tick, 600);
  }
  tick();
  return () => { stopped = true; };
}

async function qtSendSignal(kind, roomId, payload) {
  const base = kind === "video" ? "/api/video" : "/api/voice";
  return qtFetchJson(`${base}/rooms/${roomId}/signals`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload || {})
  });
}

async function qtJoinInvite(kind, token, guestName, password) {
  const endpoint = kind === "video" ? "/api/video-invite" : "/api/voice-invite";
  const body = { guest_name: guestName || undefined };
  if (password) body.password = password;
  return qtFetchJson(`${endpoint}/${encodeURIComponent(token)}/join`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
}

async function qtCreateRoom(kind, title) {
  const endpoint = kind === "video" ? "/api/video/rooms" : "/api/voice/rooms";
  return qtFetchJson(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ title })
  });
}

async function qtCreateInvite(kind, roomId, expiresInSec, allowWrite, password) {
  const endpoint = kind === "video" ? "/api/video" : "/api/voice";
  const body = {
    allow_write: !!allowWrite,
    expires_in_seconds: Number(expiresInSec || 0) || 0
  };
  if (password) body.password = password;
  return qtFetchJson(`${endpoint}/rooms/${roomId}/invites`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
}


// Helper: normalize invite token across server response shapes
function qtPickInviteToken(inv) {
  if (!inv) return null;
  // most common
  let t = inv.token || inv.inviteToken || null;

  // nested shapes (older patches)
  if (!t) t = inv.invite?.token || inv.invite?.inviteToken || null;

  // sometimes returned as id (not ideal, but last resort)
  if (!t) t = inv.id || inv.invite?.id || inv.invite_id || null;

  // if server returned a URL, extract token=...
  if (!t && inv.url) {
    const m = String(inv.url).match(/token=([^&]+)/i);
    if (m && m[1]) t = decodeURIComponent(m[1]);
  }
  return t || null;
}

async function qtStartWebRtcCall(opts) {
  const {
    kind, // "video" | "voice"
    roomId,
    inviteToken,
    localVideoEl,
    remoteVideoEl,
    remoteAudioEl,
    statusEl
  } = opts;

  let pc = null;
  let localStream = null;
  let remoteStreams = [];
  let onRemoteStreamCb = null;
  let peerId = "p_" + Math.random().toString(16).slice(2) + Date.now();

  const setStatus = (msg, isErr) => {
    if (!statusEl) return;
    statusEl.style.color = isErr ? "var(--danger, #ef4444)" : "var(--muted)";
    statusEl.textContent = msg || "";
  };

  const stopPoll = await qtStartPollSignals(kind, roomId, peerId, async (sig) => {
    if (!pc) return;
    const t = sig.type;
    const d = sig.data || {};
    if (t === "offer") {
      await pc.setRemoteDescription(d);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await qtSendSignal(kind, roomId, { type: "answer", to: sig.from_peer_id || null, from_peer_id: peerId, data: answer });
    } else if (t === "answer") {
      await pc.setRemoteDescription(d);
    } else if (t === "ice") {
      try { await pc.addIceCandidate(d); } catch (_) {}
    }
  });

  async function start(isHost) {
    if (pc) return;
    setStatus("Starting…");

    pc = new RTCPeerConnection({
      iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"] }]
    });

    pc.onicecandidate = (ev) => {
      if (ev.candidate) qtSendSignal(kind, roomId, { type: "ice", from_peer_id: peerId, data: ev.candidate }).catch(()=>{});
    };

    if (kind === "video") {
      pc.ontrack = (ev) => {
        const s = (ev && ev.streams && ev.streams[0]) ? ev.streams[0] : null;
        if (remoteVideoEl && s) remoteVideoEl.srcObject = s;
        if (s) {
          if (!remoteStreams.some((rs) => rs && rs.id === s.id)) remoteStreams.push(s);
          try { onRemoteStreamCb && onRemoteStreamCb(s); } catch (_) {}
        }
      };
    } else {
      pc.ontrack = (ev) => {
        const s = (ev && ev.streams && ev.streams[0]) ? ev.streams[0] : null;
        if (remoteAudioEl && s) remoteAudioEl.srcObject = s;
        if (s) {
          if (!remoteStreams.some((rs) => rs && rs.id === s.id)) remoteStreams.push(s);
          try { onRemoteStreamCb && onRemoteStreamCb(s); } catch (_) {}
        }
      };
    }

    localStream = await navigator.mediaDevices.getUserMedia(kind === "video" ? { video: true, audio: true } : { audio: true });
    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));
    if (kind === "video" && localVideoEl) localVideoEl.srcObject = localStream;

    if (isHost) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await qtSendSignal(kind, roomId, { type: "offer", from_peer_id: peerId, data: offer });
    }

    setStatus("Connected (or waiting for peer) …");
  }

  function hangup() {
    try { stopPoll && stopPoll(); } catch (_) {}
    try { pc && pc.close(); } catch (_) {}
    pc = null;
    try { localStream && localStream.getTracks().forEach(t => t.stop()); } catch (_) {}
    localStream = null;
    remoteStreams = [];
    onRemoteStreamCb = null;
    if (localVideoEl) localVideoEl.srcObject = null;
    if (remoteVideoEl) remoteVideoEl.srcObject = null;
    if (remoteAudioEl) remoteAudioEl.srcObject = null;
    setStatus("Ended.");
  }

  return { start, hangup, setStatus, getLocalStream: () => localStream, getRemoteStreams: () => remoteStreams.slice(), onRemoteStream: (cb) => { onRemoteStreamCb = cb; } };
}

/* -----------------------------
   Secure Video UI
   ----------------------------- */
function initQuickSecureVideo() {
  const createBtn = document.getElementById("qtVideoCreateBtn");
  const joinBtn = document.getElementById("qtVideoJoinBtn");
  const startBtn = document.getElementById("qtVideoStartBtn");
  const hangupBtn = document.getElementById("qtVideoHangupBtn");
  const inviteOut = document.getElementById("qtVideoInviteLink");
  const copyInvite = document.getElementById("qtVideoCopyInvite");
  const nameEl = document.getElementById("qtVideoName");
  const tokenEl = document.getElementById("qtVideoInviteToken");
  const status = document.getElementById("qtVideoStatus");
  const localVideo = document.getElementById("qtVideoLocal");
  const remoteVideo = document.getElementById("qtVideoRemote");
  if (!createBtn || !joinBtn || !startBtn || !hangupBtn || !inviteOut || !status) return;

  const state = { roomId: null, inviteToken: null, call: null, isHost: false };

  const setStatus = (m, e) => {
    status.style.color = e ? "var(--danger, #ef4444)" : "var(--muted)";
    status.textContent = m || "";
  };


  // -------------------- Secure AI Notes add-on (Video) --------------------
  // /PDFREALM_SECURE_AI_NOTES_ASSISTANT_V1
  const qtVideoAiToggle = document.getElementById("qtVideoAiToggle");
  const qtVideoAiIndicator = document.getElementById("qtVideoAiIndicator");
  const qtVideoAiStatus = document.getElementById("qtVideoAiStatus");
  const qtVideoAiFinalizeBtn = document.getElementById("qtVideoAiFinalizeBtn");
  const qtVideoAiDownloadBtn = document.getElementById("qtVideoAiDownloadBtn");
  const qtVideoAiDeleteBtn = document.getElementById("qtVideoAiDeleteBtn");

  const videoAiAddon = SECURE_AI_NOTES.attachAudioAddon({
    sessionType: "video",
    getContextId: () => state.roomId,
    getIsHost: () => state.isHost,
    getCall: () => state.call,
    getTitle: () => "Secure Video Chat",
    toggleEl: qtVideoAiToggle,
    indicatorEl: qtVideoAiIndicator,
    statusEl: qtVideoAiStatus,
    finalizeBtn: qtVideoAiFinalizeBtn,
    downloadBtn: qtVideoAiDownloadBtn,
    deleteBtn: qtVideoAiDeleteBtn
  });
  // /PDFREALM_SECURE_AI_NOTES_ASSISTANT_V1

  copyInvite?.addEventListener("click", () => inviteOut.value && qtCopy(inviteOut.value));

  createBtn.addEventListener("click", async () => {
    try {
      const token = (typeof getToken === "function") ? getToken() : "";
      if (!token) return setStatus("Please sign in (Account) to create a room.", true);

      setStatus("Creating room…");
      inviteOut.value = "";

      const created = await qtCreateRoom("video", "Quick Secure Video Chat");
      const roomId = created.room?.id || created.id;
      if (!roomId) throw new Error("No room id returned.");
      state.roomId = roomId;

      const inv = await qtCreateInvite("video", roomId, 3600, true);
      const invToken = qtPickInviteToken(inv);
      if (!invToken) throw new Error("No invite token returned.");
      state.inviteToken = invToken;
      state.isHost = true;

      const base = window.location.origin + window.location.pathname;
      inviteOut.value = `${base}?tool=secure_video&invite=${encodeURIComponent(invToken)}`;

      setStatus("Room created. Share the invite link.");
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  joinBtn.addEventListener("click", async () => {
    try {
      setStatus("Joining…");
      const raw = qtExtractTokenOrLink(tokenEl.value || new URL(window.location.href).searchParams.get("invite") || "");
      if (!raw) return setStatus("Paste an invite token or link.", true);

      const guestName = (nameEl?.value || "").trim();
      const joined = await qtJoinInvite("video", raw, guestName);
      state.roomId = joined.room_id || joined.room?.id;
      state.inviteToken = raw;
      state.isHost = false;

      setStatus("Joined. Click Start to begin.");
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  startBtn.addEventListener("click", async () => {
    try {
      if (!state.roomId) return setStatus("Create or join a room first.", true);
      if (state.call) return;
      state.call = await qtStartWebRtcCall({
        kind: "video",
        roomId: state.roomId,
        inviteToken: state.inviteToken,
        localVideoEl: localVideo,
        remoteVideoEl: remoteVideo,
        statusEl: status
      });
      await state.call.start(state.isHost);
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  hangupBtn.addEventListener("click", async () => {
    try { await videoAiAddon.stopAndFinalize(); } catch (_) {}
    try { state.call && state.call.hangup(); } catch (_) {}
    state.call = null;
  });
}

/* -----------------------------
   Secure VoIP UI
   ----------------------------- */
function initQuickSecureVoip() {
  const createBtn = document.getElementById("qtVoipCreateBtn");
  const joinBtn = document.getElementById("qtVoipJoinBtn");
  const startBtn = document.getElementById("qtVoipStartBtn");
  const hangupBtn = document.getElementById("qtVoipHangupBtn");
  const inviteOut = document.getElementById("qtVoipInviteLink");
  const copyInvite = document.getElementById("qtVoipCopyInvite");
  const nameEl = document.getElementById("qtVoipName");
  const tokenEl = document.getElementById("qtVoipInviteToken");
  const status = document.getElementById("qtVoipStatus");
  const remoteAudio = document.getElementById("qtVoipRemoteAudio");
  if (!createBtn || !joinBtn || !startBtn || !hangupBtn || !inviteOut || !status) return;

  const state = { roomId: null, inviteToken: null, call: null, isHost: false };

  const setStatus = (m, e) => {
    status.style.color = e ? "var(--danger, #ef4444)" : "var(--muted)";
    status.textContent = m || "";
  };


  // -------------------- Secure AI Notes add-on (VoIP) --------------------
  // /PDFREALM_SECURE_AI_NOTES_ASSISTANT_V1
  const qtVoipAiToggle = document.getElementById("qtVoipAiToggle");
  const qtVoipAiIndicator = document.getElementById("qtVoipAiIndicator");
  const qtVoipAiStatus = document.getElementById("qtVoipAiStatus");
  const qtVoipAiFinalizeBtn = document.getElementById("qtVoipAiFinalizeBtn");
  const qtVoipAiDownloadBtn = document.getElementById("qtVoipAiDownloadBtn");
  const qtVoipAiDeleteBtn = document.getElementById("qtVoipAiDeleteBtn");

  const voipAiAddon = SECURE_AI_NOTES.attachAudioAddon({
    sessionType: "voip",
    getContextId: () => state.roomId,
    getIsHost: () => state.isHost,
    getCall: () => state.call,
    getTitle: () => "Secure VoIP Call",
    toggleEl: qtVoipAiToggle,
    indicatorEl: qtVoipAiIndicator,
    statusEl: qtVoipAiStatus,
    finalizeBtn: qtVoipAiFinalizeBtn,
    downloadBtn: qtVoipAiDownloadBtn,
    deleteBtn: qtVoipAiDeleteBtn
  });
  // /PDFREALM_SECURE_AI_NOTES_ASSISTANT_V1

  copyInvite?.addEventListener("click", () => inviteOut.value && qtCopy(inviteOut.value));

  createBtn.addEventListener("click", async () => {
    try {
      const token = (typeof getToken === "function") ? getToken() : "";
      if (!token) return setStatus("Please sign in (Account) to create a call.", true);

      setStatus("Creating call…");
      inviteOut.value = "";

      const created = await qtCreateRoom("voice", "Quick Secure VoIP");
      const roomId = created.room?.id || created.id;
      if (!roomId) throw new Error("No room id returned.");
      state.roomId = roomId;

      const inv = await qtCreateInvite("voice", roomId, 3600, true);
      const invToken = qtPickInviteToken(inv);
      if (!invToken) throw new Error("No invite token returned.");
      state.inviteToken = invToken;
      state.isHost = true;

      const base = window.location.origin + window.location.pathname;
      inviteOut.value = `${base}?tool=secure_voip&invite=${encodeURIComponent(invToken)}`;

      setStatus("Call created. Share the invite link.");
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  joinBtn.addEventListener("click", async () => {
    try {
      setStatus("Joining…");
      const raw = qtExtractTokenOrLink(tokenEl.value || new URL(window.location.href).searchParams.get("invite") || "");
      if (!raw) return setStatus("Paste an invite token or link.", true);

      const guestName = (nameEl?.value || "").trim();
      const joined = await qtJoinInvite("voice", raw, guestName);
      state.roomId = joined.room_id || joined.room?.id;
      state.inviteToken = raw;
      state.isHost = false;

      setStatus("Joined. Click Start to begin.");
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  startBtn.addEventListener("click", async () => {
    try {
      if (!state.roomId) return setStatus("Create or join a call first.", true);
      if (state.call) return;
      state.call = await qtStartWebRtcCall({
        kind: "voice",
        roomId: state.roomId,
        inviteToken: state.inviteToken,
        remoteAudioEl: remoteAudio,
        statusEl: status
      });
      await state.call.start(state.isHost);
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e.message || e), true);
    }
  });

  hangupBtn.addEventListener("click", async () => {
    try { await voipAiAddon.stopAndFinalize(); } catch (_) {}
    try { state.call && state.call.hangup(); } catch (_) {}
    state.call = null;
  });
}

/* -----------------------------
   Encrypted Containers (PVR1)
   ----------------------------- */
function initEncryptedContainers() {
  const elPwd = document.getElementById("qtContainerPassword");
  const elFiles = document.getElementById("qtContainerFiles");
  const elAlsoUpload = document.getElementById("qtContainerAlsoUpload");
  const elCreate = document.getElementById("qtContainerCreateBtn");
  const elDownload = document.getElementById("qtContainerDownloadBtn");
  const elOffline = document.getElementById("qtContainerOfflineBtn");
  const elStatus = document.getElementById("qtContainerStatus");

  const elImportFile = document.getElementById("qtContainerImportFile");
  const elImportPwd = document.getElementById("qtContainerImportPassword");
  const elUnlock = document.getElementById("qtContainerUnlockBtn");
  const elExtract = document.getElementById("qtContainerExtractBtn");
  const elImportStatus = document.getElementById("qtContainerImportStatus");
  const elTbody = document.getElementById("qtContainerPreviewTbody");

  if (!elCreate || !elUnlock || !elTbody) return;

  const te = new TextEncoder();
  const td = new TextDecoder();
  const state = { built: null, unlocked: null };

  const setStatus = (el, msg, isErr) => {
    if (!el) return;
    el.style.color = isErr ? "var(--danger, #ef4444)" : "var(--muted)";
    el.textContent = msg || "";
  };

  function triggerDownload(blob, filename) {
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2500);
  }

  function u8ToB64(u8) { return qtBytesToB64Url(u8); }
  function b64ToU8(b64u) { return qtB64UrlToBytes(b64u); }

  async function deriveAesKeyFromPassword(password, saltU8, iterations) {
    const pwKey = await crypto.subtle.importKey("raw", te.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      { name: "PBKDF2", salt: saltU8, iterations, hash: "SHA-256" },
      pwKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt","decrypt"]
    );
  }

  function renderPreview(unlocked) {
    if (!unlocked || !unlocked.files || !unlocked.files.length) {
      elTbody.innerHTML = `<tr><td colspan="4" style="padding:10px; color:var(--muted); font-size:0.9rem;">No container loaded.</td></tr>`;
      return;
    }
    elTbody.innerHTML = unlocked.files.map((f, idx) => {
      const size = (typeof formatBytes === "function") ? formatBytes(f.size || 0) : String(f.size || "");
      return `
        <tr data-cidx="${idx}">
          <td style="padding:10px;">${escapeHtml(f.name || "")}</td>
          <td style="padding:10px;">${escapeHtml(f.type || "")}</td>
          <td style="padding:10px;">${escapeHtml(size)}</td>
          <td style="padding:10px;"><button class="btn btn-secondary" type="button" data-act="cdownload">Download</button></td>
        </tr>
      `;
    }).join("");
  }

  async function uploadBlobToVault(blob, filename, folderPath) {
    const token = (typeof getToken === "function") ? getToken() : "";
    if (!token) throw new Error("Not signed in.");
    const fd = new FormData();
    fd.append("file", blob, filename);
    if (folderPath) fd.append("folderPath", folderPath);
    const res = await qtFetchJson("/api/vault/upload", { method: "POST", body: fd });
    return res?.id;
  }

  async function createContainer() {
    const password = String(elPwd?.value || "").trim();
    const files = Array.from(elFiles?.files || []);
    if (!password) return setStatus(elStatus, "Enter a password.", true);
    if (!files.length) return setStatus(elStatus, "Select files to encrypt.", true);

    elDownload.disabled = true;
    state.built = null;
    setStatus(elStatus, "Encrypting…");

    try {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iterations = 200000;
      const key = await deriveAesKeyFromPassword(password, salt, iterations);

      const chunks = [];
      const filesMeta = [];
      let offset = 0;

      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        setStatus(elStatus, `Encrypting (${i+1}/${files.length}): ${f.name}`);

        const iv = crypto.getRandomValues(new Uint8Array(12));
        const mtime = f.lastModified || Date.now();
        const aadObj = { name: f.name, type: f.type || "", size: f.size || 0, mtime };
        const aadStr = JSON.stringify(aadObj);
        const aadBytes = te.encode(aadStr);

        const plain = await f.arrayBuffer();
        const cipherBuf = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv, additionalData: aadBytes },
          key,
          plain
        );
        const cipherU8 = new Uint8Array(cipherBuf);

        filesMeta.push({
          name: f.name,
          type: f.type || "",
          size: f.size || 0,
          mtime,
          iv: u8ToB64(iv),
          aad: aadStr,
          offset,
          length: cipherU8.byteLength
        });

        chunks.push(cipherU8);
        offset += cipherU8.byteLength;
      }

      const header = {
        v: 1,
        kdf: { name: "PBKDF2", hash: "SHA-256", iterations, salt: u8ToB64(salt) },
        enc: { name: "AES-GCM" },
        createdAt: new Date().toISOString(),
        files: filesMeta
      };

      const headerBytes = te.encode(JSON.stringify(header));
      const lenBuf = new ArrayBuffer(4);
      new DataView(lenBuf).setUint32(0, headerBytes.byteLength, true);
      const magic = te.encode("PVR1");

      const blob = new Blob([magic, lenBuf, headerBytes, ...chunks], { type: "application/octet-stream" });
      const filename = `pdfrealm-container-${new Date().toISOString().replace(/[:.]/g,"-")}.pvr`;

      state.built = { blob, filename, header };
      elDownload.disabled = false;
      setStatus(elStatus, `Container ready (${files.length} file${files.length===1?"":"s"}).`);

      if (elAlsoUpload?.checked) {
        setStatus(elStatus, "Uploading container to Vault…");
        await uploadBlobToVault(blob, filename, "Encrypted Containers");
        setStatus(elStatus, "Container uploaded to Vault.");
      }
    } catch (e) {
      console.error(e);
      state.built = null;
      elDownload.disabled = true;
      setStatus(elStatus, "Failed: " + (e.message || e), true);
    }
  }

  async function unlockContainer() {
    const file = elImportFile?.files?.[0];
    const password = String(elImportPwd?.value || "").trim();
    if (!file) return setStatus(elImportStatus, "Select a container file.", true);
    if (!password) return setStatus(elImportStatus, "Enter the password.", true);

    state.unlocked = null;
    elExtract.disabled = true;
    renderPreview(null);
    setStatus(elImportStatus, "Unlocking…");

    try {
      const buf = await file.arrayBuffer();
      const u8 = new Uint8Array(buf);
      const magic = td.decode(u8.slice(0, 4));
      if (magic !== "PVR1") throw new Error("Invalid container format (missing PVR1 header).");

      const headerLen = new DataView(buf, 4, 4).getUint32(0, true);
      if (headerLen <= 0 || headerLen > (buf.byteLength - 8)) throw new Error("Invalid header length.");

      const headerBytes = u8.slice(8, 8 + headerLen);
      const header = JSON.parse(td.decode(headerBytes));

      const salt = b64ToU8(header?.kdf?.salt || "");
      const iterations = header?.kdf?.iterations || 0;
      if (!salt.length || !iterations) throw new Error("Container KDF parameters missing.");

      const key = await deriveAesKeyFromPassword(password, salt, iterations);
      const dataStart = 8 + headerLen;

      const list = Array.isArray(header.files) ? header.files : [];
      const files = [];

      for (let i = 0; i < list.length; i++) {
        const meta = list[i];
        setStatus(elImportStatus, `Decrypting (${i+1}/${list.length}): ${meta.name || "file"}`);

        const iv = b64ToU8(meta.iv || "");
        const aadStr = meta.aad || JSON.stringify({ name: meta.name, type: meta.type || "", size: meta.size || 0, mtime: meta.mtime || 0 });
        const aadBytes = te.encode(aadStr);

        const start = dataStart + (meta.offset || 0);
        const end = start + (meta.length || 0);
        if (start < dataStart || end > buf.byteLength || end <= start) throw new Error("Container data range invalid.");

        const cipherSlice = buf.slice(start, end);
        const plainBuf = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv, additionalData: aadBytes },
          key,
          cipherSlice
        );

        const blob = new Blob([plainBuf], { type: meta.type || "application/octet-stream" });
        files.push({ name: meta.name || `file-${i+1}`, type: meta.type || "", size: meta.size || blob.size, mtime: meta.mtime || 0, blob });
      }

      state.unlocked = { header, files };
      renderPreview(state.unlocked);
      elExtract.disabled = false;
      setStatus(elImportStatus, `Unlocked. ${files.length} file${files.length===1?"":"s"} ready.`, false);
    } catch (e) {
      console.error(e);
      state.unlocked = null;
      renderPreview(null);
      elExtract.disabled = true;
      setStatus(elImportStatus, "Failed: " + (e.message || e), true);
    }
  }

  async function extractToVault() {
    if (!state.unlocked || !state.unlocked.files?.length) return setStatus(elImportStatus, "Unlock a container first.", true);
    const token = (typeof getToken === "function") ? getToken() : "";
    if (!token) return setStatus(elImportStatus, "Sign in to extract to Vault.", true);

    const files = state.unlocked.files;
    setStatus(elImportStatus, "Extracting to Vault…");
    elExtract.disabled = true;

    try {
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        setStatus(elImportStatus, `Uploading (${i+1}/${files.length}): ${f.name}`);
        await uploadBlobToVault(f.blob, f.name, "Extracted Containers");
      }
      setStatus(elImportStatus, "Extract complete (uploaded to Vault).", false);
    } catch (e) {
      console.error(e);
      setStatus(elImportStatus, "Extract failed: " + (e.message || e), true);
    } finally {
      elExtract.disabled = false;
    }
  }

  elCreate.addEventListener("click", () => createContainer().catch(()=>{}));
  elDownload.addEventListener("click", () => {
    if (!state.built) return setStatus(elStatus, "Create a container first.", true);
    triggerDownload(state.built.blob, state.built.filename);
  });
  elOffline?.addEventListener("click", () => {
    const a = document.createElement("a");
    a.href = "/offline-unlocker.zip";
    a.download = "pdfrealm-offline-unlocker.zip";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });
  elUnlock.addEventListener("click", () => unlockContainer().catch(()=>{}));
  elExtract.addEventListener("click", () => extractToVault().catch(()=>{}));
  elTbody.addEventListener("click", (ev) => {
    const btn = ev.target?.closest?.("button[data-act='cdownload']");
    if (!btn) return;
    const tr = btn.closest("tr");
    const idx = tr?.getAttribute("data-cidx");
    if (idx == null) return;
    const i = parseInt(idx, 10);
    const f = state.unlocked?.files?.[i];
    if (!f) return;
    triggerDownload(f.blob, f.name);
  });
}

/* -----------------------------
   Auto-route invite links to the right tool view
   ----------------------------- */
function autoRouteSecureInvites() {
  try {
    const u = new URL(window.location.href);
    const tool = u.searchParams.get("tool") || "";
    const invite = u.searchParams.get("invite") || "";
    if (!invite) return;

    const map = {
      "secure_chat": { tool: "secure_chat", inputId: "qtChatInviteToken", btnId: "qtChatJoinBtn" },
      "secure_video": { tool: "secure_video", inputId: "qtVideoInviteToken", btnId: "qtVideoJoinBtn" },
      "secure_voip": { tool: "secure_voip", inputId: "qtVoipInviteToken", btnId: "qtVoipJoinBtn" }
    };

    const chosen = map[tool] || null;
    if (!chosen) return;

    if (typeof window.__pdfrealmActivateTool === "function") {
      window.__pdfrealmActivateTool(chosen.tool);
    }
    const input = document.getElementById(chosen.inputId);
    if (input) input.value = invite;

    // Don't auto-join if key hash missing (chat). Let user click Join.
  } catch (_) {}
}

/* PDFREALM_TIFF_UTIF_PAKO_BOOTSTRAP_V2
   Ensures UTIF works reliably:
   - Load pako first (inflate required)
   - Reload UTIF after pako to avoid "inflate undefined"
   - Polyfill UTIF.decodeImages when missing
*/
(function(){
  if (window.__pdfrealm_tiff_bootstrap_v2) return;
  window.__pdfrealm_tiff_bootstrap_v2 = true;

  const CDN_PAKO = "https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js";
  const CDN_UTIF = "https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js";

  function loadScriptOnce(src){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === src);
      if (found) return resolve();
      const s = document.createElement("script");
      s.src = src;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }

  async function ensurePako(){
    if (!window.pako || typeof window.pako.inflate !== "function") {
      await loadScriptOnce(CDN_PAKO);
    }
    if (!window.pako || typeof window.pako.inflate !== "function") {
      throw new Error("pako.inflate not available (pako failed to load)");
    }
  }

  async function ensureUTIF(){
    await ensurePako();

    // If UTIF already exists but was loaded before pako, it can be broken.
    // Force reload with cache buster.
    const needsReload = !window.UTIF || !window.UTIF.__pdfrealm_ok;
    if (needsReload) {
      try { delete window.UTIF; } catch {}
      await loadScriptOnce(CDN_UTIF + "?v=" + Date.now());
      if (window.UTIF) window.UTIF.__pdfrealm_ok = true;
    }

    const UTIF = window.UTIF;
    if (!UTIF) throw new Error("UTIF not available");

    // Polyfill decodeImages if missing
    if (typeof UTIF.decodeImages !== "function" && typeof UTIF.decodeImage === "function") {
      UTIF.decodeImages = function(buf, ifds){
        for (const ifd of (ifds || [])) {
          try { UTIF.decodeImage(buf, ifd); }
          catch { UTIF.decodeImage(new Uint8Array(buf), ifd); }
        }
      };
    }
    return UTIF;
  }

  // Make a robust TIFF renderer globally available
  window.__pdfrealmEnsureUTIF = ensureUTIF;

  // Optional: also provide a safe render helper other code can call
  window.__pdfrealmRenderTiffToHost = async function(file, host){
    const UTIF = await ensureUTIF().catch(() => null);
    if (!UTIF) {
      host.innerHTML = '<div class="muted">TIFF preview requires UTIF.js + pako (failed to load).</div>';
      return;
    }

    const buf = await file.arrayBuffer();
    const ifds = UTIF.decode(buf);
    if (!ifds || !ifds.length) {
      host.innerHTML = '<div class="muted">Unable to decode TIFF.</div>';
      return;
    }

    try {
      if (typeof UTIF.decodeImages === "function") UTIF.decodeImages(buf, ifds);
      else if (typeof UTIF.decodeImage === "function") ifds.forEach(ifd => UTIF.decodeImage(buf, ifd));
    } catch (e) {
      console.error(e);
      host.innerHTML = '<div class="muted">This TIFF compression is not supported for in-browser preview.</div>';
      return;
    }

    const first = ifds[0];
    const rgba = UTIF.toRGBA8(first);
    const w = first.width, h = first.height;

    const canvas = document.createElement("canvas");
    canvas.width = w; canvas.height = h;
    canvas.style.maxWidth = "100%";
    canvas.style.height = "auto";
    canvas.style.borderRadius = "12px";
    canvas.style.boxShadow = "0 8px 28px rgba(0,0,0,.25)";
    canvas.style.background = "white";

    const ctx = canvas.getContext("2d");
    ctx.putImageData(new ImageData(new Uint8ClampedArray(rgba), w, h), 0, 0);

    host.innerHTML = "";
    host.appendChild(canvas);
  };

  // Preload UTIF after DOM ready to avoid race conditions
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => { ensureUTIF().catch(()=>{}); });
  } else {
    ensureUTIF().catch(()=>{});
  }
})();

/* PDFREALM_PACK3_TOOLS_V1
   Client-side tools added in Pack 3:
   - xml2pdf, pdf2md, pdf2html, pdf2json, extractimgzip
*/
(function(){
  if (window.__pdfrealm_pack3_tools_v1) return;
  window.__pdfrealm_pack3_tools_v1 = true;

  const CDN_PDFLIB = "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
  const CDN_PDFJS  = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
  const CDN_JSZIP  = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";

  const $ = (id) => document.getElementById(id);

  function setStatus(id, msg){
    const el = $(id);
    if (el) el.textContent = msg || "";
  }

  function escapeHtml(s){
    return (s ?? "").toString()
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement("script");
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === "function") return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error("pdf-lib failed to load");
  }

  async function ensureJSZip(){
    if (typeof window.ensureJSZip === "function") return window.ensureJSZip();
    if (window.JSZip) return;
    await loadScriptOnce(CDN_JSZIP);
    if (!window.JSZip) throw new Error("JSZip failed to load");
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === "function") return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== "function") throw new Error("pdf.js failed to load");
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }
    } catch {}
  }

  async function readFileAsArrayBuffer(file){
    return await file.arrayBuffer();
  }

  async function readFileAsText(file){
    return await file.text();
  }

  async function pdfToTextPages(file, onProgress){
    await ensurePDFJS();
    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
    const pages = [];
    for (let p = 1; p <= doc.numPages; p++){
      if (onProgress) onProgress(p, doc.numPages);
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const strings = content.items.map(it => it.str).filter(Boolean);
      pages.push(strings.join(" "));
    }
    return pages;
  }

  function toMarkdown(pagesText){
    const out = [];
    pagesText.forEach((t, idx) => {
      out.push("\n\n---\n\n## Page " + (idx+1) + "\n\n");
      const lines = (t || "").split(/\n+/).flatMap(x => x.split(/\s{2,}/));
      lines.forEach(line => {
        const s = (line || "").trim();
        if (!s) return;
        if (/^[A-Z0-9][A-Z0-9 \-]{8,}$/.test(s) && s.length < 90) out.push("### " + s + "\n\n");
        else out.push(s + "\n\n");
      });
    });
    return out.join("").trim() + "\n";
  }

  function toHtml(pagesText){
    const parts = [];
    parts.push("<!doctype html><html><head><meta charset=\"utf-8\"><title>PDF Export</title>");
    parts.push("<style>body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;padding:24px}pre{white-space:pre-wrap;word-break:break-word;background:#f6f8fa;border:1px solid #e5e7eb;border-radius:12px;padding:14px}</style>");
    parts.push("</head><body>");
    pagesText.forEach((t, idx) => {
      parts.push("<h2>Page " + (idx+1) + "</h2>");
      parts.push("<pre>" + escapeHtml(t || "") + "</pre>");
    });
    parts.push("</body></html>");
    return parts.join("");
  }

  async function buildCodePdfFromText(text, opts){
    await ensurePDFLib();
    const PDFDocument = window.PDFLib.PDFDocument;
    const StandardFonts = window.PDFLib.StandardFonts;
    const rgb = window.PDFLib.rgb;
    const PageSizes = window.PDFLib.PageSizes;

    const doc = await PDFDocument.create();
    const font = await doc.embedFont(StandardFonts.Courier);

    const pageSize = (opts && opts.pageSize === "A4") ? PageSizes.A4 : PageSizes.Letter;
    const fontSize = (opts && opts.fontSize) ? opts.fontSize : 10;
    const margin = (opts && opts.margin) ? opts.margin : 36;
    const maxCols = (opts && opts.maxCols) ? opts.maxCols : 110;

    function wrapLine(line){
      const out = [];
      let s = line || "";
      while (s.length > maxCols){
        out.push(s.slice(0, maxCols));
        s = s.slice(maxCols);
      }
      out.push(s);
      return out;
    }

    const linesRaw = (text || "").replace(/\r\n/g, "\n").split("\n");
    let lines = [];
    for (const ln of linesRaw){
      lines.push.apply(lines, wrapLine(ln));
    }

    let page = doc.addPage(pageSize);
    let size = page.getSize();
    let height = size.height;
    let y = height - margin;
    const lineHeight = fontSize * 1.25;

    for (const ln of lines){
      if (y < margin + lineHeight){
        page = doc.addPage(pageSize);
        size = page.getSize();
        height = size.height;
        y = height - margin;
      }
      page.drawText(ln, { x: margin, y: y, size: fontSize, font: font, color: rgb(0.85,0.88,0.92) });
      y -= lineHeight;
    }

    const pdfBytes = await doc.save();
    return new Blob([pdfBytes], { type: "application/pdf" });
  }

  async function initXml2Pdf(){
    const fileEl = $("xml2pdfFile");
    const txtEl = $("xml2pdfText");
    const buildBtn = $("xml2pdfBuildBtn");
    const dlBtn = $("xml2pdfDownloadBtn");
    const frame = $("xml2pdfPreviewFrame");
    if (!txtEl || !buildBtn) return;
    let lastBlob = null;

    if (fileEl){
      fileEl.addEventListener("change", async () => {
        try {
          const f = fileEl.files && fileEl.files[0];
          if (!f) return;
          setStatus("xml2pdfStatus", "Loading XML...");
          txtEl.value = await readFileAsText(f);
          setStatus("xml2pdfStatus", "");
        } catch (e){
          setStatus("xml2pdfStatus", e.message || String(e));
        }
      });
    }

    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("xml2pdfStatus", "Building PDF...");
        const xml = (txtEl.value || "").trim();
        if (!xml) throw new Error("Paste XML first.");
        lastBlob = await buildCodePdfFromText(xml, { fontSize: 10, maxCols: 110, pageSize: "Letter" });
        setStatus("xml2pdfStatus", "Ready.");
        if (frame){
          const url = URL.createObjectURL(lastBlob);
          frame.src = url;
          setTimeout(() => URL.revokeObjectURL(url), 60000);
        }
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("xml2pdfStatus", e.message || String(e));
      }
    });

    if (dlBtn){
      dlBtn.addEventListener("click", () => {
        if (!lastBlob) return;
        downloadBlob(lastBlob, "xml.pdf");
      });
    }
  }

  async function initPdf2Md(){
    const fileEl = $("pdf2mdFile");
    const runBtn = $("pdf2mdRunBtn");
    const dlBtn = $("pdf2mdDownloadBtn");
    const outEl = $("pdf2mdOut");
    if (!fileEl || !runBtn || !outEl) return;
    let lastText = "";

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = "";
        setStatus("pdf2mdStatus", "Extracting text...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const pages = await pdfToTextPages(f, (p,n) => setStatus("pdf2mdStatus", "Extracting page " + p + "/" + n + "..."));
        lastText = toMarkdown(pages);
        outEl.value = lastText;
        setStatus("pdf2mdStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("pdf2mdStatus", e.message || String(e));
      }
    });

    if (dlBtn){
      dlBtn.addEventListener("click", () => {
        if (!lastText) return;
        downloadBlob(new Blob([lastText], { type: "text/markdown;charset=utf-8" }), "document.md");
      });
    }
  }

  async function initPdf2Html(){
    const fileEl = $("pdf2htmlFile");
    const runBtn = $("pdf2htmlRunBtn");
    const dlBtn = $("pdf2htmlDownloadBtn");
    const outEl = $("pdf2htmlOut");
    if (!fileEl || !runBtn || !outEl) return;
    let lastHtml = "";

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = "";
        setStatus("pdf2htmlStatus", "Extracting text...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const pages = await pdfToTextPages(f, (p,n) => setStatus("pdf2htmlStatus", "Extracting page " + p + "/" + n + "..."));
        lastHtml = toHtml(pages);
        outEl.value = lastHtml;
        setStatus("pdf2htmlStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("pdf2htmlStatus", e.message || String(e));
      }
    });

    if (dlBtn){
      dlBtn.addEventListener("click", () => {
        if (!lastHtml) return;
        downloadBlob(new Blob([lastHtml], { type: "text/html;charset=utf-8" }), "document.html");
      });
    }
  }

  async function initPdf2Json(){
    const fileEl = $("pdf2jsonFile");
    const runBtn = $("pdf2jsonRunBtn");
    const dlBtn = $("pdf2jsonDownloadBtn");
    const outEl = $("pdf2jsonOut");
    if (!fileEl || !runBtn || !outEl) return;
    let lastObj = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.textContent = "";
        setStatus("pdf2jsonStatus", "Loading PDF...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        await ensurePDFLib();
        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const pdfDoc = await window.PDFLib.PDFDocument.load(bytes, { ignoreEncryption: true });

        const out = { fileName: f.name, pageCount: pdfDoc.getPageCount(), fields: [] };
        try {
          const form = pdfDoc.getForm();
          const fields = form.getFields();
          for (const fld of fields){
            const name = fld.getName ? fld.getName() : "unknown";
            const type = (fld.constructor && fld.constructor.name) ? fld.constructor.name : "Field";
            let value = null;
            try {
              if (fld.getText) value = fld.getText();
              else if (fld.isChecked) value = fld.isChecked();
              else if (fld.getSelected) value = fld.getSelected();
            } catch {}
            out.fields.push({ name: name, type: type, value: value });
          }
        } catch {}

        lastObj = out;
        outEl.textContent = JSON.stringify(out, null, 2);
        setStatus("pdf2jsonStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("pdf2jsonStatus", e.message || String(e));
      }
    });

    if (dlBtn){
      dlBtn.addEventListener("click", () => {
        if (!lastObj) return;
        downloadBlob(new Blob([JSON.stringify(lastObj, null, 2)], { type: "application/json;charset=utf-8" }), "document.json");
      });
    }
  }

  async function initExtractImgZip(){
    const fileEl = $("extractimgzipFile");
    const runBtn = $("extractimgzipRunBtn");
    const dlBtn = $("extractimgzipDownloadBtn");
    const scaleEl = $("extractimgzipScale");
    const fmtEl = $("extractimgzipFormat");
    const maxEl = $("extractimgzipMaxPages");
    const previewEl = $("extractimgzipPreview");
    if (!fileEl || !runBtn || !previewEl) return;
    let lastZipBlob = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        lastZipBlob = null;
        previewEl.innerHTML = "";
        setStatus("extractimgzipStatus", "Preparing...");

        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");

        const scale = Math.max(0.5, Math.min(4, parseFloat((scaleEl && scaleEl.value) || "1.5")));
        const fmt = (fmtEl && fmtEl.value === "jpg") ? "jpg" : "png";
        const maxPages = Math.max(1, parseInt((maxEl && maxEl.value) || "50", 10));

        await ensurePDFJS();
        await ensureJSZip();

        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
        const total = Math.min(doc.numPages, maxPages);
        if (doc.numPages > maxPages){
          setStatus("extractimgzipStatus", "Large PDF (" + doc.numPages + " pages). Exporting first " + maxPages + " pages...");
        }

        const zip = new window.JSZip();

        // Preview thumb (page 1)
        const thumbPage = await doc.getPage(1);
        const thumbViewport = thumbPage.getViewport({ scale: Math.min(scale, 1.2) });
        const thumbCanvas = document.createElement("canvas");
        thumbCanvas.width = Math.floor(thumbViewport.width);
        thumbCanvas.height = Math.floor(thumbViewport.height);
        await thumbPage.render({ canvasContext: thumbCanvas.getContext("2d"), viewport: thumbViewport }).promise;
        previewEl.appendChild(thumbCanvas);

        for (let p = 1; p <= total; p++){
          setStatus("extractimgzipStatus", "Rendering page " + p + "/" + total + "...");
          const page = await doc.getPage(p);
          const viewport = page.getViewport({ scale: scale });
          const canvas = document.createElement("canvas");
          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          const ctx = canvas.getContext("2d");
          await page.render({ canvasContext: ctx, viewport: viewport }).promise;

          const blob = await new Promise((resolve) => {
            if (fmt === "jpg"){
              canvas.toBlob((b) => resolve(b), "image/jpeg", 0.92);
            } else {
              canvas.toBlob((b) => resolve(b), "image/png");
            }
          });

          const name = "page-" + String(p).padStart(4, "0") + "." + fmt;
          zip.file(name, blob);
        }

        setStatus("extractimgzipStatus", "Zipping...");
        lastZipBlob = await zip.generateAsync({ type: "blob" });
        setStatus("extractimgzipStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("extractimgzipStatus", e.message || String(e));
      }
    });

    if (dlBtn){
      dlBtn.addEventListener("click", () => {
        if (!lastZipBlob) return;
        downloadBlob(lastZipBlob, "images.zip");
      });
    }
  }

  function initPack3(){
    initXml2Pdf();
    initPdf2Md();
    initPdf2Html();
    initPdf2Json();
    initExtractImgZip();
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", initPack3);
  else initPack3();
})();



/* PDFREALM_TABS_BOOTSTRAP_V1
   Ensures tool tab clicks work by calling initTabs().
*/
(function(){
  function bootTabs(){
    try {
      if (typeof initTabs === "function") {
        initTabs();
      } else {
        console.warn("[PDFRealm] initTabs() not found.");
      }

      // Tier tabs must run AFTER initTabs() so __pdfrealmActivateTool is available.
      try {
        if (window.PDFREALM_TIER && typeof window.PDFREALM_TIER.init === "function") {
          window.PDFREALM_TIER.init();
        } else {
          // If tier UI isn't present, make sure tool list isn't stuck hidden
          document.body && document.body.setAttribute("data-tier-ready", "1");
        }
      } catch (e) {
        console.warn("[PDFRealm] Tier init failed:", e);
        document.body && document.body.setAttribute("data-tier-ready", "1");
      }
    } catch (e) {
      console.warn("[PDFRealm] initTabs() failed:", e);
      document.body && document.body.setAttribute("data-tier-ready", "1");
    }
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", bootTabs);
  else bootTabs();
})();

/* PDFREALM_PACK4_TOOLS_V1
   Client-side tools added in Pack 4:
   - eml2pdf, heic2pdf, zip2pdf, pdf2csv, pdf2txt
*/
(function(){
  if (window.__pdfrealm_pack4_tools_v1) return;
  window.__pdfrealm_pack4_tools_v1 = true;

  const CDN_PDFLIB = "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
  const CDN_PDFJS  = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
  const CDN_JSZIP  = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
  const CDN_HEIC2ANY = "https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js";

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ""; }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement("script");
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === "function") return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error("pdf-lib failed to load");
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === "function") return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== "function") throw new Error("pdf.js failed to load");
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }
    } catch {}
  }

  async function ensureJSZip(){
    if (window.JSZip) return;
    await loadScriptOnce(CDN_JSZIP);
    if (!window.JSZip) throw new Error("JSZip failed to load");
  }

  async function ensureHeic2Any(){
    if (window.heic2any) return;
    await loadScriptOnce(CDN_HEIC2ANY);
    if (!window.heic2any) throw new Error("heic2any failed to load");
  }

  function csvEscape(s){
    const v = (s ?? "").toString();
    if (/[\",\n\r]/.test(v)) return '"' + v.replace(/"/g, '""') + '"';
    return v;
  }

  async function pdfExtractLinesByPage(file, onProgress){
    await ensurePDFJS();
    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
    const pagesOut = [];
    for (let p = 1; p <= doc.numPages; p++){
      if (onProgress) onProgress(p, doc.numPages);
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const items = (content.items || []).map(it => {
        const str = (it.str || "").trim();
        if (!str) return null;
        const t = it.transform || [];
        return { str, x: (t[4]||0), y: (t[5]||0) };
      }).filter(Boolean);

      const map = new Map();
      for (const it of items){
        const key = Math.round(it.y);
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(it);
      }
      const keys = Array.from(map.keys()).sort((a,b)=>b-a);
      const lines = [];
      for (const k of keys){
        const arr = map.get(k).sort((a,b)=>a.x-b.x);
        lines.push(arr.map(x=>x.str).join(" ").trim());
      }
      pagesOut.push(lines.filter(Boolean));
    }
    return pagesOut;
  }

  async function buildTextPdf(text){
    await ensurePDFLib();
    const PDFDocument = window.PDFLib.PDFDocument;
    const StandardFonts = window.PDFLib.StandardFonts;
    const rgb = window.PDFLib.rgb;
    const PageSizes = window.PDFLib.PageSizes;

    const doc = await PDFDocument.create();
    const font = await doc.embedFont(StandardFonts.Courier);
    const pageSize = PageSizes.Letter;
    const margin = 36;
    const fontSize = 10;
    const lineHeight = fontSize * 1.25;
    const raw = (text || "").replace(/\r\n/g, "\n");
    const rawLines = raw.split("\n");

    const maxCols = 110;
    const lines = [];
    for (const ln of rawLines){
      let s = ln || "";
      while (s.length > maxCols){ lines.push(s.slice(0, maxCols)); s = s.slice(maxCols); }
      lines.push(s);
    }

    let page = doc.addPage(pageSize);
    let y = page.getHeight() - margin;
    for (const ln of lines){
      if (y < margin + lineHeight){
        page = doc.addPage(pageSize);
        y = page.getHeight() - margin;
      }
      page.drawText(ln, { x: margin, y, size: fontSize, font, color: rgb(0.85,0.88,0.92) });
      y -= lineHeight;
    }

    const bytes = await doc.save();
    return new Blob([bytes], { type: "application/pdf" });
  }

  async function embedImagePage(pdfDoc, imgBytes, kind){
    const PageSizes = window.PDFLib.PageSizes;
    const page = pdfDoc.addPage(PageSizes.Letter);
    const margin = 24;
    const w = page.getWidth();
    const h = page.getHeight();
    const img = kind === "png" ? await pdfDoc.embedPng(imgBytes) : await pdfDoc.embedJpg(imgBytes);
    const iw = img.width, ih = img.height;
    const scale = Math.min((w-margin*2)/iw, (h-margin*2)/ih);
    const dw = iw*scale, dh = ih*scale;
    page.drawImage(img, { x:(w-dw)/2, y:(h-dh)/2, width:dw, height:dh });
  }

  function parseEml(emlText){
    const t = (emlText || "").replace(/\r\n/g, "\n");
    const idx = t.indexOf("\n\n");
    const headerPart = idx >= 0 ? t.slice(0, idx) : t;
    let bodyPart = idx >= 0 ? t.slice(idx+2) : "";

    const headerLines = headerPart.split("\n");
    const unfolded = [];
    for (const ln of headerLines){
      if (/^[ \t]/.test(ln) && unfolded.length) unfolded[unfolded.length-1] += " " + ln.trim();
      else unfolded.push(ln);
    }
    const headers = {};
    for (const ln of unfolded){
      const m = ln.match(/^([^:]+):\s*(.*)$/);
      if (!m) continue;
      const k = m[1].trim().toLowerCase();
      const v = m[2].trim();
      headers[k] = headers[k] ? (headers[k] + ", " + v) : v;
    }

    const ct = (headers["content-type"] || "").toLowerCase();
    if (ct.includes("multipart/") && ct.includes("boundary=")) {
      const b = (headers["content-type"] || "").match(/boundary="?([^";]+)"?/i);
      const boundary = b ? b[1] : null;
      if (boundary) {
        const parts = bodyPart.split("--" + boundary);
        for (const part of parts){
          const ptxt = part.trim();
          if (!ptxt || ptxt === "--") continue;
          const split = ptxt.indexOf("\n\n");
          const ph = split >= 0 ? ptxt.slice(0, split) : "";
          const pb = split >= 0 ? ptxt.slice(split+2) : "";
          if (/content-type:\s*text\/plain/i.test(ph)) { bodyPart = pb.trim(); break; }
        }
      }
    }

    return { headers, body: bodyPart.trim() };
  }

  async function initEml2Pdf(){
    const fileEl = $("eml2pdfFile"), buildBtn = $("eml2pdfBuildBtn"), dlBtn = $("eml2pdfDownloadBtn"), frame = $("eml2pdfPreviewFrame");
    if (!fileEl || !buildBtn) return;
    let lastBlob = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("eml2pdfStatus", "Reading email...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose an .eml file first.");
        const parsed = parseEml(await f.text());
        const h = parsed.headers;
        const content = [
          "From: " + (h.from||""),
          "To: " + (h.to||""),
          "Subject: " + (h.subject||""),
          "Date: " + (h.date||""),
          "",
          "---",
          "",
          (parsed.body||"")
        ].join("\n");
        setStatus("eml2pdfStatus", "Building PDF...");
        lastBlob = await buildTextPdf(content);
        setStatus("eml2pdfStatus", "Ready.");
        if (frame){ const url = URL.createObjectURL(lastBlob); frame.src = url; setTimeout(()=>URL.revokeObjectURL(url), 60000); }
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("eml2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> lastBlob && downloadBlob(lastBlob, "email.pdf"));
  }

  async function initHeic2Pdf(){
    const fileEl = $("heic2pdfFiles"), buildBtn = $("heic2pdfBuildBtn"), dlBtn = $("heic2pdfDownloadBtn"), frame = $("heic2pdfPreviewFrame");
    if (!fileEl || !buildBtn) return;
    let lastBlob = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("heic2pdfStatus", "Loading converter...");
        await ensureHeic2Any();
        await ensurePDFLib();
        const files = Array.from(fileEl.files || []);
        if (!files.length) throw new Error("Choose one or more HEIC files.");
        const pdfDoc = await window.PDFLib.PDFDocument.create();
        for (let i=0;i<files.length;i++){
          setStatus("heic2pdfStatus", "Converting " + (i+1) + "/" + files.length + "...");
          const out = await window.heic2any({ blob: files[i], toType: "image/jpeg", quality: 0.92 });
          const jpgBlob = Array.isArray(out) ? out[0] : out;
          await embedImagePage(pdfDoc, await jpgBlob.arrayBuffer(), "jpg");
        }
        lastBlob = new Blob([await pdfDoc.save()], { type: "application/pdf" });
        setStatus("heic2pdfStatus", "Ready.");
        if (frame){ const url = URL.createObjectURL(lastBlob); frame.src = url; setTimeout(()=>URL.revokeObjectURL(url), 60000); }
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("heic2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> lastBlob && downloadBlob(lastBlob, "images.pdf"));
  }

  async function initZip2Pdf(){
    const fileEl = $("zip2pdfFile"), buildBtn = $("zip2pdfBuildBtn"), dlBtn = $("zip2pdfDownloadBtn"), frame = $("zip2pdfPreviewFrame");
    if (!fileEl || !buildBtn) return;
    let lastBlob = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("zip2pdfStatus", "Loading ZIP...");
        const zf = fileEl.files && fileEl.files[0];
        if (!zf) throw new Error("Choose a .zip file first.");
        await ensureJSZip();
        await ensurePDFLib();
        const zip = await window.JSZip.loadAsync(await zf.arrayBuffer());
        const entries = [];
        zip.forEach((path, file) => { if (!file.dir) entries.push({ path, file }); });
        entries.sort((a,b)=>a.path.localeCompare(b.path));
        const pdfDoc = await window.PDFLib.PDFDocument.create();
        let added = 0;
        for (const ent of entries){
          const name = ent.path;
          const lower = name.toLowerCase();
          setStatus("zip2pdfStatus", "Adding " + name + "...");
          if (lower.endsWith(".png") || lower.endsWith(".jpg") || lower.endsWith(".jpeg")) {
            const ab = await ent.file.async("arraybuffer");
            await embedImagePage(pdfDoc, ab, lower.endsWith(".png") ? "png" : "jpg");
            added++;
            continue;
          }
          if (lower.endsWith(".txt") || lower.endsWith(".md") || lower.endsWith(".json") || lower.endsWith(".xml") || lower.endsWith(".html")) {
            const txt = await ent.file.async("string");
            const blob = await buildTextPdf("File: " + name + "\n\n" + txt);
            const tmp = await window.PDFLib.PDFDocument.load(await __pdfrealmPdfFileToBytesMaybeDecrypt(blob));
            const copied = await pdfDoc.copyPages(tmp, tmp.getPageIndices());
            copied.forEach(p => pdfDoc.addPage(p));
            added++;
          }
        }
        if (!added) throw new Error("No supported files found in ZIP (need JPG/PNG or text files)." );
        lastBlob = new Blob([await pdfDoc.save()], { type: "application/pdf" });
        setStatus("zip2pdfStatus", "Ready.");
        if (frame){ const url = URL.createObjectURL(lastBlob); frame.src = url; setTimeout(()=>URL.revokeObjectURL(url), 60000); }
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("zip2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> lastBlob && downloadBlob(lastBlob, "bundle.pdf"));
  }

  function pagesToCsv(pages){
    const rows = [];
    rows.push("page,line,text");
    for (let p=0;p<pages.length;p++){
      for (let i=0;i<pages[p].length;i++){
        rows.push([String(p+1), String(i+1), csvEscape(pages[p][i]||"")].join(","));
      }
    }
    return rows.join("\n") + "\n";
  }

  async function initPdf2Csv(){
    const fileEl = $("pdf2csvFile"), runBtn = $("pdf2csvRunBtn"), dlBtn = $("pdf2csvDownloadBtn"), outEl = $("pdf2csvOut");
    if (!fileEl || !runBtn || !outEl) return;
    let last = "";
    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = "";
        setStatus("pdf2csvStatus", "Extracting...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const pages = await pdfExtractLinesByPage(f, (p,n)=>setStatus("pdf2csvStatus", "Extracting page " + p + "/" + n + "..."));
        last = pagesToCsv(pages);
        outEl.value = last;
        setStatus("pdf2csvStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("pdf2csvStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(new Blob([last], {type:"text/csv;charset=utf-8"}), "document.csv"));
  }

  async function initPdf2Txt(){
    const fileEl = $("pdf2txtFile"), runBtn = $("pdf2txtRunBtn"), dlBtn = $("pdf2txtDownloadBtn"), outEl = $("pdf2txtOut");
    if (!fileEl || !runBtn || !outEl) return;
    let last = "";
    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = "";
        setStatus("pdf2txtStatus", "Extracting...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const pages = await pdfExtractLinesByPage(f, (p,n)=>setStatus("pdf2txtStatus", "Extracting page " + p + "/" + n + "..."));
        last = pages.map(lines=>lines.join("\n")).join("\n\n---\n\n") + "\n";
        outEl.value = last;
        setStatus("pdf2txtStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("pdf2txtStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(new Blob([last], {type:"text/plain;charset=utf-8"}), "document.txt"));
  }

  function initPack4(){ initEml2Pdf(); initHeic2Pdf(); initZip2Pdf(); initPdf2Csv(); initPdf2Txt(); }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", initPack4);
  else initPack4();
})();

/* PDFREALM_PACK5_TOOLS_V1
   Client-side tools added in Pack 5:
   - html2pdf, url2pdf, md2pdf, txt2pdf, csv2pdf
*/
(function(){
  if (window.__pdfrealm_pack5_tools_v1) return;
  window.__pdfrealm_pack5_tools_v1 = true;

  const CDN_PDFLIB = "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ""; }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement("script");
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === "function") return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error("pdf-lib failed to load");
  }

  function stripHtmlToText(html){
    const s = (html || "").replace(/\r\n/g, "\n");
    const noScript = s.replace(/<script[\s\S]*?<\/script>/gi, " ").replace(/<style[\s\S]*?<\/style>/gi, " ");
    const div = document.createElement("div");
    div.innerHTML = noScript;
    const text = (div.textContent || div.innerText || "");
    return text.replace(/\n{3,}/g, "\n\n").trim();
  }

  async function buildTextPdf(text){
    await ensurePDFLib();
    const PDFDocument = window.PDFLib.PDFDocument;
    const StandardFonts = window.PDFLib.StandardFonts;
    const rgb = window.PDFLib.rgb;
    const PageSizes = window.PDFLib.PageSizes;

    const doc = await PDFDocument.create();
    const font = await doc.embedFont(StandardFonts.Courier);
    const pageSize = PageSizes.Letter;
    const margin = 36;
    const fontSize = 10;
    const lineHeight = fontSize * 1.25;
    const raw = (text || "").replace(/\r\n/g, "\n");
    const rawLines = raw.split("\n");

    const maxCols = 110;
    const lines = [];
    for (const ln of rawLines){
      let s = ln || "";
      while (s.length > maxCols){ lines.push(s.slice(0, maxCols)); s = s.slice(maxCols); }
      lines.push(s);
    }

    let page = doc.addPage(pageSize);
    let y = page.getHeight() - margin;
    for (const ln of lines){
      if (y < margin + lineHeight){
        page = doc.addPage(pageSize);
        y = page.getHeight() - margin;
      }
      page.drawText(ln, { x: margin, y, size: fontSize, font, color: rgb(0.1,0.1,0.12) });
      y -= lineHeight;
    }

    const bytes = await doc.save();
    return new Blob([bytes], { type: "application/pdf" });
  }

  function parseCsv(text){
    const rows = [];
    const s = (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    let i = 0, field = "", row = [], inQuotes = false;
    function pushField(){ row.push(field); field = ""; }
    function pushRow(){ rows.push(row); row = []; }
    while (i < s.length){
      const ch = s[i];
      if (inQuotes){
        if (ch === '"'){
          const next = s[i+1];
          if (next === '"'){ field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += ch; i++; continue;
      }
      if (ch === '"'){ inQuotes = true; i++; continue; }
      if (ch === ','){ pushField(); i++; continue; }
      if (ch === '\n'){ pushField(); pushRow(); i++; continue; }
      field += ch; i++;
    }
    pushField();
    if (row.length > 1 || row[0] !== "" || rows.length) pushRow();
    // trim trailing empty rows
    while (rows.length && rows[rows.length-1].every(c => String(c||"").trim()==="")) rows.pop();
    return rows;
  }

  function rowsToMonospaceTable(rows, maxCols=10, maxRows=300){
    const r = rows.slice(0, maxRows).map(x => x.slice(0, maxCols));
    if (!r.length) return "";
    const colCount = Math.max(...r.map(x => x.length));
    const widths = new Array(colCount).fill(0);
    for (const row of r){
      for (let c=0;c<colCount;c++){
        const v = (row[c] ?? "").toString().trim();
        widths[c] = Math.min(40, Math.max(widths[c], v.length));
      }
    }
    const sep = widths.map(w => '-'.repeat(Math.max(3, Math.min(40, w)))).join("-+-");
    const lines = [];
    const pad = (s,w)=>{ s=(s??"").toString(); if (s.length>w) return s.slice(0, w-1)+"…"; return s + " ".repeat(w - s.length); };
    for (let idx=0; idx<r.length; idx++){
      const row = r[idx];
      const line = widths.map((w,c)=>pad((row[c]??"").toString().trim(), Math.max(3, Math.min(40, w)))).join(" | ");
      lines.push(line);
      if (idx === 0) lines.push(sep);
    }
    if (rows.length > maxRows) lines.push("\n[Truncated] Showing first " + maxRows + " rows.");
    if (colCount > maxCols) lines.push("\n[Truncated] Showing first " + maxCols + " columns.");
    return lines.join("\n");
  }

  function previewBlob(frameId, blob){
    const frame = $(frameId);
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(()=>URL.revokeObjectURL(url), 60000);
  }

  async function initHtml2Pdf(){
    const fileEl = $("html2pdfFile"), buildBtn = $("html2pdfBuildBtn"), dlBtn = $("html2pdfDownloadBtn");
    if (!fileEl || !buildBtn) return;
    let last = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("html2pdfStatus", "Reading HTML...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose an .html file first.");
        const html = await f.text();
        const text = stripHtmlToText(html);
        setStatus("html2pdfStatus", "Building PDF...");
        last = await buildTextPdf(text || "(No text extracted)");
        previewBlob("html2pdfPreviewFrame", last);
        setStatus("html2pdfStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("html2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(last, "document.html.pdf"));
  }

  async function initUrl2Pdf(){
    const urlEl = $("url2pdfUrl"), buildBtn = $("url2pdfBuildBtn"), dlBtn = $("url2pdfDownloadBtn");
    if (!urlEl || !buildBtn) return;
    let last = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const raw = (urlEl.value || "").trim();
        if (!raw) throw new Error("Paste a URL first.");
        setStatus("url2pdfStatus", "Fetching...");
        const resp = await fetch("/api/proxy-fetch?url=" + encodeURIComponent(raw));
        if (!resp.ok) {
          let msg = "Fetch failed";
          try { const j = await resp.json(); msg = j.error || msg; } catch {}
          throw new Error(msg);
        }
        const html = await resp.text();
        const text = stripHtmlToText(html);
        setStatus("url2pdfStatus", "Building PDF...");
        last = await buildTextPdf(("URL: " + raw + "\n\n" + (text || "(No text extracted)")));
        previewBlob("url2pdfPreviewFrame", last);
        setStatus("url2pdfStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("url2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(last, "webpage.pdf"));
  }

  async function initMd2Pdf(){
    const fileEl = $("md2pdfFile"), buildBtn = $("md2pdfBuildBtn"), dlBtn = $("md2pdfDownloadBtn");
    if (!fileEl || !buildBtn) return;
    let last = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("md2pdfStatus", "Reading markdown...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a .md file first.");
        const md = await f.text();
        setStatus("md2pdfStatus", "Building PDF...");
        last = await buildTextPdf(md || "(Empty file)");
        previewBlob("md2pdfPreviewFrame", last);
        setStatus("md2pdfStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("md2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(last, "document.md.pdf"));
  }

  async function initTxt2Pdf(){
    const fileEl = $("txt2pdfFile"), buildBtn = $("txt2pdfBuildBtn"), dlBtn = $("txt2pdfDownloadBtn");
    if (!fileEl || !buildBtn) return;
    let last = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("txt2pdfStatus", "Reading text...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a .txt file first.");
        const txt = await f.text();
        setStatus("txt2pdfStatus", "Building PDF...");
        last = await buildTextPdf(txt || "(Empty file)");
        previewBlob("txt2pdfPreviewFrame", last);
        setStatus("txt2pdfStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("txt2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(last, "document.txt.pdf"));
  }

  async function initCsv2Pdf(){
    const fileEl = $("csv2pdfFile"), buildBtn = $("csv2pdfBuildBtn"), dlBtn = $("csv2pdfDownloadBtn");
    if (!fileEl || !buildBtn) return;
    let last = null;
    buildBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("csv2pdfStatus", "Reading CSV...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a .csv file first.");
        const csv = await f.text();
        const rows = parseCsv(csv);
        const table = rowsToMonospaceTable(rows);
        setStatus("csv2pdfStatus", "Building PDF...");
        last = await buildTextPdf(table || "(No rows)" );
        previewBlob("csv2pdfPreviewFrame", last);
        setStatus("csv2pdfStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("csv2pdfStatus", e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener("click", ()=> last && downloadBlob(last, "document.csv.pdf"));
  }

  function initPack5(){
    initHtml2Pdf();
    initUrl2Pdf();
    initMd2Pdf();
    initTxt2Pdf();
    initCsv2Pdf();
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", initPack5);
  else initPack5();
})();
/* PDFREALM_PACK7_TOOLS_V1
   Client-side tools added in Pack 7:
   - smartcompress, deskewclean, pdf2pptx, extractembedded, visualdiff
*/
(function(){
  if (window.__pdfrealm_pack7_tools_v1) return;
  window.__pdfrealm_pack7_tools_v1 = true;

  const CDN_PDFLIB  = "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
  const CDN_PDFJS   = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
  const CDN_JSZIP   = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
  const CDN_PPTXGEN = "https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js";

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ""; }
  function setLog(id, msg){ const el = $(id); if (el) el.value = (msg || ""); }
  function appendLog(id, msg){
    const el = $(id);
    if(!el) return;
    el.value = (el.value ? (el.value + "\n") : "") + (msg || "");
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function previewBlob(frameId, blob){
    const frame = $(frameId);
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(()=>URL.revokeObjectURL(url), 60000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement("script");
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === "function") return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error("pdf-lib failed to load");
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === "function") return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== "function") throw new Error("pdf.js failed to load");
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }
    } catch {}
  }

  async function ensureJSZip(){
    if (window.JSZip) return;
    await loadScriptOnce(CDN_JSZIP);
    if (!window.JSZip) throw new Error("JSZip failed to load");
  }

  async function ensurePptxGen(){
    if (window.PptxGenJS || window.pptxgen) return;
    await loadScriptOnce(CDN_PPTXGEN);
    if (!window.PptxGenJS && !window.pptxgen) throw new Error("PptxGenJS failed to load");
  }

  function clamp(n, a, b){
    n = Number(n);
    if (!Number.isFinite(n)) n = a;
    return Math.max(a, Math.min(b, n));
  }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function pad3(n){ return String(n).padStart(3,'0'); }

  async function renderPdfPageToCanvas(page, dpi){
    const scale = (dpi || 144) / 72;
    const viewport = page.getViewport({ scale });
    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(viewport.width);
    canvas.height = Math.ceil(viewport.height);
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const renderTask = page.render({ canvasContext: ctx, viewport });
    await renderTask.promise;
    return { canvas, ctx, viewport, scale };
  }

  async function canvasToJpegArrayBuffer(canvas, quality){
    const q = clamp(quality, 0.1, 1.0);
    const blob = await new Promise(res => canvas.toBlob(res, "image/jpeg", q));
    if (!blob) throw new Error("Failed to encode JPEG");
    return await blob.arrayBuffer();
  }

  function rotateCanvas(srcCanvas, degrees){
    const deg = Number(degrees) || 0;
    if (!deg) return srcCanvas;
    const rad = deg * Math.PI / 180;
    const w = srcCanvas.width, h = srcCanvas.height;
    const dst = document.createElement("canvas");
    dst.width = w; dst.height = h;
    const ctx = dst.getContext("2d", { willReadFrequently: true });
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(rad);
    ctx.translate(-w/2, -h/2);
    ctx.drawImage(srcCanvas, 0, 0);
    ctx.restore();
    return dst;
  }

  function thresholdDespeckle(canvas, threshold){
    const t = clamp(threshold, 0, 255) | 0;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const d = img.data;
    for (let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2];
      const y = (0.2126*r + 0.7152*g + 0.0722*b);
      const v = y >= t ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
    }
    ctx.putImageData(img, 0, 0);
    return canvas;
  }

  async function rebuildPdfFromRenderedPages(file, dpi, jpegQuality, transformFn, statusId){
    await ensurePDFJS();
    await ensurePDFLib();

    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const srcDoc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
    const outDoc = await window.PDFLib.PDFDocument.create();

    for (let p=1; p<=srcDoc.numPages; p++){
      if (statusId) setStatus(statusId, "Rendering page " + p + "/" + srcDoc.numPages + "...");
      const page = await srcDoc.getPage(p);
      const viewport1 = page.getViewport({ scale: 1 }); // points
      const { canvas } = await renderPdfPageToCanvas(page, dpi);
      let c = canvas;
      if (typeof transformFn === "function") c = await transformFn(c, p);
      const jpg = await canvasToJpegArrayBuffer(c, jpegQuality);
      const img = await outDoc.embedJpg(jpg);
      const outPage = outDoc.addPage([viewport1.width, viewport1.height]);
      outPage.drawImage(img, { x: 0, y: 0, width: viewport1.width, height: viewport1.height });
    }

    const outBytes = await outDoc.save();
    return new Blob([outBytes], { type: "application/pdf" });
  }

  async function initSmartCompress(){
    const fileEl = $("smartcompressFile");
    const runBtn = $("smartcompressRunBtn");
    const dlBtn = $("smartcompressDownloadBtn");
    const dpiEl = $("smartcompressDpi");
    const qEl = $("smartcompressQuality");
    if (!fileEl || !runBtn) return;

    let last = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const dpi = clamp(dpiEl?.value || 150, 72, 300);
        const q = clamp(qEl?.value || 0.80, 0.10, 1.0);

        setStatus("smartcompressStatus", "Starting...");
        last = await rebuildPdfFromRenderedPages(f, dpi, q, null, "smartcompressStatus");
        previewBlob("smartcompressPreviewFrame", last);
        setStatus("smartcompressStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("smartcompressStatus", e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => last && downloadBlob(last, "compressed.pdf"));
  }

  async function initDeskewClean(){
    const fileEl = $("deskewcleanFile");
    const runBtn = $("deskewcleanRunBtn");
    const dlBtn = $("deskewcleanDownloadBtn");
    const dpiEl = $("deskewcleanDpi");
    const rotEl = $("deskewcleanRotate");
    const thEl = $("deskewcleanThresh");
    const qEl = $("deskewcleanQuality");
    if (!fileEl || !runBtn) return;

    let last = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const dpi = clamp(dpiEl?.value || 200, 72, 300);
        const rot = clamp(rotEl?.value || 0, -5, 5);
        const th = clamp(thEl?.value || 200, 0, 255);
        const q = clamp(qEl?.value || 0.85, 0.10, 1.0);

        setStatus("deskewcleanStatus", "Starting...");
        last = await rebuildPdfFromRenderedPages(
          f, dpi, q,
          async (canvas) => {
            const rotated = rotateCanvas(canvas, rot);
            return thresholdDespeckle(rotated, th);
          },
          "deskewcleanStatus"
        );
        previewBlob("deskewcleanPreviewFrame", last);
        setStatus("deskewcleanStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("deskewcleanStatus", e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => last && downloadBlob(last, "cleaned.pdf"));
  }

  async function initPdf2Pptx(){
    const fileEl = $("pdf2pptxFile");
    const runBtn = $("pdf2pptxRunBtn");
    const dlBtn = $("pdf2pptxDownloadBtn");
    const dpiEl = $("pdf2pptxDpi");
    if (!fileEl || !runBtn) return;

    let lastBlob = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setLog("pdf2pptxLog", "");

        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const dpi = clamp(dpiEl?.value || 144, 72, 240);

        setStatus("pdf2pptxStatus", "Loading libraries...");
        await ensurePDFJS();
        await ensurePptxGen();

        const PptxCtor = window.PptxGenJS || window.pptxgen;
        const pptx = new PptxCtor();
        try { pptx.layout = "LAYOUT_WIDE"; } catch {}

        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;

        appendLog("pdf2pptxLog", "Pages: " + doc.numPages);

        const SLIDE_W = 13.33, SLIDE_H = 7.5;

        for (let p=1; p<=doc.numPages; p++){
          setStatus("pdf2pptxStatus", "Rendering page " + p + "/" + doc.numPages + "...");
          const page = await doc.getPage(p);
          const { canvas } = await renderPdfPageToCanvas(page, dpi);
          const dataUrl = canvas.toDataURL("image/jpeg", 0.92);

          const slide = pptx.addSlide();
          const ar = canvas.width / canvas.height;

          let w = SLIDE_W, h = SLIDE_H;
          if (w / h > ar) w = h * ar;
          else h = w / ar;

          const x = (SLIDE_W - w) / 2;
          const y = (SLIDE_H - h) / 2;

          slide.addImage({ data: dataUrl, x, y, w, h });
          appendLog("pdf2pptxLog", "Added slide " + p);
        }

        setStatus("pdf2pptxStatus", "Building PPTX...");
        let out = await pptx.write("blob");
        if (out instanceof Blob) lastBlob = out;
        else lastBlob = new Blob([out], { type: "application/vnd.openxmlformats-officedocument.presentationml.presentation" });

        setStatus("pdf2pptxStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("pdf2pptxStatus", e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => lastBlob && downloadBlob(lastBlob, "slides.pptx"));
  }

  function getPdfObjPromise(objs, name){
    return new Promise((resolve) => {
      try {
        const direct = objs.get(name);
        if (direct) return resolve(direct);
      } catch {}
      try { objs.get(name, resolve); } catch { resolve(null); }
    });
  }

  async function imageObjToPngBlob(obj){
    if (!obj) return null;
    const w = obj.width || obj.w || 0;
    const h = obj.height || obj.h || 0;
    if (!w || !h) return null;

    let data = obj.data || obj;
    if (!data || !data.length) return null;

    const canvas = document.createElement("canvas");
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    let rgba;
    if (data.length === w*h*4){
      rgba = new Uint8ClampedArray(data);
    } else if (data.length === w*h*3){
      rgba = new Uint8ClampedArray(w*h*4);
      for (let i=0, j=0; i<data.length; i+=3, j+=4){
        rgba[j] = data[i];
        rgba[j+1] = data[i+1];
        rgba[j+2] = data[i+2];
        rgba[j+3] = 255;
      }
    } else {
      return null;
    }

    ctx.putImageData(new ImageData(rgba, w, h), 0, 0);
    const blob = await new Promise(res => canvas.toBlob(res, "image/png"));
    return blob || null;
  }

  async function initExtractEmbedded(){
    const fileEl = $("extractembeddedFile");
    const runBtn = $("extractembeddedRunBtn");
    const dlBtn = $("extractembeddedDownloadBtn");
    if (!fileEl || !runBtn) return;

    let lastZipBlob = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setLog("extractembeddedLog", "");

        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");

        setStatus("extractembeddedStatus", "Loading...");
        await ensurePDFJS();
        await ensureJSZip();

        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;

        const zip = new window.JSZip();
        let total = 0;

        const OPS = window.pdfjsLib.OPS || {};

        for (let p=1; p<=doc.numPages; p++){
          setStatus("extractembeddedStatus", "Scanning page " + p + "/" + doc.numPages + "...");
          const page = await doc.getPage(p);
          const opList = await page.getOperatorList();

          const fnArray = opList.fnArray || [];
          const argsArray = opList.argsArray || [];

          const names = [];
          for (let i=0; i<fnArray.length; i++){
            const fn = fnArray[i];
            if (fn === OPS.paintImageXObject || fn === OPS.paintJpegXObject){
              const args = argsArray[i] || [];
              if (args[0]) names.push(args[0]);
            }
          }

          const uniq = Array.from(new Set(names));
          appendLog("extractembeddedLog", "Page " + p + ": found " + uniq.length + " image refs");

          let imgIdx = 0;
          for (const name of uniq){
            const objA = await getPdfObjPromise(page.objs, name);
            const objB = objA || (page.commonObjs ? await getPdfObjPromise(page.commonObjs, name) : null);
            const blob = await imageObjToPngBlob(objB);

            if (!blob){
              appendLog("extractembeddedLog", "  - " + name + ": skip (unavailable/unsupported)");
              continue;
            }

            imgIdx++; total++;
            const fname = "page-" + pad3(p) + "_img-" + pad2(imgIdx) + ".png";
            zip.file(fname, blob);
            appendLog("extractembeddedLog", "  - " + fname);
          }
        }

        if (!total) throw new Error("No extractable image XObjects found (v1).");

        setStatus("extractembeddedStatus", "Building ZIP...");
        lastZipBlob = await zip.generateAsync({ type: "blob" });

        setStatus("extractembeddedStatus", "Ready. Extracted " + total + " images.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("extractembeddedStatus", e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => lastZipBlob && downloadBlob(lastZipBlob, "embedded-images.zip"));
  }

  function diffPixels(a, b, threshold){
    const t = clamp(threshold, 0, 255) | 0;
    const n = Math.min(a.length, b.length);
    const out = new Uint8ClampedArray(n);
    let changed = 0;
    for (let i=0;i<n;i+=4){
      const dr = Math.abs(a[i] - b[i]);
      const dg = Math.abs(a[i+1] - b[i+1]);
      const db = Math.abs(a[i+2] - b[i+2]);
      const v = Math.max(dr, dg, db);
      if (v > t){
        changed++;
        out[i]=255; out[i+1]=0; out[i+2]=0; out[i+3]=255;
      } else {
        out[i]=255; out[i+1]=255; out[i+2]=255; out[i+3]=255;
      }
    }
    const px = n/4;
    const pct = px ? (changed/px)*100 : 0;
    return { out, pct, changed, total: px };
  }

  async function initVisualDiff(){
    const aEl = $("visualdiffA");
    const bEl = $("visualdiffB");
    const runBtn = $("visualdiffRunBtn");
    const dlBtn = $("visualdiffDownloadBtn");
    const dpiEl = $("visualdiffDpi");
    const thEl = $("visualdiffThreshold");
    if (!aEl || !bEl || !runBtn) return;

    let lastZip = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setLog("visualdiffLog", "");

        const fa = aEl.files && aEl.files[0];
        const fb = bEl.files && bEl.files[0];
        if (!fa || !fb) throw new Error("Choose PDF A and PDF B.");

        const dpi = clamp(dpiEl?.value || 120, 72, 200);
        const th = clamp(thEl?.value || 18, 0, 255);

        setStatus("visualdiffStatus", "Loading...");
        await ensurePDFJS();
        await ensureJSZip();

        const da = await window.pdfjsLib.getDocument({ data: await __pdfrealmPdfFileToBytesMaybeDecrypt(fa) }).promise;
        const db = await window.pdfjsLib.getDocument({ data: await __pdfrealmPdfFileToBytesMaybeDecrypt(fb) }).promise;

        const pages = Math.min(da.numPages, db.numPages);
        appendLog("visualdiffLog", "Pages compared: " + pages + " (A=" + da.numPages + ", B=" + db.numPages + ")");

        const zip = new window.JSZip();
        const summary = [];

        for (let p=1; p<=pages; p++){
          setStatus("visualdiffStatus", "Rendering page " + p + "/" + pages + "...");
          const pa = await da.getPage(p);
          const pb = await db.getPage(p);

          const ra = await renderPdfPageToCanvas(pa, dpi);
          const rb = await renderPdfPageToCanvas(pb, dpi);

          const w = Math.min(ra.canvas.width, rb.canvas.width);
          const h = Math.min(ra.canvas.height, rb.canvas.height);

          const ca = document.createElement("canvas"); ca.width=w; ca.height=h;
          const cb = document.createElement("canvas"); cb.width=w; cb.height=h;

          ca.getContext("2d").drawImage(ra.canvas, 0, 0, w, h);
          cb.getContext("2d").drawImage(rb.canvas, 0, 0, w, h);

          const ida = ca.getContext("2d", { willReadFrequently:true }).getImageData(0,0,w,h).data;
          const idb = cb.getContext("2d", { willReadFrequently:true }).getImageData(0,0,w,h).data;

          const { out, pct } = diffPixels(ida, idb, th);

          const diffC = document.createElement("canvas"); diffC.width=w; diffC.height=h;
          const dctx = diffC.getContext("2d", { willReadFrequently:true });
          dctx.putImageData(new ImageData(out, w, h), 0, 0);

          const png = await new Promise(res => diffC.toBlob(res, "image/png"));
          if (png) zip.file("diff_page-" + pad3(p) + ".png", png);

          summary.push({ page: p, diffPercent: Number(pct.toFixed(3)) });
          appendLog("visualdiffLog", "Page " + p + ": diff ~ " + pct.toFixed(3) + "%");
        }

        zip.file("summary.json", JSON.stringify({ pages, threshold: th, dpi, summary }, null, 2));
        zip.file("summary.txt", summary.map(s => "page " + s.page + ": " + s.diffPercent + "%").join("\n") + "\n");

        setStatus("visualdiffStatus", "Building ZIP...");
        lastZip = await zip.generateAsync({ type: "blob" });

        setStatus("visualdiffStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus("visualdiffStatus", e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => lastZip && downloadBlob(lastZip, "visual-diff.zip"));
  }

  function initPack7(){
    initSmartCompress();
    initDeskewClean();
    initPdf2Pptx();
    initExtractEmbedded();
    initVisualDiff();
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", initPack7);
  else initPack7();
})();
/* PDFREALM_PACK8_TOOLS_V1
   Client-side tools added in Pack 8:
   - templaterun, batchrename, extractattach, extractfonts, pdf2epub
*/
(function(){
  if (window.__pdfrealm_pack8_tools_v1) return;
  window.__pdfrealm_pack8_tools_v1 = true;

  const CDN_PDFLIB = "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
  const CDN_PDFJS  = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
  const CDN_JSZIP  = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ""; }
  function setValue(id, msg){ const el = $(id); if (el) el.value = msg || ""; }
  function appendValue(id, msg){ const el = $(id); if (!el) return; el.value = (el.value ? (el.value + "\\n") : "") + (msg || ""); }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function previewBlob(frameId, blob){
    const frame = $(frameId);
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(() => URL.revokeObjectURL(url), 60000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement("script");
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === "function") return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error("pdf-lib failed to load");
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === "function") return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== "function") throw new Error("pdf.js failed to load");
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }
    } catch {}
  }

  async function ensureJSZip(){
    if (window.JSZip) return;
    await loadScriptOnce(CDN_JSZIP);
    if (!window.JSZip) throw new Error("JSZip failed to load");
  }

  function clampInt(v, a, b){ const n = Number(v); if (!Number.isFinite(n)) return a; return Math.max(a, Math.min(b, Math.round(n))); }
  function safeName(s){
    return (s || "").toString().trim().replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_\-\.]/g, "").replace(/_+/g, "_").replace(/^_+|_+$/g, "");
  }

  // ---- PDF text sampling (simple line grouping) ----
  async function extractTextPages(file, pagesToSample, onProgress){
    await ensurePDFJS();
    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
    const n = Math.min(doc.numPages, pagesToSample);
    const outPages = [];
    for (let p=1; p<=n; p++){
      if (onProgress) onProgress(p, n);
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const items = (content.items || []).map(it => {
        const str = (it.str || "").trim();
        if (!str) return null;
        const t = it.transform || [];
        return { str, x: (t[4]||0), y: (t[5]||0), fontName: it.fontName || "" };
      }).filter(Boolean);
      const byLine = new Map();
      for (const it of items){
        const key = Math.round(it.y);
        if (!byLine.has(key)) byLine.set(key, []);
        byLine.get(key).push(it);
      }
      const ys = Array.from(byLine.keys()).sort((a,b)=>b-a);
      const lines = [];
      for (const y of ys){
        const arr = byLine.get(y).sort((a,b)=>a.x-b.x);
        lines.push(arr.map(x=>x.str).join(" ").trim());
      }
      outPages.push(lines.filter(Boolean).join("\\n"));
    }
    return { text: outPages.join("\\n\\n---\\n\\n"), doc };
  }

  // ---- 1) Template Runner (fillable PDF + JSON -> filled PDF) ----
  async function initTemplateRun(){
    const tplEl = $("templaterunTemplate");
    const jsonEl = $("templaterunJson");
    const listBtn = $("templaterunListBtn");
    const runBtn = $("templaterunRunBtn");
    const dlBtn = $("templaterunDownloadBtn");
    const flattenEl = $("templaterunFlatten");
    const fieldsOut = $("templaterunFields");
    if (!tplEl || !listBtn || !runBtn) return;
    let lastBlob = null;

    async function loadTemplateDoc(){
      await ensurePDFLib();
      const f = tplEl.files && tplEl.files[0];
      if (!f) throw new Error("Choose a template PDF first.");
      const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
      return await window.PDFLib.PDFDocument.load(bytes);
    }

    function listFields(pdfDoc){
      const form = pdfDoc.getForm();
      return form.getFields().map(f => ({ name: f.getName(), type: (f.constructor && f.constructor.name) ? f.constructor.name : "Field" }));
    }

    function parseJsonFromFile(file){
      return file.text().then(t => {
        const s = (t || "").trim();
        if (!s) return {};
        try { return JSON.parse(s); }
        catch {
          const obj = {};
          s.split(/\r?\n/).forEach(line => {
            const m = line.match(/^\s*([^=:#]+)\s*[:=#]\s*(.+)\s*$/);
            if (m) obj[m[1].trim()] = m[2].trim();
          });
          return obj;
        }
      });
    }

    function trySetField(form, key, val){
      const v = (val === null || val === undefined) ? "" : val;
      try { form.getTextField(key).setText(String(v)); return "text"; } catch {}
      try {
        const cb = form.getCheckBox(key);
        const truthy = (typeof v === "boolean") ? v : /^(1|true|yes|y|on)$/i.test(String(v).trim());
        if (truthy) cb.check(); else cb.uncheck();
        return "checkbox";
      } catch {}
      try { form.getDropdown(key).select(String(v)); return "dropdown"; } catch {}
      try { form.getRadioGroup(key).select(String(v)); return "radio"; } catch {}
      try { form.getOptionList(key).select(String(v)); return "optionlist"; } catch {}
      return null;
    }

    listBtn.addEventListener("click", async () => {
      try {
        setStatus("templaterunStatus", "Loading template...");
        const pdfDoc = await loadTemplateDoc();
        const fields = listFields(pdfDoc);
        const txt = fields.map(f => f.name + "  (" + f.type + ")").join("\\n") + (fields.length ? "\\n" : "");
        if (fieldsOut) fieldsOut.value = txt || "No AcroForm fields detected.";
        setStatus("templaterunStatus", "Ready.");
      } catch (e){ setStatus("templaterunStatus", e.message || String(e)); }
    });

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("templaterunStatus", "Loading...");
        const pdfDoc = await loadTemplateDoc();
        const jf = jsonEl.files && jsonEl.files[0];
        if (!jf) throw new Error("Choose a JSON data file.");
        const data = await parseJsonFromFile(jf);
        const form = pdfDoc.getForm();
        const keys = Object.keys(data || {});
        if (!keys.length) throw new Error("JSON has no keys.");
        const applied = [];
        const missing = [];
        for (const k of keys){
          const kind = trySetField(form, k, data[k]);
          if (kind) applied.push({ k, kind }); else missing.push(k);
        }
        if (flattenEl && flattenEl.checked) { try { form.flatten(); } catch {} }
        const outBytes = await pdfDoc.save();
        lastBlob = new Blob([outBytes], { type: "application/pdf" });
        previewBlob("templaterunPreviewFrame", lastBlob);
        const report = [
          "Applied fields: " + applied.length,
          applied.slice(0, 200).map(x => "  - " + x.k + " (" + x.kind + ")").join("\\n"),
          missing.length ? ("\\nMissing/unmatched keys: " + missing.length + "\\n" + missing.slice(0, 200).map(x => "  - " + x).join("\\n")) : ""
        ].filter(Boolean).join("\\n");
        if (fieldsOut) fieldsOut.value = report + "\\n";
        setStatus("templaterunStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("templaterunStatus", e.message || String(e)); }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => { if (lastBlob) downloadBlob(lastBlob, "filled.pdf"); });
  }

  // ---- 2) Batch rename by content (v1) ----
  function makeStopwords(){
    return new Set([
      "the","and","for","with","from","this","that","you","your","are","was","were","have","has","had","not","but","can","will","shall",
      "to","of","in","on","at","by","as","an","a","or","is","it","be","we","our","us","they","their","them","i","me","my",
      "page","pages","pdf","document","invoice","bill","shipping","address","date","due","total","amount"
    ]);
  }
  function topKeywords(text, n){
    const stop = makeStopwords();
    const words = (text || "").toLowerCase().replace(/[^a-z0-9\s]/g, " ").split(/\s+/).filter(w => w && w.length >= 3 && !stop.has(w));
    const freq = new Map();
    for (const w of words) freq.set(w, (freq.get(w) || 0) + 1);
    return Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]).slice(0, n).map(x=>x[0]);
  }
  function yyyy_mm_dd(){ const d=new Date(); const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,"0"); const day=String(d.getDate()).padStart(2,"0"); return y+"-"+m+"-"+day; }

  async function initBatchRename(){
    const fileEl = $("batchrenameFile");
    const runBtn = $("batchrenameRunBtn");
    const dlBtn  = $("batchrenameDownloadBtn");
    const pagesEl = $("batchrenamePages");
    const wordsEl = $("batchrenameWords");
    const outEl = $("batchrenameOut");
    const sampleEl = $("batchrenameSample");
    if (!fileEl || !runBtn) return;
    let lastBlob = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("batchrenameStatus", "Reading...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const pages = clampInt(pagesEl ? pagesEl.value : 2, 1, 10) || 2;
        const topN = clampInt(wordsEl ? wordsEl.value : 5, 3, 12) || 5;
        const res = await extractTextPages(f, pages, (p,n)=>setStatus("batchrenameStatus", "Extracting page " + p + "/" + n + "..."));
        if (sampleEl) sampleEl.value = res.text;
        const keys = topKeywords(res.text, topN);
        const base = safeName(keys.join("_"));
        const name = (base ? (base + "_") : "") + yyyy_mm_dd() + ".pdf";
        if (outEl) outEl.value = name;
        lastBlob = new Blob([await f.arrayBuffer()], { type: "application/pdf" });
        setStatus("batchrenameStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("batchrenameStatus", e.message || String(e)); }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => {
      if (!lastBlob) return;
      let name = safeName(outEl ? outEl.value : "renamed.pdf") || "renamed.pdf";
      if (!/\.pdf$/i.test(name)) name += ".pdf";
      downloadBlob(lastBlob, name);
    });
  }

  // ---- 3) Extract embedded attachments -> ZIP (pdf.js) ----
  async function initExtractAttach(){
    const fileEl = $("extractattachFile");
    const runBtn = $("extractattachRunBtn");
    const dlBtn  = $("extractattachDownloadBtn");
    if (!fileEl || !runBtn) return;
    let lastZip = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setValue("extractattachLog", "");
        setStatus("extractattachStatus", "Loading...");
        await ensurePDFJS();
        await ensureJSZip();
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
        if (typeof doc.getAttachments !== "function") throw new Error("pdf.js getAttachments() not available in this build.");
        setStatus("extractattachStatus", "Extracting attachments...");
        const atts = await doc.getAttachments();
        const names = atts ? Object.keys(atts) : [];
        if (!names.length) throw new Error("No embedded attachments found.");
        const zip = new window.JSZip();
        for (const k of names){
          const a = atts[k];
          const fn = (a && a.filename) ? a.filename : (k || "attachment.bin");
          const content = (a && a.content) ? a.content : null;
          if (!content) continue;
          zip.file(fn, content);
          appendValue("extractattachLog", " - " + fn + " (" + (content.length || 0) + " bytes)");
        }
        lastZip = await zip.generateAsync({ type: "blob" });
        setStatus("extractattachStatus", "Ready. " + names.length + " attachment(s).");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("extractattachStatus", e.message || String(e)); }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => { if (lastZip) downloadBlob(lastZip, "attachments.zip"); });
  }

  // ---- 4) Extract fonts report -> ZIP ----
  function csvEscape(v){ const s = (v ?? "").toString(); return /[",\n\r]/.test(s) ? ('"' + s.replace(/"/g,'""') + '"') : s; }

  async function initExtractFonts(){
    const fileEl = $("extractfontsFile");
    const runBtn = $("extractfontsRunBtn");
    const dlBtn  = $("extractfontsDownloadBtn");
    const outEl  = $("extractfontsOut");
    if (!fileEl || !runBtn) return;
    let lastZip = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        if (outEl) outEl.value = "";
        setStatus("extractfontsStatus", "Loading...");
        await ensurePDFJS();
        await ensureJSZip();
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
        const fontSet = new Map();
        const perPage = [];
        for (let p=1; p<=doc.numPages; p++){
          setStatus("extractfontsStatus", "Scanning page " + p + "/" + doc.numPages + "...");
          const page = await doc.getPage(p);
          const tc = await page.getTextContent();
          const styles = tc.styles || {};
          const names = new Set();
          for (const it of (tc.items || [])){ if (it.fontName) names.add(it.fontName); }
          const pageFonts = [];
          names.forEach(nm => {
            const st = styles[nm] || {};
            const rec = { fontName: nm, fontFamily: st.fontFamily || "", ascent: (st.ascent ?? ""), descent: (st.descent ?? ""), vertical: (st.vertical ?? "") };
            pageFonts.push(rec);
            if (!fontSet.has(nm)) fontSet.set(nm, rec);
          });
          perPage.push({ page: p, fonts: pageFonts });
        }
        const all = Array.from(fontSet.values()).sort((a,b)=>String(a.fontName).localeCompare(String(b.fontName)));
        const reportTxt = [
          "Fonts found: " + all.length,
          "",
          ...all.map(fx => "- " + fx.fontName + (fx.fontFamily ? ("  [" + fx.fontFamily + "]") : ""))
        ].join("\\n") + "\\n";
        const csv = ["fontName,fontFamily,ascent,descent,vertical"].concat(all.map(fx => [csvEscape(fx.fontName),csvEscape(fx.fontFamily),csvEscape(fx.ascent),csvEscape(fx.descent),csvEscape(fx.vertical)].join(","))).join("\\n") + "\\n";
        const json = JSON.stringify({ total: all.length, fonts: all, perPage }, null, 2);
        if (outEl) outEl.value = reportTxt;
        const zip = new window.JSZip();
        zip.file("fonts.txt", reportTxt);
        zip.file("fonts.csv", csv);
        zip.file("fonts.json", json);
        lastZip = await zip.generateAsync({ type: "blob" });
        setStatus("extractfontsStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("extractfontsStatus", e.message || String(e)); }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => { if (lastZip) downloadBlob(lastZip, "fonts-report.zip"); });
  }

  // ---- 5) PDF -> EPUB (text-only v1) ----
  function epubEscape(s){ return (s || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\"/g,"&quot;"); }

  async function buildEpubFromText(title, author, text){
    await ensureJSZip();
    const zip = new window.JSZip();
    zip.file("mimetype", "application/epub+zip", { compression: "STORE" });
    const containerXml = '<?xml version="1.0" encoding="UTF-8"?>' +
      '<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">' +
      '<rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles>' +
      '</container>';
    zip.file("META-INF/container.xml", containerXml);
    const uid = "pdfrealm-" + Math.random().toString(16).slice(2);
    const safeTitle = epubEscape(title || "PDFRealm Export");
    const safeAuthor = epubEscape(author || "");
    const contentXhtml = '<?xml version="1.0" encoding="utf-8"?>' +
      '<!DOCTYPE html>' +
      '<html xmlns="http://www.w3.org/1999/xhtml">' +
      '<head><title>' + safeTitle + '</title><meta charset="utf-8"/>' +
      '<style>body{font-family:serif;line-height:1.4;}pre{white-space:pre-wrap;}</style></head>' +
      '<body><h1>' + safeTitle + '</h1>' + (safeAuthor ? ('<h3>' + safeAuthor + '</h3>') : '') +
      '<pre>' + epubEscape(text || "") + '</pre></body></html>';
    zip.file("OEBPS/Text/content.xhtml", contentXhtml);
    const opf = '<?xml version="1.0" encoding="UTF-8"?>' +
      '<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">' +
      '<metadata xmlns:dc="http://purl.org/dc/elements/1.1/">' +
      '<dc:title>' + safeTitle + '</dc:title>' + (safeAuthor ? ('<dc:creator>' + safeAuthor + '</dc:creator>') : '') +
      '<dc:language>en</dc:language><dc:identifier id="BookId">' + uid + '</dc:identifier>' +
      '</metadata><manifest>' +
      '<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>' +
      '<item id="content" href="Text/content.xhtml" media-type="application/xhtml+xml"/>' +
      '</manifest><spine toc="ncx"><itemref idref="content"/></spine></package>';
    zip.file("OEBPS/content.opf", opf);
    const ncx = '<?xml version="1.0" encoding="UTF-8"?>' +
      '<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">' +
      '<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">' +
      '<head><meta name="dtb:uid" content="' + uid + '"/></head>' +
      '<docTitle><text>' + safeTitle + '</text></docTitle><navMap>' +
      '<navPoint id="navPoint-1" playOrder="1"><navLabel><text>' + safeTitle + '</text></navLabel><content src="Text/content.xhtml"/></navPoint>' +
      '</navMap></ncx>';
    zip.file("OEBPS/toc.ncx", ncx);
    return await zip.generateAsync({ type: "blob" });
  }

  async function initPdf2Epub(){
    const fileEl = $("pdf2epubFile");
    const runBtn = $("pdf2epubRunBtn");
    const dlBtn  = $("pdf2epubDownloadBtn");
    const titleEl = $("pdf2epubTitle");
    const authorEl = $("pdf2epubAuthor");
    const previewEl = $("pdf2epubPreview");
    if (!fileEl || !runBtn) return;
    let lastEpub = null;

    runBtn.addEventListener("click", async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        setStatus("pdf2epubStatus", "Extracting text...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a PDF first.");
        const res = await extractTextPages(f, 200, (p,n)=>setStatus("pdf2epubStatus", "Extracting page " + p + "/" + n + "..."));
        if (previewEl) previewEl.value = (res.text || "").slice(0, 4000);
        const title = (titleEl && titleEl.value) ? titleEl.value : (f.name.replace(/\.pdf$/i, "") || "PDFRealm Export");
        const author = (authorEl && authorEl.value) ? authorEl.value : "";
        setStatus("pdf2epubStatus", "Building EPUB...");
        lastEpub = await buildEpubFromText(title, author, res.text);
        setStatus("pdf2epubStatus", "Ready.");
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus("pdf2epubStatus", e.message || String(e)); }
    });

    if (dlBtn) dlBtn.addEventListener("click", () => {
      if (!lastEpub) return;
      let base = safeName((titleEl && titleEl.value) ? titleEl.value : "export") || "export";
      if (!/\.epub$/i.test(base)) base += ".epub";
      downloadBlob(lastEpub, base);
    });
  }

  function initPack8(){
    initTemplateRun();
    initBatchRename();
    initExtractAttach();
    initExtractFonts();
    initPdf2Epub();
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", initPack8);
  else initPack8();
})();

/* PDFREALM_PACK11_TOOLS_V1
   Client-side tools added in Pack 11:
   - epub2pdf, qrbarcode, bulkqrbarcode, webhooksend, pdfperms
*/
(function(){
  if (window.__pdfrealm_pack11_tools_v1) return;
  window.__pdfrealm_pack11_tools_v1 = true;

  const CDN_PDFLIB = 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js';
  const CDN_PDFJS  = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
  const CDN_JSZIP  = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
  const CDN_QRCODE = 'https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js';
  const CDN_JSBARCODE = 'https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js';

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ''; }
  function appendLog(id, msg){ const el = $(id); if(!el) return; el.value = (el.value ? (el.value + '\n') : '') + (msg || ''); }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'download';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function previewBlob(frameId, blob){
    const frame = $(frameId);
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(() => URL.revokeObjectURL(url), 60000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement('script');
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('Failed to load ' + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === 'function') return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error('pdf-lib failed to load');
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === 'function') return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== 'function') throw new Error('pdf.js failed to load');
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    } catch {}
  }

  async function ensureJSZip(){
    if (window.JSZip) return;
    await loadScriptOnce(CDN_JSZIP);
    if (!window.JSZip) throw new Error('JSZip failed to load');
  }

  async function ensureQRCode(){
    if (window.QRCode && typeof window.QRCode.toDataURL === 'function') return;
    await loadScriptOnce(CDN_QRCODE);
    if (!window.QRCode || typeof window.QRCode.toDataURL !== 'function') throw new Error('qrcode failed to load');
  }

  async function ensureJsBarcode(){
    if (window.JsBarcode) return;
    await loadScriptOnce(CDN_JSBARCODE);
    if (!window.JsBarcode) throw new Error('JsBarcode failed to load');
  }

  async function buildTextPdf(text){
    await ensurePDFLib();
    const { PDFDocument, StandardFonts, rgb, PageSizes } = window.PDFLib;
    const doc = await PDFDocument.create();
    const font = await doc.embedFont(StandardFonts.Courier);
    const pageSize = PageSizes.Letter;
    const margin = 36;
    const fontSize = 10;
    const lineHeight = fontSize * 1.25;
    const raw = (text || '').replace(/\r\n/g, '\n');
    const rawLines = raw.split('\n');
    const maxCols = 110;
    const lines = [];
    for (const ln of rawLines){
      let s = ln || '';
      while (s.length > maxCols){ lines.push(s.slice(0, maxCols)); s = s.slice(maxCols); }
      lines.push(s);
    }
    let page = doc.addPage(pageSize);
    let y = page.getHeight() - margin;
    for (const ln of lines){
      if (y < margin + lineHeight){ page = doc.addPage(pageSize); y = page.getHeight() - margin; }
      page.drawText(ln, { x: margin, y, size: fontSize, font, color: rgb(0.85,0.88,0.92) });
      y -= lineHeight;
    }
    const bytes = await doc.save();
    return new Blob([bytes], { type: 'application/pdf' });
  }

  function normText(t){ return (t || '').replace(/\s+/g, ' ').replace(/\u00A0/g, ' ').trim(); }

  function joinPath(base, rel){
    if (!base) return rel;
    if (!rel) return base;
    if (/^[a-z]+:\/\/\//i.test(rel)) return rel;
    const b = base.replace(/\\/g,'/');
    const stack = b.split('/');
    stack.pop();
    const parts = rel.replace(/\\/g,'/').split('/');
    for (const p of parts){
      if (!p || p === '.') continue;
      if (p === '..') stack.pop();
      else stack.push(p);
    }
    return stack.join('/');
  }

  async function epubToText(file, statusCb){
    await ensureJSZip();
    const zip = await window.JSZip.loadAsync(await file.arrayBuffer());
    const container = await (zip.file('META-INF/container.xml') ? zip.file('META-INF/container.xml').async('string') : null);
    if (!container) throw new Error('Invalid EPUB: missing META-INF/container.xml');
    const dom = new DOMParser().parseFromString(container, 'application/xml');
    const rootfile = dom.querySelector('rootfile');
    const opfPath = rootfile ? rootfile.getAttribute('full-path') : null;
    if (!opfPath) throw new Error('Invalid EPUB: missing OPF path');
    if (statusCb) statusCb('Reading package...');
    const opfXml = await (zip.file(opfPath) ? zip.file(opfPath).async('string') : null);
    if (!opfXml) throw new Error('Invalid EPUB: missing OPF');
    const opfDom = new DOMParser().parseFromString(opfXml, 'application/xml');
    const manifest = {};
    opfDom.querySelectorAll('manifest > item').forEach(it => {
      const id = it.getAttribute('id');
      const href = it.getAttribute('href');
      if (id && href) manifest[id] = href;
    });
    const spine = Array.from(opfDom.querySelectorAll('spine > itemref')).map(x => x.getAttribute('idref')).filter(Boolean);
    if (!spine.length) throw new Error('Invalid EPUB: empty spine');
    const base = opfPath.replace(/\\/g,'/');
    let out = '';
    for (let i=0;i<spine.length;i++){
      const idref = spine[i];
      const href = manifest[idref];
      if (!href) continue;
      const full = joinPath(base, href);
      if (statusCb) statusCb('Extracting section ' + (i+1) + '/' + spine.length + '...');
      const html = await (zip.file(full) ? zip.file(full).async('string') : null);
      if (!html) continue;
      const hdom = new DOMParser().parseFromString(html, 'text/html');
      const title = normText((hdom.querySelector('title') && hdom.querySelector('title').textContent) ? hdom.querySelector('title').textContent : '');
      const body = normText(hdom.body ? hdom.body.textContent : '');
      if (!body) continue;
      out += (title ? ('\n\n# ' + title + '\n\n') : '\n\n') + body + '\n';
    }
    return out.trim();
  }

  function posXY(pos, pageW, pageH, boxW, boxH, margin){
    const m = margin || 0;
    if (pos === 'tl') return { x: m, y: pageH - boxH - m };
    if (pos === 'tr') return { x: pageW - boxW - m, y: pageH - boxH - m };
    if (pos === 'bl') return { x: m, y: m };
    if (pos === 'c')  return { x: (pageW - boxW)/2, y: (pageH - boxH)/2 };
    return { x: pageW - boxW - m, y: m };
  }

  async function stampPdfBytes(pdfBytes, stampText, type, pos, size, margin){
    await ensurePDFLib();
    const { PDFDocument } = window.PDFLib;
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const pages = pdfDoc.getPages();
    const text = (stampText || '').trim();
    if (!text) throw new Error('Enter Text / URL');
    const s = Math.max(40, Math.min(360, Number(size||120)));
    const m = Math.max(0, Math.min(100, Number(margin||24)));
    let pngBytes = null;
    let drawW = s, drawH = s;
    if (type === 'code128'){
      await ensureJsBarcode();
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(240, s*2);
      canvas.height = Math.max(80, Math.round(s*0.6));
      window.JsBarcode(canvas, text, { format: 'CODE128', displayValue: false, margin: 0 });
      const dataUrl = canvas.toDataURL('image/png');
      const res = await fetch(dataUrl);
      pngBytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(res);
      drawW = s * 2;
      drawH = Math.round(s * 0.6);
    } else {
      await ensureQRCode();
      const dataUrl = await window.QRCode.toDataURL(text, { margin: 1, width: s });
      const res = await fetch(dataUrl);
      pngBytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(res);
      drawW = s;
      drawH = s;
    }
    const img = await pdfDoc.embedPng(pngBytes);
    for (const page of pages){
      const w = page.getWidth();
      const h = page.getHeight();
      const p = posXY(pos, w, h, drawW, drawH, m);
      page.drawImage(img, { x: p.x, y: p.y, width: drawW, height: drawH });
    }
    return await pdfDoc.save();
  }

  async function initEpub2Pdf(){
    const fileEl = $('epub2pdfFile');
    const buildBtn = $('epub2pdfBuildBtn');
    const dlBtn = $('epub2pdfDownloadBtn');
    if (!fileEl || !buildBtn) return;
    let lastBlob = null;
    buildBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose an .epub file first.');
        setStatus('epub2pdfStatus', 'Opening EPUB...');
        const text = await epubToText(f, (m)=>setStatus('epub2pdfStatus', m));
        setStatus('epub2pdfStatus', 'Building PDF...');
        lastBlob = await buildTextPdf(text || '(No text extracted)');
        previewBlob('epub2pdfPreviewFrame', lastBlob);
        setStatus('epub2pdfStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('epub2pdfStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'book.pdf'));
  }

  async function initQrBarcode(){
    const pdfEl = $('qrbarcodePdf');
    const runBtn = $('qrbarcodeRunBtn');
    const dlBtn = $('qrbarcodeDownloadBtn');
    if (!pdfEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = pdfEl.files && pdfEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const text = ($('qrbarcodeText') && $('qrbarcodeText').value) ? $('qrbarcodeText').value : '';
        const type = ($('qrbarcodeType') && $('qrbarcodeType').value) ? $('qrbarcodeType').value : 'qr';
        const pos  = ($('qrbarcodePos') && $('qrbarcodePos').value) ? $('qrbarcodePos').value : 'br';
        const size = ($('qrbarcodeSize') && $('qrbarcodeSize').value) ? $('qrbarcodeSize').value : 120;
        const margin = ($('qrbarcodeMargin') && $('qrbarcodeMargin').value) ? $('qrbarcodeMargin').value : 24;
        setStatus('qrbarcodeStatus', 'Stamping...');
        const outBytes = await stampPdfBytes(await __pdfrealmPdfFileToBytesMaybeDecrypt(f), text, type, pos, size, margin);
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('qrbarcodePreviewFrame', lastBlob);
        setStatus('qrbarcodeStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('qrbarcodeStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'stamped.pdf'));
  }

  async function initBulkQr(){
    const filesEl = $('bulkqrFiles');
    const runBtn = $('bulkqrRunBtn');
    const dlBtn = $('bulkqrDownloadBtn');
    const logEl = $('bulkqrLog');
    if (!filesEl || !runBtn) return;
    let lastZip = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        if (logEl) logEl.value = '';
        const files = Array.from(filesEl.files || []);
        if (!files.length) throw new Error('Choose one or more PDFs.');
        const text = ($('bulkqrText') && $('bulkqrText').value) ? $('bulkqrText').value : '';
        const type = ($('bulkqrType') && $('bulkqrType').value) ? $('bulkqrType').value : 'qr';
        const pos  = ($('bulkqrPos') && $('bulkqrPos').value) ? $('bulkqrPos').value : 'br';
        const size = ($('bulkqrSize') && $('bulkqrSize').value) ? $('bulkqrSize').value : 120;
        const margin = ($('bulkqrMargin') && $('bulkqrMargin').value) ? $('bulkqrMargin').value : 24;
        setStatus('bulkqrStatus', 'Loading ZIP...');
        await ensureJSZip();
        const zip = new window.JSZip();
        for (let i=0;i<files.length;i++){
          const f = files[i];
          appendLog('bulkqrLog', 'Stamping ' + (i+1) + '/' + files.length + ' - ' + (f.name||('file'+i)) );
          const outBytes = await stampPdfBytes(await __pdfrealmPdfFileToBytesMaybeDecrypt(f), text, type, pos, size, margin);
          const safeName = (f.name || ('file'+i+'.pdf')).replace(/[^a-z0-9._-]+/gi, '_');
          zip.file('stamped_' + safeName, outBytes);
        }
        appendLog('bulkqrLog', 'Building ZIP...');
        lastZip = await zip.generateAsync({ type: 'blob' });
        setStatus('bulkqrStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('bulkqrStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastZip && downloadBlob(lastZip, 'stamped_pdfs.zip'));
  }

  async function initWebhookSend(){
    const fileEl = $('webhookFile');
    const urlEl = $('webhookUrl');
    const btn = $('webhookSendBtn');
    const outEl = $('webhookOut');
    if (!btn || !fileEl || !urlEl) return;
    btn.addEventListener('click', async () => {
      try {
        if (outEl) outEl.value = '';
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a file first.');
        const url = (urlEl.value || '').trim();
        if (!/^https?:\/\//i.test(url)) throw new Error('Enter a valid http(s) webhook URL.');
        setStatus('webhookStatus', 'Sending...');
        const fd = new FormData();
        fd.append('file', f, f.name || 'file');
        fd.append('filename', f.name || 'file');
        fd.append('mime', f.type || 'application/octet-stream');
        fd.append('sentAt', new Date().toISOString());
        const resp = await fetch(url, { method: 'POST', body: fd });
        const text = await resp.text();
        const msg = 'HTTP ' + resp.status + ' ' + resp.statusText + '\n\n' + (text || '');
        if (outEl) outEl.value = msg.slice(0, 20000);
        setStatus('webhookStatus', resp.ok ? 'Sent.' : 'Sent (non-2xx).');
      } catch (e){ setStatus('webhookStatus', e.message || String(e)); }
    });
  }

  async function initPdfPerms(){
    const fileEl = $('pdfpermsFile');
    const passEl = $('pdfpermsPassword');
    const runBtn = $('pdfpermsRunBtn');
    const dlBtn  = $('pdfpermsDownloadBtn');
    const outEl  = $('pdfpermsOut');
    if (!fileEl || !runBtn || !outEl) return;
    let lastText = '';
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = '';
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const password = (passEl && passEl.value) ? passEl.value : undefined;
        setStatus('pdfpermsStatus', 'Loading PDF...');
        await ensurePDFJS();
        const data = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const loadingTask = window.pdfjsLib.getDocument({ data: data, password: password });
        const doc = await loadingTask.promise;
        const meta = await doc.getMetadata().catch(()=>({}));
        const perms = await doc.getPermissions().catch(()=>null);
        const info = {
          filename: f.name || 'document.pdf',
          pages: doc.numPages,
          permissions: perms,
          metadata: (meta && meta.info) ? meta.info : meta,
        };
        lastText = JSON.stringify(info, null, 2);
        outEl.value = lastText;
        setStatus('pdfpermsStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('pdfpermsStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastText && downloadBlob(new Blob([lastText], {type:'text/plain;charset=utf-8'}), 'pdf_permissions_report.txt'));
  }

  function initPack11(){ initEpub2Pdf(); initQrBarcode(); initBulkQr(); initWebhookSend(); initPdfPerms(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initPack11);
  else initPack11();
})();

/* PDFREALM_PACK12_TOOLS_V1
   Client-side tools added in Pack 12:
   - pdf2xlsx, pdfcrop, datestamp, tableextract, chainrunner
*/
(function(){
  if (window.__pdfrealm_pack12_tools_v1) return;
  window.__pdfrealm_pack12_tools_v1 = true;

  const CDN_PDFLIB = 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js';
  const CDN_PDFJS  = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
  const CDN_XLSX   = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
  const CDN_JSZIP  = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ''; }
  function appendLog(id, msg){ const el = $(id); if(!el) return; el.value = (el.value ? (el.value + '\n') : '') + (msg || ''); }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'download';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function previewBlob(frameId, blob){
    const frame = $(frameId);
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(() => URL.revokeObjectURL(url), 60000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement('script');
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('Failed to load ' + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === 'function') return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error('pdf-lib failed to load');
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === 'function') return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== 'function') throw new Error('pdf.js failed to load');
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    } catch {}
  }

  async function ensureXLSX(){
    if (window.XLSX && window.XLSX.utils) return;
    await loadScriptOnce(CDN_XLSX);
    if (!window.XLSX || !window.XLSX.utils) throw new Error('xlsx failed to load');
  }

  async function ensureJSZip(){
    if (window.JSZip) return;
    await loadScriptOnce(CDN_JSZIP);
    if (!window.JSZip) throw new Error('JSZip failed to load');
  }

  function csvEscape(s){
    const v = (s ?? '').toString();
    if (/[",\n\r]/.test(v)) return String.fromCharCode(34) + v.replace(/"/g, '""') + String.fromCharCode(34);
    return v;
  }

  function toPts(val, units){
    const n = Number(val || 0) || 0;
    return (units === 'in') ? (n * 72) : n;
  }

  function posXY(pos, pageW, pageH, boxW, boxH, margin){
    const m = margin || 0;
    if (pos === 'tl') return { x: m, y: pageH - boxH - m };
    if (pos === 'tr') return { x: pageW - boxW - m, y: pageH - boxH - m };
    if (pos === 'bl') return { x: m, y: m };
    if (pos === 'c')  return { x: (pageW - boxW)/2, y: (pageH - boxH)/2 };
    return { x: pageW - boxW - m, y: m };
  }

  async function pdfExtractLinesByPage(file, onProgress){
    await ensurePDFJS();
    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
    const pagesOut = [];
    for (let p = 1; p <= doc.numPages; p++){
      if (onProgress) onProgress(p, doc.numPages);
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const items = (content.items || []).map(it => {
        const str = (it.str || '').trim();
        if (!str) return null;
        const t = it.transform || [];
        return { str, x: (t[4]||0), y: (t[5]||0) };
      }).filter(Boolean);
      const map = new Map();
      for (const it of items){
        const key = Math.round(it.y);
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(it);
      }
      const keys = Array.from(map.keys()).sort((a,b)=>b-a);
      const lines = [];
      for (const k of keys){
        const arr = map.get(k).sort((a,b)=>a.x-b.x);
        lines.push(arr.map(x=>x.str).join(' ').trim());
      }
      pagesOut.push(lines.filter(Boolean));
    }
    return pagesOut;
  }

  async function pdfExtractTableRows(file, onProgress){
    await ensurePDFJS();
    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;
    const allRows = [];
    for (let p = 1; p <= doc.numPages; p++){
      if (onProgress) onProgress(p, doc.numPages);
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const items = (content.items || []).map(it => {
        const str = (it.str || '').trim();
        if (!str) return null;
        const t = it.transform || [];
        return { str, x: (t[4]||0), y: (t[5]||0) };
      }).filter(Boolean);
      const byY = new Map();
      for (const it of items){
        const yk = Math.round(it.y);
        if (!byY.has(yk)) byY.set(yk, []);
        byY.get(yk).push(it);
      }
      const ys = Array.from(byY.keys()).sort((a,b)=>b-a);
      for (const y of ys){
        const rowItems = byY.get(y).sort((a,b)=>a.x-b.x);
        const cells = [];
        let lastX = null;
        for (const it of rowItems){
          if (lastX !== null && (it.x - lastX) > 28){
            cells.push('');
          }
          if (cells.length === 0) cells.push(it.str);
          else cells[cells.length-1] = (cells[cells.length-1] ? (cells[cells.length-1] + ' ' + it.str) : it.str);
          lastX = it.x;
        }
        const clean = cells.map(c => (c || '').trim()).filter(c => c.length > 0);
        if (clean.length >= 2){
          allRows.push({ page: p, cells: clean });
        }
      }
    }
    return allRows;
  }

  async function cropPdfBytes(pdfBytes, marginsPt){
    await ensurePDFLib();
    const { PDFDocument } = window.PDFLib;
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const pages = pdfDoc.getPages();
    const Lm = Math.max(0, marginsPt.left||0);
    const Rm = Math.max(0, marginsPt.right||0);
    const Tm = Math.max(0, marginsPt.top||0);
    const Bm = Math.max(0, marginsPt.bottom||0);
    for (const page of pages){
      const w = page.getWidth();
      const h = page.getHeight();
      const nx = Lm;
      const ny = Bm;
      const nw = Math.max(36, w - Lm - Rm);
      const nh = Math.max(36, h - Tm - Bm);
      if (typeof page.setCropBox === 'function') page.setCropBox(nx, ny, nw, nh);
      else if (typeof page.setMediaBox === 'function') page.setMediaBox(nx, ny, nw, nh);
    }
    return await pdfDoc.save();
  }

  async function stampPdfBytes(pdfBytes, text, pos, fontSize, margin, opacity){
    await ensurePDFLib();
    const { PDFDocument, StandardFonts, rgb } = window.PDFLib;
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const pages = pdfDoc.getPages();
    const t = (text || '').trim() || new Date().toISOString();
    const fs = Math.max(6, Math.min(40, Number(fontSize||10)));
    const m = Math.max(0, Math.min(120, Number(margin||24)));
    const a = Math.max(0.1, Math.min(1, Number(opacity||0.7)));
    for (const page of pages){
      const w = page.getWidth();
      const h = page.getHeight();
      const tw = font.widthOfTextAtSize(t, fs);
      const th = fs * 1.2;
      const p = posXY(pos, w, h, tw, th, m);
      page.drawText(t, { x: p.x, y: p.y, size: fs, font, color: rgb(0.9,0.92,0.96), opacity: a });
    }
    return await pdfDoc.save();
  }

  async function initPdf2Xlsx(){
    const fileEl = $('pdf2xlsxFile');
    const runBtn = $('pdf2xlsxRunBtn');
    const dlBtn = $('pdf2xlsxDownloadBtn');
    const outEl = $('pdf2xlsxOut');
    if (!fileEl || !runBtn || !outEl) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = '';
        setStatus('pdf2xlsxStatus', 'Extracting...');
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const pages = await pdfExtractLinesByPage(f, (p,n)=>setStatus('pdf2xlsxStatus', 'Extracting page ' + p + '/' + n + '...'));
        await ensureXLSX();
        const rows = [['page','line','text']];
        for (let p=0;p<pages.length;p++){
          for (let i=0;i<pages[p].length;i++){
            rows.push([p+1, i+1, pages[p][i]]);
          }
        }
        const ws = window.XLSX.utils.aoa_to_sheet(rows);
        const wb = window.XLSX.utils.book_new();
        window.XLSX.utils.book_append_sheet(wb, ws, 'Extract');
        const out = window.XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
        lastBlob = new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const preview = rows.slice(0, 200).map(r => r.join('\\t')).join('\\n');
        outEl.value = preview + (rows.length > 200 ? ('\\n\\n... (' + (rows.length-1) + ' lines)') : '');
        setStatus('pdf2xlsxStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('pdf2xlsxStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'document.xlsx'));
  }

  async function initPdfCrop(){
    const fileEl = $('pdfcropFile');
    const runBtn = $('pdfcropRunBtn');
    const dlBtn = $('pdfcropDownloadBtn');
    if (!fileEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const units = ($('pdfcropUnits') && $('pdfcropUnits').value) ? $('pdfcropUnits').value : 'pt';
        const margins = {
          left: toPts(($('pdfcropLeft') && $('pdfcropLeft').value) ? $('pdfcropLeft').value : 0, units),
          right: toPts(($('pdfcropRight') && $('pdfcropRight').value) ? $('pdfcropRight').value : 0, units),
          top: toPts(($('pdfcropTop') && $('pdfcropTop').value) ? $('pdfcropTop').value : 0, units),
          bottom: toPts(($('pdfcropBottom') && $('pdfcropBottom').value) ? $('pdfcropBottom').value : 0, units),
        };
        setStatus('pdfcropStatus', 'Cropping...');
        const outBytes = await cropPdfBytes(await __pdfrealmPdfFileToBytesMaybeDecrypt(f), margins);
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('pdfcropPreviewFrame', lastBlob);
        setStatus('pdfcropStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('pdfcropStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'cropped.pdf'));
  }

  async function initDateStamp(){
    const fileEl = $('datestampFile');
    const runBtn = $('datestampRunBtn');
    const dlBtn = $('datestampDownloadBtn');
    if (!fileEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const txtEl = $('datestampText');
        const posEl = $('datestampPos');
        const fsEl  = $('datestampFontSize');
        const mEl   = $('datestampMargin');
        const opEl  = $('datestampOpacity');
        const text = (txtEl && txtEl.value) ? txtEl.value : '';
        const pos  = (posEl && posEl.value) ? posEl.value : 'br';
        const fs   = (fsEl && fsEl.value) ? fsEl.value : 10;
        const margin = (mEl && mEl.value) ? mEl.value : 24;
        const opacity = (opEl && opEl.value) ? opEl.value : 0.7;
        setStatus('datestampStatus', 'Stamping...');
        const outBytes = await stampPdfBytes(await __pdfrealmPdfFileToBytesMaybeDecrypt(f), text, pos, fs, margin, opacity);
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('datestampPreviewFrame', lastBlob);
        setStatus('datestampStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('datestampStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'datestamped.pdf'));
  }

  async function initTableExtract(){
    const fileEl = $('tableextractFile');
    const runBtn = $('tableextractRunBtn');
    const dlBtn = $('tableextractDownloadBtn');
    const outEl = $('tableextractOut');
    if (!fileEl || !runBtn || !outEl) return;
    let lastCsv = '';
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = '';
        setStatus('tableextractStatus', 'Extracting...');
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const rows = await pdfExtractTableRows(f, (p,n)=>setStatus('tableextractStatus', 'Extracting page ' + p + '/' + n + '...'));
        const maxCols = Math.min(20, rows.reduce((m,r)=>Math.max(m, r.cells.length), 0));
        const header = ['page'];
        for (let i=1;i<=maxCols;i++) header.push('col' + i);
        const lines = [header.join(',')];
        for (const r of rows){
          const cells = r.cells.slice(0, maxCols);
          while (cells.length < maxCols) cells.push('');
          lines.push([String(r.page), ...cells.map(csvEscape)].join(','));
        }
        lastCsv = lines.join('\n') + '\n';
        outEl.value = lastCsv.slice(0, 20000);
        setStatus('tableextractStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('tableextractStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastCsv && downloadBlob(new Blob([lastCsv], {type:'text/csv;charset=utf-8'}), 'tables.csv'));
  }

  async function initChainRunner(){
    const filesEl = $('chainrunnerFiles');
    const runBtn = $('chainrunnerRunBtn');
    const dlBtn  = $('chainrunnerDownloadBtn');
    const logEl  = $('chainrunnerLog');
    if (!filesEl || !runBtn) return;
    let lastZip = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        if (logEl) logEl.value = '';
        const files = Array.from(filesEl.files || []);
        if (!files.length) throw new Error('Choose one or more PDFs.');
        const doCrop = $('chainrunnerDoCrop') ? !!$('chainrunnerDoCrop').checked : true;
        const doStamp = $('chainrunnerDoStamp') ? !!$('chainrunnerDoStamp').checked : true;
        const units = ($('chainrunnerUnits') && $('chainrunnerUnits').value) ? $('chainrunnerUnits').value : 'pt';
        const pos = ($('chainrunnerPos') && $('chainrunnerPos').value) ? $('chainrunnerPos').value : 'br';
        const margins = {
          left: toPts(($('chainrunnerLeft') && $('chainrunnerLeft').value) ? $('chainrunnerLeft').value : 0, units),
          right: toPts(($('chainrunnerRight') && $('chainrunnerRight').value) ? $('chainrunnerRight').value : 0, units),
          top: toPts(($('chainrunnerTop') && $('chainrunnerTop').value) ? $('chainrunnerTop').value : 0, units),
          bottom: toPts(($('chainrunnerBottom') && $('chainrunnerBottom').value) ? $('chainrunnerBottom').value : 0, units),
        };
        const stampText = ($('chainrunnerText') && $('chainrunnerText').value) ? $('chainrunnerText').value : '';
        setStatus('chainrunnerStatus', 'Loading ZIP...');
        await ensureJSZip();
        const zip = new window.JSZip();
        for (let i=0;i<files.length;i++){
          const f = files[i];
          appendLog('chainrunnerLog', 'Processing ' + (i+1) + '/' + files.length + ' - ' + (f.name||('file'+i)) );
          let bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
          if (doCrop) bytes = await cropPdfBytes(bytes, margins);
          if (doStamp) bytes = await stampPdfBytes(bytes, stampText, pos, 10, 24, 0.7);
          const safeName = (f.name || ('file'+i+'.pdf')).replace(/[^a-z0-9._-]+/gi, '_');
          zip.file('processed_' + safeName, bytes);
        }
        appendLog('chainrunnerLog', 'Building ZIP...');
        lastZip = await zip.generateAsync({ type: 'blob' });
        setStatus('chainrunnerStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('chainrunnerStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastZip && downloadBlob(lastZip, 'processed_pdfs.zip'));
  }

  function initPack12(){ initPdf2Xlsx(); initPdfCrop(); initDateStamp(); initTableExtract(); initChainRunner(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initPack12);
  else initPack12();
})();

/* PDFREALM_PACK13_TOOLS_V1
   Client-side tools added in Pack 13:
   - watermarktext, watermarkimage, headerfooter, rotate90, flattenforms
*/
(function(){
  if (window.__pdfrealm_pack13_tools_v1) return;
  window.__pdfrealm_pack13_tools_v1 = true;

  const CDN_PDFLIB = 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js';

  const $ = (id) => document.getElementById(id);
  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ''; }
  function clamp(n, a, b){ n = Number(n); if (!isFinite(n)) n = a; return Math.max(a, Math.min(b, n)); }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'download';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function previewBlob(frameId, blob){
    const frame = $(frameId);
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(() => URL.revokeObjectURL(url), 60000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement('script');
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('Failed to load ' + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (typeof window.ensurePDFLib === 'function') return window.ensurePDFLib();
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error('pdf-lib failed to load');
  }

  function posXY(pos, pageW, pageH, boxW, boxH, margin){
    const m = margin || 0;
    if (pos === 'tl') return { x: m, y: pageH - boxH - m };
    if (pos === 'tr') return { x: pageW - boxW - m, y: pageH - boxH - m };
    if (pos === 'bl') return { x: m, y: m };
    if (pos === 'c')  return { x: (pageW - boxW)/2, y: (pageH - boxH)/2 };
    return { x: pageW - boxW - m, y: m };
  }

  function applyTokens(tpl, pageNum, totalPages){
    return (tpl || '')
      .replace(/{page}/g, String(pageNum))
      .replace(/{pages}/g, String(totalPages));
  }

  async function initWatermarkText(){
    const fileEl = $('wmTextFile');
    const runBtn = $('wmTextRunBtn');
    const dlBtn  = $('wmTextDownloadBtn');
    if (!fileEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const text = ($('wmTextValue') && $('wmTextValue').value) ? $('wmTextValue').value : 'CONFIDENTIAL';
        const size = clamp(($('wmTextSize') && $('wmTextSize').value), 8, 160);
        const opacity = clamp(($('wmTextOpacity') && $('wmTextOpacity').value), 0.05, 1);
        const angle = clamp(($('wmTextAngle') && $('wmTextAngle').value), -90, 90);
        const repeat = ($('wmTextRepeat') && $('wmTextRepeat').value) ? $('wmTextRepeat').value : 'single';
        setStatus('wmTextStatus', 'Applying watermark...');
        await ensurePDFLib();
        const { PDFDocument, StandardFonts, rgb, degrees } = window.PDFLib;
        const pdfDoc = await PDFDocument.load(await __pdfrealmPdfFileToBytesMaybeDecrypt(f));
        const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
        const pages = pdfDoc.getPages();
        for (const page of pages){
          const w = page.getWidth();
          const h = page.getHeight();
          const tw = font.widthOfTextAtSize(text, size);
          const th = size * 1.2;
          if (repeat === 'tile'){
            const stepX = Math.max(160, tw + 120);
            const stepY = Math.max(140, th + 120);
            for (let x = -w; x < w*2; x += stepX){
              for (let y = -h; y < h*2; y += stepY){
                page.drawText(text, { x, y, size, font, color: rgb(0.9,0.92,0.96), rotate: degrees(angle), opacity });
              }
            }
          } else {
            const p = posXY('c', w, h, tw, th, 0);
            page.drawText(text, { x: p.x, y: p.y, size, font, color: rgb(0.9,0.92,0.96), rotate: degrees(angle), opacity });
          }
        }
        const outBytes = await pdfDoc.save();
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('wmTextPreview', lastBlob);
        setStatus('wmTextStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('wmTextStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'watermarked.pdf'));
  }

  async function initWatermarkImage(){
    const pdfEl = $('wmImgPdf');
    const imgEl = $('wmImgFile');
    const runBtn = $('wmImgRunBtn');
    const dlBtn  = $('wmImgDownloadBtn');
    if (!pdfEl || !imgEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const pf = pdfEl.files && pdfEl.files[0];
        const imf = imgEl.files && imgEl.files[0];
        if (!pf) throw new Error('Choose a PDF first.');
        if (!imf) throw new Error('Choose an image (PNG/JPG).');
        const pos = ($('wmImgPos') && $('wmImgPos').value) ? $('wmImgPos').value : 'br';
        const scale = clamp(($('wmImgScale') && $('wmImgScale').value), 0.05, 2);
        const margin = clamp(($('wmImgMargin') && $('wmImgMargin').value), 0, 200);
        const opacity = clamp(($('wmImgOpacity') && $('wmImgOpacity').value), 0.05, 1);
        setStatus('wmImgStatus', 'Applying watermark...');
        await ensurePDFLib();
        const { PDFDocument } = window.PDFLib;
        const pdfDoc = await PDFDocument.load(await __pdfrealmPdfFileToBytesMaybeDecrypt(pf));
        const imgBytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(imf);
        const lower = (imf.name || '').toLowerCase();
        const img = (lower.endsWith('.png')) ? await pdfDoc.embedPng(imgBytes) : await pdfDoc.embedJpg(imgBytes);
        const pages = pdfDoc.getPages();
        for (const page of pages){
          const w = page.getWidth();
          const h = page.getHeight();
          const iw = img.width * scale;
          const ih = img.height * scale;
          const p = posXY(pos, w, h, iw, ih, margin);
          page.drawImage(img, { x: p.x, y: p.y, width: iw, height: ih, opacity });
        }
        const outBytes = await pdfDoc.save();
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('wmImgPreview', lastBlob);
        setStatus('wmImgStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('wmImgStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'watermarked.pdf'));
  }

  async function initHeaderFooter(){
    const fileEl = $('hfFile');
    const runBtn = $('hfRunBtn');
    const dlBtn  = $('hfDownloadBtn');
    if (!fileEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const headerTpl = ($('hfHeader') && $('hfHeader').value) ? $('hfHeader').value : '';
        const footerTpl = ($('hfFooter') && $('hfFooter').value) ? $('hfFooter').value : '';
        const align = ($('hfAlign') && $('hfAlign').value) ? $('hfAlign').value : 'left';
        const fontSize = clamp(($('hfFontSize') && $('hfFontSize').value), 6, 24);
        const margin = clamp(($('hfMargin') && $('hfMargin').value), 0, 120);
        const opacity = clamp(($('hfOpacity') && $('hfOpacity').value), 0.1, 1);
        setStatus('hfStatus', 'Applying header/footer...');
        await ensurePDFLib();
        const { PDFDocument, StandardFonts, rgb } = window.PDFLib;
        const pdfDoc = await PDFDocument.load(await __pdfrealmPdfFileToBytesMaybeDecrypt(f));
        const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
        const pages = pdfDoc.getPages();
        const total = pages.length;
        for (let i=0;i<pages.length;i++){
          const page = pages[i];
          const w = page.getWidth();
          const h = page.getHeight();
          const pn = i+1;
          const header = applyTokens(headerTpl, pn, total);
          const footer = applyTokens(footerTpl, pn, total);
          const drawLine = (txt, y) => {
            if (!txt) return;
            const tw = font.widthOfTextAtSize(txt, fontSize);
            let x = margin;
            if (align === 'center') x = (w - tw)/2;
            if (align === 'right') x = w - tw - margin;
            page.drawText(txt, { x, y, size: fontSize, font, color: rgb(0.9,0.92,0.96), opacity });
          };
          drawLine(header, h - margin - fontSize*1.2);
          drawLine(footer, margin);
        }
        const outBytes = await pdfDoc.save();
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('hfPreview', lastBlob);
        setStatus('hfStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('hfStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'header_footer.pdf'));
  }

  async function initRotate90(){
    const fileEl = $('rotFile');
    const runBtn = $('rotRunBtn');
    const dlBtn  = $('rotDownloadBtn');
    if (!fileEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const delta = Number(($('rotDir') && $('rotDir').value) ? $('rotDir').value : 90) || 90;
        setStatus('rotStatus', 'Rotating...');
        await ensurePDFLib();
        const { PDFDocument, degrees } = window.PDFLib;
        const pdfDoc = await PDFDocument.load(await __pdfrealmPdfFileToBytesMaybeDecrypt(f));
        const pages = pdfDoc.getPages();
        for (const page of pages){
          const cur = (page.getRotation && page.getRotation().angle) ? page.getRotation().angle : 0;
          let next = (cur + delta) % 360;
          if (next < 0) next += 360;
          if (page.setRotation) page.setRotation(degrees(next));
        }
        const outBytes = await pdfDoc.save();
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('rotPreview', lastBlob);
        setStatus('rotStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('rotStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'rotated.pdf'));
  }

  async function initFlattenForms(){
    const fileEl = $('flatFile');
    const runBtn = $('flatRunBtn');
    const dlBtn  = $('flatDownloadBtn');
    if (!fileEl || !runBtn) return;
    let lastBlob = null;
    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        setStatus('flatStatus', 'Flattening...');
        await ensurePDFLib();
        const { PDFDocument } = window.PDFLib;
        const pdfDoc = await PDFDocument.load(await __pdfrealmPdfFileToBytesMaybeDecrypt(f));
        try {
          const form = pdfDoc.getForm();
          form.flatten();
        } catch (e) {
          // No form or flatten not supported on this doc; still return a copy
        }
        const outBytes = await pdfDoc.save();
        lastBlob = new Blob([outBytes], { type: 'application/pdf' });
        previewBlob('flatPreview', lastBlob);
        setStatus('flatStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){ setStatus('flatStatus', e.message || String(e)); }
    });
    if (dlBtn) dlBtn.addEventListener('click', ()=> lastBlob && downloadBlob(lastBlob, 'flattened.pdf'));
  }

  function initPack13(){ initWatermarkText(); initWatermarkImage(); initHeaderFooter(); initRotate90(); initFlattenForms(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initPack13);
  else initPack13();
})();




/* PDFREALM_PACK14_TOOLS_V1
   Client-side tools:
   - pdfflatten, pdf2layoutjson, qrstamp, barcodestamp, pdf2outline
*/
(function(){
  if (window.__pdfrealm_pack14_tools_v1) return;
  window.__pdfrealm_pack14_tools_v1 = true;

  const CDN_PDFLIB = 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js';
  const CDN_PDFJS  = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
  const CDN_QRCODE = 'https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js';
  const CDN_JSBARCODE = 'https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js';

  const $ = (id) => document.getElementById(id);

  function setStatus(id, msg){ const el = $(id); if (el) el.textContent = msg || ''; }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'download';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function loadScriptOnce(srcUrl){
    return new Promise((resolve, reject) => {
      const found = Array.from(document.scripts || []).some(s => s.src === srcUrl);
      if (found) return resolve();
      const s = document.createElement('script');
      s.src = srcUrl;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('Failed to load ' + srcUrl));
      document.head.appendChild(s);
    });
  }

  async function ensurePDFLib(){
    if (window.PDFLib && window.PDFLib.PDFDocument) return;
    await loadScriptOnce(CDN_PDFLIB);
    if (!window.PDFLib || !window.PDFLib.PDFDocument) throw new Error('pdf-lib failed to load');
  }

  async function ensurePDFJS(){
    if (window.pdfjsLib && typeof window.pdfjsLib.getDocument === 'function') return;
    await loadScriptOnce(CDN_PDFJS);
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== 'function') throw new Error('pdf.js failed to load');
    try {
      if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    } catch {}
  }

  async function ensureQRCode(){
    if (window.QRCode && typeof window.QRCode.toDataURL === 'function') return;
    await loadScriptOnce(CDN_QRCODE);
    if (!window.QRCode || typeof window.QRCode.toDataURL !== 'function') throw new Error('qrcode failed to load');
  }

  async function ensureJsBarcode(){
    if (window.JsBarcode) return;
    await loadScriptOnce(CDN_JSBARCODE);
    if (!window.JsBarcode) throw new Error('JsBarcode failed to load');
  }

  function objectUrlToIframe(frame, blob){
    if (!frame) return;
    const url = URL.createObjectURL(blob);
    frame.src = url;
    setTimeout(() => URL.revokeObjectURL(url), 60000);
  }

  function cornerXY(pos, pageW, pageH, boxW, boxH, margin){
    const m = margin || 24;
    if (pos === 'tl') return { x: m, y: pageH - m - boxH };
    if (pos === 'tr') return { x: pageW - m - boxW, y: pageH - m - boxH };
    if (pos === 'bl') return { x: m, y: m };
    return { x: pageW - m - boxW, y: m }; // br
  }

  async function fileToPdfDoc(file){
    await ensurePDFLib();
    const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(file);
    const PDFDocument = window.PDFLib.PDFDocument;
    try {
      return await PDFDocument.load(bytes, { ignoreEncryption: true });
    } catch (e){
      throw new Error('Could not open PDF (encrypted or invalid). Decrypt it first.');
    }
  }

  async function makePngFromSvg(svgEl, scale){
    const s = new XMLSerializer().serializeToString(svgEl);
    const svgBlob = new Blob([s], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    const done = await new Promise((resolve, reject) => {
      img.onload = () => resolve(true);
      img.onerror = () => reject(new Error('Failed to render barcode'));
      img.src = url;
    });

    const w = Math.max(1, Math.floor((img.width || svgEl.viewBox.baseVal.width || 400) * (scale || 1)));
    const h = Math.max(1, Math.floor((img.height || svgEl.viewBox.baseVal.height || 120) * (scale || 1)));
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(img, 0, 0, w, h);
    URL.revokeObjectURL(url);

    const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
    if (!blob) throw new Error('Could not create PNG');
    return blob;
  }

  async function initPdfFlatten(){
    const fileEl = $('pdfflattenFile');
    const runBtn = $('pdfflattenRunBtn');
    const dlBtn = $('pdfflattenDownloadBtn');
    const frame = $('pdfflattenPreviewFrame');
    if (!fileEl || !runBtn) return;

    let outBlob = null;

    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outBlob = null;
        setStatus('pdfflattenStatus', 'Loading...');
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const pdfDoc = await fileToPdfDoc(f);

        setStatus('pdfflattenStatus', 'Flattening...');
        try {
          const form = pdfDoc.getForm();
          form.flatten();
        } catch {
          // no forms or unsupported, still save
        }

        const bytes = await pdfDoc.save();
        outBlob = new Blob([bytes], { type: 'application/pdf' });
        setStatus('pdfflattenStatus', 'Ready.');
        objectUrlToIframe(frame, outBlob);
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus('pdfflattenStatus', e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener('click', () => outBlob && downloadBlob(outBlob, 'flattened.pdf'));
  }

  async function initPdf2LayoutJson(){
    const fileEl = $('pdf2layoutjsonFile');
    const runBtn = $('pdf2layoutjsonRunBtn');
    const dlBtn = $('pdf2layoutjsonDownloadBtn');
    const outEl = $('pdf2layoutjsonOut');
    if (!fileEl || !runBtn || !outEl) return;

    let lastJson = '';

    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = '';
        lastJson = '';
        setStatus('pdf2layoutjsonStatus', 'Loading...');
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');

        await ensurePDFJS();
        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;

        const out = { pages: [] };
        for (let p=1; p<=doc.numPages; p++){
          setStatus('pdf2layoutjsonStatus', 'Extracting page ' + p + '/' + doc.numPages + '...');
          const page = await doc.getPage(p);
          const viewport = page.getViewport({ scale: 1.0 });
          const tc = await page.getTextContent();
          const items = (tc.items || []).map(it => {
            const t = it.transform || [1,0,0,1,0,0];
            return {
              text: (it.str || ''),
              x: t[4] || 0,
              y: t[5] || 0,
              width: it.width || 0,
              height: it.height || 0,
              fontName: it.fontName || ''
            };
          });
          out.pages.push({ page: p, width: viewport.width, height: viewport.height, items });
        }

        lastJson = JSON.stringify(out, null, 2);
        outEl.value = lastJson;
        setStatus('pdf2layoutjsonStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus('pdf2layoutjsonStatus', e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener('click', () => {
      if (!lastJson) return;
      downloadBlob(new Blob([lastJson], { type: 'application/json;charset=utf-8' }), 'layout.json');
    });
  }

  async function initQrStamp(){
    const fileEl = $('qrstampFile');
    const runBtn = $('qrstampRunBtn');
    const dlBtn = $('qrstampDownloadBtn');
    const frame = $('qrstampPreviewFrame');
    const textEl = $('qrstampText');
    const sizeEl = $('qrstampSize');
    const posEl = $('qrstampPos');
    const pagesEl = $('qrstampPages');
    if (!fileEl || !runBtn || !textEl) return;

    let outBlob = null;

    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outBlob = null;

        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const qrText = (textEl.value || '').trim();
        if (!qrText) throw new Error('Enter QR content.');

        const sizePx = Math.max(60, Math.min(600, parseInt(sizeEl && sizeEl.value ? sizeEl.value : '140', 10) || 140));
        const pos = (posEl && posEl.value) ? posEl.value : 'br';
        const pages = (pagesEl && pagesEl.value) ? pagesEl.value : 'first';

        setStatus('qrstampStatus', 'Loading...');
        await ensureQRCode();
        const dataUrl = await window.QRCode.toDataURL(qrText, { errorCorrectionLevel: 'M', margin: 1, width: sizePx });
        const pngBytes = await (await fetch(dataUrl)).arrayBuffer();

        const pdfDoc = await fileToPdfDoc(f);
        const png = await pdfDoc.embedPng(pngBytes);

        const pageCount = pdfDoc.getPageCount();
        const indices = (pages === 'all') ? [...Array(pageCount).keys()] : [0];

        setStatus('qrstampStatus', 'Stamping...');
        for (const idx of indices){
          const page = pdfDoc.getPage(idx);
          const w = page.getWidth();
          const h = page.getHeight();
          const boxW = png.width;
          const boxH = png.height;
          // scale image to requested px size (pdf points ~ px-ish for our usage)
          const scale = sizePx / Math.max(boxW, boxH);
          const drawW = boxW * scale;
          const drawH = boxH * scale;
          const xy = cornerXY(pos, w, h, drawW, drawH, 24);
          page.drawImage(png, { x: xy.x, y: xy.y, width: drawW, height: drawH });
        }

        const bytes = await pdfDoc.save();
        outBlob = new Blob([bytes], { type: 'application/pdf' });
        setStatus('qrstampStatus', 'Ready.');
        objectUrlToIframe(frame, outBlob);
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus('qrstampStatus', e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener('click', () => outBlob && downloadBlob(outBlob, 'qr-stamped.pdf'));
  }

  async function initBarcodeStamp(){
    const fileEl = $('barcodestampFile');
    const runBtn = $('barcodestampRunBtn');
    const dlBtn = $('barcodestampDownloadBtn');
    const frame = $('barcodestampPreviewFrame');
    const textEl = $('barcodestampText');
    const heightEl = $('barcodestampHeight');
    const posEl = $('barcodestampPos');
    const pagesEl = $('barcodestampPages');
    if (!fileEl || !runBtn || !textEl) return;

    let outBlob = null;

    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outBlob = null;

        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');
        const value = (textEl.value || '').trim();
        if (!value) throw new Error('Enter barcode value.');

        const heightPx = Math.max(30, Math.min(300, parseInt(heightEl && heightEl.value ? heightEl.value : '80', 10) || 80));
        const pos = (posEl && posEl.value) ? posEl.value : 'br';
        const pages = (pagesEl && pagesEl.value) ? pagesEl.value : 'first';

        setStatus('barcodestampStatus', 'Loading...');
        await ensureJsBarcode();
        await ensurePDFLib();

        // Build SVG barcode
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        window.JsBarcode(svg, value, { format: 'CODE128', displayValue: false, margin: 0, height: heightPx });
        const pngBlob = await makePngFromSvg(svg, 1);
        const pngBytes = await pngBlob.arrayBuffer();

        const pdfDoc = await fileToPdfDoc(f);
        const png = await pdfDoc.embedPng(pngBytes);

        const pageCount = pdfDoc.getPageCount();
        const indices = (pages === 'all') ? [...Array(pageCount).keys()] : [0];

        setStatus('barcodestampStatus', 'Stamping...');
        for (const idx of indices){
          const page = pdfDoc.getPage(idx);
          const w = page.getWidth();
          const h = page.getHeight();
          const boxW = png.width;
          const boxH = png.height;
          // Keep aspect; target height ~ heightPx
          const scale = heightPx / Math.max(1, boxH);
          const drawW = boxW * scale;
          const drawH = boxH * scale;
          const xy = cornerXY(pos, w, h, drawW, drawH, 24);
          page.drawImage(png, { x: xy.x, y: xy.y, width: drawW, height: drawH });
        }

        const bytes = await pdfDoc.save();
        outBlob = new Blob([bytes], { type: 'application/pdf' });
        setStatus('barcodestampStatus', 'Ready.');
        objectUrlToIframe(frame, outBlob);
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus('barcodestampStatus', e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener('click', () => outBlob && downloadBlob(outBlob, 'barcode-stamped.pdf'));
  }

  async function initPdf2Outline(){
    const fileEl = $('pdf2outlineFile');
    const runBtn = $('pdf2outlineRunBtn');
    const dlBtn = $('pdf2outlineDownloadBtn');
    const outEl = $('pdf2outlineOut');
    if (!fileEl || !runBtn || !outEl) return;

    let lastJson = '';

    runBtn.addEventListener('click', async () => {
      try {
        if (dlBtn) dlBtn.disabled = true;
        outEl.value = '';
        lastJson = '';
        setStatus('pdf2outlineStatus', 'Loading...');
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error('Choose a PDF first.');

        await ensurePDFJS();
        const bytes = await __pdfrealmPdfFileToBytesMaybeDecrypt(f);
        const doc = await window.pdfjsLib.getDocument({ data: bytes }).promise;

        setStatus('pdf2outlineStatus', 'Extracting outline...');
        const outline = await doc.getOutline();
        lastJson = JSON.stringify(outline || [], null, 2);
        outEl.value = lastJson;
        setStatus('pdf2outlineStatus', 'Ready.');
        if (dlBtn) dlBtn.disabled = false;
      } catch (e){
        setStatus('pdf2outlineStatus', e.message || String(e));
      }
    });

    if (dlBtn) dlBtn.addEventListener('click', () => {
      if (!lastJson) return;
      downloadBlob(new Blob([lastJson], { type: 'application/json;charset=utf-8' }), 'outline.json');
    });
  }

  function initPack14(){
    initPdfFlatten();
    initPdf2LayoutJson();
    initQrStamp();
    initBarcodeStamp();
    initPdf2Outline();
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initPack14);
  else initPack14();
})();













;

/* PDFREALM_CODE2PDF_V2_MIN
   Minimal client wiring: reads file text and posts to /api/text-to-pdf
*/
(function(){
  if (window.__pdfrealm_code2pdf_v2_min) return;
  window.__pdfrealm_code2pdf_v2_min = true;

  const $ = (id) => document.getElementById(id);
  const status = (m)=>{ const el=$("code2pdfStatus"); if(el) el.textContent = m||""; };

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "code.pdf";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  function init(){
    const fileEl = $("code2pdfFile");
    const buildBtn = $("code2pdfBuildBtn");
    const dlBtn = $("code2pdfDownloadBtn");
    const frame = $("code2pdfPreviewFrame");
    if (!fileEl || !buildBtn) return;

    let lastBlob = null;
    let lastName = "code.pdf";

    buildBtn.addEventListener("click", async () => {
      try{
        if (dlBtn) dlBtn.disabled = true;
        status("Reading file...");
        const f = fileEl.files && fileEl.files[0];
        if (!f) throw new Error("Choose a code file first.");

        const text = await f.text();
        lastName = (f.name || "code").replace(/.[^.]+$/, "") + ".pdf";

        status("Building PDF...");
        const body = new URLSearchParams();
        body.set("text", "File: " + (f.name || "") + "\n\n" + text);

        const resp = await fetch("/api/text-to-pdf", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body
        });

        if (!resp.ok) throw new Error(await resp.text());
        lastBlob = await resp.blob();

        status("Ready.");
        if (frame){
          const url = URL.createObjectURL(lastBlob);
          frame.src = url;
          setTimeout(()=>URL.revokeObjectURL(url), 60000);
        }
        if (dlBtn) dlBtn.disabled = false;
      } catch(e){
        status(e?.message || String(e));
      }
    });

    if (dlBtn){
      dlBtn.addEventListener("click", () => {
        if (!lastBlob) return;
        downloadBlob(lastBlob, lastName);
      });
    }
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();
















/* =================== PDFREALM_TIER_PAGER_V4_START =================== */
(() => {
  if (window.__PDFREALM_TIER_PAGER_V4__) return;
  window.__PDFREALM_TIER_PAGER_V4__ = true;

  // Disable flags used by older versions if they exist
  try { window.__PDFREALM_TIER_PAGER_V1__ = true; } catch {}
  try { window.__PDFREALM_TIER_PAGER_V2__ = true; } catch {}
  try { window.__PDFREALM_TIER_PAGER_V3__ = true; } catch {}

  const TIER_KEY = "pdfrealm_tool_tier";
  const DEFAULT_TIER = "standard";

  // Secure Suite
  const SECURE_TOOLS = new Set([
    "secure_send",
    "secure_chat",
    "secure_video",
    "secure_voip",
    "secure_containers",
    "breakthrough",
  ]);

  // Premium (higher server resources)
  const PREMIUM_TOOLS = new Set([
    "embedvideo",
    "embedaudio",
    "embedimage",
    "ocr",
    "embedimage",
    "embedaudio",
    "embedvideo",
    "studio",
    "rasterize",
    "pdf2jpg",
    "pdf2png",
    "compare",
    "visualdiff",
    "deskewclean",
    "smartcompress",
    "compress",
    "pdf2word",
    "word2pdf",
    "pdf2pptx",
    "pdf2xlsx",
    "docx2png",
    "tableextract",
    "html2pdf",
    "url2pdf",
    "heic2pdf",
    "pdf2layoutjson",
    "pdf2outline",
    "extractembedded",
    "extractattach",
    "extractfonts",
    "bulkqrbarcode",
    "batchrename",
    "chainrunner",
    "templaterun",
    "webhooksend",
    "pdf2epub",
    "epub2pdf",
    "eml2pdf",
  

]);

  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function tierForTool(toolId) {
    const id = String(toolId || "");
    if (SECURE_TOOLS.has(id)) return "secure";
    if (PREMIUM_TOOLS.has(id)) return "premium";
    return "standard";
  }

  function getTier() {
    try {
      const t = localStorage.getItem(TIER_KEY);
      return (t === "premium" || t === "secure") ? t : "standard";
    } catch {
      return "standard";
    }
  }

  function setTier(tier) {
    const t = (tier === "premium" || tier === "secure") ? tier : "standard";
    try { localStorage.setItem(TIER_KEY, t); } catch {}
    document.body.setAttribute("data-pdfrealm-tier", t);
    paintTierButtons(t);
    requestRender(t, "click");
  }

  function ensureStyle() {
    if ($("#pdfrealmTierPagerV4Style")) return;
    const style = document.createElement("style");
    style.id = "pdfrealmTierPagerV4Style";
    style.textContent = [
      "/* Hide older tier UIs if lingering */",
      ".tier-switch, .tier-tabs, .tier-switcher, .pdfrealm-tier-tabs { display:none !important; }",
      "",
      "/* Sidebar header tabs */",
      ".sidebar-head .title { display:none !important; }",
      ".pdfrealm-tierbar-pager { display:flex; gap:10px; align-items:stretch; width:100%; }",
      ".pdfrealm-tierbar-pager button {",
      "  border: 1px solid rgba(255,255,255,0.14);",
      "  background: rgba(255,255,255,0.04);",
      "  color: inherit;",
      "  padding: 10px 12px;",
      "  border-radius: 12px;",
      "  cursor: pointer;",
      "  line-height: 1.1;",
      "  font-size: 13px;",
      "}",
      ".pdfrealm-tierbar-pager button small { display:block; opacity:0.85; margin-top:4px; font-size: 11px;  white-space: nowrap; }",
      ".pdfrealm-tierbar-pager button.active {",
      "  border-color: rgba(255,255,255,0.28);",
      "  background: rgba(255,255,255,0.08);",
      "}",
      "",
      "/* Page-flip feel */",
      ".tool-tabs { transition: opacity 120ms ease; will-change: opacity; }",
      ".tool-tabs.pdfrealm-tier-fadeout { opacity: 0.15; }",
      ".tool-tabs.pdfrealm-tier-fadein { opacity: 1; }",
      "",
      ".pdfrealm-tier-status { font-size: 12px; opacity: 0.75; margin: 6px 10px 0 10px; }",
    ].join("\n");
    document.head.appendChild(style);
  }

  function findSidebarHead() {
    return $(".sidebar-head")
      || $(".sidebar .sidebar-head")
      || $(".sidebar-header")
      || ($(".sidebar .title") ? $(".sidebar .title").parentElement : null);
  }

  function ensureTierBar() {
    ensureStyle();
    const head = findSidebarHead();
    if (!head) return null;

    let bar = $("#pdfrealmTierPagerV4Bar", head);
    if (bar) return bar;

    // Remove known old injected bars if present
    [
      "pdfrealmTierPagerV1Bar",
      "pdfrealmTierPagerV2Bar",
      "pdfrealmTierPagerV3Bar",
      "pdfrealmTierFinalV1Tabs",
      "pdfrealmTierNoFlickerBarV1",
      "pdfrealmTierFinalV1Tabs2",
      "pdfrealmTierFinalV1TabsX"
    ].forEach(id => { const el = document.getElementById(id); if (el) el.remove(); });

    bar = document.createElement("div");
    bar.id = "pdfrealmTierPagerV4Bar";
    bar.className = "pdfrealm-tierbar-pager";
    bar.innerHTML = [
      '<button type="button" data-tier="standard">',
      '  Standard Tools',
      '  <small>$2.99 / export</small>',
      '</button>',
      '<button type="button" data-tier="premium">',
      '  Premium Tools',
      '  <small>$3.99 / export</small>',
      '</button>',
      '<button type="button" data-tier="secure">',
      '  Secure Suite',
      '  <small>Send $3.99 / 7d • Chat/Video/VoIP $4.99/hr</small>',
      '</button>',
    ].join("");

    bar.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-tier]");
      if (!btn) return;
      setTier(btn.getAttribute("data-tier"));
    });

    const title = $(".title", head);
    if (title) title.style.display = "none";

    head.appendChild(bar);

    if (!$("#pdfrealmTierPagerV4Status", head)) {
      const st = document.createElement("div");
      st.id = "pdfrealmTierPagerV4Status";
      st.className = "pdfrealm-tier-status";
      st.textContent = "";
      head.appendChild(st);
    }

    return bar;
  }

  function paintTierButtons(tier) {
    const bar = $("#pdfrealmTierPagerV4Bar");
    if (!bar) return;
    $$("button[data-tier]", bar).forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-tier") === tier);
      b.setAttribute("aria-selected", b.getAttribute("data-tier") === tier ? "true" : "false");
    });
  }

  function setStatus(msg) {
    const head = findSidebarHead();
    const el = head ? $("#pdfrealmTierPagerV4Status", head) : null;
    if (el) el.textContent = msg || "";
  }

  function toolContainer() {
    return $(".tool-tabs")
      || $("#toolTabs")
      || $("[data-tool-tabs]")
      || $(".sidebar .tool-tabs");
  }

  function ensureStash() {
    let stash = $("#pdfrealmTierPagerV4Stash");
    if (stash) return stash;
    stash = document.createElement("div");
    stash.id = "pdfrealmTierPagerV4Stash";
    stash.style.display = "none";
    document.body.appendChild(stash);
    return stash;
  }

  const MASTER_BY_ID = new Map(); // toolId -> button
  let MASTER_ORDER = [];          // toolIds in original order
  let suppress = 0;               // mutation suppression counter
  let lastVisibleIds = [];        // restore set if tier unavailable

  // render control
  let pendingTier = null;
  let renderQueued = false;
  let renderToken = 0;
  let retryTimer = null;

  function collectButtonsFrom(node) {
    if (!node) return [];
    let btns = $$(".tool-tab[data-tool]", node);
    if (!btns.length) btns = $$("button[data-tool]", node);
    return btns;
  }

  function captureButtonsIfAny() {
    const wrap = toolContainer();
    if (!wrap) return false;

    const btns = collectButtonsFrom(wrap);
    if (!btns.length) return false;

    if (!MASTER_ORDER.length) {
      MASTER_ORDER = btns.map(b => b.getAttribute("data-tool")).filter(Boolean);
    }

    btns.forEach(btn => {
      const id = btn.getAttribute("data-tool");
      if (!id) return;
      if (!MASTER_BY_ID.has(id)) MASTER_BY_ID.set(id, btn);
    });

    return true;
  }

  function updateMasterWithNewButtons(node) {
    const btns = collectButtonsFrom(node);
    if (!btns.length) return false;
    let changed = false;
    btns.forEach(btn => {
      const id = btn.getAttribute("data-tool");
      if (!id) return;
      if (!MASTER_BY_ID.has(id)) {
        MASTER_BY_ID.set(id, btn);
        MASTER_ORDER.push(id);
        changed = true;
      }
    });
    return changed;
  }

  function idsForTier(tier) {
    const ids = MASTER_ORDER.filter(id => tierForTool(id) === tier);

    // Premium: keep original order, but pin new enterprise tools to the very top
    if (tier === "premium") {
      const pin = ["embedvideo", "embedaudio", "embedimage"];
      const pinned = [];
      const rest = [];
      for (const id of ids) {
        if (pin.includes(id)) pinned.push(id);
        else rest.push(id);
      }
      
  function reorderPremiumIds(ids) {
    // Preferred visual ordering for Premium tier (3-column grid)
    const prefer = [
      "studio",
      "rasterize",
      "compress",
      // embed tools (support both naming styles)
      "embedvideo",
      "embedaudio",
      "embedimage",
      "embed_video",
      "embed_audio",
      "embed_image"
    ];

    const inSet = new Set(ids);
    const seen = new Set();
    const out = [];

    for (const id of prefer) {
      if (inSet.has(id) && !seen.has(id)) {
        out.push(id);
        seen.add(id);
      }
    }

    for (const id of ids) {
      if (!seen.has(id)) {
        out.push(id);
        seen.add(id);
      }
    }

    return out;
  }

const orderedPinned = pin.filter(x => pinned.includes(x));
      return orderedPinned.concat(rest);
    }

    return ids;
  }

  function moveVisibleToStash() {
    const wrap = toolContainer();
    if (!wrap) return;
    const stash = ensureStash();
    collectButtonsFrom(wrap).forEach(btn => stash.appendChild(btn));
  }

  function appendIdsToWrap(ids) {
    const wrap = toolContainer();
    if (!wrap) return 0;
    let n = 0;
    ids.forEach(id => {
      const btn = MASTER_BY_ID.get(id);
      if (btn) { wrap.appendChild(btn); n++; }
    });
    return n;
  }

  function restoreLastVisible() {
    moveVisibleToStash();
    if (lastVisibleIds.length) appendIdsToWrap(lastVisibleIds);
    else appendIdsToWrap(MASTER_ORDER);
  }

  function snapshotVisibleIds() {
    const wrap = toolContainer();
    if (!wrap) return;
    const ids = collectButtonsFrom(wrap).map(b => b.getAttribute("data-tool")).filter(Boolean);
    if (ids.length) lastVisibleIds = ids;
  }

  function ensureActiveInTier(tier) {
    const active = document.querySelector(".tool-tab.tool-tab-active[data-tool]");
    if (active && tierForTool(active.getAttribute("data-tool")) === tier) return;
    const ids0 = idsForTier(tier);
    const ids = (tier === "premium") ? reorderPremiumIds(ids0) : ids0;
    const firstId = ids.find(id => {
      const b = MASTER_BY_ID.get(id);
      return b && !b.disabled && b.getAttribute("aria-disabled") !== "true";
    });

    if (firstId) {
      const btn = MASTER_BY_ID.get(firstId);
      if (btn) btn.click();
    }
  }

  function doRender(tier, token) {
    // token check: cancel stale render
    if (token !== renderToken) return;

    ensureTierBar();
    captureButtonsIfAny();

    const wrap = toolContainer();
    if (!wrap) return;
    const ids0 = idsForTier(tier);
    const ids = (tier === "premium") ? reorderPremiumIds(ids0) : ids0;
    if (!ids.length) {
      // Not ready yet; don't blank list
      setStatus("Loading tools…");
      scheduleRetry(tier, token);
      return;
    }

    setStatus("");
    snapshotVisibleIds();

    suppress++;
    wrap.classList.add("pdfrealm-tier-fadeout");

    window.requestAnimationFrame(() => {
      // token check again
      if (token !== renderToken) {
        wrap.classList.remove("pdfrealm-tier-fadeout");
        suppress = Math.max(0, suppress-1);
        return;
      }

      moveVisibleToStash();
      const appended = appendIdsToWrap(ids);

      if (!appended) {
        // Still avoid blank
        restoreLastVisible();
        setStatus("Loading tools…");
        
        // PDFREALM_TIER_BLANK_FALLBACK_V1: if chosen tier yields no tools, auto-fallback to standard once
        try {
          const current = String(tier || "");
          if (current !== "standard") {
            localStorage.setItem("pdfrealm_active_tier", "standard");
            document.body.setAttribute("data-pdfrealm-tier", "standard");
            paintTierButtons && paintTierButtons("standard");
            requestRender && requestRender("standard", "blank-fallback");
          }
        } catch {}

        scheduleRetry(tier, token);
      } else {
        setStatus("");
        ensureActiveInTier(tier);
      }

      wrap.classList.remove("pdfrealm-tier-fadeout");
      wrap.classList.add("pdfrealm-tier-fadein");
      setTimeout(() => wrap.classList.remove("pdfrealm-tier-fadein"), 140);

      // Release suppression after mutations settle
      setTimeout(() => { suppress = Math.max(0, suppress-1); }, 0);
    });
  }

  function scheduleRetry(tier, token) {
    if (retryTimer) clearTimeout(retryTimer);
    retryTimer = setTimeout(() => {
      if (token !== renderToken) return;
      requestRender(tier, "retry");
    }, 140);
  }

  function requestRender(tier, reason) {
    pendingTier = tier;
    // cancel any retry chain on a new request
    if (retryTimer) { clearTimeout(retryTimer); retryTimer = null; }

    // bump token for "newest wins"
    renderToken++;

    if (renderQueued) return;
    renderQueued = true;

    window.requestAnimationFrame(() => {
      renderQueued = false;
      const t = pendingTier || getTier();
      doRender(t, renderToken);
    });
  }

  function waitForStabilizedToolsThenInit() {
    let last = -1;
    let stable = 0;
    const max = 50; // ~6s
    let tries = 0;

    const check = () => {
      tries++;
      const wrap = toolContainer();
      const cnt = wrap ? collectButtonsFrom(wrap).length : 0;

      if (cnt > 0 && cnt === last) stable++;
      else stable = 0;

      last = cnt;

      // stable for 3 consecutive checks
      if (cnt > 0 && stable >= 3) {
        captureButtonsIfAny();
        const t = getTier();
        document.body.setAttribute("data-pdfrealm-tier", t);
        paintTierButtons(t);
        requestRender(t, "init");
        observeForNewButtons();
        return;
      }

      if (tries < max) setTimeout(check, 120);
      else {
        const t = getTier();
        paintTierButtons(t);
        requestRender(t, "init_fallback");
        observeForNewButtons();
      }
    };

    check();
  }

  function observeForNewButtons() {
    const wrap = toolContainer();
    if (!wrap) return;

    const obs = new MutationObserver((muts) => {
      if (suppress > 0) return;

      let changed = false;
      muts.forEach(m => {
        (m.addedNodes || []).forEach(n => {
          if (!(n instanceof HTMLElement)) return;
          // Only treat as new if it introduces unseen tool IDs
          if (updateMasterWithNewButtons(n)) changed = true;
        });
      });

      if (changed) {
        requestRender(getTier(), "new_buttons");
      }
    });

    // subtree true catches frameworks that wrap buttons
    obs.observe(wrap, { childList:true, subtree:true });
  }

  function boot() {
    ensureTierBar();
    try { if (!localStorage.getItem(TIER_KEY)) localStorage.setItem(TIER_KEY, DEFAULT_TIER); } catch {}
    const t = getTier();
    document.body.setAttribute("data-pdfrealm-tier", t);
    paintTierButtons(t);

    waitForStabilizedToolsThenInit();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
 /* ==================== PDFREALM_TIER_PAGER_V4_END ==================== */



/* =================== PDFREALM_STANDARD_SPLIT_PREVIEW_V1_START =================== */
(() => {
  if (window.__PDFREALM_STANDARD_SPLIT_PREVIEW_V1__) return;
  window.__PDFREALM_STANDARD_SPLIT_PREVIEW_V1__ = true;

  // Keep tier mapping consistent with Tier Pager (Standard = not premium, not secure)
  const SECURE_TOOLS = new Set([
    "secure_send","secure_chat","secure_video","secure_voip","secure_containers"
  ]);

  const PREMIUM_TOOLS = new Set([
    "ocr","rasterize","pdf2jpg","pdf2png","compare","visualdiff","deskewclean","smartcompress","compress",
    "pdf2word","word2pdf","pdf2pptx","pdf2xlsx","docx2png","tableextract","html2pdf","url2pdf","heic2pdf",
    "pdf2layoutjson","pdf2outline","extractembedded","extractattach","extractfonts","bulkqrbarcode",
    "batchrename","chainrunner","templaterun","webhooksend","pdf2epub","epub2pdf","eml2pdf"
  




]);

  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function isStandardTool(toolId) {
    const id = String(toolId || "");
    if (!id) return false;
    if (SECURE_TOOLS.has(id)) return false;
    if (PREMIUM_TOOLS.has(id)) return false;
    return true;
  }

  function getActiveToolId() {
    const v = document.querySelector(".tool-view.tool-view-active");
    return v ? v.getAttribute("data-tool-view") : null;
  }

  function toolViewFor(toolId) {
    return document.querySelector(`.tool-view[data-tool-view="${toolId}"]`);
  }

  function acceptsPdf(toolView) {
    if (!toolView) return false;
    const files = $$('input[type="file"]', toolView);
    return files.some(inp => String(inp.getAttribute("accept") || "").includes("application/pdf"));
  }

  function ensureStyleOnce() {
    if ($("#pdfrealmStandardSplitPreviewStyleV1")) return;
    const style = document.createElement("style");
    style.id = "pdfrealmStandardSplitPreviewStyleV1";
    style.textContent = [
      "/* Split-style iframe crop (prevents bottom cut-off, matches Split/Extract) */",
      ".pdfrealm-splitstyle-wrap{ overflow:hidden !important; }",
      ".pdfrealm-splitstyle-frame{ position:relative !important; top:-64px !important; height:calc(100% + 64px) !important; width:100% !important; border:0 !important; }",
      "",
      "/* Ensure placeholder sits above iframe until src set */",
      ".pdfrealm-splitstyle-placeholder{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; padding:20px; text-align:center; }",
    ].join("\n");
    document.head.appendChild(style);
  }

  function createSplitStyleViewerCard(toolId) {
    const card = document.createElement("div");
    card.className = "card viewer-card";
    card.setAttribute("data-pdfrealm-injected-preview", "1");

    const frameId = `${toolId}PreviewFrame`;
    const phId = `${toolId}PreviewPlaceholder`;

    card.innerHTML = [
      '<div class="viewer-top">',
      '  <div class="viewer-title">Preview</div>',
      '</div>',
      '<div class="viewer-wrapper pdfrealm-splitstyle-wrap" style="position:relative;">',
      `  <div id="${phId}" class="placeholder pdfrealm-splitstyle-placeholder">Upload a PDF to preview it here.</div>`,
      `  <iframe id="${frameId}" title="Preview" class="pdfrealm-splitstyle-frame"></iframe>`,
      '</div>'
    ].join("");

    return card;
  }

  function normalizeExistingPreview(toolView) {
    // Handles various preview layouts: viewer-card/viewer-wrapper, preview-card/preview-wrap, etc.
    const wrappers = [
      ...$$(".viewer-wrapper", toolView),
      ...$$(".preview-wrap", toolView),
      ...$$(".viewer", toolView),
    ];

    wrappers.forEach(w => {
      w.classList.add("pdfrealm-splitstyle-wrap");
      // Some wrappers are not position:relative; placeholder positioning needs it
      if (!w.style.position) w.style.position = "relative";
    });

    // Prefer iframe in viewer-card first; else any iframe
    const iframe =
      $(".viewer-card iframe", toolView) ||
      $(".preview-card iframe", toolView) ||
      $("iframe", toolView);

    if (iframe) {
      iframe.classList.add("pdfrealm-splitstyle-frame");
      // Some tools define inline style; we keep it but our class enforces the crop
    }

    // Ensure placeholder is positioned correctly if it exists
    const ph =
      $(".viewer-card .placeholder", toolView) ||
      $(".preview-card .preview-placeholder", toolView) ||
      $(".preview-placeholder", toolView) ||
      $(".placeholder", toolView);

    if (ph) ph.classList.add("pdfrealm-splitstyle-placeholder");

    return { iframe, placeholder: ph, wrappers };
  }

  function injectPreviewIfMissing(toolId, toolView) {
    // Only inject if tool accepts PDFs and has no obvious preview container
    if (!acceptsPdf(toolView)) return null;

    const hasAnyPreview =
      toolView.querySelector(".viewer-card") ||
      toolView.querySelector(".preview-card") ||
      toolView.querySelector(".viewer-wrapper") ||
      toolView.querySelector(".preview-wrap") ||
      toolView.querySelector("iframe");

    if (hasAnyPreview) return null;

    const grid2 = toolView.querySelector(".grid2");
    const body = toolView.querySelector(".tool-body") || toolView;

    const card = createSplitStyleViewerCard(toolId);
    if (grid2) grid2.appendChild(card);
    else body.appendChild(card);

    return card;
  }

  const previewState = new Map(); // toolId -> { url, iframe, placeholder }

  function setIframePreview(toolId, iframe, placeholder, file) {
    if (!iframe || !placeholder) return;

    const prev = previewState.get(toolId);
    try { if (prev?.url) URL.revokeObjectURL(prev.url); } catch {}

    if (!file) {
      iframe.removeAttribute("src");
      placeholder.style.display = "";
      previewState.set(toolId, { url:null, iframe, placeholder });
      return;
    }

    const url = URL.createObjectURL(file);
    iframe.src = url;
    placeholder.style.display = "none";
    previewState.set(toolId, { url, iframe, placeholder });

    // If the tool had an image/canvas preview, hide it so the Split-style doc preview is the one users see.
    const img = toolViewFor(toolId)?.querySelector("img[id$='PreviewImg'], img.preview-img, img#deletePreviewImg, img#rotatePreviewImg");
    if (img) img.style.display = "none";
    const canvas = toolViewFor(toolId)?.querySelector("canvas[id$='PreviewCanvas'], canvas.preview-canvas");
    if (canvas) canvas.style.display = "none";
  }

  function wirePdfInputs(toolId, toolView, iframe, placeholder) {
    if (!toolView || !iframe || !placeholder) return;
    if (toolView.getAttribute("data-pdfrealm-splitstyle-wired") === "1") return;

    const inputs = $$('input[type="file"]', toolView)
      .filter(inp => String(inp.getAttribute("accept") || "").includes("application/pdf"));

    if (!inputs.length) {
      toolView.setAttribute("data-pdfrealm-splitstyle-wired", "1");
      return;
    }

    const pickFirstFile = () => {
      for (const inp of inputs) {
        const f = inp.files && inp.files[0];
        if (f) return f;
      }
      return null;
    };

    // Wire all relevant inputs
    inputs.forEach(inp => {
      inp.addEventListener("change", () => {
        const f = pickFirstFile();
        setIframePreview(toolId, iframe, placeholder, f);
      });
    });

    // If already populated (e.g., back/forward cache), preview it
    const existing = pickFirstFile();
    if (existing) setIframePreview(toolId, iframe, placeholder, existing);
    else setIframePreview(toolId, iframe, placeholder, null);

    toolView.setAttribute("data-pdfrealm-splitstyle-wired", "1");
  }

  function ensureSplitStylePreviewForTool(toolId) {
    if (!isStandardTool(toolId)) return;

    const toolView = toolViewFor(toolId);
    if (!toolView) return;

    // Only target PDF-based standard tools (document preview request)
    if (!acceptsPdf(toolView)) return;

    ensureStyleOnce();

    // If missing, inject a Split-style viewer card
    injectPreviewIfMissing(toolId, toolView);

    // Normalize what exists (viewer-card, preview-card, iframe, wrapper)
    const norm = normalizeExistingPreview(toolView);

    // If no placeholder exists, create one inside the closest wrapper
    let placeholder = norm.placeholder;
    let iframe = norm.iframe;

    // Ensure wrapper exists
    let wrapper =
      toolView.querySelector(".viewer-wrapper") ||
      toolView.querySelector(".preview-wrap") ||
      toolView.querySelector(".viewer") ||
      (iframe ? iframe.parentElement : null);

    if (!wrapper) {
      // Create wrapper next to the first card
      const card = toolView.querySelector(".card") || toolView;
      wrapper = document.createElement("div");
      wrapper.className = "viewer-wrapper pdfrealm-splitstyle-wrap";
      wrapper.style.position = "relative";
      card.appendChild(wrapper);
    } else {
      wrapper.classList.add("pdfrealm-splitstyle-wrap");
      if (!wrapper.style.position) wrapper.style.position = "relative";
    }

    if (!iframe) {
      iframe = document.createElement("iframe");
      iframe.id = `${toolId}PreviewFrame`;
      iframe.title = "Preview";
      iframe.className = "pdfrealm-splitstyle-frame";
      wrapper.appendChild(iframe);
    } else {
      iframe.classList.add("pdfrealm-splitstyle-frame");
    }

    if (!placeholder) {
      placeholder = document.createElement("div");
      placeholder.id = `${toolId}PreviewPlaceholder`;
      placeholder.className = "placeholder pdfrealm-splitstyle-placeholder";
      placeholder.textContent = "Upload a PDF to preview it here.";
      wrapper.insertBefore(placeholder, iframe);
    } else {
      placeholder.classList.add("pdfrealm-splitstyle-placeholder");
    }

    wirePdfInputs(toolId, toolView, iframe, placeholder);
  }

  function observeActiveToolChanges() {
    const views = $$(".tool-view[data-tool-view]");
    if (!views.length) return;

    const obs = new MutationObserver(() => {
      const active = getActiveToolId();
      if (active) ensureSplitStylePreviewForTool(active);
    });

    views.forEach(v => {
      obs.observe(v, { attributes:true, attributeFilter:["class","style"] });
    });
  }

  function boot() {
    // Initial pass after the app has had a chance to activate a tool
    setTimeout(() => {
      const active = getActiveToolId();
      if (active) ensureSplitStylePreviewForTool(active);
    }, 250);

    // Also handle clicks directly (some activations don't mutate style immediately)
    document.addEventListener("click", (e) => {
      const btn = e.target && e.target.closest ? e.target.closest(".tool-tab[data-tool]") : null;
      if (!btn) return;
      const toolId = btn.getAttribute("data-tool");
      setTimeout(() => ensureSplitStylePreviewForTool(toolId), 0);
    }, true);

    observeActiveToolChanges();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
 /* ==================== PDFREALM_STANDARD_SPLIT_PREVIEW_V1_END ==================== */




/* =================== PDFREALM_UNIVERSAL_ENCRYPT_DECRYPT_V1_START =================== */
(() => {
  if (window.__pdfrealm_universal_encdec_v1) return;
  window.__pdfrealm_universal_encdec_v1 = true;

  const EXCLUDE_TOOLS = new Set([
    // The password/encrypt tool already manages encrypted inputs explicitly
    "encrypt",
    "password",
    // merge handles multiple files and has its own unlock UX
    "merge",
    // secure suite tools are not PDF processing tools
    "secure_send","secure_chat","secure_video","secure_voip","secure_containers"
  ]);

  const $  = (sel, root=document) => root.querySelector(sel);

  function getActiveToolId() {
    const v = document.querySelector(".tool-view.tool-view-active");
    return v ? v.getAttribute("data-tool-view") : null;
  }

  function getActiveToolView() {
    const id = getActiveToolId();
    return id ? document.querySelector(`.tool-view[data-tool-view="${id}"]`) : null;
  }

  function isPdfLike(obj) {
    try {
      const type = String(obj?.type || "").toLowerCase();
      if (type.includes("pdf")) return true;
      const name = String(obj?.name || obj?.filename || "").toLowerCase();
      if (name.endsWith(".pdf")) return true;
    } catch {}
    return false;
  }

  function findPasswordInActiveView() {
    const view = getActiveToolView();
    if (!view) return "";
    // Prefer explicit password inputs
    const pw =
      view.querySelector('input[type="password"]') ||
      view.querySelector('input[id*="Password"]') ||
      view.querySelector('input[name*="password"]') ||
      null;
    const val = pw ? String(pw.value || "").trim() : "";
    return val;
  }

  // Cache decrypted results per input object identity
  const _cache = new WeakMap(); // obj -> { bytes:Uint8Array, pw:string, ts:number }
  const _cacheMaxAgeMs = 5 * 60 * 1000;

  async function maybeDecryptPdfToBytes(obj, toolIdHint=null) {
    // Non-blob objects with arrayBuffer: just return bytes (no encryption detection)
    const isBlob = (typeof Blob !== "undefined") && (obj instanceof Blob);
    if (!isBlob) {
      if (obj && typeof obj.arrayBuffer === "function") {
        return new Uint8Array(await obj.arrayBuffer());
      }
      throw new Error("Unsupported input (expected File/Blob).");
    }

    // Not a PDF => don't run encryption detection, return raw bytes
    if (!isPdfLike(obj)) {
      return new Uint8Array(await obj.arrayBuffer());
    }

    // Exclusions by active tool (prevents interfering with the Password Protect tool)
    const activeTool = toolIdHint || getActiveToolId();
    if (activeTool && EXCLUDE_TOOLS.has(activeTool)) {
      return new Uint8Array(await obj.arrayBuffer());
    }

    // Cache hit
    const hit = _cache.get(obj);
    if (hit && (Date.now() - (hit.ts || 0) < _cacheMaxAgeMs) && hit.bytes) {
      return hit.bytes;
    }

    // Check encryption
    let encrypted = false;
    try {
      // detectEncryptedPdfReliable is already defined in app.js
      encrypted = await detectEncryptedPdfReliable(obj);
    } catch {
      encrypted = false;
    }

    if (!encrypted) {
      const bytes = new Uint8Array(await obj.arrayBuffer());
      _cache.set(obj, { bytes, pw:"", ts: Date.now() });
      return bytes;
    }

    // Get password (DOM field first, then prompt)
    let pw = findPasswordInActiveView();
    if (!pw) {
      pw = window.__pdfrealm_last_pdf_password || "";
    }
    if (!pw) {
      pw = prompt("Encrypted PDF detected. Enter the password to decrypt/unlock it:");
      pw = String(pw || "").trim();
    }

    if (!pw) {
      throw new Error("Password required to decrypt this PDF.");
    }

    // Remember last password for convenience (session only)
    try { window.__pdfrealm_last_pdf_password = pw; } catch {}

    // decryptPdfToFile is already defined in app.js; it uses /api/decrypt (qpdf)
    const decFile = await decryptPdfToFile(obj, pw);
    const bytes = new Uint8Array(await decFile.arrayBuffer());

    _cache.set(obj, { bytes, pw, ts: Date.now() });
    return bytes;
  }

  async function maybeDecryptPdfToArrayBuffer(obj, toolIdHint=null) {
    const bytes = await maybeDecryptPdfToBytes(obj, toolIdHint);
    // Return ArrayBuffer view
    return bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
  }

  // Expose helpers used by patched code
  window.__pdfrealmPdfFileToBytesMaybeDecrypt = (obj) => maybeDecryptPdfToBytes(obj, getActiveToolId());
  window.__pdfrealmPdfFileToArrayBufferMaybeDecrypt = (obj) => maybeDecryptPdfToArrayBuffer(obj, getActiveToolId());

  // Wrap runPaidPdfExport: auto-decrypt single-file FormData if needed
  try {
    const orig = window.runPaidPdfExport;
    if (typeof orig === "function") {
      window.runPaidPdfExport = async function(args) {
        const tool = args?.tool || null;

        // Never interfere with excluded tools
        if (tool && EXCLUDE_TOOLS.has(tool)) {
          return await orig(args);
        }

        const fd = args?.formData;
        if (fd && typeof fd.get === "function") {
          const f = fd.get("file");
          // Only handle single-file workflows
          if (f && isPdfLike(f)) {
            try {
              const encrypted = await detectEncryptedPdfReliable(f);
              if (encrypted) {
                // Try DOM field first; then prompt
                let pw = findPasswordInActiveView();
                if (!pw) pw = window.__pdfrealm_last_pdf_password || "";
                if (!pw) {
                  pw = prompt("Encrypted PDF detected. Enter the password to decrypt/unlock it:");
                  pw = String(pw || "").trim();
                }
                if (!pw) throw new Error("Password required to decrypt this PDF.");

                try { window.__pdfrealm_last_pdf_password = pw; } catch {}

                const dec = await decryptPdfToFile(f, pw);
                // Replace the file in the formdata
                try { fd.set("file", dec, dec.name || "unlocked.pdf"); } catch { fd.delete("file"); fd.append("file", dec); }
              }
            } catch (e) {
              // Let the caller handle alerts; rethrow
              throw e;
            }
          }
        }

        return await orig(args);
      };
    }
  } catch {}
})();
/* ==================== PDFREALM_UNIVERSAL_ENCRYPT_DECRYPT_V1_END ==================== */




/* ===========================================================
   BREAKTHROUGH ROADMAP (Secure Suite)
   - UI-only roadmap tabs in the Breakthrough tool view.
   - Additive; does not touch existing tool behavior.
   =========================================================== */
(function initBreakthroughRoadmap(){
  function $(sel, root){ return (root||document).querySelector(sel); }
  function $$(sel, root){ return Array.from((root||document).querySelectorAll(sel)); }

  function activate(key){
    const view = $('.tool-view[data-tool-view="breakthrough"]');
    if (!view) return;
    $$('.bt-tab', view).forEach(b => {
      const on = b.getAttribute('data-bt') === key;
      b.classList.toggle('bt-active', on);
      if (on) b.classList.add('btn-primary'); else b.classList.remove('btn-primary');
      if (on) b.classList.remove('btn-secondary'); else b.classList.add('btn-secondary');
    });
    $$('.bt-section', view).forEach(sec => {
      const on = sec.getAttribute('data-bt-section') === key;
      sec.classList.toggle('bt-active', on);
    });
  }

  function wire(){
    const view = document.querySelector('.tool-view[data-tool-view="breakthrough"]');
    if (!view) return;
    if (view.__btWired) return;
    view.__btWired = true;

    view.addEventListener('click', (e) => {
      const btn = e.target && e.target.closest && e.target.closest('.bt-tab[data-bt]');
      if (!btn) return;
      e.preventDefault();
      activate(btn.getAttribute('data-bt'));
    });

    // default
    activate('hash');
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wire);
  } else {
    wire();
  }

  // also re-wire after tool switching (some UIs re-render)
  document.addEventListener('click', (e) => {
    const tb = e.target && e.target.closest && e.target.closest('.tool-tab[data-tool="breakthrough"]');
    if (tb) setTimeout(wire, 0);
  });
})();
